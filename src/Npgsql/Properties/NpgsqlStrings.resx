<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CannotUseSslVerifyWithCustomValidationCallback" xml:space="preserve">
    <value>SslMode.{0} cannot be used in conjunction with SslClientAuthenticationOptionsCallback overwriting RemoteCertificateValidationCallback; when registering a validation callback, perform whatever validation you require in that callback.</value>
  </data>
  <data name="CannotUseSslRootCertificateWithCustomValidationCallback" xml:space="preserve">
    <value>RootCertificate cannot be used in conjunction with SslClientAuthenticationOptionsCallback overwriting RemoteCertificateValidationCallback; when registering a validation callback, perform whatever validation you require in that callback.</value>
  </data>
  <data name="TransportSecurityDisabled" xml:space="preserve">
    <value>Transport security hasn't been enabled; please call {0} on NpgsqlSlimDataSourceBuilder to enable it.</value>
  </data>
  <data name="IntegratedSecurityDisabled" xml:space="preserve">
    <value>Integrated security hasn't been enabled; please call {0} on NpgsqlSlimDataSourceBuilder to enable it.</value>
  </data>
  <data name="NoMultirangeTypeFound" xml:space="preserve">
    <value>No multirange type could be found in the database for subtype {0}.</value>
  </data>
  <data name="NotSupportedOnDataSourceCommand" xml:space="preserve">
    <value>Connection and transaction access is not supported on commands created from DbDataSource.</value>
  </data>
  <data name="NotSupportedOnDataSourceBatch" xml:space="preserve">
    <value>Connection and transaction access is not supported on batches created from DbDataSource.</value>
  </data>
  <data name="CannotSetBothPasswordProviderAndPassword" xml:space="preserve">
    <value>When registering a password provider, a password or password file may not be set.</value>
  </data>
  <data name="CannotSetMultiplePasswordProviderKinds" xml:space="preserve">
    <value>Multiple kinds of password providers were found, only one kind may be configured per DbDataSource.</value>
  </data>
  <data name="SyncAndAsyncPasswordProvidersRequired" xml:space="preserve">
    <value>Both sync and async password providers must be provided.</value>
  </data>
  <data name="PasswordProviderMissing" xml:space="preserve">
    <value>The right type of password provider (sync or async) was not found.</value>
  </data>
  <data name="ArgumentMustBePositive" xml:space="preserve">
    <value>'{0}' must be positive.</value>
  </data>
  <data name="CannotSpecifyTargetSessionAttributes" xml:space="preserve">
    <value>When creating a multi-host data source, TargetSessionAttributes cannot be specified. Create without TargetSessionAttributes, and then obtain DataSource wrappers from it. Consult the docs for more information.</value>
  </data>
  <data name="CannotReadIntervalWithMonthsAsTimeSpan" xml:space="preserve">
    <value>Cannot read interval values with non-zero months as TimeSpan, since that type doesn't support months. Consider using NodaTime Period which better corresponds to PostgreSQL interval, or read the value as NpgsqlInterval, or transform the interval to not contain months or years in PostgreSQL before reading it.</value>
  </data>
  <data name="PositionalParameterAfterNamed" xml:space="preserve">
    <value>When using CommandType.StoredProcedure, all positional parameters must come before named parameters.</value>
  </data>
  <data name="CannotReadInfinityValue" xml:space="preserve">
    <value>Cannot read infinity value since Npgsql.DisableDateTimeInfinityConversions is enabled.</value>
  </data>
  <data name="SyncAndAsyncConnectionInitializersRequired" xml:space="preserve">
    <value>Both sync and async connection initializers must be provided.</value>
  </data>
  <data name="CannotUseValidationRootCertificateCallbackWithCustomValidationCallback" xml:space="preserve">
    <value>ValidationRootCertificateCallback cannot be used in conjunction with SslClientAuthenticationOptionsCallback overwriting RemoteCertificateValidationCallback; when registering a validation callback, perform whatever validation you require in that callback.</value>
  </data>
  <data name="RecordsNotEnabled" xml:space="preserve">
    <value>Could not read a PostgreSQL record. If you're attempting to read a record as a .NET tuple, call '{0}' on '{1}' or NpgsqlConnection.GlobalTypeMapper (see https://www.npgsql.org/doc/types/basic.html and the 8.0 release notes for more details). If you're reading a record as a .NET object array using NpgsqlSlimDataSourceBuilder, call '{2}'.
</value>
  </data>
  <data name="FullTextSearchNotEnabled" xml:space="preserve">
    <value>Full-text search isn't enabled; please call {0} on {1} to enable full-text search.</value>
  </data>
  <data name="LTreeNotEnabled" xml:space="preserve">
    <value>Ltree isn't enabled; please call {0} on {1} to enable LTree.</value>
  </data>
  <data name="RangesNotEnabled" xml:space="preserve">
    <value>Ranges aren't enabled; please call {0} on {1} to enable ranges.</value>
  </data>
  <data name="MultirangesNotEnabled" xml:space="preserve">
    <value>Multiranges aren't enabled; please call {0} on {1} to enable multiranges.</value>
  </data>
  <data name="ArraysNotEnabled" xml:space="preserve">
    <value>Arrays aren't enabled; please call {0} on {1} to enable arrays.</value>
  </data>
  <data name="TimestampTzNoDateTimeUnspecified" xml:space="preserve">
    <value>Cannot write DateTime with Kind={0} to PostgreSQL type '{1}', only UTC is supported. Note that it's not possible to mix DateTimes with different Kinds in an array, range, or multirange.</value>
  </data>
  <data name="TimestampNoDateTimeUtc" xml:space="preserve">
    <value>Cannot write DateTime with Kind=UTC to PostgreSQL type '{0}', consider using '{1}'. Note that it's not possible to mix DateTimes with different Kinds in an array, range, or multirange.</value>
  </data>
  <data name="DynamicJsonNotEnabled" xml:space="preserve">
    <value>Type '{0}' required dynamic JSON serialization, which requires an explicit opt-in; call '{1}' on '{2}' or NpgsqlConnection.GlobalTypeMapper (see https://www.npgsql.org/doc/types/json.html and the 8.0 release notes for more details). Alternatively, if you meant to use Newtonsoft JSON.NET instead of System.Text.Json, call UseJsonNet() instead.
</value>
  </data>
  <data name="DynamicOrSourceGeneratedJsonNotEnabled" xml:space="preserve">
    <value>Type '{0}' required dynamic (or Source Generated) JSON serialization, which requires an explicit opt-in; call '{1}' on '{2}' or NpgsqlConnection.GlobalTypeMapper (see https://www.npgsql.org/doc/types/json.html and the 8.0 release notes for more details). Alternatively, if you meant to use Newtonsoft JSON.NET instead of System.Text.Json, call UseJsonNet() instead.
</value>
  </data>
  <data name="UnmappedEnumsNotEnabled" xml:space="preserve">
    <value>Reading and writing unmapped enums requires an explicit opt-in; call '{0}' on '{1}' or NpgsqlConnection.GlobalTypeMapper (see https://www.npgsql.org/doc/types/enums_and_composites.html and the 8.0 release notes for more details).</value>
  </data>
  <data name="UnmappedRangesNotEnabled" xml:space="preserve">
    <value>Reading and writing unmapped ranges and multiranges requires an explicit opt-in; call '{0}' on '{1}' or NpgsqlConnection.GlobalTypeMapper (see https://www.npgsql.org/doc/types/ranges.html and the 8.0 release notes for more details).</value>
  </data>
  <data name="SslClientAuthenticationOptionsCallbackWithOtherCallbacksNotSupported" xml:space="preserve">
    <value>SslClientAuthenticationOptionsCallback is not supported together with UserCertificateValidationCallback and ClientCertificatesCallback</value>
  </data>
</root>