/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    VSDebugEng.h

Abstract:

    Master include file for extending the Visual Studio Debugger Engine
    (debugger back end).

--*/

#ifndef _INC_VSDEBUGENG_
#define _INC_VSDEBUGENG_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef __cplusplus
    #error This file requires C++ compilation (use a .cpp suffix)
#endif

#if defined(_MANAGED) || defined(__cplusplus_cli)
    #error This file should not be included in code compiled with /clr. Reference the managed assembly instead.
#endif

#ifndef VSDEBUGENG_NO_WINDOWS
    #include <windows.h>
    #include <ole2.h>
#endif

// By default, vsdebugeng.h defines helpers to make the API easier to use with the ATL.
// To disable these helpers, define VSDEBUGENG_NO_ATL prior to including this header file
#ifndef VSDEBUGENG_NO_ATL
    #include <atlbase.h>
    #include <atlstr.h>
#endif

// vsdebugeng.h defines helpers to make the API easier to use with the STL. However, these
// helpers are NOT included by default. To include these helpers, define VSDEBUGENG_USE_STL.
#ifdef VSDEBUGENG_USE_STL
    #include <string>
#endif

#pragma pack(push, 8)
#pragma warning(push)
#pragma warning(disable:4324) // Disable 'structure was padded due to __declspec(align())' warning

interface ICorDebugAppDomain;
interface ICorDebugThread;
interface ICorDebugProcess;
interface ICorDebugModule;
interface ICorDebugFunction;
interface ICorDebugEval;
interface IRemoteDebugApplication;
enum CV_HREG_e;
enum enum_TASKLOAD_FLAGS;
enum enum_TASKSTATE_TYPE;
enum enum_TASKPROPERTIES_FIELDS;
enum enum_TASKPROPERTIES_FLAGS;
typedef enum _MINIDUMP_TYPE MINIDUMP_TYPE;

#include <cor.h>
#include <cordebug.h>



namespace Microsoft { namespace VisualStudio { namespace Debugger {



// Forward definitions

struct DkmApiVersion { enum e; };
struct DkmAsyncBreakStatus { enum e; };
class DkmCustomMessage;
struct DkmDataCreationDisposition { enum e; };
struct DkmDispatcherObjectFlags { enum e; };
struct DkmDisplayUserMessagePromptAsyncResult;
struct DkmDumpType { enum e; };
struct DkmEngineFlags { enum e; };
class DkmEngineSettings;
struct DkmEventCode { enum e; };
class DkmEventDescriptor;
class DkmEventDescriptorS;
struct DkmFuncEvalMode { enum e; };
struct DkmGetCurrentCPUAddressAsyncResult;
struct DkmGetInstructionAddressAsyncResult;
class DkmInstructionAddress;
class DkmLanguageRegistrySetting;
struct DkmModuleFlags { enum e; };
class DkmModuleInstance;
struct DkmModuleMemoryLayout { enum e; };
class DkmModuleVersion;
class DkmProcess;
struct DkmReadMemoryFlags { enum e; };
class DkmRegistryTweak;
struct DkmResolveCPUInstructionAddressAsyncResult;
struct DkmRuntimeCapabilities { enum e; };
class DkmRuntimeInstance;
struct DkmRuntimeInstanceId;
struct DkmSendLowerAsyncResult;
struct DkmStoppingEventProcessingNextAction { enum e; };
class DkmThread;
class DkmUnknownInstructionAddress;
class DkmUserMessage;
struct DkmUserMessageOutputKind { enum e; };

// Contains types related to expression evaluation.
namespace Evaluation {
    class DkmChildVisualizedExpression;
    class DkmCompiledCustomInspectionQuery;
    class DkmCompiledInspectionQuery;
    class DkmCompiledVisualizationData;
    struct DkmCompiledVisualizationDataPriority { enum e; };
    struct DkmCompilerId;
    class DkmCustomRawReturnValue;
    class DkmCustomUIVisualizerInfo;
    class DkmDataAddress;
    struct DkmEvaluateExpressionAsyncResult;
    struct DkmEvaluateReturnValueAsyncResult;
    struct DkmEvaluationEnumAsyncResult;
    struct DkmEvaluationFlags { enum e; };
    class DkmEvaluationResult;
    struct DkmEvaluationResultAccessType { enum e; };
    struct DkmEvaluationResultCategory { enum e; };
    class DkmEvaluationResultEnumContext;
    struct DkmEvaluationResultFlags { enum e; };
    struct DkmEvaluationResultStorageType { enum e; };
    struct DkmEvaluationResultTypeModifierFlags { enum e; };
    struct DkmExecuteQueryAsyncResult;
    class DkmExpressionValueHome;
    class DkmFailedEvaluationResult;
    class DkmFakeValueHome;
    struct DkmFuncEvalFlags { enum e; };
    struct DkmGetChildrenAsyncResult;
    struct DkmGetFrameArgumentsAsyncResult;
    struct DkmGetFrameLocalsAsyncResult;
    struct DkmGetFrameNameAsyncResult;
    struct DkmGetFrameReturnTypeAsyncResult;
    struct DkmGetLanguageSettingsAsyncResult;
    class DkmILContext;
    class DkmInspectionContext;
    class DkmInspectionSession;
    class DkmIntermediateEvaluationResult;
    class DkmLanguage;
    class DkmLanguageExpression;
    class DkmLanguageInstructionAddress;
    class DkmNativeRawReturnValue;
    class DkmNativeReturnValueRegister;
    class DkmPointerValueHome;
    class DkmRawManagedReturnValue;
    class DkmRawReturnValue;
    class DkmRootVisualizedExpression;
    struct DkmRootVisualizedExpressionFlags { enum e; };
    class DkmSuccessEvaluationResult;
    struct DkmVariableInfoFlags { enum e; };
    class DkmVisualizedExpression;
};

// Contains the types used in the debugger's intermediate language (IL).
namespace Evaluation { namespace IL {
    class DkmCompiledILInspectionQuery;
    class DkmILAdd;
    class DkmILAmpAdjustBufferTag;
    class DkmILBeginTry;
    class DkmILBitAnd;
    class DkmILBitFieldRead;
    class DkmILBitFieldReadFromBytes;
    class DkmILBitFieldWrite;
    class DkmILBitFieldWriteToBytes;
    class DkmILBitNot;
    class DkmILBitOr;
    class DkmILBitShiftLeft;
    class DkmILBitShiftRight;
    class DkmILBitXor;
    struct DkmILCallingConvention { enum e; };
    class DkmILCatchBlock;
    class DkmILCompareEqual;
    class DkmILCompareGreaterThan;
    class DkmILCompareGreaterThanOrEqual;
    class DkmILCompareLessThan;
    class DkmILCompareLessThanOrEqual;
    class DkmILCompareNotEqual;
    class DkmILConvert;
    class DkmILDivide;
    class DkmILDuplicateTop;
    class DkmILEndTry;
    class DkmILEvaluationResult;
    class DkmILExecuteFunction;
    class DkmILExecuteIntrinsic;
    class DkmILExtractBytes;
    struct DkmILFailureReason { enum e; };
    struct DkmILFunctionEvaluationArgumentFlags { enum e; };
    struct DkmILFunctionEvaluationFlags { enum e; };
    class DkmILHlslBufferRead;
    class DkmILHlslGetGroupId;
    class DkmILHlslGetThreadId;
    class DkmILHlslIndexedRegisterRead;
    class DkmILHlslRegisterRead;
    class DkmILInstruction;
    class DkmILIsFalse;
    class DkmILIsTrue;
    class DkmILJump;
    class DkmILJumpIfFalse;
    class DkmILJumpIfTrue;
    class DkmILLoad;
    class DkmILMemoryRead;
    class DkmILMemoryStringRead;
    class DkmILMemoryWrite;
    class DkmILMultiply;
    class DkmILNop;
    class DkmILParameterValue;
    class DkmILPop;
    class DkmILPushConstant;
    class DkmILRegisterRead;
    class DkmILRegisterWrite;
    class DkmILRemainder;
    class DkmILReturnTop;
    class DkmILSave;
    class DkmILSetBytesRegion;
    class DkmILSubtract;
    class DkmILThrow;
    class DkmILTlsGetValue;
    struct DkmPrimitiveObjectType { enum e; };
};};

// Contains the types used to evaluation the same expression across multiple threads.
namespace Evaluation { namespace Group {
    class DkmContextGroupEvaluationILResult;
    class DkmContextGroupEvaluationResult;
    struct DkmEvaluateExpressionOnThreadsAsyncResult;
    struct DkmExecuteQueryOnThreadsAsyncResult;
    class DkmFailedContextGroupEvaluationResult;
    class DkmILParameterValueCollection;
    class DkmSuccessContextGroupEvaluationResult;
    class DkmThreadEvaluationResultCollection;
};};

// Contains the types used for dealing with symbolic information in the debugger. This
// includes all types related to handling documents and text ranges. This namespace
// contains only the runtime environment agnostic types, with additional types found in
// the 'Native', 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Symbols {
    struct DkmCodeViewCompilerId;
    class DkmCustomSymbolFileId;
    struct DkmDocumentMatchStrength { enum e; };
    class DkmDynamicSymbolFileId;
    class DkmEngineSymbolSettings;
    struct DkmFindDocumentsAsyncResult;
    struct DkmFindSymbolsAsyncResult;
    struct DkmGetFunctionInfoAsyncResult;
    struct DkmGetMethodSymbolStoreDataAsyncResult;
    struct DkmGetMethodSymbolStoreDataPreRemapAsyncResult;
    struct DkmGetSourcePositionAsyncResult;
    struct DkmGetSourcePositionCallbackAsyncResult;
    struct DkmGetTokenSymbolStoreAttributeAsyncResult;
    struct DkmGetUserCodeSourcePositionCallbackAsyncResult;
    struct DkmHasLineInfoAsyncResult;
    struct DkmImageDebugDirectoryFormat;
    class DkmInstructionSymbol;
    struct DkmIsHiddenCodeAsyncResult;
    struct DkmIsUserCodeAsyncResult;
    struct DkmMD5HashValue;
    class DkmModule;
    struct DkmModuleId;
    class DkmPdbFileId;
    struct DkmRVASizePair;
    class DkmResolvedDocument;
    struct DkmResolvedDocumentWarning { enum e; };
    class DkmResolvedMappedDocument;
    struct DkmSHA1HashValue;
    class DkmSourceFileId;
    class DkmSourcePosition;
    struct DkmSourcePositionFlags { enum e; };
    struct DkmSteppingRange;
    struct DkmSteppingRangeBoundary { enum e; };
    class DkmSymbolFileId;
    struct DkmTextSpan;
};

// Contains types used for resolving function names to instruction addresses/symbols such
// as for setting function breakpoints.
namespace FunctionResolution {
    struct DkmAddressSearchFlags { enum e; };
    struct DkmOnFunctionResolvedAsyncResult;
    struct DkmOnResolverMessageAsyncResult;
    class DkmRuntimeFunctionResolutionRequest;
    class DkmSymbolFunctionResolutionRequest;
};

// Contains the types used for call stack walking and call stack frame formatting. This
// also includes types related to processor registers, as registers are tracked per-stack
// frame.
namespace CallStack {
    class DkmArmFrameRegisters;
    class DkmAsyncStackWalkContext;
    struct DkmCallStackFilterOptions { enum e; };
    struct DkmFrameFormatOptions;
    struct DkmFrameNameFormatOptions { enum e; };
    class DkmFrameRegisters;
    struct DkmGetAsyncCallStackAsyncResult;
    struct DkmGetContinuationFramesFromTaskObjectAsyncResult;
    struct DkmGetCurrentLocationAsyncResult;
    struct DkmGetManagedTaskContinuationFramesAsyncResult;
    struct DkmGetNextFramesAsyncResult;
    struct DkmGetTaskContinuationFramesAsyncResult;
    struct DkmGetTaskCreationStackAsyncResult;
    struct DkmHeuristicWalkFramesAsyncResult;
    class DkmMonitorStackWalkContext;
    struct DkmMonitorStackWalkResult;
    struct DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult;
    struct DkmRuntimeWalkNextFramesAsyncResult;
    class DkmStackContext;
    class DkmStackFrame;
    class DkmStackHash;
    struct DkmStackMemoryRange;
    class DkmStackTraceContext;
    class DkmStackWalkContext;
    class DkmStackWalkFrame;
    class DkmStackWalkFrameAnnotation;
    class DkmStackWalkFrameData;
    struct DkmStackWalkFrameFlags { enum e; };
    struct DkmStackWalkOperation { enum e; };
    struct DkmStackWalkStatus { enum e; };
    class DkmSymbolStackWalkContext;
    class DkmUnwoundRegister;
    class DkmX64FrameRegisters;
    class DkmX86FrameRegisters;
};

// Contains types related to processing exceptions coming from the target process. This
// includes both setting triggers to be notified when specific exceptions are raised as
// well as describing exceptions coming out of the target. This namespace contains only
// the runtime environment agnostic types, with additional types found in the 'Native',
// 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Exceptions {
    struct DkmAddExceptionTriggerAsyncResult;
    class DkmExceptionCategoryTrigger;
    class DkmExceptionCodeTrigger;
    class DkmExceptionGlobalTrigger;
    class DkmExceptionInformation;
    struct DkmExceptionInterceptActionFlags { enum e; };
    class DkmExceptionNameTrigger;
    struct DkmExceptionProcessingStage { enum e; };
    class DkmExceptionTrigger;
    class DkmExceptionTriggerHit;
};

// Contains the types related to setting breakpoints. This includes both the high-level
// breakpoint classes (DkmPendingBreakpoint, etc) that offer the same capabilities as
// user-set breakpoints, as well as the lower-level DkmRuntimeBreakpoint classes that the
// high-level breakpoints are implemented upon.
namespace Breakpoints {
    class DkmBoundBreakpoint;
    class DkmBreakpointCondition;
    struct DkmBreakpointConditionOperator { enum e; };
    class DkmBreakpointFileUpdateNotification;
    class DkmBreakpointHitCountCondition;
    struct DkmBreakpointHitCountConditionOperator { enum e; };
    struct DkmBreakpointMessageLevel { enum e; };
    struct DkmBreakpointUnboundReason { enum e; };
    struct DkmClearRuntimeBreakpointConditionsAsyncResult;
    struct DkmClearRuntimeBreakpointHitCountConditionAsyncResult;
    struct DkmDataAccessStopMask { enum e; };
    struct DkmDisableBoundBreakpointAsyncResult;
    struct DkmDisablePendingBreakpointAsyncResult;
    struct DkmDisableRuntimeBreakpointAsyncResult;
    struct DkmEnableBoundBreakpointAsyncResult;
    struct DkmEnablePendingBreakpointAsyncResult;
    struct DkmEnableRuntimeBreakpointAsyncResult;
    struct DkmEnrollPendingBreakpointAsyncResult;
    struct DkmEvaluateConditionAndSelectThreadAsyncResult;
    class DkmEvaluationBreakpointCondition;
    struct DkmGetBoundBreakpointHitCountValueAsyncResult;
    struct DkmGetRuntimeBreakpointHitCountConditionAsyncResult;
    class DkmPendingAddressBreakpoint;
    class DkmPendingAddressNameBreakpoint;
    class DkmPendingBreakpoint;
    class DkmPendingDataBreakpoint;
    class DkmPendingFileLineBreakpoint;
    class DkmPendingFunctionBreakpoint;
    struct DkmRequestBreakpointEventOnModifiedThreadAsyncResult;
    class DkmRuntimeBreakpoint;
    class DkmRuntimeHardwareDataBreakpoint;
    class DkmRuntimeInstructionBreakpoint;
    struct DkmSetCompiledConditionAsyncResult;
    struct DkmSetCompiledConditionPendingAsyncResult;
    struct DkmSetEvaluationConditionAsyncResult;
    struct DkmSetPendingBreakpointConditionAsyncResult;
    struct DkmSetPendingBreakpointHitCountConditionAsyncResult;
    struct DkmSetRuntimeBreakpointHitCountConditionAsyncResult;
    struct DkmTestRuntimeBreakpointAsyncResult;
    struct DkmTryClearConditionOnTargetDeviceAsyncResult;
    struct DkmTryPushConditionToTargetDeviceAsyncResult;
};

// Contains the types used to implement setting in the debugger.
namespace Stepping {
    struct DkmLanguageStepIntoFlags { enum e; };
    class DkmNativeSteppingCallSite;
    class DkmSingleStepRequest;
    struct DkmStepArbitrationReason { enum e; };
    struct DkmStepKind { enum e; };
    struct DkmStepUnit { enum e; };
    class DkmStepper;
    class DkmSteppingCodePath;
    class DkmSteppingCodePathSource;
};

// Contains types for start debugging and launching processes.
namespace Start {
    struct DkmActivateAppPackageAsyncResult;
    class DkmDebugLaunchSettings;
    struct DkmLaunchedProcessInfo;
    class DkmProcessAttachRequest;
    struct DkmProcessLaunchEnvironmentFilterScenario { enum e; };
    struct DkmProcessLaunchModeFlags { enum e; };
    class DkmProcessLaunchRequest;
    class DkmProcessStartupInfo;
    struct DkmStartMethod { enum e; };
};

// Contains types used to perform the basic, generally pre-debugging, tasks on the target
// computer such as listing processes, deploying files, etc.
namespace DefaultPort {
    struct DkmActivateBackgroundTaskAsyncResult;
    class DkmAppPackageId;
    class DkmDeploymentCommand;
    struct DkmDeploymentCommandFlags { enum e; };
    struct DkmDownloadFileAsyncResult;
    struct DkmEnumerateBackgroundTasksAsyncResult;
    class DkmFileInfo;
    class DkmFileTransferStream;
    class DkmInstalledAppPackageInfo;
    class DkmInstalledApplicationInfo;
    struct DkmPackageExecutionState { enum e; };
    struct DkmPackagedAppPlatform { enum e; };
    struct DkmProcessorFeatures { enum e; };
    class DkmPublishedProgramInfo;
    struct DkmRemoteAuthenticationMode { enum e; };
    struct DkmRunningProcessFlags { enum e; };
    class DkmRunningProcessInfo;
    struct DkmRunningProcessInfoPropertyMask { enum e; };
    struct DkmShutDownAppPackageAsyncResult;
    class DkmStandardRemoteTransportConnection;
    struct DkmSuspendAppPackageAsyncResult;
    class DkmSystemInformation;
    struct DkmSystemInformationFlags { enum e; };
    class DkmTransportConnection;
    struct DkmTransportConnectionFlags { enum e; };
};

// Contains types specific to debugging code running under the Common Language Runtime
// (CLR).
namespace Clr {
    class DkmClrAppDomain;
    struct DkmClrAsyncMethodLocation { enum e; };
    struct DkmClrAwaitExpressionInfo;
    class DkmClrCaughtExceptionInformation;
    struct DkmClrDebuggingServicesId { enum e; };
    class DkmClrExceptionInformation;
    struct DkmClrHeaderStatus { enum e; };
    class DkmClrInstructionAddress;
    class DkmClrInstructionSymbol;
    class DkmClrLocalConstant;
    class DkmClrLocalVariable;
    struct DkmClrMethodId;
    struct DkmClrMethodScopeData;
    struct DkmClrModuleFlags { enum e; };
    class DkmClrModuleInstance;
    struct DkmClrNativeCodeMapEntry;
    class DkmClrRuntimeInstance;
    class DkmClrType;
    struct DkmGetAllAwaitExpressionInfoForStatementAsyncResult;
    struct DkmGetAsyncKickoffMethodAsyncResult;
    struct DkmGetAsyncMethodLocationAsyncResult;
    struct DkmGetMethodLocalSymbolsAsyncResult;
    struct DkmGetMethodSymbolStoreAttributeAsyncResult;
    struct DkmGetNextAwaitExpressionInfoAsyncResult;
    struct DkmILInterpreterOptions { enum e; };
    class DkmILInterpreterPrimitiveValue;
    class DkmILInterpreterReferenceValue;
    class DkmILInterpreterValue;
    struct DkmILRange;
    struct DkmManagedHeapObjectInfo;
    struct DkmManagedHeapRootInfo;
    class DkmManagedHeapSampler;
    struct DkmManagedHeapSegmentInfo;
    struct DkmManagedHeapTypeInfo;
    class DkmManagedHeapWalker;
    struct DkmManagedObjectReferenceInfo;
    class DkmManagedReturnStackFrame;
    class DkmManagedReturnValueContext;
    class DkmManagedReturnValueCopy;
    class DkmManagedReturnValueInfo;
    class DkmManagedReturnValueReference;
    struct DkmManagedTypeId;
    struct DkmMetadataStatus { enum e; };
    struct DkmNonUserCodeFlags { enum e; };
};

// Contains types specific to debugging code running under the native-compiled CLR.
namespace Clr { namespace NativeCompilation {
    class DkmClrNcContainerModuleInstance;
    class DkmClrNcInstanceFieldSymbol;
    class DkmClrNcInstructionAddress;
    class DkmClrNcInstructionSymbol;
    class DkmClrNcModuleInstance;
    class DkmClrNcRuntimeInstance;
};};

// Contains types specific to debugging native code.
namespace Native {
    class DkmCppExceptionInformation;
    class DkmCppWinRTExceptionInformation;
    struct DkmFindExportNameAsyncResult;
    struct DkmFindNearestExportAsyncResult;
    class DkmNativeAddressMetadata;
    struct DkmNativeAddressStepType { enum e; };
    struct DkmNativeAddressType { enum e; };
    class DkmNativeInstructionAddress;
    class DkmNativeInstructionSymbol;
    class DkmNativeModuleInstance;
    class DkmNativeRuntimeInstance;
    class DkmWin32ExceptionInformation;
};

// Contains types specific to debugging script code.
namespace Script {
    struct DkmOnScriptCriticalErrorAsyncResult;
    class DkmScriptBlockMappingInfo;
    class DkmScriptDocument;
    struct DkmScriptDocumentContentType { enum e; };
    struct DkmScriptDocumentFlags { enum e; };
    struct DkmScriptDocumentJmcState { enum e; };
    class DkmScriptDocumentTreeNode;
    struct DkmScriptEmbeddedDocumentKind { enum e; };
    class DkmScriptInstructionAddress;
    class DkmScriptInstructionSymbol;
    class DkmScriptRuntimeInstance;
    class DkmScriptSourceProjectItem;
    struct DkmScriptSymbolNextSteppingAction { enum e; };
    struct DkmSetRaiseSymbolEventsAsyncResult;
};

// Contains types specific to GPU debugging.
namespace GPU {
    struct DkmComputeKernelModel { enum e; };
    struct DkmComputeProperty;
    struct DkmComputeThreadInfo;
    struct DkmComputeThreadState { enum e; };
    struct DkmGPUAddressType { enum e; };
    struct DkmGPUBreakpointBehaviorFlags { enum e; };
    class DkmGPUComputeKernel;
    class DkmGPUComputeThread;
    class DkmGPUDataAddress;
    class DkmGPUMemoryAccessExceptionInformation;
    struct DkmGPURegisterDescription;
    struct DkmHlslThreadIdComponents { enum e; };
    struct DkmQueryComputeThreadInfoFlags { enum e; };
    struct DkmWhereClause;
};

// Contains types specific to extending the debugger to support a custom execution
// environment.
namespace CustomRuntimes {
    class DkmCustomExceptionInformation;
    class DkmCustomInstructionAddress;
    class DkmCustomInstructionSymbol;
    class DkmCustomModuleInstance;
    class DkmCustomRuntimeInstance;
};

// Contains types specific to runtime environment agnostic disassembly.
namespace Disassembly {
    class DkmDisassembledInstruction;
    struct DkmEffectiveAddress;
    struct DkmEffectiveAddressFlags { enum e; };
};

// Contains types used to describe properties of threads running in the target process.
namespace ThreadProperties {
    struct DkmGetManagedThreadPropertiesAsyncResult;
    struct DkmGetThreadDisplayPropertiesAsyncResult;
    struct DkmGetThreadNameAsyncResult;
    struct DkmGetVolatileFlagsAsyncResult;
    struct DkmGetVolatilePropertiesAsyncResult;
    struct DkmVolatileThreadFlags { enum e; };
};

// Contains types used to provide data to the 'Parallel Tasks' and 'Parallel Stacks'
// debugger windows. Types in this namespace are subject to change in future versions of
// Visual Studio.
namespace ParallelTasks {
    struct DkmManagedTaskInfo;
    class DkmTask;
    struct DkmTaskProperties;
    class DkmTaskProvider;
    struct DkmTaskProviderCapabilityFlags { enum e; };
    struct DkmTaskReturnStatus { enum e; };
    struct DkmTaskStackSegment;
    class DkmTaskSynchronizationObject;
};

// Contains types which are Microsoft-internal and subject to change.
namespace Internal {
    class DkmEELocalObject;
    class DkmPropertyProxy;
};

// Include SAL 2.0 definition for compiling aganst older versions of sal.h
#ifndef SAL_VERSION_SAL2
#define _Field_size_opt_(size)
#endif

///<summary>
///Tuple of a pointer to a raw array, and the number of elements contained within the
///raw array.
///
///Memory Allocation:
///1. There are no requirements as to how the struct ITSELF is allocated.
///   Generally, it should be simply placed on the stack.
///2. If the DkmArray is being passed as input, or as a buffer which is allocated by the
///   caller, then there are no requirements on the way that 'Members' is allocated.
///3. When returned from a function as a callee-allocated buffer, this memory
///   should be allocated with DkmAllocBytes/DkmAllocArray and freed with DkmFreeMemory.
///</summary>
template <typename T>
struct DkmArray
{
    _Field_size_opt_(Length) T* Members; // Pointer to a raw array of 'Length' elements
    DWORD Length;
};

// Allocate zero-initialized memory from the Dispatcher's heap. This is primarily used for
// array memory.
DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DkmAllocBytes(
    _In_ size_t bytes,
    _Out_bytecap_(bytes) void** ppMemory
    );

// Allocate a DkmArray of the specified size. On successful return, the
// count of elements will be set to the specified value, and the 'Members' field
// will point to a block of zero-initialized memory.
template <class T>
DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DkmAllocArray(
    _In_ size_t elements,
    _Out_ DkmArray<T>* pArray
    );

// Free a DkmArray, releasing its elements.
template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmFreeArray(
    _In_ const DkmArray<T>& Array
    );

// Release an element from a DkmArray.
template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(
    T& element
    );

// Free memory allocated with DkmAllocBytes
DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmFreeMemory(
    _Post_ptr_invalid_ void* pMemory
    );

DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseInterface(
    _In_opt_ IUnknown* pObject
    );




/* Class DkmDataContainer Description

DkmDataContainer is a building block which is used throughout this API. It allows many
of the objects in this API to contain 'virtual fields' which are added by any component
in the system. This is similar to a type-safe version of the 'expando' concept in
JScript.

Rules for DkmDataContainer:
1. All the 'reference' objects in the system inherit from DkmDataContainer. Reference
objects are tracked by the dispatcher component of this system, and at various
marshalling points (managed->native, native->managed, remoting) the object reference
identity is preserved. 'Value' objects do not inherit from DkmDataContainer because
the system does not track these objects, so at any marshalling transition, the value
of the object is copied.
2. The 'virtual fields' of these objects which inherit from DkmDataContainer are
called data items.
3. Data items are PRIVATE to the component that added them. This feature cannot be
used to share fields across component boundaries.
4. Data items are instances of a data item class. In managed code, data item classes
inherit from DkmDataItem to identify them as a data item. In native code, data items
inherit from IUnknown.
5. Usually, a component would never need to remove a data item. This is because data
items are automatically removed when the container object is closed.

Example:
//In native code, data items need to implement IUnknown and have a associated UUID.
//UUID should be randomly generated with a GUID generation tool.
class __declspec(uuid("{250266E5-99C0-4d4d-ABD4-39B53F1A59EA}")) CMyDataItem :
    // If the data item wishes to perform additional cleanup on container close, it may implement
    // IDkmDisposableDataItem in addition to IUnknown
    public IDkmDisposableDataItem
    // If the data item is passed as the 'DataItem' argument to a 'Create' method, it
    // may also wish to implement IDkmDataContainerCreateNotification
{
    // Object needs to declare the data that it wants to associate with the Dkm object
    int m_field1;

    // Object needs to implement IUnknown. Here is a very simple implementation
    volatile LONG m_refCount;

    ULONG __stdcall AddRef()
    {
        return (ULONG)InterlockedIncrement(&m_refCount);
    }
    ULONG __stdcall Release()
    {
        ULONG result = (ULONG)InterlockedDecrement(&m_refCount);
        if (result == 0)
        {
            delete this;
        }
        return result;
    }
    HRESULT __stdcall QueryInterface(REFIID riid, _Deref_out_ void** ppv)
    {
        if (riid == __uuidof(IUnknown))
        {
            *ppv = static_cast<IUnknown*>(this);
            AddRef();
            return S_OK;
        }
        // This example is implementing the optional interface IDkmDisposableDataItem
        else if (riid == __uuidof(IDkmDisposableDataItem))
        {
            *ppv = static_cast<IDkmDisposableDataItem*>(this);
            AddRef();
            return S_OK;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }

    // Data items can override the 'IDkmDisposableDataItem::OnClose' method to receive
    // notification when the data container object.
    HRESULT __stdcall OnClose()
    {
        printf("CMyDataItem is going away\n");

        return S_OK;
    }

public:
    CMyDataItem(int field1)
    {
        m_refCount = 1;
        m_field1 = field1;
    }
};

// create a new instance of the example data object
CComPtr<CMyDataItem> pMyDataItem;
pMyDataItem.Attach( new CMyDataItem(12) );

// data items can be passed to a create method...
CComPtr<DkmClrAlias> pNewObject;
DkmClrAlias::Create("ExampleName", pMyDataItem, &pNewObject);

// ...or then can be added using SetDataItem
pNewObject->SetDataItem(DkmDataCreationDisposition::CreateAlways, pMyDataItem);
*/
class DECLSPEC_NOVTABLE DECLSPEC_UUID("0DBABB2A-C342-49c9-B8A5-8764834CD78C") DkmDataContainer : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    private: void* m_DataContainerCollection;
    private: void* m_pCreator;
    private: void* m_pCreateEventPosition;
    private: CRITICAL_SECTION m_ObjectCriticalSection;

    // DkmDataContainer is an abstract base class
    protected: DkmDataContainer();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmDataContainer();
    // This object cannot be copied
    private: DkmDataContainer& operator=(const DkmDataContainer&);
    private: DkmDataContainer(const DkmDataContainer&);

    // Place a new item within this data container.
    // CreationDisposition: Action to be taken if there is already an item with the
    // same id.
    // item  : Item to add to the container. The DkmDataItem structure is usually
    // implicitly created from a pointer to a data item class. See DkmDataContainer for
    // more information.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDataItem(
        _In_ DkmDataCreationDisposition::e CreationDisposition,
        _In_ const struct DkmDataItem& item
        );

#if !defined(NO_DATA_CONTAINER_TEMPLATES)
    // Gets the instance of 'T' which has been added to this container instance.
    // T  : Type of a data item class. The compiler can determine 'T' from the 'ppObject'
    // argument. This method can be used with any data item class which uses
    // '__declspec(uuid(<value>))' to associate a UUID (GUID) with the class.
    // ppobject : Returns the 'T' object for this container instance.
    // Return value : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_DATA_ITEM_NOT_FOUND indicates that there is no instance of 'T'
    // associated with this object.
    public: template <class T> DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDataItem(
        _Deref_out_ T** ppObject
        );
#endif

    // Gets the value associated with 'ItemId'.
    // ItemId     : GUID Item key.
    // ppObject   : Value associated with 'ItemId'
    // Return value : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_DATA_ITEM_NOT_FOUND indicates that the container does not have a
    // value for 'ItemId'.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDataItem(
        _In_ REFGUID ItemId,
        _Deref_out_ IUnknown** ppObject
        );

#if !defined(NO_DATA_CONTAINER_TEMPLATES)
    // Remove the instance of 'T' from this container. It is usually unnecessary to call
    // this method as a data container will automatically be emptied when the object is
    // closed.  If this contain does not have a 'T', this function will return S_FALSE.
    // T  : Type of a data item class.
    public: template <class T> DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveDataItem(
        );
#endif

    // Remove the value associated with 'ItemId' from this container. It is usually
    // unnecessary to call this method as a data container will automatically be emptied
    // when the object is closed.  If no value is associated, this function will return
    // S_FALSE.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveDataItem(
        _In_ REFGUID ItemId
        );

    // Returns true if a 'unloaded' event has been raised for this object (example:
    // DkmThread::Unload is called) or if the object has been closed. Note that care
    // must be used when checking this status as, without synchronization, the returned
    // status may no longer be accurate the instruction after it is read.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsUnloaded(
        );
}; // end of DkmDataContainer

// DkmDataItem is a pairing between a pointer to an instance of a data item class, and
// the associated GUID value used to identify this class. DkmDataItem is usually
// implicitly constructed, so code doesn't directly make use of it.
// See DkmDataContainer for more information.
struct DkmDataItem
{
    const LPUNKNOWN pValue;
    const GUID Id;

#if !defined(NO_DATA_CONTAINER_TEMPLATES) && !defined(VSDEBUGENG_NO_ATL)
    // Implicitly create a DkmDataItem. This overload is used when the pointer to the
    // data item class has been stored in a CComPtr.
    template <class T>
    DkmDataItem(_In_ const ATL::CComPtr<T>& pObject)
        : pValue(pObject.p), Id(__uuidof(T))
    {
    }
#endif

#if !defined(NO_DATA_CONTAINER_TEMPLATES)
    // Implicitly create a DkmDataItem from a pointer to a data item class.
    template <class T>
    DkmDataItem(_In_ T* pObject)
        : pValue(pObject), Id(__uuidof(T))
    {
    }
#endif

    // Explicitly construct a DkmDataItem. This overload is only necessary when it is
    // useful to calculate the ItemId instead of using the GUID associated with an item
    // class.
    DkmDataItem(_In_ IUnknown* pItemValue, _In_ const GUID& ItemId)
        : pValue(pItemValue), Id(ItemId)
    {
    }

    // Returns the empty DkmDataItem for passing to an object 'Create' method.
    static const DkmDataItem& STDMETHODCALLTYPE Null(
        );
};

// Optional interface which native data item classes may implement to receive
// notification when their container object is closed. This interface may be helpful to break AddRef cycles.
#define IID_IDkmDisposableDataItem __uuidof(Microsoft::VisualStudio::Debugger::IDkmDisposableDataItem)
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("39738b1d-2e90-4164-a21c-749be02f9a96") IDkmDisposableDataItem : public IUnknown
{
    // 'OnClose' is invoked on all data items when a data container is closed.
    virtual HRESULT STDMETHODCALLTYPE OnClose(
        ) = 0;
};

// Optional interface which native data item classes may implement to obtain a pointer to
// a newly created data container that the item has been added to. This interface is only
// used when the data item is passed as the 'DataItem' argument to a 'Create' method.
// This allows the data item to obtain the newly created dispatcher object before this
// dispatcher object has been passed to any other component.
//
// Example:
// class CMyModuleDataItem : public IDkmDataContainerCreateNotification
// {
// public:
//     CComPtr<DkmModule> m_pModule;
//
//     HRESULT OnContainerCreated(DkmDataContainer* pContainer)
//     {
//         return pContainer->QueryInterface(&m_pModule);
//     }
//
//     ...
// };
//
// CMyModuleDataItem* pMyDataItem = new CMyModuleDataItem();
//
// CComPtr<DkmModule> pModule;
// hr = DkmModule::Create(..., pMyDataItem, &pModule);
// if (FAILED(hr))
//     return hr;
//
// ASSERT(pModule == pMyDataItem->m_pModule);
#define IID_IDkmDataContainerCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::IDkmDataContainerCreateNotification)
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("86c6f523-22af-46be-a4bc-a9e3b82fa5d9") IDkmDataContainerCreateNotification : public IUnknown
{
    // 'OnContainerCreated' is invoked when a 'Create' method succeeds in creating the object
    // and adding the initial data item to the collection
    virtual HRESULT STDMETHODCALLTYPE OnContainerCreated(
        _In_ DkmDataContainer* pContainer
        ) = 0;
};

// Callback interface which fires when an asynchronous request completes. This must be
// implemented by any component that appends work items to a work list.
//
// TResult: each async operation defines a 'Result' structure containing any returned
// data (including a status code). TResult is this struct.
template <class TResult>
interface DECLSPEC_NOVTABLE IDkmCompletionRoutine : public IUnknown
{
    // Function fired when results are complete.
    virtual void STDMETHODCALLTYPE OnComplete(
        _In_ const TResult& Result
        ) = 0;
};

// {F9A8DEDF-C104-495b-BA47-5C33364A3F6E}
__declspec(selectany) const extern IID IID_IDkmCompletionRoutine =
{ 0xf9a8dedf, 0xc104, 0x495b, { 0xba, 0x47, 0x5c, 0x33, 0x36, 0x4a, 0x3f, 0x6e } };

// Optional interface which is fired when the work list is complete, including firing
// all completion routines.
#define IID_IDkmWorkListCompletionRoutine __uuidof(Microsoft::VisualStudio::Debugger::IDkmWorkListCompletionRoutine)
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1CE48366-A05C-4955-BE03-8436A0662D8F") IDkmWorkListCompletionRoutine : public IUnknown
{
    // 'OnComplete' is called when processing for the work list has completed.
    virtual void STDMETHODCALLTYPE OnComplete(
        _In_ class DkmWorkList* pWorkList
        ) = 0;
};

// Internal flags indicating the current state of a work list.
struct DkmWorkListFlags
{
    enum e
    {
        // No flags are currently set
        None = 0x0,
        // Critical Section has been initialized
        LockInitialized = 0x1,
        // The 'Create' method succeeded
        Created = 0x2,
        // Processing has begun for the work list
        Started = 0x4,
        // Processing started and all work items are complete (no new work items are allowed)
        ItemsComplete = 0x8,
        // The completion routine has finished executing
        CompleteInvoked = 0x10,
        // The work list was canceled before being marked as complete
        Canceled = 0x20,
        // We are currently invoking work items
        InvokingItems = 0x40,
        // The work items are executed on the thread that called 'Execute'
        InvokingOnExecuteThread = 0x80,
        // We added a task to the request thread to process requests/replies for this work list
        ScheduledNetProcessing = 0x100
    };
};
DEFINE_ENUM_FLAG_OPERATORS(DkmWorkListFlags::e);

// Collection of asynchronous work items which are processed together. Work items
// are appended by calling any of the asynchronous methods throughout this API. Work
// items may be appended freely until the work list begins execution. Once execution has
// begun, additional work may only be appended from the implementation of a work item
// processing interface, or from a completion routine.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("E33525D5-B5F4-4A7C-BF6B-4A5ED9D2646E") DkmWorkList : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: size_t m_ObjectGCHandle;
    private: const GUID m_UniqueId;
    private: DkmWorkListFlags::e m_Flags;

    // Use DkmWorkList::Create to create this object
    private: DkmWorkList();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmWorkList();
    // This object cannot be copied
    private: DkmWorkList& operator=(const DkmWorkList&);
    private: DkmWorkList(const DkmWorkList&);

    // Creates a new empty work list object. Callers should append operations to the
    // work list and then start execution ('BeginExecution' or 'Execute').
    //
    // Once created, a WorkList object will continue to exist until its execution is
    // completed, or until the request is canceled. So callers should ensure that
    // 'Cancel' is called in the case of failure.
    //
    // pCompletionRoutine: [In,Optional] Optional function which is fired when the work
    // list is complete, including firing all completion routines.
    // ppCreatedObject : [Out] Result of this method call.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_opt_ IDkmWorkListCompletionRoutine* pCompletionRoutine,
        _Deref_out_ DkmWorkList** ppCreatedObject
        );

    // This function allows a component to determine if the current operation should be
    // canceled. This will return true when called from a thread which is currently
    // processing a work list, and when this work list has been canceled.
    //
    // This will fail if called from a completion routine or from a thread that is not
    // currently processing an interface call.
    //
    // Example:
    // for (DWORD c = 0; c < myFiles.GetCount(); c++)
    // {
    //     if (DkmWorkList::QueryIsCurrentInstanceCanceled() == S_OK)
    //         return COR_E_OPERATIONCANCELED;
    //
    //     ProcessFile(myFiles[c]);
    // }
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryIsCurrentInstanceCanceled(
        );

    // This property allows a component processing a work item to determine if it is
    // canceled, or for a completion routine to determine if the operation was canceled.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsCanceled(
        );

    // Begin execution of the items in this work list. This API will return immediately
    // and completion routines are fired to return results. Callbacks will fire as
    // results complete (unordered).
    //
    // This method may only be called by the component which created the object.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeginExecution(
        );

    // Synchronously execute all items in the work list and return when processing is
    // complete or has been canceled, including firing all completion routines. Callbacks
    // will fire as results are complete (unordered).
    //
    // This method may only be called by the component which created the object. This
    // method will fail if execution is already in progress.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
        );

    // Cancel execution of this work list. This API will return once all work on this
    // work queue has stopped (state reaches canceled or completed). The request is
    // ignored if the work list is already canceled. This method may only be called by
    // the component which created the object.
    //
    // Note for components declared as 'Synchronized' in the component configuration:
    // calling this API may implicitly release and then reacquire the lock around your
    // component. Be mindful of possible state changes.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Cancel(
        );
}; // end of DkmWorkList

class DkmSourceString;
class DkmString;
template <class T> class DkmReadOnlyCollection;



//
// Macro to allocate a BSTR from a DkmString. This is done as a macro to avoid
// interfering with BSTR leak tracking macros
#define DkmSysAllocString(dkmString) \
    SysAllocStringLen(Microsoft::VisualStudio::Debugger::DkmString::Value(dkmString), Microsoft::VisualStudio::Debugger::DkmString::Length(dkmString))


class DECLSPEC_UUID("1c64ee50-f8e3-4554-b67c-c8f5c91fea3a") DkmString : public IUnknown
{
    public: static const DWORD MaxLength = 0x0fffffff;
    private: DWORD m_ReferenceCount;
    private: const DWORD m_Length;
    private: const WCHAR m_Value[ANYSIZE_ARRAY];

    // DkmString's should never be directly allocated or copied
    private: DkmString();
    private: DkmString(const DkmString&);
    private: DkmString& operator=(const DkmString&);
    // This object is refcounted. It is deleted through Release
    protected: ~DkmString();

public:
    /// <summary>
    /// Accesses the underlying null terminated Unicode string in a DkmString. Note that
    /// a DkmString is immutable, so the returned value is a 'const' string and should
    /// NOT be written to.
    /// </summary>
    /// <example>
    /// MessageBox(NULL, pMessage->Value(), L"My message box", MB_OK);
    /// </example>
    _Ret_z_ inline const WCHAR* Value(
        ) const
    {
        return m_Value;
    }

    /// <summary>
    /// Returns the length of the string. For strings that do not contain embedded nulls,
    /// this value will match the length returned from wcslen.
    /// </summary>
    _Ret_range_(0,0x0fffffff) inline DWORD Length(
        ) const
    {
        return m_Length;
    }

    /// <summary>
    /// Accesses the underlying null terminated Unicode string in a DkmString. Note that
    /// a DkmString is immutable, so the returned value is a 'const' string and should
    /// NOT be written to.
    /// </summary>
    /// <example>
    /// SysAllocString(DkmString::Value(pString));
    /// </example>
    _Ret_opt_z_ static inline const WCHAR* Value(
        _In_opt_ DkmString* pString
        )
    {
        if (pString == NULL)
            return NULL;
        else
            return pString->Value();
    }

    /// <summary>
    /// Returns the length of the string. For strings that do not contain embedded nulls,
    /// this value will match the length returned from wcslen.
    /// </summary>
    _Ret_range_(0,0x0fffffff) static inline DWORD Length(
        _In_opt_ DkmString* pString
        )
    {
        if (pString == NULL)
            return 0;
        else
            return pString->Length();
    }

    /// <summary>
    /// Create a DkmString from a DkmStringSource. If the InputString is empty, the empty string will be returned.
    /// </summary>
    /// <example>
    /// DkmString::Create(L"Example String", &pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        const DkmSourceString& InputString,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Create a DkmString from a multi-byte string (ANSI, UTF-8, etc). If the InputString is empty, the empty string will be returned.
    /// </summary>
    /// <example>
    /// DkmString::Create(CP_THREAD_ACP, "hi", 2, &pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_ DWORD CodePage,
        _In_bytecount_(cbMultiByte) const char* pMultiByteString,
        _In_ size_t cbMultiByte,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Returns true if the given string variable is a NULL pointer or if it is the empty
    /// string.
    /// </summary>
    static inline bool IsNullOrEmpty(
        _In_opt_ DkmString* pString
        )
    {
        return (pString == NULL || pString->Length() == 0);
    }

    /// <summary>
    /// Compares two strings by evaluating the numeric values of each character in the
    /// string. This is a binary comparison which will not ignore case.
    /// </summary>
    /// <param name="a">The first string to compare</param>
    /// <param name="b">The second string to compare</param>
    /// <returns>
    /// An integer indicating the lexical relationship between the two comparands. A
    /// negative return value if 'a' is less than 'b'. Zero if 'a' is equal to 'b'. A
    /// positive return value if 'a' is greater than 'b'.</returns>
    /// <example>
    /// if (DkmString::CompareOrdinal(L"A", L"A") == 0)
    /// {
    ///   ...
    /// }
    /// </example>
    DECLSPEC_NOTHROW static int STDMETHODCALLTYPE CompareOrdinal(
        const DkmSourceString& a,
        const DkmSourceString& b
        );

    /// <summary>
    /// Compare strings using ordinal sort rules and ignoring the case of the strings.
    /// This comparison is locale-invariant and will follow the same casing rules as the
    /// operating system, so it is appropriate for comparing file names, registery paths,
    /// etc.
    /// </summary>
    /// <param name="a">The first string to compare</param>
    /// <param name="b">The second string to compare</param>
    /// <returns>
    /// An integer indicating the lexical relationship between the two comparands. A
    /// negative return value if 'a' is less than 'b'. Zero if 'a' is equal to 'b'. A
    /// positive return value if 'a' is greater than 'b'.
    /// </returns>
    /// <example>
    /// if (DkmString::CompareOrdinalIgnoreCase(L"A", L"a") == 0)
    /// {
    ///   ...
    /// }
    /// </example>
    DECLSPEC_NOTHROW static int STDMETHODCALLTYPE CompareOrdinalIgnoreCase(
        const DkmSourceString& a,
        const DkmSourceString& b
        );

    /// <summary>
    /// Concatenate various strings together to create a DkmString.
    /// </summary>
    /// <example>
    /// DkmString::Concat(L"One", L" -and- ", L"Two", &pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        const DkmSourceString& item7,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        const DkmSourceString& item7,
        const DkmSourceString& item8,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        const DkmSourceString& item7,
        const DkmSourceString& item8,
        const DkmSourceString& item9,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Concatenate various strings together to create a DkmString.
    /// </summary>
    /// <example>
    /// DkmSourceString sources[2] = { DkmSourceString(L"one"), DkmSourceString(L"two") };
    /// DkmString::ConcatV(sources, _countof(sources), &pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE ConcatV(
        _In_count_(cSources) const DkmSourceString sources[],
        _In_ DWORD cSources,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Returns the empty string singleton object. Note that the empty string object is a
    /// singleton with infinite lifetime. So the caller does not need to monitor the
    /// reference count on this object.
    /// </summary>
    /// <example>
    /// DkmString::Empty()
    /// </example>
    _Ret_ DECLSPEC_NOTHROW static DkmString* STDMETHODCALLTYPE Empty(
        );

};

// DkmSourceString is used an input to functions which create a DkmString
// (DkmString::Create or DkmString::Concat).
//
// Generally this class is implicitly constructed by the compiler, so the consumer
// of these APIs does NOT need to explicitly create an instance.
//
// Example:
// DkmString::Create(L"My string", &pString);
//
// Here the compiler will automatically create a DkmSourceString from the string
// literal 'My string'.
class DkmSourceString
{
    LPCWSTR Text;
    DWORD Length;

    static DWORD LengthOf(_In_opt_z_ LPCWSTR text)
    {
        if (text == NULL)
            return 0;

        for (DWORD length = 0; true; length++)
        {
            if (text[length] == 0)
                return length;
            if (length > DkmString::MaxLength)
                return length;
        }
    }

public:
    DkmSourceString() : Text(NULL), Length(0)
    {
    }

    // DkmSourceString(LPCWSTR, DWORD) is used to explicitly define an input string
    // with its length. This is required when trying to create a DkmString that contains
    // embedded '\0' characters, or when trying to create a DkmString from data which may
    // not be null terminated.
    DkmSourceString(_In_opt_count_(length) LPCWSTR text, DWORD length) : Text(text), Length(length)
    {
    }

    // DkmSourceString(LPCWSTR) is used to implicitly convert from a null-terminated
    // Unicode string into a DkmSourceString
    DkmSourceString(_In_opt_z_ LPCWSTR text) : Text(text), Length(LengthOf(text))
    {
    }

    // DkmSourceString(DkmString*) is used to implicitly convert from a DkmString
    // into a DkmSourceString
    DkmSourceString(_In_opt_ DkmString* pString) :
        Text(DkmString::Value(pString)),
        Length(DkmString::Length(pString))
    {
    }

#ifndef VSDEBUGENG_NO_ATL
    // DkmSourceString(const ATL::CComPtr<DkmString>&) is used to implicitly convert
    // from a DkmString which is held in an ATL smart pointer into a DkmSourceString
    DkmSourceString(const ATL::CComPtr<DkmString>& pString) :
        Text(DkmString::Value(pString)),
        Length(DkmString::Length(pString))
    {
    }
#endif

#ifndef VSDEBUGENG_NO_ATL
    // DkmSourceString(const ATL::CComBSTR&) is used to implicitly convert from a BSTR
    // which is held in an ATL smart BSTR into a DkmSourceString
    DkmSourceString(const ATL::CComBSTR& bstr) : Text(bstr), Length(bstr.Length())
    {
    }
#endif

#ifndef VSDEBUGENG_NO_ATL
    // DkmSourceString(const ATL::CStringW&) is used to implicitly convert from an ATL
    // CString into a DkmSourceString
    DkmSourceString(const ATL::CStringW& str) : Text(str), Length((DWORD)str.GetLength())
    {
    }
#endif

#ifdef VSDEBUGENG_USE_STL
    // DkmSourceString(const std::wstring&) is used to implicitly convert from an STL
    // std::string into a DkmSourceString
    DkmSourceString(const std::wstring& string) : Text(string.c_str()), Length(string.length())
    {
    }
#endif
};

// Like DkmSourceString, DkmSourceBSTR is used an input to functions which create a
// DkmString (DkmString::Create or DkmString::Concat).
//
// This class is used to explicitly declare that an input string is a BSTR.
//
// Example:
// BSTR bstrResult;
// pExample->GetResult(&bstrResult);
//
// DkmString::Create(DkmSourceBSTR(bstrResult), &pString);
struct DkmSourceBSTR : public DkmSourceString
{
    // Constructs a new DkmSourceBSTR
    explicit DkmSourceBSTR(_In_opt_ BSTR bstr)
        : DkmSourceString(bstr, SysStringLen(bstr))
    {
    }
};

// Like DkmSourceString, DkmSourceStringLiteral is used an input to functions which
// create a DkmString (DkmString::Create or DkmString::Concat).
//
// This class is used to explicitly declare string literals such that the length of the
// literal can be assigned at compile time.
//
// Example:
// DkmString::Create(DkmSourceStringLiteral(L"My string"), &pString);
struct DkmSourceStringLiteral : public DkmSourceString
{
    // Constructs a new DkmSourceStringLiteral
    template <int CCH> explicit DkmSourceStringLiteral(const WCHAR (&string)[CCH])
        : DkmSourceString(string, CCH-1)
    {
    }
};

template <class T>
class DkmReadOnlyCollection : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: const DWORD m_Count;
    private: const FARPROC m_pElementRelease;
    private: __declspec(align(16)) const T m_Items[ANYSIZE_ARRAY];

    // DkmReadOnlyCollection's should never be directly allocated or copied
    private: DkmReadOnlyCollection();
    private: DkmReadOnlyCollection(const DkmReadOnlyCollection<T>&);
    private: DkmReadOnlyCollection<T>& operator=(const DkmReadOnlyCollection<T>&);
    // This object is refcounted. It is deleted through Release
    protected: ~DkmReadOnlyCollection();

public:
    /// <summary>
    /// Provides access to the underlying array. Note that DkmReadOnlyCollection
    /// represents an immutable array, so the returned value is a 'const' array and
    /// should NOT be written to.
    /// </summary>
#if _MSC_VER >= 1700 // VS 2010 cannot handle this annotation
    _Ret_count_(Count())
#endif
    const T* Items(
        )
    {
        return m_Items;
    }

    /// <summary>
    /// Gets the number of elements contained in the ReadOnlyCollection instance.
    /// </summary>
    _Ret_range_(0,0x7FFFFFFF/sizeof(T)) inline DWORD Count(
        )
    {
        return m_Count;
    }

    /// <summary>
    /// Accesses an element in the collecion. Note that DkmReadOnlyCollection
    /// represents an immutable array, so the returned value is a 'const' element and
    /// should NOT be written to.
    /// </summary>
    /// DkmReadOnlyCollection<DkmString*>* pStringCollection;
    /// MyExampleFunction(&pStringCollection);
    /// printf("First returned string was '%S'\n", pStringCollection->Element(0));
    DECLSPEC_NOTHROW const T& STDMETHODCALLTYPE Element(
        size_t index
        );

    /// <summary>
    /// Create a DkmReadOnlyCollection<T> instance.
    /// </summary>
    /// <example>
    /// DkmReadOnlyCollection<DkmString*>* pStringCollection;
    /// DkmString* strings[2];
    /// DkmString::Create(L"String1", &strings[0]);
    /// DkmString::Create(L"String2", &strings[1]);
    /// DkmReadOnlyCollection<DkmString*>::Create(strings, _countof(strings), &pStringCollection);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_count_(Count) const T* pItemArray,
        _In_ DWORD Count,
        _Deref_out_ DkmReadOnlyCollection<T>** ppCollection
        );

    /// <summary>
    /// Create a DkmReadOnlyCollection<T> instance from a DkmArray<T>.
    /// </summary>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_ const DkmArray<T>& input,
        _Deref_out_ DkmReadOnlyCollection<T>** ppCollection
        )
    {
        return Create(input.Members, input.Length, ppCollection);
    }

    /// <summary>
    /// Returns true if the given collection variable is a NULL pointer or if the
    /// collection contains no objects.
    /// </summary>
    static inline bool IsNullOrEmpty(
        _In_opt_ DkmReadOnlyCollection<T>* pCollection
        )
    {
        return (pCollection == NULL || pCollection->Count() == 0);
    }

    // Searches for the specified object and returns the zero-based index of the
    // first occurrence within the entire DkmReadOnlyCollection.
    // value           : [In,Optional] The value to search for in the collection,
    // the value can be nullptr if the collection is a pointer collection
    // Return value    : The index of the element if the element is found. MAXDWORD
    // if the element is not found.
    inline DWORD IndexOf(
        _In_opt_ const T& value
        )
    {
        const DWORD count = this->Count();
        for (DWORD c = 0; c < count; c++)
        {
            if (m_Items[c] == value)
            {
                return c;
            }
        }

        return MAXDWORD;
    }

    // Determines whether an element is in the DkmReadOnlyCollection.
    // value           : [In,Optional] The value to search for in the collection,
    // the value can be nullptr if the collection is a pointer collection
    // Return value    : true if value is found; otherwise, false.
    inline bool Contains(
        _In_opt_ const T& value
        )
    {
        return IndexOf(value) != MAXDWORD;
    }

    /// <summary>
    /// Returns the empty collection object. Note that the empty collection object is a
    /// singleton with infinite lifetime. So the caller does not need to monitor the
    /// reference count on this object.
    /// </summary>
    /// <example>
    /// DkmReadOnlyCollection::Empty()
    /// </example>
    _Ret_ static DkmReadOnlyCollection<T>* STDMETHODCALLTYPE Empty(
        );

};

/// <summary>
/// DkmXmm128 represents the content of a 128-bit XMM register on x64 systems
/// </summary>
union DkmXmm128
{
    float Single[4];
    double Double[2];
    UINT64 u64[2];
    UINT32 u32[4];
};
__declspec(selectany) const extern DkmXmm128 DkmXmm128_Zero = {0};

class DECLSPEC_UUID("030c428a-30e8-4e9d-9586-85e03b80e3d6") DkmVariant : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: const VARIANT m_Value;

    // DkmVariant's should never be directly allocated or copied
    private: DkmVariant();
    private: DkmVariant(const DkmVariant&);
    private: DkmVariant& operator=(const DkmVariant&);
    // This object is refcounted. It is deleted through Release
    protected: ~DkmVariant();

public:
    /// <summary>
    /// Accesses the VARIANT stored within this object. Note that the variant will
    /// never be empty.
    /// </summary>
    inline const VARIANT& Value(
        )
    {
        return m_Value;
    }

    /// <summary>
    /// Returns the type of VARIANT stored in this object (ex: VT_BSTR for strings,
    //  VT_SAFEARRAY for arrays). Note that the type will never be VT_EMPTY.
    /// </summary>
    inline VARTYPE Type(
        )
    {
        return m_Value.vt;
    }

    /// <summary>
    /// Allocates a new DkmVariant. The value of this new DkmVariant comes from the source
    /// argument. On success, the source argument will be set to an empty variant.
    ///
    /// If pSource is an empty VARIANT (VT_EMPTY) a NULL DkmVariant will be returned, and
    /// the status code will be S_FALSE.
    /// </summary>
    /// <example>
    /// CComVariant helloWorld(L"Hello World");
    /// CComPtr<DkmVariant> pNewObject;
    /// DkmVariant::Convert(&helloWorld, &pNewObject);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Convert(
        _Inout_ VARIANT* pSource,
        _Deref_out_opt_ DkmVariant** ppVariant
        );

    /// <summary>
    /// Allocates a new DkmVariant from a source BYTE array. This may be used to send
    /// serialized data from one component to another. The resulting variant will have
    /// a type of VT_ARRAY | VT_UI1, with:
    ///   size = DkmVariant::Value().parray->rgsabound->cElements
    ///   value = DkmVariant::Value().parray->pvData
    /// </summary>
    /// <example>
    /// CComPtr<DkmVariant> pNewObject;
    /// BYTE bytes[] = { 1, 2, 3, 4 };
    /// DkmVariant::Create(bytes, _countof(bytes), &pNewObject);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_count_(size) const BYTE* pValue,
        DWORD size,
        _Deref_out_ DkmVariant** ppVariant
        );

};

// Static class containing settings which are global to the debugger process
/*static*/ class DkmGlobalSettings
{
public:
    // Language Identifier used by Visual Studio. For example, 1033 (MAKELANGID(LANG_ENGLISH,
    // SUBLANG_ENGLISH_US)) is used for English strings.
    static DECLSPEC_NOTHROW LCID STDMETHODCALLTYPE Locale(
        );
    // Obtain the registry root used by Visual Studio.
    // ppValue         : [Out,Optional] String object containing the current value (ex:
    // Software\Microsoft\VisualStudio\11.0). For components loaded into the remote debugger,
    // Registry root is NULL in remote debugging, and pseudo-remote (64-bit) scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRegistryRoot(
        _Deref_out_opt_ DkmString** ppValue
        );
    // Obtain paths for native visualizers using the visual studio extensibility mechanism
    // ppValue         : [Out,Optional] Read only collection of string objects containing
    // a list of paths to .natvis files.  VisualizerPaths is NULL in remote debugging scenarios.
    // It will be non-null in pseudo-remote, and local debugging scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVisualizerPaths(
        _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppVisualizerPaths
        );
    // Obtain paths for native step filters using the visual studio extensibility mechanism
    // ppValue         : [Out,Optional] Read only collection of string objects containing
    // a list of paths to .natstepfilter files.  *ppStepFilterPaths is NULL in remote debugging scenarios.
    // It will be non-null in pseudo-remote, and local debugging scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStepFilterPaths(
        _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppStepFilterPaths
        );
    // Obtain paths for native JustMyCode files using the visual studio extensibility mechanism.
    // ppValue         : [Out,Optional] Read only collection of string objects containing
    // a list of paths to .natjmc files.  *ppNativeJustMyCodePaths is NULL in remote debugging scenarios.
    // It will be non-null in pseudo-remote, and local debugging scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetJustMyCodePaths(
        _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppNativeJustMyCodePaths
        );
    // Obtains the process id of the process which is logically the root process of the
    // Visual Studio or remote debugger instance. In Visual Studio scenarios, this will
    // be the process id of Visual Studio. In remote debugger scenarios, this is the
    // process id of the root msvsmon.exe instance.
    //
    // This API was introduced in Visual Studio 11 Feature Pack 1
    // (DkmApiVersion.VS11FeaturePack1).
    static DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE RootProcessId(
        );
};

// Describes the event being processed.
class DECLSPEC_UUID("1ff2acd1-b938-46ad-8eaa-422af78bc305") DkmEventDescriptor
{
    // This class cannot be created
    private: DkmEventDescriptor();
    // This class cannot be deleted
    protected: ~DkmEventDescriptor();
    // This class cannot be copied
    private: DkmEventDescriptor& operator=(const DkmEventDescriptor&);
    private: DkmEventDescriptor(const DkmEventDescriptor&);
private:
    const DkmEventCode::e m_Code;
    const DWORD m_Id;

public:
    // Returns an enumeration code to indicate the type of event. May be helpful
    // in diagnostic logging.
    DkmEventCode::e Code()
    {
        return m_Code;
    }

    // Returns an id for the event. May be helpful in diagnostic logging.
    DWORD Id()
    {
        return m_Id;
    }
};

// Describes the event being processed and provides the ability for a component to
// suppress this event.
class DECLSPEC_UUID("14bb75d0-1ab6-4a8a-a47b-7cd68e96c8bb") DkmEventDescriptorS : public DkmEventDescriptor
{
    // This class cannot be created
    private: DkmEventDescriptorS();
    // This class cannot be deleted
    protected: ~DkmEventDescriptorS();
    // This class cannot be copied
    private: DkmEventDescriptorS& operator=(const DkmEventDescriptorS&);
    private: DkmEventDescriptorS(const DkmEventDescriptorS&);

private:
    BOOL m_suppress;

public:
    // Returns true if the event has been supressed (Supress() was called).
    bool IsSuppressed()
    {
        return m_suppress != 0;
    }

public:
    // This method is used to suppress event processing for this event. When called,
    // the event will not be seen by components with a greater component level than the
    // suppressing component.
    DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Suppress(
        )
    {
        m_suppress = true;
        return S_OK;
    }
};


typedef struct {}* DkmComponentHandle;

/* static*/ class DkmComponentManager
{
private:
    // Class cannot be created
    DkmComponentManager();
    DkmComponentManager(const DkmComponentManager&);

public:
    // Initialize a thread with the component manager. This is necessary when a component
    // creates one or more worker threads. InitializeThread should only be called once,
    // it should be called after COM has been initialized, and must have a matching call
    // to UninitializeThread. InitializeThread will return S_FALSE if the same thread is
    // initialized multiple times with the same component id. Callers can use this
    // as a hint that UninitializeThread should not be called.
    // guidComponentId : Component ID of the thread.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeThread(
        _In_ REFGUID guidComponentId
        );

    // Initialize a thread with the component manager. InitializeThreadByHandle will return
    // S_FALSE if the same thread is initialized multiple times with the same component handle.
    // Callers can use this as a hint that UninitializeThreadByHandle should not be called.
    // Unlike InitializeThread, this method uses a previously found component handle instead of a
    // guid. This allows faster thread initialization.
    // ComponentHandle : The component handle to initialize on the thread. This must be obtained
    // with FindComponentHandle.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeThreadByHandle(
        _In_ DkmComponentHandle ComponentHandle
        );

    // Clean up a thread which was previously initialized with a call to
    // DkmComponentManager::InitializeThreadByHandle.
    // ComponentHandle : Component handle, obtained from FindComponentHandle.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UninitializeThreadByHandle(
        _In_ DkmComponentHandle ComponentHandle
        );

    // Clean up a thread which was previously initialized with a call to
    // DkmComponentManager::InitializeThread.
    // guidComponentId : Component ID of the thread.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UninitializeThread(
        _In_ REFGUID guidComponentId
        );
    // Obtain the component ID which is running on this thread. E_XAPI_NOT_INITIALIZED
    // is returned if the thread has not been initialized.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentComponentId(
        _Out_ GUID* pComponentId
        );

    // Release the component lock for a synchronized component. This can be very
    // dangerous as it will allow component re-entrancy. The normal way to use this
    // is to release the lock on a call that exits a compoent and retake the lock
    // as soon as the call completes.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AllowComponentReentrancy(
        );

    // Relock a synchronized component after a call to ReleaseComponentLock.
    // This can be very dangerous as it will allow component re-entrancy.
    // The normal way to use this is to release the lock on a call that exits
    // a compoent and retake the lock
    // as soon as the call completes.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DisableComponentReentrancy(
        );

    // Returns true if the version of the Dispatcher is greater than or equal to
    // the specified API version.
    static DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsApiVersionSupported(
        _In_ DkmApiVersion::e apiVersion
        );

    // Returns a component handle, based on the component guid. The component handle
    // should only be used to call [Un]InitializeThreadByHandle or [Push]PopComponentHandle without
    // having to perform a search for the component every time based on its GUID
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindComponentHandle(
        _In_ REFGUID componentInfo,
        _Deref_out_ DkmComponentHandle* pComponentHandle
        );

    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE PushComponentTransition(
        _In_ DkmComponentHandle ComponentHandle
        );

    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE PopComponentTransition(
        _In_ DkmComponentHandle ComponentHandle
        );

};

// Identifies a DkmRuntimeInstance object within a process.
struct DECLSPEC_UUID("38ab90f5-dd83-b247-4d45-bd415c909b21") DkmRuntimeInstanceId
{
    // Indicates which type of runtime instance this is (ex: native code, CLR, etc).
    GUID RuntimeType;

    // Used along with the 'RuntimeType' to uniquely identify a particular runtime
    // instance within a given DkmProcess. If the 'RuntimeType' only supports a single
    // runtime instance per process (ex: DkmRuntimeId.Native), this value is typically
    // zero. For DkmRuntimeId.Clr, this value is the base address of the CLR dll.
    UINT64 InstanceId;

    // Compare an instance of the DkmRuntimeInstanceId struct to another instance.
    // Return value is as follows:
    // Less than zero:     This instance is less than 'other'.
    // Zero:               This instance is equal to 'other'.
    // Greater than zero:  This instance is greater than 'other'.
    DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
        const DkmRuntimeInstanceId& other
        ) const;

    bool operator==(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) == 0; }
    bool operator!=(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) != 0; }
    bool operator> (const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) > 0;  }
    bool operator< (const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) < 0;  }
    bool operator>=(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) >= 0; }
    bool operator<=(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) <= 0; }

    // Release all reference-counted fields within the DkmRuntimeInstanceId structure.
    static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
        _In_ DkmRuntimeInstanceId* pItem
        )
    {
        // structure requires no cleanup
    }
};

// Enumeration code of the various versions of this API.
enum DkmApiVersion::e
{
    // Visual Studio 11 Release to Manufacturing (RTM) version
    VS11RTM = 0xB000001,
    // Visual Studio 11 Update 1
    VS11FeaturePack1 = 0xB000002,
    // Visual Studio 11 Update 2
    VS11Update2 = 0xB000003,
    // Visual Studio 12 Release to Manufacturing (RTM) version
    VS12RTM = 0xC000000
};

// Indicates the type of async-break that occurred.
enum DkmAsyncBreakStatus::e
{
    // An active thread was found inside the target process and the debugger used it to
    // break.
    ActiveBreak = 0,
    // The target process appears to be deadlocked and was frozen to emulate break mode.
    FrozenBreak = 1,
    // The caller of AsyncBreak requested an immediate break. The target process is
    // frozen to emulate break mode.
    ImmediateBreak = 2
};

// DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and control
// the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is used for
// processes debugged by the Win32 debugging API and DkmBaseDebugMonitorId.DumpFile is
// used for minidumps.
struct DkmBaseDebugMonitorId
{
    // DkmProcess is backed by a live Microsoft Windows process.
    // WindowsProcess is defined as {8ed4705e-401a-4f04-a0c9-5b7d7c679ec4}.
    static const GUID WindowsProcess;
    // DkmProcess is debugged using ONLY the ICorDebug API (the process is not being
    // debugging through the Win32 debugging API). This value is used when debugging with
    // the ICorDebug v2 pipeline. Scenarios include debugging a Win32 process running the
    // v2 CLR and debugging a managed process running on a Windows CE device.
    // ClrVirtualMachine is defined as {ff26db58-d56b-4420-a069-82b947de1ea0}.
    static const GUID ClrVirtualMachine;
    // DkmProcess is back by a minidump or crashdump file.
    // DumpFile is defined as {5283b2bd-0738-41fd-8a3c-8be6745cce3f}.
    static const GUID DumpFile;
    // DkmProcess is backed by a live Microsoft Windows ActiveScript process.
    // ActiveScript is defined as {9fb039e3-af4b-41ea-8b5f-c1e52138ffb8}.
    static const GUID ActiveScript;
    // DkmProcess is backed by a live Microsoft Windows D3D process that runs GPU code on
    // GPU hardware or reference rasterizer.
    // GpuVirtualMachine is defined as {72e62fa3-9001-40f1-9d75-ad1166a9ff41}.
    static const GUID GpuVirtualMachine;
    // DkmProcess is a live win32 process being debugged with the legacy in-process CLR
    // interop model. Both managed and native code can be debugged.
    // InProcessManagedNativeInterop is defined as {2a76521b-69f7-4919-b693-79f1dc5aee27}.
    static const GUID InProcessManagedNativeInterop;
    // Managed/native interop dump debugging.
    // DumpFileInterop is defined as {0d1e3537-15c6-4ba4-9c32-5e1c13197e19}.
    static const GUID DumpFileInterop;
};
__declspec(selectany) const GUID DkmBaseDebugMonitorId::WindowsProcess = { 0x8ed4705e, 0x401a, 0x4f04, { 0xa0, 0xc9, 0x5b, 0x7d, 0x7c, 0x67, 0x9e, 0xc4 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::ClrVirtualMachine = { 0xff26db58, 0xd56b, 0x4420, { 0xa0, 0x69, 0x82, 0xb9, 0x47, 0xde, 0x1e, 0xa0 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::DumpFile = { 0x5283b2bd, 0x738, 0x41fd, { 0x8a, 0x3c, 0x8b, 0xe6, 0x74, 0x5c, 0xce, 0x3f } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::ActiveScript = { 0x9fb039e3, 0xaf4b, 0x41ea, { 0x8b, 0x5f, 0xc1, 0xe5, 0x21, 0x38, 0xff, 0xb8 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::GpuVirtualMachine = { 0x72e62fa3, 0x9001, 0x40f1, { 0x9d, 0x75, 0xad, 0x11, 0x66, 0xa9, 0xff, 0x41 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::InProcessManagedNativeInterop = { 0x2a76521b, 0x69f7, 0x4919, { 0xb6, 0x93, 0x79, 0xf1, 0xdc, 0x5a, 0xee, 0x27 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::DumpFileInterop = { 0xd1e3537, 0x15c6, 0x4ba4, { 0x9c, 0x32, 0x5e, 0x1c, 0x13, 0x19, 0x7e, 0x19 } };

// Message structure used to pass information between custom debugger backend components
// and custom visual studio UI components (packages, add-ins, etc).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("d308a6ed-8e21-e7dd-abfa-9ae22434f9bc") DkmCustomMessage : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmCustomMessage::Create to create this object
    private: DkmCustomMessage();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmCustomMessage();
    // This object cannot be copied
    private: DkmCustomMessage& operator=(const DkmCustomMessage&);
    private: DkmCustomMessage(const DkmCustomMessage&);

    private: DefaultPort::DkmTransportConnection* const m_pConnection;
    private: OPTIONAL DkmProcess* const m_pProcess;
    private: const GUID m_SourceId;
    private: const UINT32 m_MessageCode;
    private: OPTIONAL DkmVariant* const m_pParameter1;
    private: OPTIONAL DkmVariant* const m_pParameter2;
    private: void* m__pExtendedData;

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // [Optional] DkmProcess represents a target process which is being debugged. The
    // debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
    // can represent a system process or a virtual process such as minidumps.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Identifies the source of an object. SourceIds are used to enable filtering in
    // scenarios when multiple components may be creating instances of a class. For
    // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
    // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
    // breakpoint which may be created by another component (for example an internal
    // breakpoint used for stepping).
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
        );

    // Identifies the type of custom event being sent. Partners are free to define any
    // set of values.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MessageCode(
        );

    // [Optional] Specifies additional message-specific information. Note that if this
    // message may need to travel over remoting boundaries, it is important to restrict
    // the type of this parameter to something which can be marshalled: strings,
    // primitives (ex: int), and arrays of primitives (ex: byte array).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Parameter1(
        );

    // [Optional] Specifies additional message-specific information. Note that if this
    // message may need to travel over remoting boundaries, it is important to restrict
    // the type of this parameter to something which can be marshalled: strings,
    // primitives (ex: int), and arrays of primitives (ex: byte array).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Parameter2(
        );

    // Create a new DkmCustomMessage object instance.
    // pConnection     : [In] This represents a connection between the monitor and the
    // IDE. It can either be a local connection if the monitor is running in the same
    // process as the IDE, or it can be a remote connection. In the monitor process,
    // there is only one connection.
    // pProcess        : [In,Optional] DkmProcess represents a target process which is
    // being debugged. The debugger debugs processes, so this is the basic unit of
    // debugging. A DkmProcess can represent a system process or a virtual process such
    // as minidumps.
    // SourceId        : [In] Identifies the source of an object. SourceIds are used to
    // enable filtering in scenarios when multiple components may be creating instances
    // of a class. For example, source ids can be used to determine if a breakpoint comes
    // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
    // level) instead of a breakpoint which may be created by another component (for
    // example an internal breakpoint used for stepping).
    // MessageCode     : [In] Identifies the type of custom event being sent. Partners
    // are free to define any set of values.
    // pParameter1     : [In,Optional] Specifies additional message-specific information.
    // Note that if this message may need to travel over remoting boundaries, it is
    // important to restrict the type of this parameter to something which can be
    // marshalled: strings, primitives (ex: int), and arrays of primitives (ex: byte
    // array).
    // pParameter2     : [In,Optional] Specifies additional message-specific information.
    // Note that if this message may need to travel over remoting boundaries, it is
    // important to restrict the type of this parameter to something which can be
    // marshalled: strings, primitives (ex: int), and arrays of primitives (ex: byte
    // array).
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_opt_ DkmProcess* pProcess,
        _In_ const GUID& SourceId,
        _In_ UINT32 MessageCode,
        _In_opt_ DkmVariant* pParameter1,
        _In_opt_ DkmVariant* pParameter2,
        _Deref_out_ DkmCustomMessage** ppCreatedObject
        );

    // Raises a CustomStop event to a VS service which is expecting it. Note that there
    // are restrictions on the type for parameters to this custom message. See
    // DkmCustomMessage.SendToVsService for more information.
    // pThread         : [In] DkmThread represents a thread running in the target
    // process.
    // VsService       : [In] Visual Studio service that this event should be sent to. A
    // VS package must register this service id (ex:
    // Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package must
    // implement the IVsCustomDebuggerStoppingEventHandler110 interface.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnCustomStop(
        _In_ DkmThread* pThread,
        _In_ const GUID& VsService
        );

    // Sends a message to a listening component which is higher in the hierarchy.
    // ppReplyMessage  : [Out,Optional] Message sent back from the implementation.
    // Return value    : S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is
    // returned when *ppReplyMessage is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendHigher(
        _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
        );

    // Sends a message to a listening component which is lower in the hierarchy.
    // ppReplyMessage  : [Out,Optional] Message sent back from the implementation.
    // Return value    : S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is
    // returned when *ppReplyMessage is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendLower(
        _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
        );

    // Sends a message to a listening component which is lower in the hierarchy.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendLower(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmSendLowerAsyncResult>* pCompletionRoutine
        );

    // Sends a custom message to a Visual Studio package. This can be used, for example,
    // to drive a custom UI or make a custom UI visible by enabling a command context
    // (IVsMonitorSelection.SetCmdUIContext).
    //
    // For local 32-bit debugging, the custom message parameters
    // (DkmCustomMessage.Parameter1/2), may contain any value (ex: object/IUnknown,
    // string, etc), however, values are transferred between threads without marshalling,
    // so in cases where this will not work, the sender is responsible for converting the
    // parameter into a form which can be used from the VS service (ex: calling
    // ole32!CoMarshalInterThreadInterfaceInStream).
    //
    // For remote debugging, and 64-bit debugging, the custom message parameters are
    // marshalled across machines, and so the restrictions describe in the
    // DkmCustomMessage.Parameter1 documentation applies.
    // VsService       : [In] Visual Studio service that this event should be sent to. A
    // VS package must register this service id. The service class must implement the
    // IVsCustomDebuggerEventHandler110 interface. Services can be registered in the
    // registry ($RootKey$\Services\{VsService}), or through the VS shell IProfferService
    // interface. Registry keys may be set through through .pkgdef files. If the service
    // should be called even if it is not already loaded, then the registry approach
    // should be used. If the service should only be called if it has already been
    // started, then IProfferService should be used.
    // IsBlocking      : [In] True if SendToPackage should block waiting for the package
    // to finish processing this message. When true, DkmCustomMessage.Process must be
    // non-null.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendToVsService(
        _In_ const GUID& VsService,
        _In_ bool IsBlocking
        );
}; // end of DkmCustomMessage

// Action to be taken if the data item is already in the container.
enum DkmDataCreationDisposition::e
{
    // Add the data item only if there is no other data item with the same id.
    CreateNew = 0,
    // Always add the data item. If the data item is already present then overwrite it
    // with the new value.
    CreateAlways = 1
};

// Internal flags indicating the current state of a dispatcher object.
enum DkmDispatcherObjectFlags::e
{
    // No flags are currently set
    None = 0x0,
    // Object has been fully initialized and has not been closed
    ObjectAlive = 0x1,
    // Object has been unloaded
    ObjectUnloaded = 0x2,
    // Critical Section has been initialized
    LockInitialized = 0x4,
    // Object is hidden from components which are above the creation level.
    RestrictVisibilityAboveCreationLevel = 0x8,
    // Object is hidden from components which are below the creation level.
    RestrictVisibilityBelowCreationLevel = 0x10,
    // Reference object has been marshalled into its associated connection
    RemoteMarshalled = 0x20
};
DEFINE_ENUM_FLAG_OPERATORS(DkmDispatcherObjectFlags::e);

// Result of an asynchronous DkmUserMessage.DisplayPrompt call.
struct DkmDisplayUserMessagePromptAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Win32 'ID' code from displaying the message box (ex: IDYES). These codes are
    // defined in winuser.h from the Windows SDK.
    UINT32 Result;
};

// Type of dump to save.
enum DkmDumpType::e
{
    // Save a basic minidump. Global memory, heap memory, and modules are not included.
    Minidump = 0,
    // Save a full minidump. Global memory, heap memory, and modules are included.
    MinidumpWithFullMemory = 1
};

// Flags that indicate immutable traits of this engine settings.
enum DkmEngineFlags::e
{
    // No process debug flags are set.
    None = 0x0,
    // Engine is capable of debugging native code. This will be 'false' when debugging
    // .NET CLR v2 code, or .NET code on the device. Note that even when true, native
    // debugging may not be currently enabled (see
    // DkmProcessSettings.IsNativeDebuggingEnabled).
    NativeCodeSupported = 0x1,
    // Engine will use Just My Code when enabled from the IDE.
    JustMyCodeSupported = 0x2
};
DEFINE_ENUM_FLAG_OPERATORS(DkmEngineFlags::e);

// These are the 'standard' engine GUID values. It is expected that this list will grow
// over time, so where possible, it is recommended to query for a setting instead of
// comparing the EngineId.
struct DkmEngineId
{
    // Native-only debugging engine Guid.
    // NativeEng is defined as {3b476d35-a401-11d2-aad4-00c04f990171}.
    static const GUID NativeEng;
    // Debug engine for debugging all code within a Win32 process.
    // COMPlusNativeEng is defined as {92ef0900-2251-11d2-b72e-0000f87572ef}.
    static const GUID COMPlusNativeEng;
    // Debug engine for debugging CLR code within the desktop CLR v2.0. For example, a VB
    // application. When debugging in this mode, native debugging is not possible.
    // COMPlusOnlyEng2 is defined as {5fff7536-0c87-462d-8fd2-7971d948e6dc}.
    static const GUID COMPlusOnlyEng2;
    // Debug engine for debugging CLR code within CLR v4. When debugging in this mode,
    // native debugging is not possible.
    // COMPlusOnlyEng4 is defined as {fb0d4648-f776-4980-95f8-bb7f36ebc1ee}.
    static const GUID COMPlusOnlyEng4;
    // Debug engine for debugging only user CLR code inside the Microsoft SQL Server
    // process.
    // COMPlusSQLLocalEng is defined as {e04bde58-45ec-48db-9807-513f78865212}.
    static const GUID COMPlusSQLLocalEng;
    // Debug engine used for Silverlight debugging.
    // SilverlightEng is defined as {032f4b8c-7045-4b24-accf-d08c9da108fe}.
    static const GUID SilverlightEng;
    // Debug engine used for .NET Compact Framework v1 debugging.
    // EmbeddedClrEngV1 is defined as {123d150b-fa18-461c-b218-45b3e4589f9b}.
    static const GUID EmbeddedClrEngV1;
    // Debug engine used for .NET Compact Framework v2 debugging.
    // EmbeddedClrEngV2 is defined as {8c37b683-c921-4076-ac47-ec6da03fa658}.
    static const GUID EmbeddedClrEngV2;
    // Debug engine used for debugging Silverlight apps on Apple computers.
    // MacSilverlightEng is defined as {22189d02-cca4-40ae-a874-6c2a764fb071}.
    static const GUID MacSilverlightEng;
    // Debug engine used for active script debugging (ex: script in Microsoft Internet
    // Explorer).
    // Script is defined as {f200a7e7-dea5-11d0-b854-00a0244a1de2}.
    static const GUID Script;
    // Debug engine used for Core CLR debugging in Silverlight and XNA apps on Windows
    // Phone.
    // CoreSystemClr is defined as {2e36f1d4-b23c-435d-ab41-18e608940038}.
    static const GUID CoreSystemClr;
    // Debug engine used for Concord interop CLR v2. This GUID is used within Concord and
    // is not known above the AD7 layer.
    // InteropEngineV2 is defined as {1c23520a-8dba-4f3c-b228-8add24c0a1fe}.
    static const GUID InteropEngineV2;
    // Debug engine used for Concord interop CLR v4. This GUID is used within Concord and
    // is not known above the AD7 layer.
    // InteropEngineV4 is defined as {29c2639d-0c6f-4ae8-9b09-0cfb2f075fdf}.
    static const GUID InteropEngineV4;
    // Debug an application running under the native-compiled .NET Framework.
    // ClrNativeCompilation is defined as {47843766-18ee-4226-b2ee-0baa38e1e0d3}.
    static const GUID ClrNativeCompilation;
};
__declspec(selectany) const GUID DkmEngineId::NativeEng = { 0x3b476d35, 0xa401, 0x11d2, { 0xaa, 0xd4, 0x0, 0xc0, 0x4f, 0x99, 0x1, 0x71 } };
__declspec(selectany) const GUID DkmEngineId::COMPlusNativeEng = { 0x92ef0900, 0x2251, 0x11d2, { 0xb7, 0x2e, 0x0, 0x0, 0xf8, 0x75, 0x72, 0xef } };
__declspec(selectany) const GUID DkmEngineId::COMPlusOnlyEng2 = { 0x5fff7536, 0xc87, 0x462d, { 0x8f, 0xd2, 0x79, 0x71, 0xd9, 0x48, 0xe6, 0xdc } };
__declspec(selectany) const GUID DkmEngineId::COMPlusOnlyEng4 = { 0xfb0d4648, 0xf776, 0x4980, { 0x95, 0xf8, 0xbb, 0x7f, 0x36, 0xeb, 0xc1, 0xee } };
__declspec(selectany) const GUID DkmEngineId::COMPlusSQLLocalEng = { 0xe04bde58, 0x45ec, 0x48db, { 0x98, 0x7, 0x51, 0x3f, 0x78, 0x86, 0x52, 0x12 } };
__declspec(selectany) const GUID DkmEngineId::SilverlightEng = { 0x32f4b8c, 0x7045, 0x4b24, { 0xac, 0xcf, 0xd0, 0x8c, 0x9d, 0xa1, 0x8, 0xfe } };
__declspec(selectany) const GUID DkmEngineId::EmbeddedClrEngV1 = { 0x123d150b, 0xfa18, 0x461c, { 0xb2, 0x18, 0x45, 0xb3, 0xe4, 0x58, 0x9f, 0x9b } };
__declspec(selectany) const GUID DkmEngineId::EmbeddedClrEngV2 = { 0x8c37b683, 0xc921, 0x4076, { 0xac, 0x47, 0xec, 0x6d, 0xa0, 0x3f, 0xa6, 0x58 } };
__declspec(selectany) const GUID DkmEngineId::MacSilverlightEng = { 0x22189d02, 0xcca4, 0x40ae, { 0xa8, 0x74, 0x6c, 0x2a, 0x76, 0x4f, 0xb0, 0x71 } };
__declspec(selectany) const GUID DkmEngineId::Script = { 0xf200a7e7, 0xdea5, 0x11d0, { 0xb8, 0x54, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xe2 } };
__declspec(selectany) const GUID DkmEngineId::CoreSystemClr = { 0x2e36f1d4, 0xb23c, 0x435d, { 0xab, 0x41, 0x18, 0xe6, 0x8, 0x94, 0x0, 0x38 } };
__declspec(selectany) const GUID DkmEngineId::InteropEngineV2 = { 0x1c23520a, 0x8dba, 0x4f3c, { 0xb2, 0x28, 0x8a, 0xdd, 0x24, 0xc0, 0xa1, 0xfe } };
__declspec(selectany) const GUID DkmEngineId::InteropEngineV4 = { 0x29c2639d, 0xc6f, 0x4ae8, { 0x9b, 0x9, 0xc, 0xfb, 0x2f, 0x7, 0x5f, 0xdf } };
__declspec(selectany) const GUID DkmEngineId::ClrNativeCompilation = { 0x47843766, 0x18ee, 0x4226, { 0xb2, 0xee, 0xb, 0xaa, 0x38, 0xe1, 0xe0, 0xd3 } };

// Contains the session-wide debug settings. There is one instance of this object per
// engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("3c1f22df-556c-18bf-7584-c2c649777bfe") DkmEngineSettings : public DkmDataContainer
{
    // Use DkmEngineSettings::Create to create this object
    private: DkmEngineSettings();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmEngineSettings();
    // This object cannot be copied
    private: DkmEngineSettings& operator=(const DkmEngineSettings&);
    private: DkmEngineSettings(const DkmEngineSettings&);

    // Contains additional fields of DkmEngineSettings which were added after the class
    // was initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // The maximum number of frames supported in the call stack window.
        const UINT32 MaxCallStackFrames;

        // Enables Edit and Continue.
        const bool IsEditAndContinue;

        // True if the debugger should validate the digital signatures of CLR debugging
        // libraries before loading them.
        const bool ValidateFilesForMinidumps;

        // [Optional] List of registry tweaks in the Visual Studio registry that
        // components may use to customize their behavior.  Registry tweaks are read from
        // the key [Visual Studio Registry Root]\Debugger\Engine at the start of each
        // debug session.
        OPTIONAL DkmReadOnlyCollection<DkmRegistryTweak*>* const pRegistryTweaks;
    };

    private: const GUID m_EngineId;
    private: const DkmEngineFlags::e m_Flags;
    private: const Clr::DkmClrDebuggingServicesId::e m_ClrDebuggingServicesId;
    private: DkmReadOnlyCollection<Evaluation::DkmLanguage*>* const m_pLanguages;
    private: DkmReadOnlyCollection<Symbols::DkmImageDebugDirectoryFormat>* const m_pImageDebugDirectoryFormats;
    private: const bool m_EnableFuncEvalQuickAbort;
    private: DkmReadOnlyCollection<DkmString*>* const m_pFuncEvalQuickAbortExcludeList;
    private: const bool m_EnableAsyncDebugging;
    private: DkmReadOnlyCollection<DkmString*>* const m_pRemoteClrPdbNamePatterns;
    private: const GUID m_BaseDebugMonitorId;
    private: bool m_IsJustMyCodeEnabled;
    private: Symbols::DkmEngineSymbolSettings* m_pSymbolPaths;
    private: bool m_IsSuppressOptimizationsEnabled;
    private: bool m_IsStepOverPropertiesAndOperatorsEnabled;
    private: bool m_IsNativeExportsEnabled;
    private: bool m_IsGpuRaceHazardsAllowSameSettingEnabled;
    private: bool m_RequireFullTrustForSourceServer;
    private: ___ExtendedData* const m__pExtendedData;
    private: void* m_pProcessCollection2;

    // These are the 'standard' engine GUID values. It is expected that this list will
    // grow over time, so where possible, it is recommended to query for a setting
    // instead of comparing the EngineId.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE EngineId(
        );

    // Flags that indicate immutable traits of this engine settings.
    public: DECLSPEC_NOTHROW DkmEngineFlags::e STDMETHODCALLTYPE Flags(
        );

    // Indicates which version of the CLR debugging services (mscordbi.dll or other
    // implementation of the ICorDebug API) should be used when debugging this process.
    public: DECLSPEC_NOTHROW Clr::DkmClrDebuggingServicesId::e STDMETHODCALLTYPE ClrDebuggingServicesId(
        );

    // Collection of all programming languages supported while debugging this process.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmLanguage*>* STDMETHODCALLTYPE Languages(
        );

    // List of supported values for IMAGE_DEBUG_DIRECTORY.Type.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Symbols::DkmImageDebugDirectoryFormat>* STDMETHODCALLTYPE ImageDebugDirectoryFormats(
        );

    // Specifies whether FEQA is enabled for this engine for this debug session.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE EnableFuncEvalQuickAbort(
        );

    // List of executables for whom FEQA isn't enabled even if FEQA DLLs are loaded.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE FuncEvalQuickAbortExcludeList(
        );

    // Enables stepping over 'await' statements and stepping out of async methods. This
    // is on by default.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE EnableAsyncDebugging(
        );

    // List of PDB name patterns used to determine if PDB will be loaded on remote side.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE RemoteClrPdbNamePatterns(
        );

    // Base debug monitor used by this engine. This value may be Guid.Empty (GUID_NULL)
    // if the engine may use various base debug monitors depending on the process being
    // debugged.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE BaseDebugMonitorId(
        );

    // The maximum number of frames supported in the call stack window.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MaxCallStackFrames(
        );

    // Enables Edit and Continue.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsEditAndContinue(
        );

    // True if the debugger should validate the digital signatures of CLR debugging
    // libraries before loading them.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ValidateFilesForMinidumps(
        );

    // [Optional] List of registry tweaks in the Visual Studio registry that components
    // may use to customize their behavior.  Registry tweaks are read from the key
    // [Visual Studio Registry Root]\Debugger\Engine at the start of each debug session.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmRegistryTweak*>* STDMETHODCALLTYPE RegistryTweaks(
        );

    // When true, the debugger will enable JustMyCode features (stepping, call stack, and
    // exception filtering).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsJustMyCodeEnabled(
        );

    // A collection of DkmStrings representing the symbol search paths and cache path.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolPaths(
        _Deref_out_ Symbols::DkmEngineSymbolSettings** ppValue);

    // When true, the debugger will suppress Just-In-Time compiler optimizations for
    // newly-loaded modules.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsSuppressOptimizationsEnabled(
        );

    // When true, the debugger will step over properties and operators when a step in is
    // done.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsStepOverPropertiesAndOperatorsEnabled(
        );

    // When true, the debugger will will attempt to use the export tables from Win32 PE
    // files to resolve addresses.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsNativeExportsEnabled(
        );

    // When true, the debugger will ignore GPU race hazards that didn't change the
    // previous data.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsGpuRaceHazardsAllowSameSettingEnabled(
        );

    // When true, the debugger will require assemblies to be fully trusted before
    // executing source server commands from an assembly. The concept of fully trusted
    // only applies to CLR assemblies.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE RequireFullTrustForSourceServer(
        );

    // Find a DkmEngineSettings object. If no object with the given input key is present,
    // FindSettings will fail.
    // EngineId        : [In] Search key used to find the element.
    // ppSettings      : [Out] Result of the search.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSettings(
        _In_ const GUID& EngineId,
        _Deref_out_ DkmEngineSettings** ppSettings
        );

    // GetSettings enumerates all the created DkmEngineSettings objects.
    // pSettings       : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSettings(
        _Out_ DkmArray<DkmEngineSettings*>* pSettings
        );

    // Find a DkmProcess element within this DkmEngineSettings. If no element with the
    // given input key is present, FindProcess will fail.
    // UniqueId        : [In] Search key used to find the element.
    // ppProcess       : [Out] Result of the search.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindProcess(
        _In_ const GUID& UniqueId,
        _Deref_out_ DkmProcess** ppProcess
        );

    // GetProcesses enumerates the DkmProcess elements of this DkmEngineSettings object.
    // pProcesses      : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProcesses(
        _Out_ DkmArray<DkmProcess*>* pProcesses
        );

    // Returns the DkmLanguage object which matches the given compiler id. If the
    // language is unknown (not registered with the engine), then this method will return
    // the default language object.
    // CompilerId      : [In] LanguageId/VendorId search key. Both values may be
    // Guid.Empty to obtain the default language. Otherwise the vendor id must be
    // non-zero or the default language object will be returned.
    // ppLanguage      : [Out] Describes a programming language.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLanguage(
        _In_ const Evaluation::DkmCompilerId& CompilerId,
        _Deref_out_ Evaluation::DkmLanguage** ppLanguage
        );

    // Returns the enumeration of DkmCodeViewCompilerId values. This enumeration may then
    // be used by a symbol provider to map the information within a code view record to
    // the DkmCompilerId structure.
    // pCodeViewCompilers: [Out] DkmCodeViewCompilerId[] is used to translate information
    // that is within the S_COMPILE* code view records into a DkmCompilerId. This allows
    // the debugger to load an appropriate expression evaluator for a stack frame. Symbol
    // providers may obtain this collection through DkmEngineSettings. Expression
    // evaluators may add additional entries to this collection by having their setup add
    // sub key(s) to the '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCodeViewCompilers(
        _Out_ DkmArray<Symbols::DkmCodeViewCompilerId>* pCodeViewCompilers
        );

    // Get the user document visual studio folder path.
    // ppUserDocumentPath: [Out] Returns the user document visual studio path.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUserDocumentPath(
        _Deref_out_ DkmString** ppUserDocumentPath
        );
}; // end of DkmEngineSettings

// Enumeration of all events which are currently defined in this API.
enum DkmEventCode::e
{
    AsyncBreakComplete = 0,
    BoundBreakpointHit = 1,
    ComputeKernelExit = 2,
    CustomStop = 3,
    DebugMonitorException = 4,
    EmbeddedBreakpointHit = 5,
    EntryPoint = 6,
    ExceptionContinued = 7,
    ExceptionTriggerHit = 8,
    FuncEvalCompleted = 9,
    FuncEvalStarting = 10,
    GPUSingleStepComplete = 11,
    InterceptExceptionCompleted = 12,
    LoadComplete = 13,
    ModuleCreate = 14,
    ModuleInstanceLoad = 15,
    ModuleInstanceUnload = 16,
    ModuleSymbolsLoaded = 17,
    ModuleSymbolsUpdated = 18,
    ProcessCreate = 19,
    ProcessExit = 20,
    ReturnValues = 21,
    RuntimeBreakpoint = 22,
    RuntimeInstanceLoad = 23,
    RuntimeInstanceUnload = 24,
    ScriptDocumentContentInsert = 25,
    ScriptDocumentContentRemove = 26,
    ScriptDocumentTreeNodeCreate = 27,
    ScriptDocumentTreeNodeUnload = 28,
    ScriptSymbolsUpdated = 29,
    SingleStepComplete = 30,
    StepComplete = 31,
    TaskProviderCreate = 32,
    ThreadCreate = 33,
    ThreadExit = 34,
    OutOfBandException = 35,
    BinaryLoaded = 36,
    ClrDebugMonitorExceptionCaught = 37
};

// Indicates if there is a function evaluation occurring in the target process and if
// stopping events are allowed for this evaluation.
enum DkmFuncEvalMode::e
{
    // No function evaluation is currently in progress.
    NotEvaluating = 0,
    // A function evaluation is currently in progress. No stopping events are permitted
    // on the queried thread, so stopping events will be suppressed after the 'received'
    // phase of stopping event processing. This value is used when (1) the function
    // evaluation was started without the DkmFuncEvalFlags.AllowStoppingEvents flag -or-
    // (2) the queried thread is not the evaluating thread and
    // DkmFuncEvalFlags.RunAllThreads was not used.
    EvaluatingWithoutStoppingEvents = 1,
    // A function evaluation is currently in progress. Stopping events are permitted on
    // the queried thread, so if the queried thread hits a breakpoint, the debugger may
    // enter nested break state.
    EvaluatingWithStoppingEvents = 2
};

// Result of an asynchronous DkmInstructionAddress.GetCurrentCPUAddress call.
struct DkmGetCurrentCPUAddressAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // An array of the current CPU Instruction Addresses that map to this
    // DkmInstructionAddress.
    DkmArray<UINT64> InstructionPointers;
};

#ifndef EXCLUDE_IDE_ONLY_APIS
// Result of an asynchronous DkmProcess.GetInstructionAddress call.
struct DkmGetInstructionAddressAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Abstract representation of an executable code location (ex: EIP value). If
    // resolved, an Instruction Address will be within a particular module instance. An
    // Instruction Address is always within a particular Runtime Instance.
    DkmInstructionAddress* pAddressObject;

    // True if this address is the first address in the line's range. False otherwise.
    bool FirstAddress;
};
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

// Abstract representation of an executable code location (ex: EIP value). If resolved,
// an Instruction Address will be within a particular module instance. An Instruction
// Address is always within a particular Runtime Instance.
//
// Derived classes: DkmClrInstructionAddress, DkmClrNcInstructionAddress,
// DkmCustomInstructionAddress, DkmNativeInstructionAddress, DkmScriptInstructionAddress,
// DkmUnknownInstructionAddress
class DECLSPEC_NOVTABLE DECLSPEC_UUID("6e2a219f-3a14-3410-e755-d00ce1f2f5e6") DkmInstructionAddress : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmInstructionAddress::Create to create this object
    private: DkmInstructionAddress();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmInstructionAddress();
    // This object cannot be copied
    private: DkmInstructionAddress& operator=(const DkmInstructionAddress&);
    private: DkmInstructionAddress(const DkmInstructionAddress&);

    // CPUInstruction provides the address that the CPU will execute. This is always
    // provided for native instructions. It may be provided for CLR or custom addresses
    // depending on how the address object was created.
    public: struct CPUInstruction
    {
        // The address of where the CPU instruction is located in the target process.
        UINT64 InstructionPointer;
    };

    // DkmInstructionAddress is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: struct Tag { enum e {
    // Object is an instance of 'DkmNativeInstructionAddress'.
    NativeAddress = 0,
    // Object is an instance of 'DkmClrInstructionAddress'.
    ClrAddress = 1,
    // Object is an instance of 'DkmScriptInstructionAddress'.
    ScriptAddress = 2,
    // Object is an instance of 'DkmCustomInstructionAddress'.
    CustomAddress = 3,
    // Object is an instance of 'DkmUnknownInstructionAddress'.
    UnknownAddress = 4
    }; };

    private: OPTIONAL const DkmInstructionAddress::CPUInstruction* const m_pCPUInstruction;
    private: const Tag::e m_TagValue;
    private: DkmRuntimeInstance* const m_pRuntimeInstance;
    private: OPTIONAL DkmModuleInstance* const m_pModuleInstance;
    private: void* m__pExtendedData;

    // [Optional] CPUInstructionPart provides the address that the CPU will execute. This
    // is always provided for native instructions. It may be provided for CLR or custom
    // addresses depending on how the address object was created.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmInstructionAddress::CPUInstruction* STDMETHODCALLTYPE CPUInstructionPart(
        );

    // DkmInstructionAddress is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
        );

    // The DkmRuntimeInstance class represents an execution environment which is loaded
    // into a DkmProcess and which contains code to be debugged.
    public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
        );

    // [Optional] The module containing this address. Addresses without a module cannot
    // have symbols (even for custom addresses). CLR addresses will always have a module.
    // Native addresses will not have a module if either the CPU jumped to an invalid
    // address (ex: NULL), or if the CPU is executing dynamically-emitted code.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleInstance* STDMETHODCALLTYPE ModuleInstance(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Convert a DkmInstructionAddress into a DkmInstructionSymbol. If the
    // DkmInstructionAddress is not in a DkmModule then GetSymbol will return null
    // (S_FALSE in native code).
    // ppSymbol        : [Out,Optional] DkmInstructionSymbol represents a method in the
    // target process.
    // Return value    : S_OK is returned if *ppSymbol is non-NULL, S_FALSE is returned
    // when *ppSymbol is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbol(
        _Deref_out_opt_ Symbols::DkmInstructionSymbol** ppSymbol
        );

    // Compares two instruction addresses and returns a value indicating whether one is
    // less than, equal to, or greater than the other. The addresses must be from the
    // same module.
    // pOther          : [In] An address to compare with this address.
    // pResult         : [Out] A 32-bit signed integer that indicates the relative order
    // of the objects being compared. The return value has the following meanings:
    //
    // Less than zero: This instance is less than 'other'. Zero: This instance is equal
    // to 'other'. Greater than zero: This instance is greater than 'other'.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompareTo(
        _In_ DkmInstructionAddress* pOther,
        _Out_ INT32* pResult
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Compares two instruction addresses and determines if they are within the same
    // function.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // pOther          : [In] An address to compare with this address.
    // pResult         : [Out] True if the two addresses are from the same function.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsInSameFunction(
        _In_ DkmInstructionAddress* pOther,
        _Out_ bool* pResult
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse
    // mapping of ResolveCPUInstructionAddress. This API is currently only supported by
    // CLR DkmRuntimeInstance objects.
    //
    // Location constraint: This API should generally be called on the client, but it can
    // be called on the server for translating CLR addresses (but not native-compiled).
    // pInstructionPointers: [Out] An array of the current CPU Instruction Addresses that
    // map to this DkmInstructionAddress.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentCPUAddress(
        _Out_ DkmArray<UINT64>* pInstructionPointers
        );

    // Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse
    // mapping of ResolveCPUInstructionAddress. This API is currently only supported by
    // CLR DkmRuntimeInstance objects.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // Location constraint: This API should generally be called on the client, but it can
    // be called on the server for translating CLR addresses (but not native-compiled).
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentCPUAddress(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmGetCurrentCPUAddressAsyncResult>* pCompletionRoutine
        );

    // Determines if a given instruction address is user code or not.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // Location constraint: For managed, this can be called from any component.  For
    // native, this can only be called from client-side components.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsUserCode(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<Symbols::DkmIsUserCodeAsyncResult>* pCompletionRoutine
        );
}; // end of DkmInstructionAddress

// Pairing between the name of a setting and its value.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("e0271ff0-7cb5-6f49-e948-a82864f5744b") DkmLanguageRegistrySetting : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmLanguageRegistrySetting::Create to create this object
    private: DkmLanguageRegistrySetting();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmLanguageRegistrySetting();
    // This object cannot be copied
    private: DkmLanguageRegistrySetting& operator=(const DkmLanguageRegistrySetting&);
    private: DkmLanguageRegistrySetting(const DkmLanguageRegistrySetting&);

    private: DkmString* const m_pName;
    private: DkmVariant* const m_pValue;
    private: void* m__pExtendedData;

    // The name of the setting.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
        );

    // The value of the setting.  This can be either a DWORD or a string.
    public: _Ret_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
        );

    // Create a new DkmLanguageRegistrySetting object instance.
    // pName           : [In] The name of the setting.
    // pValue          : [In] The value of the setting.  This can be either a DWORD or a
    // string.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmString* pName,
        _In_ DkmVariant* pValue,
        _Deref_out_ DkmLanguageRegistrySetting** ppCreatedObject
        );
}; // end of DkmLanguageRegistrySetting

// Flags which indicate traits of a DkmModuleInstance.
enum DkmModuleFlags::e
{
    // No module flags are set.
    None = 0x0,
    // Module is backed by a file. Note that this is set even in cases where the module
    // could not be resolved (dll is missing, binary could not be found while examining a
    // minidump, etc).
    FileBacked = 0x1,
    // Module is backed by a file and the debug monitor was able to open this file.
    FileResolved = 0x2,
    // Neither the module's file or memory content could be found. Debugging will be
    // impaired.
    MissingBinary = 0x4,
    // Module was relocated because it could not load at its preferred base address.
    Relocated = 0x8,
    // Optimization status for the module could be detected and the module was determined
    // to be optimized.
    Optimized = 0x10,
    // Optimization status for the module could be detected and the module was determined
    // to be unoptimized.
    Unoptimized = 0x20,
    // The module can be edited during debugging. For .NET modules this implies that the
    // CORDEBUG_JIT_ENABLE_ENC is set.
    Editable = 0x40
};
DEFINE_ENUM_FLAG_OPERATORS(DkmModuleFlags::e);

// The Module Instance class represent a code bundle (ex: dll or exe) which is loaded
// into a particular process at a particular location. Module Instance objects are 1:1
// with the execution environment's notion of a code bundle. For example, in native code,
// Module Instance objects are 1:1 with base address.
//
// Derived classes: DkmClrModuleInstance, DkmClrNcModuleInstance,
// DkmCustomModuleInstance, DkmNativeModuleInstance, DkmClrNcContainerModuleInstance
class DECLSPEC_NOVTABLE DECLSPEC_UUID("74857b6f-618d-66e3-149e-6cebf4c4123e") DkmModuleInstance : public DkmDataContainer
{
    // Use DkmModuleInstance::Create to create this object
    private: DkmModuleInstance();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmModuleInstance();
    // This object cannot be copied
    private: DkmModuleInstance& operator=(const DkmModuleInstance&);
    private: DkmModuleInstance(const DkmModuleInstance&);

    // 'MinidumpInfo' is used to convey additional information about modules in a
    // DkmProcess for a minidump.
    public: struct MinidumpInfo
    {
        // Path where the module was loaded on the computer where the dump was taken.
        DkmString* pOriginalPath;
    };

    // DkmModuleInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: struct Tag { enum e {
    // Object is an instance of 'DkmNativeModuleInstance'.
    NativeModuleInstance = 0,
    // Object is an instance of 'DkmClrModuleInstance'.
    ClrModuleInstance = 1,
    // Object is an instance of 'DkmCustomModuleInstance'.
    CustomModuleInstance = 2,
    // Object is an instance of 'DkmClrNcContainerModuleInstance'.
    ClrNcContainerModuleInstance = 3
    }; };

    private: OPTIONAL const DkmModuleInstance::MinidumpInfo* const m_pMinidumpInfo;
    private: const Tag::e m_TagValue;
    private: const GUID m_UniqueId;
    private: DkmString* const m_pName;
    private: DkmString* const m_pFullName;
    private: const UINT64 m_TimeDateStamp;
    private: DkmRuntimeInstance* const m_pRuntimeInstance;
    private: OPTIONAL DkmModuleVersion* const m_pVersion;
    private: OPTIONAL Symbols::DkmSymbolFileId* const m_pSymbolFileId;
    private: const DkmModuleFlags::e m_Flags;
    private: const DkmModuleMemoryLayout::e m_MemoryLayout;
    private: const UINT64 m_BaseAddress;
    private: const UINT32 m_LoadOrder;
    private: const UINT32 m_Size;
    private: DkmString* const m_pLoadContext;
    private: bool m_IsDisabled;
    private: OPTIONAL Symbols::DkmModule* m_pModule;
    private: void* m__pExtendedData;

    // [Optional] 'MinidumpInfoPart' is used to convey additional information about
    // modules in a DkmProcess for a minidump.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmModuleInstance::MinidumpInfo* STDMETHODCALLTYPE MinidumpInfoPart(
        );

    // DkmModuleInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
        );

    // Uniquely identifies the DkmModuleInstance object.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
        );

    // Short representation of the module name. For file-based modules, this  is the file
    // name and extension (ex: kernel32.dll).
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
        );

    // Fully qualified module name. For file-based modules, this is the full path to the
    // module (ex: c:\windows\system32\kernel32.dll.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
        );

    // Date/Time of when the loaded module was built. This value is obtained from the
    // IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a  FILETIME
    // value, which is a 64-bit value representing the number of 100-nanosecond intervals
    // since January 1, 1601 (UTC).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TimeDateStamp(
        );

    // The DkmRuntimeInstance class represents an execution environment which is loaded
    // into a DkmProcess and which contains code to be debugged.
    public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
        );

    // [Optional] File version information.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleVersion* STDMETHODCALLTYPE Version(
        );

    // [Optional] Contains information needed to locate symbols for this module. On
    // Win32, this information is contained within the IMAGE_DEBUG_DIRECTORY.
    public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSymbolFileId* STDMETHODCALLTYPE SymbolFileId(
        );

    // Flags which indicate traits of a DkmModuleInstance.
    public: DECLSPEC_NOTHROW DkmModuleFlags::e STDMETHODCALLTYPE Flags(
        );

    // Enumeration that indicates how a module is laid out in memory.
    public: DECLSPEC_NOTHROW DkmModuleMemoryLayout::e STDMETHODCALLTYPE MemoryLayout(
        );

    // [Optional] The starting memory address of where the module loaded. This value will
    // be zero if the module did not load in a contiguous block of memory.
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE BaseAddress(
        );

    // The integer count of the number of module instances that have loaded up to and
    // including this module. Each runtime instance keeps track of its own load order
    // count.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LoadOrder(
        );

    // [Optional] The number of bytes in the module's memory region. This value will be
    // zero if the module did not load in a contiguous block of memory.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
        );

    // String description of the context under which this module has been loaded. ex:
    // 'Win32' or 'CLR v2.0.50727: Default Domain'.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE LoadContext(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // Indicates if this module instance has been disabled. Disabled modules are largely
    // ignored by the debugger. For native modules, the address range of the disabled
    // module is treated as if it is unmapped. For CLR modules, any frames from these
    // modules is hidden from the call stack.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsDisabled(
        );

    // [Optional] The symbol handler's representation of a module (DkmModule) which is
    // associated with this module instance. This value is initially null, and is
    // assigned if and when symbols are associated with this module instance.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModule(
        _Deref_out_opt_ Symbols::DkmModule** ppValue);

    // Updates the disabled status on a module. This method may only be called from a
    // ModuleInstanceLoad event. When disabling a module, it is common to also suppress
    // the module load event.
    // IsDisabled      : [In] Indicates if this module instance has been disabled.
    // Disabled modules are largely ignored by the debugger. For native modules, the
    // address range of the disabled module is treated as if it is unmapped. For CLR
    // modules, any frames from these modules is hidden from the call stack.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDisabled(
        _In_ bool IsDisabled
        );

    // Obtain the disassembly of the address range in the debuggee module instance.
    // Address         : [In] The address where disassembly should start.
    // Count           : [In] The number of instructions to disassemble.
    // IsForward       : [In] True if this is forward disassembling, otherwise this is
    // reverse disassembling.
    // pDisassembly    : [Out] The results of disassembly read from the debuggee byte
    // code.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // pIsEnd          : [Out] True if the disassembly has reached the end of byte code,
    // false otherwise.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUDisassembly(
        _In_ UINT64 Address,
        _In_ UINT32 Count,
        _In_ bool IsForward,
        _Out_ DkmArray<BYTE>* pDisassembly,
        _Out_ bool* pIsEnd
        );

    // Returns the disassembly size in the debuggee module instance.
    // pSize           : [Out] The disassembly size.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUDisassemblySize(
        _Out_ UINT64* pSize
        );

    // Returns the address of the next instruction relative to a starting address.
    // StartAddress    : [In] The address of the current instruction.
    // pNextAddress    : [Out] The address of the next instruction from StartAddress.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextGPUInstructionAddress(
        _In_ UINT64 StartAddress,
        _Out_ UINT64* pNextAddress
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // This method is invoked by base debug monitors in response to a call to
    // IDkmModuleSymbolsLoaded.RaiseSymbolsLoadedEvent. This method must be invoked from
    // the event thread, or from the request thread as part of a reload. Base debug
    // monitors should synchronously switch to the event thread, pause the target
    // process, and invoke OnSymbolsLoaded.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
    // exe) which is or once was loaded into one or more processes. The DkmModule class
    // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
    // notation of what is loaded. If a code bundle loads into three different processes
    // (or the same process but with three different base addresses or three different
    // app domains) but the symbol handler thinks of all of these as being identical,
    // there will be only one module object.
    // IsReload        : [In] True if symbols are being reloaded for an existing module,
    // False if this is happening as part of module load processing.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSymbolsLoaded(
        _In_ Symbols::DkmModule* pModule,
        _In_ bool IsReload
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // This method is invoked by a symbol provider to associate a DkmModule with a
    // DkmModuleInstance and to trigger a ModuleSymbolsLoaded event. It may be called
    // only once for a DkmModuleInstance object. Calling this API will both establish the
    // DkmModule<->DkmModuleInstance association, as well as cause a ModuleSymbolsLoaded
    // event to be raised.
    // pModule         : [In] The DkmModule that is associated with the
    // DkmModuleInstance.
    // IsReload        : [In] True if symbols are being reloaded for an existing module,
    // False if this is happening as part of module load processing.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetModule(
        _In_ Symbols::DkmModule* pModule,
        _In_ bool IsReload
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Runtime instances call this method to mark a module as a boundary module. When
    // stepping, runtimes should check if the step has hit a boundary module and start
    // stepping arbitration if they have. Note that some runtimes may not be able to
    // honor this request. The dispatcher will keep a count of the number of times this
    // has been called. Only when a matching number of calls to ClearTransitionModuleFlag
    // have been made will the module no longer be considered a transition module.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FlagAsTransitionModule(
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Runtime instances call this method to mark a module as a boundary module. When
    // stepping, runtimes should check if the step has hit a boundary module and start
    // stepping arbitration if they have. Note that some runtimes may not be able to
    // honor this request. The dispatcher will keep a count of the number of times
    // FlagAsTransitionModule has been called. Only when a matching number of calls to
    // ClearTransitionModuleFlag will the module no longer be considered a transition
    // module.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearTransitionModuleFlag(
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Returns true if any runtime instance has flagged this module as a transition
    // module.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pResult         : [Out] Boolean return value. True if the module is a transition
    // module. False otherwise.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsTransitionModule(
        _Out_ bool* pResult
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Attempt to load a binary that previously failed to load using updated symbol
    // paths.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryLoadBinary(
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Called to initiate loading of symbols for DkmModuleInstances whose symbols were
    // not found when the module loaded.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryLoadSymbols(
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Obtain a localized a string description of the current symbol status.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // ExcludeCommonErrors: [In] This value will be true for creating the initial load
    // output message, and false for obtaining the output window text.
    // ppStatus        : [Out] Localized status string (ex: 'Symbols Loaded', 'No symbols
    // loaded', etc.).
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolStatusMessage(
        _In_ bool ExcludeCommonErrors,
        _Deref_out_ DkmString** ppStatus
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Returns a string describing the various locations in which symbols were searched
    // for, and the result of checking that location. This information is used to
    // populate the 'Symbol Load Information' in the modules window.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // ppDescription   : [Out] String containing information about the symbol search. The
    // typical format is 'location1:result1\r\nlocation2:result2...'.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolLoadInformation(
        _Deref_out_ DkmString** ppDescription
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // This method is invoked by symbol handlers to read symbols for DkmModuleInstances
    // whose symbols reside in debuggee's memory.
    // ppSymbolBuffer  : [Out,Optional] The symbol buffer that is read from debuggee's
    // memory at runtime.
    // Return value    : S_OK is returned if *ppSymbolBuffer is non-NULL, S_FALSE is
    // returned when *ppSymbolBuffer is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadSymbols(
        _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppSymbolBuffer
        );

    // Mark the Unload object as unloaded and notify components which implement the event
    // sync interface. Control will return once all components have been notified.
    //
    // This method may only be called by the component which created the object.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        );

    // Raise a ModuleSymbolsUpdated event. Components which implement the event sync
    // interface will receive the event notification. Control will return once all
    // components have been notified.
    // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
    // exe) which is or once was loaded into one or more processes. The DkmModule class
    // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
    // notation of what is loaded. If a code bundle loads into three different processes
    // (or the same process but with three different base addresses or three different
    // app domains) but the symbol handler thinks of all of these as being identical,
    // there will be only one module object.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSymbolsUpdated(
        _In_ Symbols::DkmModule* pModule
        );

    // Raise a BinaryLoaded event. Components which implement the event sync interface
    // will receive the event notification. Control will return once all components have
    // been notified.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pPath           : [In] The full path, relative to the computer running Visual
    // Studio to open the minidump, of the matching binary we were able to find.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBinaryLoaded(
        _In_ DkmString* pPath
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Determines if a module is considered user code.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pIsUserCode     : [Out] True if some or all of the module is user code.  False if
    // the entire module is nonuser code.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsUserCode(
        _Out_ bool* pIsUserCode
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
}; // end of DkmModuleInstance

// Enumeration that indicates how a module is laid out in memory.
enum DkmModuleMemoryLayout::e
{
    // The memory layout of this module is unknown or not defined. This is used for CLR
    // dynamic modules.
    Unknown = 0,
    // Dll is loaded using the 'in memory' layout for a PE. This is the result from
    // LoadLibrary or CreateFileMapping(..SEC_IMAGE...).
    MemoryPE = 1,
    // Dll is loaded using the disk layout for a PE. This is the result of a PE file
    // being directly blitted into a memory buffer using ReadFile.
    DiskPE = 2
};

// File version information.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("c7094fad-97e0-e3eb-4337-60cbb394aa35") DkmModuleVersion : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmModuleVersion::Create to create this object
    private: DkmModuleVersion();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmModuleVersion();
    // This object cannot be copied
    private: DkmModuleVersion& operator=(const DkmModuleVersion&);
    private: DkmModuleVersion(const DkmModuleVersion&);

    private: OPTIONAL DkmString* const m_pFileVersionString;
    private: OPTIONAL DkmString* const m_pCompanyName;
    private: const UINT32 m_FileVersionMS;
    private: const UINT32 m_FileVersionLS;
    private: const UINT32 m_ProductVersionMS;
    private: const UINT32 m_ProductVersionLS;
    private: const UINT32 m_VersionFlags;
    private: void* m__pExtendedData;

    // [Optional] 'FileVersion' field from the variable-sized version data (ex:
    // '6.0.6000.16386 (vista_rtm.061101-2205)').
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FileVersionString(
        );

    // [Optional] 'CompanyName' field from the variable-sized version data (ex:
    // 'Microsoft Corporation').
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CompanyName(
        );

    // Most significant 32-bits of the file version (e.g. 0x00030010 = 3.10).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FileVersionMS(
        );

    // Least significant 32 bits of the file's binary version number (e.g. 0x00000031 =
    // 0.31).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FileVersionLS(
        );

    // Most significant 32 bits of the binary version number of the product with which
    // this file was distributed (e.g. 0x00030010 = 3.10).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProductVersionMS(
        );

    // Least significant 32 bits of the binary version number of the product with which
    // this file was distributed (e.g. 0x00000031 = 0.31).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProductVersionLS(
        );

    // VS_FF_* flags from winver.h of the Platform SDK.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VersionFlags(
        );

    // Create a new DkmModuleVersion object instance.
    // pFileVersionString: [In,Optional] 'FileVersion' field from the variable-sized
    // version data (ex: '6.0.6000.16386 (vista_rtm.061101-2205)').
    // pCompanyName    : [In,Optional] 'CompanyName' field from the variable-sized
    // version data (ex: 'Microsoft Corporation').
    // FileVersionMS   : [In] Most significant 32-bits of the file version (e.g.
    // 0x00030010 = 3.10).
    // FileVersionLS   : [In] Least significant 32 bits of the file's binary version
    // number (e.g. 0x00000031 = 0.31).
    // ProductVersionMS: [In] Most significant 32 bits of the binary version number of
    // the product with which this file was distributed (e.g. 0x00030010 = 3.10).
    // ProductVersionLS: [In] Least significant 32 bits of the binary version number of
    // the product with which this file was distributed (e.g. 0x00000031 = 0.31).
    // VersionFlags    : [In] VS_FF_* flags from winver.h of the Platform SDK.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_opt_ DkmString* pFileVersionString,
        _In_opt_ DkmString* pCompanyName,
        _In_ UINT32 FileVersionMS,
        _In_ UINT32 FileVersionLS,
        _In_ UINT32 ProductVersionMS,
        _In_ UINT32 ProductVersionLS,
        _In_ UINT32 VersionFlags,
        _Deref_out_ DkmModuleVersion** ppCreatedObject
        );
}; // end of DkmModuleVersion

// DkmProcess represents a target process which is being debugged. The debugger debugs
// processes, so this is the basic unit of debugging. A DkmProcess can represent a system
// process or a virtual process such as minidumps.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("a6eaf62b-6db1-4f38-6359-46e9262d7a0a") DkmProcess : public DkmDataContainer
{
    // Use DkmProcess::Create to create this object
    private: DkmProcess();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmProcess();
    // This object cannot be copied
    private: DkmProcess& operator=(const DkmProcess&);
    private: DkmProcess(const DkmProcess&);

    // Information relevant to a running process. For example, this Part will NOT be
    // present for minidumps.
    public: struct Live
    {
        // Process Id (PID) assigned by the operating system. As the same process id may
        // be used by multiple computers, and as process ids may be recycled, it is
        // recommended to use 'UniqueId' for identity purposes.
        UINT32 Id;

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process.
        UINT64 StartTime;
    };

    // Contains additional fields of DkmProcess which were added after the class was
    // initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // True if the process belongs to a Windows Store app package or Windows Phone
        // app package.
        const bool IsAppPackage;
    };

    private: OPTIONAL const DkmProcess::Live* const m_pLive;
    private: DefaultPort::DkmTransportConnection* const m_pConnection;
    private: DkmString* const m_pPath;
    private: const GUID m_UniqueId;
    private: const Start::DkmStartMethod::e m_StartMethod;
    private: DkmEngineSettings* const m_pEngineSettings;
    private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
    private: DefaultPort::DkmSystemInformation* const m_pSystemInformation;
    private: const GUID m_BaseDebugMonitorId;
    private: bool m_IsNativeDebuggingEnabled;
    private: ___ExtendedData* const m__pExtendedData;
    private: void* m_pComputeKernelCollection0;
    private: void* m_pEELocalObjectCollection0;
    private: void* m_pInspectionSessionCollection0;
    private: void* m_pPendingBreakpointCollection0;
    private: void* m_pRuntimeFunctionResolutionRequestCollection0;
    private: void* m_pRuntimeInstanceCollection0;
    private: void* m_pSystemThreadCollection1;
    private: void* m_pThreadCollection0;

    // [Optional] Information relevant to a running process. For example, this Part will
    // NOT be present for minidumps.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmProcess::Live* STDMETHODCALLTYPE LivePart(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // Full path to the starting executable of the process.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
        );

    // Guid which uniquely identifies this process object. This Guid value is the same as
    // the Guid exposed at the SDM layer (IDebugProcess2::GetProcessId) and at the
    // automation layer.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
        );

    // StartMethod describes how the debug engine started debugging this process.
    public: DECLSPEC_NOTHROW Start::DkmStartMethod::e STDMETHODCALLTYPE StartMethod(
        );

    // Contains the session-wide debug settings. There is one instance of this object per
    // engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
    // COMPlusNativeEng).
    public: _Ret_ DECLSPEC_NOTHROW DkmEngineSettings* STDMETHODCALLTYPE EngineSettings(
        );

    // Settings supplied during a start debugging operation from a project system or
    // other caller of LaunchDebugTargets (or various other start debugging APIs).
    public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
        );

    // Contains information about the computer system that this process is running under.
    // If this process is running under WOW (32-bit emulation on a 64-bit OS) this
    // information will be for the 32-bit subsystem rather than the 64-bit subsystem.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE SystemInformation(
        );

    // DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and
    // control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is
    // used for processes debugged by the Win32 debugging API and
    // DkmBaseDebugMonitorId.DumpFile is used for minidumps.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE BaseDebugMonitorId(
        );

    // True if the process belongs to a Windows Store app package or Windows Phone app
    // package.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsAppPackage(
        );

    // When true, the debugger will attempt to debug native code - it will stop on native
    // exceptions, load symbols, display native frames on the call stack, bind and hit
    // breakpoints, and leave native threads stopped while in break state.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsNativeDebuggingEnabled(
        );

    // Find a DkmProcess object. If no object with the given input key is present,
    // FindProcess will fail.
    // UniqueId        : [In] Search key used to find the element.
    // ppProcess       : [Out] Result of the search.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindProcess(
        _In_ const GUID& UniqueId,
        _Deref_out_ DkmProcess** ppProcess
        );

    // GetProcesses enumerates all the created DkmProcess objects.
    // pProcesses      : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProcesses(
        _Out_ DkmArray<DkmProcess*>* pProcesses
        );

    // Creates a new process object. This method is called from the base debug monitor on
    // the event thread as part of the processing of
    // IDkmStartDebuggingOperations.AttachToProcess or
    // IDkmStartDebuggingOperations.ResumeDebuggedProcess.
    //
    // This method will send a ProcessCreate event.
    // pConnection     : [In] This represents a connection between the monitor and the
    // IDE. It can either be a local connection if the monitor is running in the same
    // process as the IDE, or it can be a remote connection. In the monitor process,
    // there is only one connection.
    // pPath           : [In] Full path to the starting executable of the process.
    // UniqueId        : [In] Guid which uniquely identifies this process object. This
    // Guid value is the same as the Guid exposed at the SDM layer
    // (IDebugProcess2::GetProcessId) and at the automation layer.
    // StartMethod     : [In] StartMethod describes how the debug engine started
    // debugging this process.
    // pEngineSettings : [In] Contains the session-wide debug settings. There is one
    // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
    // instance for COMPlusNativeEng).
    // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
    // from a project system or other caller of LaunchDebugTargets (or various other
    // start debugging APIs).
    // pSystemInformation: [In] Contains information about the computer system that this
    // process is running under. If this process is running under WOW (32-bit emulation
    // on a 64-bit OS) this information will be for the 32-bit subsystem rather than the
    // 64-bit subsystem.
    // BaseDebugMonitorId: [In] DkmBaseDebugMonitorId identifies the base debug monitor
    // used to inspect and control the debugged process. For example,
    // DkmBaseDebugMonitorId.WindowsProcess is used for processes debugged by the Win32
    // debugging API and DkmBaseDebugMonitorId.DumpFile is used for minidumps.
    // IsNativeDebuggingEnabled: [In] When true, the debugger will attempt to debug
    // native code - it will stop on native exceptions, load symbols, display native
    // frames on the call stack, bind and hit breakpoints, and leave native threads
    // stopped while in break state.
    // pLive           : [In,Optional] Information relevant to a running process. For
    // example, this Part will NOT be present for minidumps.
    // DataItem        : [In] Data object to add to the new DkmProcess instance.
    // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_ DkmString* pPath,
        _In_ const GUID& UniqueId,
        _In_ Start::DkmStartMethod::e StartMethod,
        _In_ DkmEngineSettings* pEngineSettings,
        _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
        _In_ DefaultPort::DkmSystemInformation* pSystemInformation,
        _In_ const GUID& BaseDebugMonitorId,
        _In_ bool IsNativeDebuggingEnabled,
        _In_opt_ const DkmProcess::Live* pLive,
        _In_ const DkmDataItem& DataItem,
        _Deref_out_ DkmProcess** ppCreatedObject
        );

    // Creates a new process object. This method is called from the base debug monitor on
    // the event thread as part of the processing of
    // IDkmStartDebuggingOperations.AttachToProcess or
    // IDkmStartDebuggingOperations.ResumeDebuggedProcess.
    //
    // This method will send a ProcessCreate event.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pConnection     : [In] This represents a connection between the monitor and the
    // IDE. It can either be a local connection if the monitor is running in the same
    // process as the IDE, or it can be a remote connection. In the monitor process,
    // there is only one connection.
    // pPath           : [In] Full path to the starting executable of the process.
    // UniqueId        : [In] Guid which uniquely identifies this process object. This
    // Guid value is the same as the Guid exposed at the SDM layer
    // (IDebugProcess2::GetProcessId) and at the automation layer.
    // StartMethod     : [In] StartMethod describes how the debug engine started
    // debugging this process.
    // pEngineSettings : [In] Contains the session-wide debug settings. There is one
    // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
    // instance for COMPlusNativeEng).
    // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
    // from a project system or other caller of LaunchDebugTargets (or various other
    // start debugging APIs).
    // pSystemInformation: [In] Contains information about the computer system that this
    // process is running under. If this process is running under WOW (32-bit emulation
    // on a 64-bit OS) this information will be for the 32-bit subsystem rather than the
    // 64-bit subsystem.
    // BaseDebugMonitorId: [In] DkmBaseDebugMonitorId identifies the base debug monitor
    // used to inspect and control the debugged process. For example,
    // DkmBaseDebugMonitorId.WindowsProcess is used for processes debugged by the Win32
    // debugging API and DkmBaseDebugMonitorId.DumpFile is used for minidumps.
    // IsAppPackage    : [In] True if the process belongs to a Windows Store app package
    // or Windows Phone app package.
    // IsNativeDebuggingEnabled: [In] When true, the debugger will attempt to debug
    // native code - it will stop on native exceptions, load symbols, display native
    // frames on the call stack, bind and hit breakpoints, and leave native threads
    // stopped while in break state.
    // pLive           : [In,Optional] Information relevant to a running process. For
    // example, this Part will NOT be present for minidumps.
    // DataItem        : [In] Data object to add to the new DkmProcess instance.
    // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_ DkmString* pPath,
        _In_ const GUID& UniqueId,
        _In_ Start::DkmStartMethod::e StartMethod,
        _In_ DkmEngineSettings* pEngineSettings,
        _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
        _In_ DefaultPort::DkmSystemInformation* pSystemInformation,
        _In_ const GUID& BaseDebugMonitorId,
        _In_ bool IsAppPackage,
        _In_ bool IsNativeDebuggingEnabled,
        _In_opt_ const DkmProcess::Live* pLive,
        _In_ const DkmDataItem& DataItem,
        _Deref_out_ DkmProcess** ppCreatedObject
        );

    // GetThreads enumerates the DkmThread elements of this DkmProcess object.
    // pThreads        : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreads(
        _Out_ DkmArray<DkmThread*>* pThreads
        );

    // Find a DkmThread element within this DkmProcess. If no element with the given
    // input key is present, FindSystemThread will fail. If an object is found, it will
    // always contain the 'System' Part.
    // Id              : [In] Search key used to find the element.
    // ppThread        : [Out] Result of the search.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSystemThread(
        _In_ UINT32 Id,
        _Deref_out_ DkmThread** ppThread
        );

    // Raise a AsyncBreakComplete event. Components which implement the event sync
    // interface will receive the event notification. This method will enqueue the event
    // and control will immediately return to the caller.
    // Status          : [In] Indicates the type of async-break that occurred.
    // pThread         : [In] DkmThread represents a thread running in the target
    // process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnAsyncBreakComplete(
        _In_ DkmAsyncBreakStatus::e Status,
        _In_ DkmThread* pThread
        );

    // GetPendingBreakpoints enumerates the DkmPendingBreakpoint elements of this
    // DkmProcess object.
    // pPendingBreakpoints: [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPendingBreakpoints(
        _Out_ DkmArray<Breakpoints::DkmPendingBreakpoint*>* pPendingBreakpoints
        );

    // Find a DkmRuntimeInstance element within this DkmProcess. If no element with the
    // given input key is present, FindRuntimeInstance will fail.
    // Id              : [In] Search key used to find the element.
    // ppRuntimeInstance: [Out] Result of the search.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindRuntimeInstance(
        _In_ const DkmRuntimeInstanceId& Id,
        _Deref_out_ DkmRuntimeInstance** ppRuntimeInstance
        );

    // GetRuntimeInstances enumerates the DkmRuntimeInstance elements of this DkmProcess
    // object.
    // pRuntimeInstances: [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRuntimeInstances(
        _Out_ DkmArray<DkmRuntimeInstance*>* pRuntimeInstances
        );

    // GetComputeKernels enumerates the DkmGPUComputeKernel elements of this DkmProcess
    // object.
    // pComputeKernels : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeKernels(
        _Out_ DkmArray<GPU::DkmGPUComputeKernel*>* pComputeKernels
        );

    // GetRuntimeFunctionResolutionRequests enumerates the
    // DkmRuntimeFunctionResolutionRequest elements of this DkmProcess object.
    // pRuntimeFunctionResolutionRequests: [Out] Array containing the enumerated
    // elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRuntimeFunctionResolutionRequests(
        _Out_ DkmArray<FunctionResolution::DkmRuntimeFunctionResolutionRequest*>* pRuntimeFunctionResolutionRequests
        );

    // Raise a EntryPoint event. Components which implement the event sync interface will
    // receive the event notification. This method will enqueue the event and control
    // will immediately return to the caller.
    // pThread         : [In] DkmThread represents a thread running in the target
    // process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnEntryPoint(
        _In_ DkmThread* pThread
        );

    // Resolves a CPU instruction to a native module, and returns a
    // DkmNativeInstructionAddress to represent this CPU instruction. If the instruction
    // pointer is not within a module, a DkmUnknownInstructionAddress object is returned
    // instead.
    // InstructionPointer: [In] Memory address where the native instruction is located.
    // ppAddressObject : [Out] Abstract representation of an executable code location
    // (ex: EIP value). If resolved, an Instruction Address will be within a particular
    // module instance. An Instruction Address is always within a particular Runtime
    // Instance.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateNativeInstructionAddress(
        _In_ UINT64 InstructionPointer,
        _Deref_out_ DkmInstructionAddress** ppAddressObject
        );

    // Resolves a virtual address to a native module. If the virtual address is not
    // within a module, null is returned (S_FALSE return code in native). Disabled
    // modules will not be returned.
    // Address         : [In] Memory address to use as a search key.
    // ppModuleInstance: [Out,Optional] 'DkmNativeModuleInstance' is used for modules
    // which contain CPU code and/or are loaded by the Win32 loader.
    // Return value    : S_OK is returned if *ppModuleInstance is non-NULL, S_FALSE is
    // returned when *ppModuleInstance is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNativeModule(
        _In_ UINT64 Address,
        _Deref_out_opt_ Native::DkmNativeModuleInstance** ppModuleInstance
        );

    // Resolves a virtual address to a native module. If the virtual address is not
    // within a module, null is returned (S_FALSE return code in native).
    // Address         : [In] Memory address to use as a search key.
    // IncludeDisabledModules: [In] When true, the search will include module instances
    // that have 'IsDisabled' set to 'true'.
    // ppModuleInstance: [Out,Optional] 'DkmNativeModuleInstance' is used for modules
    // which contain CPU code and/or are loaded by the Win32 loader.
    // Return value    : S_OK is returned if *ppModuleInstance is non-NULL, S_FALSE is
    // returned when *ppModuleInstance is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNativeModule(
        _In_ UINT64 Address,
        _In_ bool IncludeDisabledModules,
        _Deref_out_opt_ Native::DkmNativeModuleInstance** ppModuleInstance
        );

    // This method will tell the debug monitors to asynchronously break execution of the
    // debuggee process. An AsyncBreakComplete event is sent after the operation is
    // complete.
    // StopImmediately : [In] If this is set to true, implementers should immediately
    // enter break rather than trying to find a thread inside the process that is
    // executing code.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AsyncBreak(
        _In_ bool StopImmediately
        );

    // This method will search the local disk and any configured symbol servers for a
    // binary that matches the parameters. The path to this file on the local disk is
    // returned. If the file was on a symbol server, it is downloaded to a cache and the
    // local path is returned.
    // pApplicationPath: [In] The original path to the exe stored in the minidump.
    // pDumpPath       : [In] The path to the dump file.
    // pOriginalPath   : [In] The original path to the binary stored in the minidump.
    // TimeDateStamp   : [In] The time date stamp of the binary in the time_t format.
    // ImageSize       : [In] The size of the image.
    // ppFoundPath     : [Out,Optional] The path on the local disk of the local (or
    // downloaded) binary.
    // Return value    : S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is
    // returned when *ppFoundPath is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LocateBinary(
        _In_ DkmString* pApplicationPath,
        _In_ DkmString* pDumpPath,
        _In_ DkmString* pOriginalPath,
        _In_ UINT32 TimeDateStamp,
        _In_ UINT32 ImageSize,
        _Deref_out_opt_ DkmString** ppFoundPath
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Disassemble an address range in the debuggee process.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // pAddress        : [In] The address where disassembly should start.
    // Count           : [In] The number of instructions to disassemble.
    // pDisassembledInstructions: [Out] The results of disassembling the address range.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disassemble(
        _In_ DkmInstructionAddress* pAddress,
        _In_ UINT32 Count,
        _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Returns the address of the kth instruction relative to a starting address. For
    // constant length instruction sets, this is simple arithmetic. For variable length
    // instruction sets, reverse-disassembly is required to obtain this address.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // pStartAddress   : [In] The address of the current instruction where the offset
    // should begin.
    // InstructionOffset: [In] The number of instructions relative to StartAddress to
    // find the desired address. This value can be negative.
    // ppAddress       : [Out] The address of the instruction InstructionOffset
    // instructions from StartAddress.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionAddress(
        _In_ DkmInstructionAddress* pStartAddress,
        _In_ INT32 InstructionOffset,
        _Deref_out_ DkmInstructionAddress** ppAddress
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // This method will write out a memory dump of the process to the path specified.
    // DumpType        : [In] The type of dump to write. Either minidump or full-memory
    // minidump.
    // pPath           : [In] The full path to where the minidump should be saved. In
    // remote scenarios, this path is relative to the remote machine.
    // pTargetThread   : [In,Optional] The thread to use for the minidump if there is no
    // current exception.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteDump(
        _In_ DkmDumpType::e DumpType,
        _In_ DkmString* pPath,
        _In_opt_ DkmThread* pTargetThread
        );

    // Adds an exception trigger so that ExceptionTriggerHit events will be sent when the
    // exception trigger has been met.
    //
    // If there is already an exception triggered defined for this {SourceId,
    // DkmExceptionTrigger} tuple then the existing trigger will be modified with the new
    // settings. For example, if a component defines a trigger to stop when an access
    // violation exception is thrown and later sets a trigger to fire when any Win32
    // exception goes unhandled, then the access violation trigger will be removed.
    // SourceId        : [In] Identifies the source of an object. SourceIds are used to
    // enable filtering in scenarios when multiple components may be creating instances
    // of a class. For example, source ids can be used to determine if a breakpoint comes
    // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
    // level) instead of a breakpoint which may be created by another component (for
    // example an internal breakpoint used for stepping).
    // pTrigger        : [In] Describes an exception or collection of exceptions which a
    // component wants to break on. When a higher level components wants to be notified
    // about certain exceptions, it should create one or more exception triggers, and
    // then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when
    // the exception occurs, a ExceptionTriggerHit exception will be fired whenever this
    // trigger is met.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddExceptionTrigger(
        _In_ const GUID& SourceId,
        _In_ Exceptions::DkmExceptionTrigger* pTrigger
        );

    // Adds an exception trigger so that ExceptionTriggerHit events will be sent when the
    // exception trigger has been met.
    //
    // If there is already an exception triggered defined for this {SourceId,
    // DkmExceptionTrigger} tuple then the existing trigger will be modified with the new
    // settings. For example, if a component defines a trigger to stop when an access
    // violation exception is thrown and later sets a trigger to fire when any Win32
    // exception goes unhandled, then the access violation trigger will be removed.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    // pWorkList       : WorkList to append the new work item to.
    // SourceId        : [In] Identifies the source of an object. SourceIds are used to
    // enable filtering in scenarios when multiple components may be creating instances
    // of a class. For example, source ids can be used to determine if a breakpoint comes
    // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
    // level) instead of a breakpoint which may be created by another component (for
    // example an internal breakpoint used for stepping).
    // pTrigger        : [In] Describes an exception or collection of exceptions which a
    // component wants to break on. When a higher level components wants to be notified
    // about certain exceptions, it should create one or more exception triggers, and
    // then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when
    // the exception occurs, a ExceptionTriggerHit exception will be fired whenever this
    // trigger is met.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddExceptionTrigger(
        _In_ DkmWorkList* pWorkList,
        _In_ const GUID& SourceId,
        _In_ Exceptions::DkmExceptionTrigger* pTrigger,
        _In_ IDkmCompletionRoutine<Exceptions::DkmAddExceptionTriggerAsyncResult>* pCompletionRoutine
        );

    // Removes all the exception triggers which have been set with a particular SourceId.
    // After this method returns, the exception triggers will no longer raise
    // ExceptionTriggerHit events. Exception triggers are automatically cleared when the
    // DkmProcess object is closed.
    // SourceId        : [In] Identifies the source of an object. SourceIds are used to
    // enable filtering in scenarios when multiple components may be creating instances
    // of a class. For example, source ids can be used to determine if a breakpoint comes
    // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
    // level) instead of a breakpoint which may be created by another component (for
    // example an internal breakpoint used for stepping).
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearExceptionTriggers(
        _In_ const GUID& SourceId
        );

    // The method will return the contents of the IMAGE_RUNTIME_FUNCTION_ENTRY for an
    // address if possible. For searching static entries, callers should call the
    // equivalent method on DkmNativeModuleInstance.
    // Address         : [In] The virtual address for which to find a function table
    // entry for.
    // pBaseAddress    : [Out] The base address for the runtime function table entry.
    // ppFunctionTableEntry: [Out,Optional] The runtime function table entry for this
    // address if found.
    // Return value    : S_OK is returned if *ppFunctionTableEntry is non-NULL, S_FALSE
    // is returned when *ppFunctionTableEntry is NULL, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SearchRuntimeFunctionTable(
        _In_ UINT64 Address,
        _Out_ UINT64* pBaseAddress,
        _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppFunctionTableEntry
        );

    // Get the breakpoint behavior of the process.
    // pBreakpointBehavior: [Out] The breakpoint behavior of the process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUBreakpointBehavior(
        _Out_ GPU::DkmGPUBreakpointBehaviorFlags::e* pBreakpointBehavior
        );

    // Enables / disables a particular GPU memory access warning.
    // WarningCode     : [In] Warning code to set.
    // Enable          : [In] True to set the warning, false to clear it.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetGPUMemoryAccessWarning(
        _In_ UINT32 WarningCode,
        _In_ bool Enable
        );

    // Disables all active GPU memory access warnings.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearAllGPUMemoryAccessWarnings(
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Resolves a CPU InstructionAddress to a DkmInstructionAddress.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // pWorkList       : WorkList to append the new work item to.
    // InstructionPointer: [In] Memory address where the native instruction is located.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionAddress(
        _In_ DkmWorkList* pWorkList,
        _In_ UINT64 InstructionPointer,
        _In_ IDkmCompletionRoutine<DkmGetInstructionAddressAsyncResult>* pCompletionRoutine
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Method called by the base debug monitor to inform other components that the
    // instruction memory of the target process was modified. Currently, this is only
    // used for breakpoint insertion.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // Address         : [In] The base address from which to write the target process's
    // memory.
    // OriginalMemory  : [In] The original code bytes which were replaced in the target
    // process.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnInstructionPatchInserted(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& OriginalMemory
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Method called by the base debug monitor to inform other components that the
    // instruction memory of the target process was restored to its original state.
    // Currently, this is only used for breakpoint removal.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // Address         : [In] The base address from which to write the target process's
    // memory.
    // OriginalMemory  : [In] The original code bytes which were restored in the target
    // process.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnInstructionPatchRemoved(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& OriginalMemory
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Read the memory of the target process.
    // Address         : [In] The base address from which to read the target process's
    // memory.
    // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
    // DkmProcess.ReadMemoryString.
    // pBuffer         : [In,Out] A buffer that receives the contents from the address
    // space of the target process. On failure, the content of this buffer is
    // unspecified.
    // Size            : [In] The number of bytes to be read from the process.
    // pBytesRead      : [Out,Optional] Indicates the number of bytes read from the
    // target process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this
    // value will always be exactly equal to the input size. If
    // DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be
    // greater than zero.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
    // 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadMemory(
        _In_ UINT64 Address,
        _In_ DkmReadMemoryFlags::e Flags,
        _Out_capcount_(Size) void* pBuffer,
        _In_ UINT32 Size,
        _Out_ UINT32* pBytesRead
        );

    // Reads a null-terminated string from the target process process's memory. This can
    // be used to read an ANSI or Unicode (UTF-8, UTF-16 or UTF-32) strings.
    // Address         : [In] The base address from which to read the target process's
    // memory.
    // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
    // DkmProcess.ReadMemoryString.
    // CharacterSize   : [In] Number of bytes in each character. This should be set to 1
    // (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).
    // MaxCharacters   : [In] The maximum number of characters to read from the target
    // process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail
    // if a null terminator isn't found within this range. This value should be
    // reasonable. The Microsoft implementation will fail any request for more than
    // 128MBs of string memory.
    // pStringMemory   : [Out] The value of the string which was read from the target
    // process. If DkmReadMemoryFlags.AllowPartialRead is clear, this memory will always
    // include the null termination character. If DkmReadMemoryFlags.AllowPartialRead is
    // specified, this buffer will not contain the null termination character if the read
    // was truncated.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
    // 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
    // E_STRING_TOO_LONG indicates that the string could not be read within the specified
    // maximum number of characters.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadMemoryString(
        _In_ UINT64 Address,
        _In_ DkmReadMemoryFlags::e Flags,
        _In_ UINT16 CharacterSize,
        _In_ UINT32 MaxCharacters,
        _Out_ DkmArray<BYTE>* pStringMemory
        );

    // Writes memory to the target process. Before data transfer occurs, the system
    // verifies that all data in the base address and memory of the specified size is
    // accessible for write access, and if it is not accessible, the function raises an
    // E_INVALID_MEMORY_ADDRESS error.
    // Address         : [In] The base address from which to write the target process's
    // memory.
    // Data            : [In] Data to be written in the address space of the specified
    // process.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteMemory(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& Data
        );

    // Write memory to the target process, but hide the write from calls to ReadMemory.
    // This API may be used to patch instructions or data within the target process to
    // implement debugger features. Before data transfer occurs, the system verifies that
    // all data in the base address and memory of the specified size is accessible for
    // write access, and if it is not accessible, the function raises an
    // E_INVALID_MEMORY_ADDRESS error.
    // Address         : [In] The base address from which to write the target process's
    // memory.
    // Data            : [In] Data to be written in the address space of the specified
    // process.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InvisibleWriteMemory(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& Data
        );

    // Obtains the number of active handles in the process.
    // pHandleCount    : [Out] The number of handles in the debuggee process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHandleCount(
        _Out_ UINT32* pHandleCount
        );

    // Obtains the number of clock cycles that the debuggee has been running since
    // ResetRunningTime() was last called.
    // pRunningTime    : [Out] The time the debuggee has been running.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRunningTime(
        _Out_ UINT64* pRunningTime
        );

    // Sets the running time counter to the specified value.
    // RunningTime     : [In] The value to set the clock to.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRunningTime(
        _In_ UINT64 RunningTime
        );

    // Provides access to the DkmRuntimeInstance which is for the naive code within a
    // process. There is exactly one DkmRuntimeInstance for a process.
    // ppRuntimeInstance: [Out] Represents the native code executing in a target process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeRuntimeInstance(
        _Deref_out_ Native::DkmNativeRuntimeInstance** ppRuntimeInstance
        );

    // This method is called to tell the monitor to detach from the target process. This
    // will trigger a ProcessExit event to be sent on the event thread.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Detach(
        );

    // This method is called to tell the monitor to terminate the target process. This
    // will trigger a ProcessExit event to be sent on the event thread.
    // ExitCode        : [In] The exit code to be used by the process and threads
    // terminated as a result of this call. Use the GetExitCodeProcess function to
    // retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a
    // thread's exit value.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Terminate(
        _In_ UINT32 ExitCode
        );

    // StoppingEventProcessingBegin is called by the base debug monitor on the event
    // thread. It notifies the Dispatcher that the target process is stopped and may have
    // reached a stopping event. For example, the Win32 base debug monitor calls this
    // whenever it receives an EXCEPTION_DEBUG_EVENT from the operating system. This
    // method updates the internal state of the DkmProcess object so that stopping events
    // are allowed to be sent.
    // ForceQueue      : [In] Normally, the dispatcher will reject (return
    // E_TARGET_ALREADY_STOPPED) attempts to send additional stopping events after the
    // target process has received its initial batch of stopping events
    // (StoppingEventProcessingContinue has been called). By passing 'true' for this
    // argument, the base debug monitor causes these events to be queued rather than
    // rejected. This is used by the Win32 debug monitor when it fully drains the Win32
    // debugging event queue prior to the start of a function evaluation.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StoppingEventProcessingBegin(
        _In_ bool ForceQueue
        );

    // StoppingEventProcessingContinue is called by the base debug monitor on the event
    // thread. This method is called after all stopping events within the current batch
    // have been issued (ex: called DkmRuntimeBreakpoint.OnHit). This method will notify
    // components which have implemented a stopping event notification interface and will
    // call into the execution manager to slip the process to a safe point. The base
    // debug monitor must call StoppingEventProcessingContinue after any successful call
    // to StoppingEventProcessingBegin. the base debug monitor after it has issued all
    // stopping events.
    //
    // A base debug monitor should expect to be reentrantly called while it is in this
    // method.
    // pNextAction     : [Out] Status code returned to the base debug monitor to indicate
    // the next action to take in stopping event processing.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StoppingEventProcessingContinue(
        _Out_ DkmStoppingEventProcessingNextAction::e* pNextAction
        );

    // AbortingFuncEvalExecution is called by the runtime debug monitor when aborting a
    // function evaluation. AbortingFuncEvalExecution will update the internal state of
    // the DkmProcess object so the stopping event manager will allow two stopping events
    // through: a function evaluation complete breakpoint or an async break.
    // Flags           : [In] Flags impacting how function evaluation requests are
    // performed.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AbortingFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags::e Flags
        );

    // This method allows a component to determined if the process is considered stopped
    // by the Dispatcher. This method does not need to be called from within an interface
    // method which requires the target process to be stopped, but it may be helpful
    // during operations which may be called from run mode.
    // pResult         : [Out] Returns true if the process is considered stopped. This
    // will return true on request threads after the debugger has sent a stopping event
    // (ex: breakpoint hit) to the IDE and before the process has been resumed. It will
    // return true on event threads if a pausing event (ex: module load) or stopping
    // event (ex: breakpoint hit) is being processed.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsStopped(
        _Out_ bool* pResult
        );

    // Provides the list of active system threads in the process. Threads which are not
    // system threads (DkmThread::System is null) or have been unloaded, will not be
    // present in this collection.
    // pSystemThreads  : [Out] Returned array of system threads.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSystemThreads(
        _Out_ DkmArray<DkmThread*>* pSystemThreads
        );

    // Reserves and/or commits a region of memory within the virtual address space of the
    // target process. The function initializes the memory it allocates to zero, unless
    // MEM_RESET is used. For additional information, see the VirtualAlloc Win32 API in
    // MSDN.
    // Address         : [In] Address within the target process where the memory should
    // be committed or reserved. This value is typically zero, in which case the system
    // chooses an address.
    // Size            : [In] The size of the region of memory to allocate, in bytes. The
    // system will automatically round up to the next page boundary.
    // AllocationType  : [In] Indicates the type of allocation to perform. This is
    // typically MEM_COMMIT | MEM_RESERVE (0x3000) which reserves and commits an
    // allocation in one step.
    // PageProtection  : [In] The memory protection for the region of pages to be
    // allocated. If the pages are being committed, you can specify any one of the memory
    // protection constants (ex: PAGE_READWRITE, PAGE_EXECUTE).
    // pAllocatedAddress: [Out] Base address of the allocated region of pages.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AllocateVirtualMemory(
        _In_ UINT64 Address,
        _In_ UINT32 Size,
        _In_ UINT32 AllocationType,
        _In_ UINT32 PageProtection,
        _Out_ UINT64* pAllocatedAddress
        );

    // Releases and/or decommits a region of memory within the virtual address space of
    // the target process. For additional information, see the VirtualFree Win32 API in
    // MSDN.
    // Address         : [In] Address within the target process where the memory should
    // be freed.
    // Size            : [In] Number of bytes to decommit. To release a region of memory,
    // this value must be zero.
    // FreeType        : [In] Indicates the type of free operation to perform. This is
    // typically MEM_RELEASE (0x8000), which releases the specified region of pages.
    // After the operation, the pages are in the free state. MEM_DECOMMIT (0x4000) can be
    // used instead to decommit the pages without releasing them.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreeVirtualMemory(
        _In_ UINT64 Address,
        _In_ UINT32 Size,
        _In_ UINT32 FreeType
        );

    // Read memory from the target process. This method differs from 'ReadMemory' in that
    // this method can be called at any time (not just when the target is stopped) and
    // the debugger will not try to cache the result of this operation.
    // Address         : [In] The base address from which to read the target process's
    // memory.
    // pBuffer         : [In,Out] A buffer that receives the contents from the address
    // space of the target process. On failure, the content of this buffer is
    // unspecified.
    // Size            : [In] The number of bytes to be read from the process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request
    // could not be read.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE VolatileReadMemory(
        _In_ UINT64 Address,
        _Out_capcount_(Size) void* pBuffer,
        _In_ UINT32 Size
        );

    // Write to the memory of the target process. This method differs from 'WriteMemory'
    // in that this method can be called at any time (not just when the target is
    // stopped) and the debugger will not try to cache the result of this operation. If
    // any memory cannot be written to, an E_INVALID_MEMORY_ADDRESS error will be raised.
    // Because the memory write may occur from run mode, this failure may happen after
    // the copy operation has already begun, and thus may lead to memory corruption in
    // the target process. For this reason, this function must be used with care, and
    // failures may be fatal.
    // Address         : [In] The base address from which to write the target process's
    // memory.
    // Data            : [In] Data to be written in the address space of the specified
    // process.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE VolatileWriteMemory(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& Data
        );

    // Raise a LoadComplete event. Components which implement the event sync interface
    // will receive the event notification. Control will return once all components have
    // been notified.
    //
    // This method may only be called by the component which created the object.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnLoadComplete(
        );

    // ProcessExit is sent by the dispatcher when DkmProcess::Unload is invoked by the
    // monitor.
    //
    // This method may only be called by the component which created the object.
    // ExitCode        : [In] 32-bit value which the processed returned on exit. This is
    // the same value that would be reported from the kernel32!GetExitCodeProcess.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        _In_ UINT32 ExitCode
        );

    // Called to initiate locating of binaries whose images might not have previously
    // found or attempted to be loaded. This method will search the local disk and any
    // configured symbol servers for a binary that matches the parameters. The path to
    // this file on the local disk is returned. If the file was on a symbol server, it is
    // downloaded to a cache and the local path is returned.
    //
    // This API was introduced in Visual Studio 11 Update 1
    // (DkmApiVersion.VS11FeaturePack1).
    // pApplicationPath: [In] The original path to the exe stored in the minidump.
    // pDumpPath       : [In] The path to the dump file.
    // pOriginalPath   : [In] The original path to the binary stored in the minidump.
    // TimeDateStamp   : [In] The time date stamp of the binary in the time_t format.
    // ImageSize       : [In] The size of the image.
    // ppFoundPath     : [Out,Optional] The path on the local disk of the local (or
    // downloaded) binary.
    // Return value    : S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is
    // returned when *ppFoundPath is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryLocateBinary(
        _In_ DkmString* pApplicationPath,
        _In_ DkmString* pDumpPath,
        _In_ DkmString* pOriginalPath,
        _In_ UINT32 TimeDateStamp,
        _In_ UINT32 ImageSize,
        _Deref_out_opt_ DkmString** ppFoundPath
        );

    // Returns the path to the primary executable in the minidump being debugged.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // ppExePath       : [Out] Path to the debuggee's primary executable file.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDumpExePath(
        _Deref_out_ DkmString** ppExePath
        );
}; // end of DkmProcess

// Flags controlling the behavior of DkmProcess.ReadMemory and
// DkmProcess.ReadMemoryString.
enum DkmReadMemoryFlags::e
{
    // Indicates that the caller wants the default behavior for ReadMemory.
    None = 0x0,
    // Indicates that the caller wants the read operation to succeed if only part of the
    // memory read succeeded. If this is set, an E_INVALID_MEMORY_ADDRESS error will only
    // be raised if 'Address' is invalid. If this flag is clear, a
    // E_INVALID_MEMORY_ADDRESS error will be raised if any portion of the requested
    // memory was unreadable.
    AllowPartialRead = 0x1,
    // Indicates that the read should only succeed if the memory pages in question have
    // one of the the execute flags set (PAGE_EXECUTE, PAGE_EXECUTE_READONLY, etc.). If
    // combined with AllowPartialRead, this will return all memory between the starting
    // address and the end of the executable region. If no executable code is found, the
    // read fails with E_INVALID_MEMORY_PROTECT.
    ExecutableOnly = 0x2,
    // Indicates that the read is a GPU C++ AMP pointer and that the high bits should be
    // read from the tag memory.
    ReadGPUPointer = 0x4
};
DEFINE_ENUM_FLAG_OPERATORS(DkmReadMemoryFlags::e);

// A key/value pair read from the registry.
//
// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("cc23b95f-53fb-bc5a-454c-9345558fa0fe") DkmRegistryTweak : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmRegistryTweak::Create to create this object
    private: DkmRegistryTweak();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmRegistryTweak();
    // This object cannot be copied
    private: DkmRegistryTweak& operator=(const DkmRegistryTweak&);
    private: DkmRegistryTweak(const DkmRegistryTweak&);

    private: DkmString* const m_pValueName;
    private: const UINT32 m_Data;
    private: void* m__pExtendedData;

    // The name of the registry value that specifies this tweak.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ValueName(
        );

    // The value of this tweak in the registry.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Data(
        );

    // Create a new DkmRegistryTweak object instance.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pValueName      : [In] The name of the registry value that specifies this tweak.
    // Data            : [In] The value of this tweak in the registry.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmString* pValueName,
        _In_ UINT32 Data,
        _Deref_out_ DkmRegistryTweak** ppCreatedObject
        );
}; // end of DkmRegistryTweak

// Result of an asynchronous DkmRuntimeInstance.ResolveCPUInstructionAddress call.
struct DkmResolveCPUInstructionAddressAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Abstract representation of an executable code location (ex: EIP value). If
    // resolved, an Instruction Address will be within a particular module instance. An
    // Instruction Address is always within a particular Runtime Instance.
    DkmInstructionAddress* pAddressObject;

    // True if this address is the first address in the line's range. False otherwise.
    bool FirstAddress;
};

// Enumeration of runtime capabilities.
//
// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
enum DkmRuntimeCapabilities::e
{
    // No capabilities specified.
    None = 0x0,
    // Allow stack caching for when this runtime has a stack frame at the top of the
    // stack.
    AllowStackCaching = 0x1,
    // Prevent detaching the debugger.  Detach will be disabled if any of the runtime
    // instances have this capability set.
    PreventDetach = 0x2,
    // Indicates that the runtime supports the Just-My-Code feature.
    SupportsJustMyCode = 0x4,
    // Indicates that the runtime does not allow stopping in non-user code.  This is
    // currently used to disable breakpoints in non-user code for runtimes with this
    // capability.  When stack frames for runtimes with this capability set are at the
    // top of the stack, any non-user frames will be collapsed to [External Code]. This
    // capability flag should only be set when SupportJustMyCode is also set.
    ProhibitsStoppingInNonUserCode = 0x8
};
DEFINE_ENUM_FLAG_OPERATORS(DkmRuntimeCapabilities::e);

// The Runtime Id identifies the execution environment for a particular piece of code.
// Runtime Ids are used by the dispatcher to decide which monitor to dispatch to. Note
// that the ordering of the runtime ID Guids is somewhat significant as this dictates
// which runtime gets the first shot during arbitration. Thus, if one wants to declare a
// new runtime instance which is built on the CLR, the runtime id should be less than
// DkmRuntimeId.Clr.
struct DkmRuntimeId
{
    // Identifies native code. Since all code executed by the CPU is native, this is the
    // default runtime and any code address unclaimed by other runtimes will be treated
    // as native.
    // Native is defined as {acec4df9-31f4-46fd-946d-2194f653fd26}.
    static const GUID Native;
    // Identifies code running under the CLR runtime.
    // Clr is defined as {390763e5-34af-483b-a7ba-e5e0235da888}.
    static const GUID Clr;
    // Identifies code running under the GPU D3D runtime.
    // Gpu is defined as {9e1b75f6-2088-4494-98bf-90985386bd85}.
    static const GUID Gpu;
    // Identifies code running under Microsoft ActiveScript based runtimes.
    // ActiveScript is defined as {4e602173-b073-4a20-b20e-1d7d6b9b075b}.
    static const GUID ActiveScript;
    // Identifies code running under Microsoft ActiveScript based runtimes that can
    // interop with other debug code types.
    // ActiveScriptInterop is defined as {0edd4525-c3ca-48e4-bd11-8eb5ae3ef6f5}.
    static const GUID ActiveScriptInterop;
    // Identifies code running under the native-compiled CLR.
    // ClrNativeCompilation is defined as {5c4f3253-8682-4aba-8fe7-dfd44e6de5bc}.
    static const GUID ClrNativeCompilation;
    // Identifies code running under the GPU Interop D3D runtime.
    // GpuInterop is defined as {a5099208-2f13-4d71-bcf6-846bc83f211f}.
    static const GUID GpuInterop;
};
__declspec(selectany) const GUID DkmRuntimeId::Native = { 0xacec4df9, 0x31f4, 0x46fd, { 0x94, 0x6d, 0x21, 0x94, 0xf6, 0x53, 0xfd, 0x26 } };
__declspec(selectany) const GUID DkmRuntimeId::Clr = { 0x390763e5, 0x34af, 0x483b, { 0xa7, 0xba, 0xe5, 0xe0, 0x23, 0x5d, 0xa8, 0x88 } };
__declspec(selectany) const GUID DkmRuntimeId::Gpu = { 0x9e1b75f6, 0x2088, 0x4494, { 0x98, 0xbf, 0x90, 0x98, 0x53, 0x86, 0xbd, 0x85 } };
__declspec(selectany) const GUID DkmRuntimeId::ActiveScript = { 0x4e602173, 0xb073, 0x4a20, { 0xb2, 0xe, 0x1d, 0x7d, 0x6b, 0x9b, 0x7, 0x5b } };
__declspec(selectany) const GUID DkmRuntimeId::ActiveScriptInterop = { 0xedd4525, 0xc3ca, 0x48e4, { 0xbd, 0x11, 0x8e, 0xb5, 0xae, 0x3e, 0xf6, 0xf5 } };
__declspec(selectany) const GUID DkmRuntimeId::ClrNativeCompilation = { 0x5c4f3253, 0x8682, 0x4aba, { 0x8f, 0xe7, 0xdf, 0xd4, 0x4e, 0x6d, 0xe5, 0xbc } };
__declspec(selectany) const GUID DkmRuntimeId::GpuInterop = { 0xa5099208, 0x2f13, 0x4d71, { 0xbc, 0xf6, 0x84, 0x6b, 0xc8, 0x3f, 0x21, 0x1f } };

// The DkmRuntimeInstance class represents an execution environment which is loaded into
// a DkmProcess and which contains code to be debugged.
//
// Derived classes: DkmClrRuntimeInstance, DkmClrNcRuntimeInstance,
// DkmCustomRuntimeInstance, DkmNativeRuntimeInstance, DkmScriptRuntimeInstance
class DECLSPEC_NOVTABLE DECLSPEC_UUID("9b32a175-6e35-1ae5-1498-c93ab323e2c8") DkmRuntimeInstance : public DkmDataContainer
{
    // Use DkmRuntimeInstance::Create to create this object
    private: DkmRuntimeInstance();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmRuntimeInstance();
    // This object cannot be copied
    private: DkmRuntimeInstance& operator=(const DkmRuntimeInstance&);
    private: DkmRuntimeInstance(const DkmRuntimeInstance&);

    // DkmRuntimeInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: struct Tag { enum e {
    // Object is an instance of 'DkmNativeRuntimeInstance'.
    NativeRuntimeInstance = 0,
    // Object is an instance of 'DkmClrRuntimeInstance'.
    ClrRuntimeInstance = 1,
    // Object is an instance of 'DkmScriptRuntimeInstance'.
    ScriptRuntimeInstance = 2,
    // Object is an instance of 'DkmCustomRuntimeInstance'.
    CustomRuntimeInstance = 3
    }; };

    // Contains additional fields of DkmRuntimeInstance which were added after the class
    // was initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // Enumeration of runtime capabilities.
        const DkmRuntimeCapabilities::e Capabilities;

        // [Optional] For runtimes that are implemented on top of another runtime, this
        // can optionally be used to indicant the logical parent. This can then be used
        // to request services from the parent when the child runtime doesn't implement
        // the service. This is currently used only for obtaining the top stack frame to
        // evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        // itself.
        OPTIONAL DkmRuntimeInstance* const pParentRuntime;
    };

    private: const Tag::e m_TagValue;
    private: DkmProcess* const m_pProcess;
    private: const DkmRuntimeInstanceId m_Id;
    private: ___ExtendedData* const m__pExtendedData;
    private: void* m_pContextGroupEvalResultCollection0;
    private: void* m_pModuleInstanceCollection0;
    private: void* m_pRuntimeBreakpointCollection0;
    private: void* m_pScriptDocumentTreeNodeCollection0;
    private: void* m_pTaskProviderCollection0;

    // DkmRuntimeInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Identifies a DkmRuntimeInstance object within a process.
    public: DECLSPEC_NOTHROW const DkmRuntimeInstanceId& STDMETHODCALLTYPE Id(
        );

    // Enumeration of runtime capabilities.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW DkmRuntimeCapabilities::e STDMETHODCALLTYPE Capabilities(
        );

    // [Optional] For runtimes that are implemented on top of another runtime, this can
    // optionally be used to indicant the logical parent. This can then be used to
    // request services from the parent when the child runtime doesn't implement the
    // service. This is currently used only for obtaining the top stack frame to evaluate
    // a conditional breakpoint when the child runtime doesn't walk stacks itself.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE ParentRuntime(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // GetScriptDocumentTreeNodes enumerates the DkmScriptDocumentTreeNode elements of
    // this DkmRuntimeInstance object.
    // pScriptDocumentTreeNodes: [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetScriptDocumentTreeNodes(
        _Out_ DkmArray<Script::DkmScriptDocumentTreeNode*>* pScriptDocumentTreeNodes
        );

    // GetModuleInstances enumerates the DkmModuleInstance elements of this
    // DkmRuntimeInstance object.
    // pModuleInstances: [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModuleInstances(
        _Out_ DkmArray<DkmModuleInstance*>* pModuleInstances
        );

    // GetTaskProviders enumerates the DkmTaskProvider elements of this
    // DkmRuntimeInstance object.
    // pTaskProviders  : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskProviders(
        _Out_ DkmArray<ParallelTasks::DkmTaskProvider*>* pTaskProviders
        );

    // Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress
    // object.
    //
    // This API is currently only supported by CLR DkmRuntimeInstance objects, and the
    // CLR runtime instance can currently only find instruction addresses which are in a
    // method that is currently on the call stack of one of the threads in the target
    // process.
    //
    // Location constraint: This API should generally be called on the client, but it can
    // be called on the server for translating CLR addresses (but not native-compiled).
    // InstructionPointer: [In] Memory address where the native instruction is located.
    // ppAddressObject : [Out] Abstract representation of an executable code location
    // (ex: EIP value). If resolved, an Instruction Address will be within a particular
    // module instance. An Instruction Address is always within a particular Runtime
    // Instance.
    // pFirstAddress   : [Out] True if this address is the first address in the line's
    // range. False otherwise.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveCPUInstructionAddress(
        _In_ UINT64 InstructionPointer,
        _Deref_out_ DkmInstructionAddress** ppAddressObject,
        _Out_ bool* pFirstAddress
        );

    // Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress
    // object.
    //
    // This API is currently only supported by CLR DkmRuntimeInstance objects, and the
    // CLR runtime instance can currently only find instruction addresses which are in a
    // method that is currently on the call stack of one of the threads in the target
    // process.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // Location constraint: This API should generally be called on the client, but it can
    // be called on the server for translating CLR addresses (but not native-compiled).
    // pWorkList       : WorkList to append the new work item to.
    // InstructionPointer: [In] Memory address where the native instruction is located.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveCPUInstructionAddress(
        _In_ DkmWorkList* pWorkList,
        _In_ UINT64 InstructionPointer,
        _In_ IDkmCompletionRoutine<DkmResolveCPUInstructionAddressAsyncResult>* pCompletionRoutine
        );

    // This method returns all modules that match the specified name.
    // pSearchKey      : [In] Name of the module to search for. This string may or may
    // not contain the file extension (ex: 'kernel32' or 'kernel32.dll').
    // pMatches        : [Out] Returns any modules that match the specified search key.
    // Only currently loaded dlls will be returned. Modules are returned in load-order.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindModulesByName(
        _In_ DkmString* pSearchKey,
        _Out_ DkmArray<DkmModuleInstance*>* pMatches
        );

    // Sets the value of the register in the thread's context. Sub registers that are
    // made up of larger registers are supported.
    // pStackWalkFrame : [In] The stack frame the register is being set in. For most
    // runtime instances, this is used to verify the stack frame is the top of the stack
    // and stop the write if it isn't.
    // RegisterIndex   : [In] The CV constant of the register to set.
    // pValue          : [In] The value to set the register to. The size of the byte
    // array must match the width of the register being set.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRegisterValue(
        _In_ CallStack::DkmStackWalkFrame* pStackWalkFrame,
        _In_ CV_HREG_e RegisterIndex,
        _In_ DkmReadOnlyCollection<BYTE>* pValue
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // BeforeEnableNewStepper is called by the stepping manager before a new stepper is
    // enabled. This gives runtimes the ability to do any initialization that might be
    // required such as performing pre-step function evaluations.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeforeEnableNewStepper(
        _In_ Stepping::DkmStepper* pStepper
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // OwnsCurrentExecutionLocation is called by the stepping manager while it is
    // searching for monitors to perform a step. If the current location in the debuggee
    // is understood by this monitor it can return true here to take control of the step.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
    // occurring.
    // pOwnsFrame      : [Out] If the runtime instance wants control of the step, it
    // should set this to true. It should be set to false to not take control.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OwnsCurrentExecutionLocation(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason::e Reason,
        _Out_ bool* pOwnsFrame
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Step is called by the stepping manager after it determines this monitor is the
    // correct monitor to perform the step.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
    // occurring.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Step(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason::e Reason
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // StopStep is called by the stepping manager when the process is being continued to
    // clear out any remaining stepping state for a stepper.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StopStep(
        _In_ Stepping::DkmStepper* pStepper
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // AfterSteppingArbitration is called by the stepping manager on the old controlling
    // runtime instance after stepping arbitration is complete but before the next
    // runtime instance starts stepping. This allows runtimes to clear any stepping state
    // if another runtime took control. If no other runtime monitor claimed the current
    // location, the original monitor should finish the step. This is indicated by
    // NewControllingRuntimeInstance being null. For instance, a runtime instance may
    // choose to step back out if a step-in landed in a location without symbols and no
    // other runtime took control.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
    // occurring.
    // pNewControllingRuntimeInstance: [In,Optional] The DkmRuntimeInstance class
    // represents an execution environment which is loaded into a DkmProcess and which
    // contains code to be debugged.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AfterSteppingArbitration(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason::e Reason,
        _In_opt_ DkmRuntimeInstance* pNewControllingRuntimeInstance
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // OnNewControllingRuntimeInstance is called by the stepping manager on all
    // non-controlling runtime instances after step arbitration has selected a new
    // controlling runtime instance.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
    // occurring.
    // pControllingRuntimeInstance: [In] The DkmRuntimeInstance class represents an
    // execution environment which is loaded into a DkmProcess and which contains code to
    // be debugged.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnNewControllingRuntimeInstance(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason::e Reason,
        _In_ DkmRuntimeInstance* pControllingRuntimeInstance
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // StepControlRequested is called by the stepping manager when a non-controlling
    // runtime instance detects that the thread has hit a transition into its runtime. If
    // the current controlling runtime instance can stop stepping, it should set Granted
    // to true. Actual control is not given until the requesting runtime calls
    // DkmStepper.TakeStepControl. This two part process allows callers to request
    // control of multiple steppers at the same time.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
    // occurring.
    // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
    // control of the step.
    // pGranted        : [Out] The controlling runtime can stop the step and give control
    // to the caller, then it should set this to true.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StepControlRequested(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason::e Reason,
        _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
        _Out_ bool* pGranted
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // TakeStepControl is called by the stepping manager when a non-controlling runtime
    // instance detects that the thread has hit a transition into its runtime. The
    // stepping manager will forward the call to the current controlling runtime
    // instance. The runtime instance requesting control should first call
    // StepControlRequested on all steppers it wants control of. If they all set Granted
    // to true, the runtime instance should then call this method on each stepper it is
    // taking control of.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // LeaveGuardsInPlace: [In] Set to true by the caller if it would like the current
    // controlling runtime instance to leave guards in place to stop the step if
    // necessary. For instance, this can be used to leave guard breakpoints after a call
    // instruction so another runtime can step back out if the target of the call doesn't
    // have source. However, any stepping state that affects the immediate step, such as
    // trap flags, should be removed by the controlling runtime instance.
    // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
    // occurring.
    // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
    // control of the step.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TakeStepControl(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ bool LeaveGuardsInPlace,
        _In_ Stepping::DkmStepArbitrationReason::e Reason,
        _In_ DkmRuntimeInstance* pCallingRuntimeInstance
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // NotifyStepComplete is called by the stepping manager on all non-controlling
    // runtime instances when a step is complete.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pStepper        : [In] DkmStepper represents a request to step a thread. It
    // facilitates shared object lifetime between the various runtime debug monitors that
    // participate in stepping.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NotifyStepComplete(
        _In_ Stepping::DkmStepper* pStepper
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Gets the Display Properties of the Thread including the Display Name and Thread
    // Category.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // pWorkList       : WorkList to append the new work item to.
    // pThread         : [In] The Thread.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadDisplayProperties(
        _In_ DkmWorkList* pWorkList,
        _In_ DkmThread* pThread,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>* pCompletionRoutine
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Compute the name of a thread.
    // pThread         : [In] The Thread.
    // ppName          : [Out,Optional] The Thread Name.
    // Return value    : S_OK is returned if *ppName is non-NULL, S_FALSE is returned
    // when *ppName is NULL, and failure codes are used for any error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadName(
        _In_ DkmThread* pThread,
        _Deref_out_opt_ DkmString** ppName
        );

    // Compute the name of a thread.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    // pWorkList       : WorkList to append the new work item to.
    // pThread         : [In] The Thread.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadName(
        _In_ DkmWorkList* pWorkList,
        _In_ DkmThread* pThread,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetThreadNameAsyncResult>* pCompletionRoutine
        );

    // RuntimeInstanceUnload is sent by the dispatcher when DkmRuntimeInstance::Unload is
    // invoked by the monitor.
    //
    // This method may only be called by the component which created the object.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        );

    // GetManagedHeapSamplers enumerates the DkmManagedHeapSampler elements of this
    // DkmRuntimeInstance object.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pManagedHeapSamplers: [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedHeapSamplers(
        _Out_ DkmArray<Clr::DkmManagedHeapSampler*>* pManagedHeapSamplers
        );

    // GetManagedHeapWalkers enumerates the DkmManagedHeapWalker elements of this
    // DkmRuntimeInstance object.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pManagedHeapWalkers: [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedHeapWalkers(
        _Out_ DkmArray<Clr::DkmManagedHeapWalker*>* pManagedHeapWalkers
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // GetCodePathsInRange is called to get code paths in specific IL range.
    //
    // Location constraint: It should only be called on server side.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pCorFrame       : [In] The ICorDebugFrame to query for code paths.
    // StartILOffset   : [In] Specifies the query start IL offset, inclusively.
    // EndILOffset     : [In] Specifies the query end IL offset, inclusively.
    // pCodePaths      : [Out] DkmSteppingCodePath[] represents a location that user can
    // step to from current location.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCodePathsInRange(
        _In_ ICorDebugFrame* pCorFrame,
        _In_ UINT32 StartILOffset,
        _In_ UINT32 EndILOffset,
        _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Disassemble an address range in the debuggee runtime.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pAddress        : [In] The address where disassembly should start.
    // Count           : [In] The number of instructions to disassemble.
    // pDisassembledInstructions: [Out] The results of disassembling the address range.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disassemble(
        _In_ DkmInstructionAddress* pAddress,
        _In_ UINT32 Count,
        _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Returns the address of the kth instruction relative to a starting address. For
    // constant length instruction sets, this is simple arithmetic. For variable length
    // instruction sets, reverse-disassembly is required to obtain this address.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pStartAddress   : [In] The address of the current instruction where the offset
    // should begin.
    // InstructionOffset: [In] The number of instructions relative to StartAddress to
    // find the desired address. This value can be negative.
    // ppAddress       : [Out] The address of the instruction InstructionOffset
    // instructions from StartAddress.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionAddress(
        _In_ DkmInstructionAddress* pStartAddress,
        _In_ INT32 InstructionOffset,
        _Deref_out_ DkmInstructionAddress** ppAddress
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
}; // end of DkmRuntimeInstance

// Result of an asynchronous DkmCustomMessage.SendLower call.
struct DkmSendLowerAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // [Optional] Message sent back from the implementation.
    OPTIONAL DkmCustomMessage* pReplyMessage;
};

// Identifies the source of an object. SourceIds are used to enable filtering in
// scenarios when multiple components may be creating instances of a class. For example,
// source ids can be used to determine if a breakpoint comes from the AD7 AL (ex: user
// breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint
// which may be created by another component (for example an internal breakpoint used for
// stepping).
struct DkmSourceId
{
    // Object was created in response to a breakpoint request from the IDE.
    // AD7BreakpointId is defined as {f7a1b1d1-d4ee-4e0e-9bac-bdaa38c83fe3}.
    static const GUID AD7BreakpointId;
    // Object was created for a source-level breakpoint by the Microsoft breakpoint
    // manager.
    // MSBreakpointManagerId is defined as {86d0cdce-288c-46df-b9b2-e888a699c4b2}.
    static const GUID MSBreakpointManagerId;
    // Filtered events sent to the Native DM filter on this Source ID.
    // NativeBaseDmRequest is defined as {c9516daf-4af3-4e0d-8f37-8f97463f2dc1}.
    static const GUID NativeBaseDmRequest;
    // DkmExceptionTrigger was created in response to exception settings from the IDE.
    // AD7ExceptionSetting is defined as {aa9327a2-5b63-42d2-aa69-9b62bbfef726}.
    static const GUID AD7ExceptionSetting;
    // DkmExceptionTrigger was created in response to the 'Break when exceptions cross
    // AppDomain or managed/native boundaries (Managed only)' debugger option.
    // AD7ExceptionBoundary is defined as {58ee2076-d444-44c6-9d2a-4a92870ecc6b}.
    static const GUID AD7ExceptionBoundary;
    // DkmStepper created in response to a step request from the IDE.
    // AD7Stepper is defined as {d7647ea0-e55c-4413-aade-bc7b6a8c3db3}.
    static const GUID AD7Stepper;
    // SymbolsUpdate event generated by Managed DM.
    // ManagedDmSymbolsUpdateId is defined as {e24ae1c1-6f67-49ac-8c27-1403c9d4979c}.
    static const GUID ManagedDmSymbolsUpdateId;
    // DkmStepper created by Managed DM.
    // ManagedDmStepper is defined as {931d08be-5b80-41c2-be46-ffe84502c2e8}.
    static const GUID ManagedDmStepper;
    // Filtered events sent to the GPU Debug Monitor filter on this Source ID.
    // GpuDebugMonitorRequest is defined as {c1ddbd10-6bfc-4adb-9ce8-2f0324b1d657}.
    static const GUID GpuDebugMonitorRequest;
    // Object was created at the AD7 layer to execute a command.
    // AD7DeploymentId is defined as {b0e66140-065d-4ef2-a899-497540228bdd}.
    static const GUID AD7DeploymentId;
    // Object was created at the AD7 layer to execute a command.
    // BaseDMServicesId is defined as {c293512f-1105-4ea7-885e-93aad05137b8}.
    static const GUID BaseDMServicesId;
    // DkmStepper created by the Stepping Manager.
    // SteppingManagerStepper is defined as {911ce3c5-0620-42bc-b814-4135728cf174}.
    static const GUID SteppingManagerStepper;
    // Object created for local CPP EE.
    // ClientCppEE is defined as {67b95d8d-0c6b-46ff-b3d2-fa011f3b610b}.
    static const GUID ClientCppEE;
    // Object created for server CPP EE.
    // ServerCppEE is defined as {61785163-5f87-4c6d-8322-04f6ce664d31}.
    static const GUID ServerCppEE;
};
__declspec(selectany) const GUID DkmSourceId::AD7BreakpointId = { 0xf7a1b1d1, 0xd4ee, 0x4e0e, { 0x9b, 0xac, 0xbd, 0xaa, 0x38, 0xc8, 0x3f, 0xe3 } };
__declspec(selectany) const GUID DkmSourceId::MSBreakpointManagerId = { 0x86d0cdce, 0x288c, 0x46df, { 0xb9, 0xb2, 0xe8, 0x88, 0xa6, 0x99, 0xc4, 0xb2 } };
__declspec(selectany) const GUID DkmSourceId::NativeBaseDmRequest = { 0xc9516daf, 0x4af3, 0x4e0d, { 0x8f, 0x37, 0x8f, 0x97, 0x46, 0x3f, 0x2d, 0xc1 } };
__declspec(selectany) const GUID DkmSourceId::AD7ExceptionSetting = { 0xaa9327a2, 0x5b63, 0x42d2, { 0xaa, 0x69, 0x9b, 0x62, 0xbb, 0xfe, 0xf7, 0x26 } };
__declspec(selectany) const GUID DkmSourceId::AD7ExceptionBoundary = { 0x58ee2076, 0xd444, 0x44c6, { 0x9d, 0x2a, 0x4a, 0x92, 0x87, 0xe, 0xcc, 0x6b } };
__declspec(selectany) const GUID DkmSourceId::AD7Stepper = { 0xd7647ea0, 0xe55c, 0x4413, { 0xaa, 0xde, 0xbc, 0x7b, 0x6a, 0x8c, 0x3d, 0xb3 } };
__declspec(selectany) const GUID DkmSourceId::ManagedDmSymbolsUpdateId = { 0xe24ae1c1, 0x6f67, 0x49ac, { 0x8c, 0x27, 0x14, 0x3, 0xc9, 0xd4, 0x97, 0x9c } };
__declspec(selectany) const GUID DkmSourceId::ManagedDmStepper = { 0x931d08be, 0x5b80, 0x41c2, { 0xbe, 0x46, 0xff, 0xe8, 0x45, 0x2, 0xc2, 0xe8 } };
__declspec(selectany) const GUID DkmSourceId::GpuDebugMonitorRequest = { 0xc1ddbd10, 0x6bfc, 0x4adb, { 0x9c, 0xe8, 0x2f, 0x3, 0x24, 0xb1, 0xd6, 0x57 } };
__declspec(selectany) const GUID DkmSourceId::AD7DeploymentId = { 0xb0e66140, 0x65d, 0x4ef2, { 0xa8, 0x99, 0x49, 0x75, 0x40, 0x22, 0x8b, 0xdd } };
__declspec(selectany) const GUID DkmSourceId::BaseDMServicesId = { 0xc293512f, 0x1105, 0x4ea7, { 0x88, 0x5e, 0x93, 0xaa, 0xd0, 0x51, 0x37, 0xb8 } };
__declspec(selectany) const GUID DkmSourceId::SteppingManagerStepper = { 0x911ce3c5, 0x620, 0x42bc, { 0xb8, 0x14, 0x41, 0x35, 0x72, 0x8c, 0xf1, 0x74 } };
__declspec(selectany) const GUID DkmSourceId::ClientCppEE = { 0x67b95d8d, 0xc6b, 0x46ff, { 0xb3, 0xd2, 0xfa, 0x1, 0x1f, 0x3b, 0x61, 0xb } };
__declspec(selectany) const GUID DkmSourceId::ServerCppEE = { 0x61785163, 0x5f87, 0x4c6d, { 0x83, 0x22, 0x4, 0xf6, 0xce, 0x66, 0x4d, 0x31 } };

// Status code returned to the base debug monitor to indicate the next action to take in
// stopping event processing.
enum DkmStoppingEventProcessingNextAction::e
{
    // The base debug monitor should resume execution of the target processes normally.
    // If an exception event was raised, standard exception processing (ex: handler
    // search, stack unwinding) should continue in the target process unless
    // DkmExceptionInformation.SquashProcessing() was successfully called.
    //
    // This status value is returned when the base debug monitor didn't issue any
    // stopping events, or when all stopping events were suppressed.
    ResumeTarget = 0,
    // The base debug monitor should resume execution of non-suspended threads in the
    // target process. Standard exception processing on suspended thread should be held
    // up so that the decision as to if it should be allowed to continue normally or be
    // squashed may be made at a later time.
    //
    // This status value is used when one or more threads are not at a safe point, so the
    // target process must be slipped. The target process is expected to hit one or more
    // stopping events (breakpoint or exception) in order to indicate that a safe point
    // has been reached. The base debug monitor may also choose to eventually time out
    // and proceed without reaching a safe point. The timeout value is specified in
    // DkmEngineSettings.SlipTimeout.
    SlipTarget = 1,
    // The base debug monitor should resume execution of non-suspended threads in the
    // target process. Standard exception processing on suspended thread should be held
    // up so that the decision as to if it should be allowed to continue normally or be
    // squashed may be made at a later time. After resuming execution, the base debug
    // monitor should immediately call StoppingEventProcessingContinue again.
    //
    // This status value is used when all threads are in the target process are at a safe
    // point, but one or more threads in the target process should run free while in
    // break mode. This is used when managed-only debugging certain host applications.
    ResumeUnclaimedThreads = 2,
    // Stopping event processing has completed and a stopping event has been sent to the
    // IDE. Execution of the target process should stay halted until the IDE resumes
    // execution.
    EnterStoppedState = 3,
    // This value is returned if StoppingEventProcessingBegin was called with
    // ForceQueueMode set to true.
    ForceQueueModeComplete = 4
};

// DkmThread represents a thread running in the target process.
//
// Derived classes: DkmGPUComputeThread
class DECLSPEC_NOVTABLE DECLSPEC_UUID("ac420a23-b721-57c1-375d-a5053f90f94c") DkmThread : public DkmDataContainer
{
    // Use DkmThread::Create to create this object
    private: DkmThread();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmThread();
    // This object cannot be copied
    private: DkmThread& operator=(const DkmThread&);
    private: DkmThread(const DkmThread&);

    // Describes traits of the thread which are relevant to a full Win32 thread.
    // Currently, this value is required, and all threads will have a 'System' block. In
    // the future, this value may be NULL if the DkmThread represents something other
    // than a full Win32 thread.
    public: struct System
    {
        // Thread Id (TID) assigned by the operating system. While running, this uniquely
        // identifies the thread within a particular DkmProcess.
        UINT32 Id;
    };

    private: OPTIONAL const DkmThread::System* const m_pSystem;
    private: const GUID m_UniqueId;
    private: DkmProcess* const m_pProcess;
    private: const UINT64 m_NativeStartAddress;
    private: const UINT64 m_TebAddress;
    private: const bool m_IsMainThread;
    private: void* m__pExtendedData;
    private: void* m_pMonitorStackWalkContextCollection0;
    private: void* m_pStackWalkContextCollection0;
    private: void* m_pStepperCollection0;

    // [Optional] Describes traits of the thread which are relevant to a full Win32
    // thread. Currently, this value is required, and all threads will have a 'System'
    // block. In the future, this value may be NULL if the DkmThread represents something
    // other than a full Win32 thread.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmThread::System* STDMETHODCALLTYPE SystemPart(
        );

    // Guid which uniquely identifies this thread object.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // If available, this is the Win32 start address of this thread (value passed to the
    // CreateThread API). The value will not always be available, for example, it is
    // generally not available in scenarios where the thread was started after the
    // debugger attached, or in minidumps.
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE NativeStartAddress(
        );

    // Address within the target process, where the Win32 thread environment block is
    // stored. See documentation on the TEB structure in MSDN for more information.
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TebAddress(
        );

    // True if this is the main thread of this process. The main thread is the first
    // thread to start.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsMainThread(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // Contains information about the computer system that this thread is running under.
    // If this thread is running under WOW (32-bit emulation on a 64-bit OS) this
    // information will be for the 32-bit subsystem rather than the 64-bit subsystem.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE SystemInformation(
        );

    // DkmThread is called by a debug monitor to create a new DkmThread instance.
    // DkmThread objects for system threads are created by the base debug monitor. This
    // method must be called on the event thread.
    //
    // This method will send a ThreadCreate event.
    // pProcess        : [In] DkmProcess represents a target process which is being
    // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
    // DkmProcess can represent a system process or a virtual process such as minidumps.
    // NativeStartAddress: [In] If available, this is the Win32 start address of this
    // thread (value passed to the CreateThread API). The value will not always be
    // available, for example, it is generally not available in scenarios where the
    // thread was started after the debugger attached, or in minidumps.
    // TebAddress      : [In] Address within the target process, where the Win32 thread
    // environment block is stored. See documentation on the TEB structure in MSDN for
    // more information.
    // IsMainThread    : [In] True if this is the main thread of this process. The main
    // thread is the first thread to start.
    // pSystem         : [In,Optional] Describes traits of the thread which are relevant
    // to a full Win32 thread. Currently, this value is required, and all threads will
    // have a 'System' block. In the future, this value may be NULL if the DkmThread
    // represents something other than a full Win32 thread.
    // DataItem        : [In] Data object to add to the new DkmThread instance.
    // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmProcess* pProcess,
        _In_ UINT64 NativeStartAddress,
        _In_ UINT64 TebAddress,
        _In_ bool IsMainThread,
        _In_opt_ const DkmThread::System* pSystem,
        _In_ const DkmDataItem& DataItem,
        _Deref_out_ DkmThread** ppCreatedObject
        );

    // GetSteppers enumerates the DkmStepper elements of this DkmThread object.
    // pSteppers       : [Out] Array containing the enumerated elements.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppers(
        _Out_ DkmArray<Stepping::DkmStepper*>* pSteppers
        );

    // Raise a EmbeddedBreakpointHit event. Components which implement the event sync
    // interface will receive the event notification. This method will enqueue the event
    // and control will immediately return to the caller.
    // pInstructionAddress: [In,Optional] The address where the embedded breakpoint was
    // hit.
    // ShowAsException : [In] If true, the UI will display an exception hit dialog for a
    // breakpoint exception. If false, UI will simply break and the DkmInstructionAddress
    // is not used.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnEmbeddedBreakpointHit(
        _In_opt_ DkmInstructionAddress* pInstructionAddress,
        _In_ bool ShowAsException
        );

    // This method is used to resume the target process so that a function evaluation may
    // occur. This function is called by a runtime debug monitor after it has setup a
    // function evaluation in order to make the target process run. The runtime monitor
    // will first update the thread context, update any necessary memory in the target
    // process, and setup any detection that the function evaluation is completed.
    //
    // Callers of this method MUST always call EndFuncEvalExecution before returning from
    // the operation that triggered the function evaluation. The behavior is undefined if
    // a caller fails to do so.
    //
    // This method is implemented in the base debug monitor by first updating the target
    // process to be in function evaluation mode (DkmThread.OnBeginFuncEvalExecution),
    // then suspending and/or resuming threads as specified by the function evaluation
    // flags and finally continuing the target process.
    //
    // This method may be called from any thread, however OnBeginFuncEvalExecution must
    // be called from the stopping event thread, so the base debug monitor may need to
    // perform as thread switch as part of the implementation of this method. The base
    // debug monitor should not return from BeginFuncEvalExecution until after the target
    // has been resumed.
    // Flags           : [In] Flags impacting how function evaluation requests are
    // performed.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeginFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags::e Flags
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // API which may be called from a IDkmSingleStepCompleteReceived or
    // IDkmRuntimeBreakpointReceived implementation to force the base DM to fire the
    // EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP exception in the target process when
    // execution is resumed. Normally, the breakpoint or single step exception is
    // implicitly suppressed. This allows the EXCEPTION_BREAKPOINT/EXCEPTION_SINGLE_STEP
    // to be handled by exception handlers within the target process. This API will fail
    // if the thread is not currently sitting at a step complete or breakpoint event.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // ExceptionCode   : [In] Win32 exception code to raise. Currently, this must be
    // EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RaiseExecutionControlException(
        _In_ UINT32 ExceptionCode
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Gets the extended registers from the thread context.
    // pExtendedRegisters: [Out] An array of extended registers.
    // The memory for the DkmArray members is allocated by the method implementation
    // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    // CAutoDkmArray template or with DkmFreeMemory and manual element release.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetExtendedRegisters(
        _Out_ DkmArray<CallStack::DkmUnwoundRegister*>* pExtendedRegisters
        );

    // Sets the value of the extended register in the thread's context.
    // RegisterIndex   : [In] The CV constant of the register to set. For AVX, this can
    // be any of the YMM register enumeration codes. The caller is expected to set the
    // full YMM register (including the portions which are aliased on XMM registers).
    // pValue          : [In] The value to set the register to. The size of the byte
    // array must match the width of the register being set.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetExtendedRegisterValue(
        _In_ CV_HREG_e RegisterIndex,
        _In_ DkmReadOnlyCollection<BYTE>* pValue
        );

    // Convert an array of DkmUnwoundRegisters into an instance of DkmFrameRegisters
    // containing a sorted DkmReadOnlyCollection of DkmUnwoundRegisters.
    // UnwoundRegisters: [In] The unwound register collection to use as the source of the
    // collection.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // VFrame          : [In] The vframe for this register set. This is only used on x86.
    // ppCreatedObject : [Out] DkmFrameRegisters represents the registers of a stack
    // frame.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateFrameRegisters(
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& UnwoundRegisters,
        _In_ UINT32 VFrame,
        _Deref_out_ CallStack::DkmFrameRegisters** ppCreatedObject
        );

    // Get a managed thread's properties.
    // pManagedThreadId: [Out] The managed thread id of the thread.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedThreadProperties(
        _Out_ INT32* pManagedThreadId
        );

    // Get a managed thread's properties.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedThreadProperties(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetManagedThreadPropertiesAsyncResult>* pCompletionRoutine
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Return the top stack frame for a thread. This frame can come from a runtime
    // instance, or a monitor unwinder. This can only be called from the server process.
    // To obtain the top frame in the client process, use GetTopStackFrame.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pRuntimeInstance: [In] The runtime instance of the frame.
    // ppFrame         : [Out] The top stack frame.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTopStackWalkFrame(
        _In_ DkmRuntimeInstance* pRuntimeInstance,
        _Deref_out_ CallStack::DkmStackWalkFrame** ppFrame
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // GetCurrentFrameInfo is used to obtain the frame base and return address for the
    // current context of the thread. This takes into account Frame Pointer Omission and
    // if the current instruction pointer is in a prolog, epilog etc... NOTE: In some
    // cases this will get it wrong if the frame has Frame Pointer Omission and there are
    // no symbols loaded.
    //
    // Location constraint: API must be called from a Monitor component (component level
    // < 100,000).
    // pReturnAddress  : [Out] The return address of the frame.
    // pFrameBase      : [Out] The frame base of the frame.
    // pVFrame         : [Out] The vframe of the current frame. Only valid on x86.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentFrameInfo(
        _Out_ UINT64* pReturnAddress,
        _Out_ UINT64* pFrameBase,
        _Out_ UINT64* pVFrame
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Returns the top call stack frame for a thread. This value is normally cached after
    // the first stack walk and cleared on continue. This is only callable above the
    // stack provider in the client process. To obtain the top frame in the server
    // process, call GetTopStackWalkFrame.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // ppTopFrame      : [Out] DkmStackWalkFrame represents a frame on a call stack which
    // has been walked, but may not have been formatted or filtered. Formatted frames are
    // represented by DkmStackFrame instead.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTopStackFrame(
        _Deref_out_ CallStack::DkmStackWalkFrame** ppTopFrame
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Returns a DkmFrameRegisters object containing the thread's current register
    // values.
    // PseudoRegisters : [In] An array of cvconst/value pairs to add to the collection of
    // register values coming from the context. This is generally used to add the vframe
    // pseudo-register on x86.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // ppCreatedObject : [Out] DkmFrameRegisters represents the registers of a stack
    // frame.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentRegisters(
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& PseudoRegisters,
        _Deref_out_ CallStack::DkmFrameRegisters** ppCreatedObject
        );

    // Creates a DkmFrameRegisters object from the supplied byte array containing a Win32
    // CONTEXT structure.
    // ThreadContext   : [In] Win32 CONTEXT to obtain the registers for.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // PseudoRegisters : [In] An array of cvconst/value pairs to add to the collection of
    // register values coming from the context. This is generally used to add the vframe
    // pseudo-register on x86.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // ExtendedRegisters: [In] An array of extended registers.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // ppCreatedObject : [Out] DkmFrameRegisters represents the registers of a stack
    // frame.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateRegistersObject(
        _In_ const DkmArray<BYTE>& ThreadContext,
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& PseudoRegisters,
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& ExtendedRegisters,
        _Deref_out_ CallStack::DkmFrameRegisters** ppCreatedObject
        );

    // OnContinueExecution is called by the base debug monitor on the event thread. This
    // method is called as part of the implementation of
    // IDkmContinueExecution.ContinueExecution, which is what is used by the IDE to
    // continue the target process. This method is used by the Dispatcher to either
    // dispatch stopping events which could not be processed earlier, or to update the
    // internal state of the DkmProcess object to indicate that the target process is now
    // running. Before marking the process as running, the Dispatcher will send a
    // Continue event.
    //
    // A base debug monitor should expect to be reentrantly called while it is in this
    // method.
    // pContinueTargetProcess: [Out] True if the base debug monitor should resume
    // execution of the target process.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContinueExecution(
        _Out_ bool* pContinueTargetProcess
        );

    // OnBeginFuncEvalExecution is called by the base debug monitor on the event thread.
    // This method is called as part of the implementation of
    // IDkmBaseFuncEvalService.BeginFuncEvalExecution, which is called to resume the
    // process for a function evaluation. OnBeginFuncEvalExecution will update the
    // internal state of the DkmProcess object to indicate that a function evaluation is
    // in progress. This will also send a FuncEvalStarting event and it will mark the
    // process as running, so that no operations which require a stopped process will be
    // allowed.
    // Flags           : [In] Flags impacting how function evaluation requests are
    // performed.
    // pContinueTargetProcess: [Out] True if the base debug monitor should resume
    // execution of the target process. This will be true unless both
    // DkmFuncEvalFlags.AllowStoppingEvents and DkmFuncEvalFlags.RunAllThreads are set
    // -and- there are events waiting to be processed.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBeginFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags::e Flags,
        _Out_ bool* pContinueTargetProcess
        );

    // EndFuncEvalExecution is called by the runtime debug monitor on the event thread to
    // exit function evaluation mode. EndFuncEvalExecution will update the internal state
    // of the DkmProcess object to indicate that the function evaluation has ended. This
    // will also send a FuncEvalEnded event and it will mark the process as stopped.
    //
    // This method may be called (1) while processing a 'received' stopping event
    // notification -or- (2) while processing a non-stopping event such as thread exit,
    // -or- (3) while the target is still stopped, for example if the function evaluation
    // setup failed.
    // Flags           : [In] Flags impacting how function evaluation requests are
    // performed.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EndFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags::e Flags
        );

    // Indicates if the given thread has a stopping event in the queue. This information
    // is used by the execution manager to decide if a thread may be slipped.
    // IgnoreAsyncBreakEvents: [In] If true, the dispatcher will ignore async break
    // events when searching for stopping events.
    // pResult         : [Out] True if the thread has a queued stopping event.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsStoppingEventQueued(
        _In_ bool IgnoreAsyncBreakEvents,
        _Out_ bool* pResult
        );

    // GetCurrentFuncEvalMode may be called by components as part of event processing to
    // determine if function evaluation is enabled. This function may only be called as
    // part of event processing.
    // pCurrentMode    : [Out] Indicates if there is a function evaluation occurring in
    // the target process and if stopping events are allowed for this evaluation.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentFuncEvalMode(
        _Out_ DkmFuncEvalMode::e* pCurrentMode
        );

    // Update the context (register values) of a thread.
    // Context         : [In] A CONTEXT structure that contains the context to be set in
    // the specified thread. The value of the ContextFlags member of this structure
    // specifies which portions of a thread's context to set. Some values in the CONTEXT
    // structure that cannot be specified are silently set to the correct value. This
    // includes bits in the CPU status register that specify the privileged processor
    // mode, global enabling bits in the debugging register, and other states that must
    // be controlled by the operating system.
    // The memory for the DkmArray members is allocated by the caller, and can be from
    // any source (stack memory, static buffer, heap, etc). The implementation should not
    // modify the members.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetContext(
        _In_ const DkmArray<BYTE>& Context
        );

    // Obtain the current context (register values) of a thread.
    // ContextFlags    : [In] Win32 flags indicating which portion of the CONTEXT object
    // to obtain (ex: CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).
    // pContext        : [In,Out] A Win32 CONTEXT structure that contains the context of
    // the specified thread. The value of the ContextFlags member of this structure
    // specifies which portions of a thread's context to obtained.
    // ContextSize     : [In] Size of the context structure to read in bytes. This must
    // exactly match the size required to read the context.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetContext(
        _In_ UINT32 ContextFlags,
        _Out_capcount_(ContextSize) void* pContext,
        _In_ UINT32 ContextSize
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Provides the location of a thread, as visible in the threads window, or threads
    // drop down in the debug location toolbar.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // Location constraint: API must be called from an IDE component (component level >
    // 100,000).
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentLocation(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<CallStack::DkmGetCurrentLocationAsyncResult>* pCompletionRoutine
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Retrieves the stack limit/stack base of the given thread. Note that its possible
    // for this value to change over time, for example, in the case of fibers.
    // pMemoryRange    : [Out] The limit/base address for the memory containing a
    // thread's stack.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error. E_INVALID_MEMORY_ADDRESS indicates that the address containing the TEB
    // structure could not be read from the target process. This may be returned for
    // minidumps without heap.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStackAddressRange(
        _Out_ CallStack::DkmStackMemoryRange* pMemoryRange
        );

    // Suspend this thread.
    // InternalSuspension: [In] Pass true if this suspension should be hidden in calls to
    // GetSuspensionCount. This is useful for internal suspensions that should not be
    // reported to the user such as thread slippage suspensions.
    // pExternalSuspensionCount: [Out,Optional] The previous number of suspensions for
    // this thread minus the ones internal to the debugger.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Suspend(
        _In_ bool InternalSuspension,
        _Out_ UINT32* pExternalSuspensionCount
        );

    // Resume this thread.
    // InternalSuspension: [In] Pass true if this suspension should be hidden in calls to
    // GetSuspensionCount. This is useful for internal suspensions that should not be
    // reported to the user such as thread slippage suspensions.
    // pExternalSuspensionCount: [Out,Optional] The previous number of suspensions for
    // this thread minus the ones internal to the debugger before this resume is applied.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Resume(
        _In_ bool InternalSuspension,
        _Out_ UINT32* pExternalSuspensionCount
        );

    // Return the current suspension count of this thread.
    // ShowInternal    : [In] Pass true to return the true suspension count for the
    // thread. Return false to only see the suspensions that occurred in the debuggee
    // process or the one's that passed true for InternalSuspension to Suspend.
    // pSuspensionCount: [Out] The suspension count of thread. The internal thread
    // suspension count is subtracted from this value if ShowInternal is false.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSuspensionCount(
        _In_ bool ShowInternal,
        _Out_ UINT32* pSuspensionCount
        );

    // Return the total number of suspensions caused by the debugger (i.e. calls to
    // DkmThread::Suspend without a call to DkmThread::Resume). This excludes any
    // suspensions external to the debugger.
    // pSuspensionCount: [Out] The total number of suspensions caused by the debugger
    // (i.e. calls to DkmThread::Suspend without a call to DkmThread::Resume). This
    // excludes any suspensions external to the debugger.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDebuggerSuspensionCount(
        _Out_ UINT32* pSuspensionCount
        );

    // Retrieves the value in the debuggee thread's thread local storage (TLS) slot for
    // the specified TLS index. Each thread of a process has its own slot for each TLS
    // index.
    // TlsIndex        : [In] The TLS index that was allocated when the target process
    // called the TlsAlloc function.
    // pValue          : [Out] The pointer-sized value which was stored in the thread's
    // TLS slot. If the target thread is 32-bit, the upper 32-bits of this value will be
    // zero.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTlsValue(
        _In_ UINT32 TlsIndex,
        _Out_ UINT64* pValue
        );

    // Stores a value in the debuggee thread's thread local storage (TLS) slot for the
    // specified TLS index. Each thread of a process has its own slot for each TLS index.
    // TlsIndex        : [In] The TLS index that was allocated when the target process
    // called the TlsAlloc function.
    // Value           : [In] The pointer-sized value to store in the thread's TLS slot.
    // If the target thread is 32-bit, the upper 32-bits of this value will be ignored.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetTlsValue(
        _In_ UINT32 TlsIndex,
        _In_ UINT64 Value
        );

    // Get a thread's dynamic properties.
    // pPriority       : [Out] The priority of the thread. The values returned correspond
    // directly to the values defined for kernel32!GetThreadPriority.
    // pAffinityMask   : [Out] The affinity mask of the thread. The values returned
    // correspond directly to the values defined for kernel32!SetThreadAffinityMask.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileProperties(
        _Out_ INT32* pPriority,
        _Out_ UINT64* pAffinityMask
        );

    // Get a thread's dynamic properties.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileProperties(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetVolatilePropertiesAsyncResult>* pCompletionRoutine
        );

    // Get volatile flags about a thread. For instance, return if a thread is a user-mode
    // scheduled thread.
    // pFlags          : [Out] Volatile flags that apply to a thread. These values are
    // expected to change over time and should not be cached by callers.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileFlags(
        _Out_ ThreadProperties::DkmVolatileThreadFlags::e* pFlags
        );

    // Get volatile flags about a thread. For instance, return if a thread is a user-mode
    // scheduled thread.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileFlags(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetVolatileFlagsAsyncResult>* pCompletionRoutine
        );

    // Raise a InterceptExceptionCompleted event. Components which implement the event
    // sync interface will receive the event notification. This method will enqueue the
    // event and control will immediately return to the caller.
    // Cookie          : [In] Cookie that was handed out when intercept exception request
    // came in.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnInterceptExceptionCompleted(
        _In_ UINT64 Cookie
        );

    // ThreadExit is sent by the dispatcher when DkmThread::Unload is invoked by the
    // monitor.
    //
    // This method may only be called by the component which created the object.
    // ExitCode        : [In] 32-bit value that the process returned on exit. This is the
    // same value that would be reported from the kernel32!GetExitCodeThread.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        _In_ UINT32 ExitCode
        );

    // GetThreadCurrentWinRtErrorInfo is used to get the address of the current
    // IErrorInfo object for this thread.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pWinRTErrorInfo : [Out,Optional] Address of the current IErrorInfo object on this
    // thread.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadCurrentWinRtErrorInfo(
        _Out_ UINT64* pWinRTErrorInfo
        );
}; // end of DkmThread

// Contains information about a message that is to be displayed to the user.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("1a166c7c-4ae6-0992-82e2-c75555ed8055") DkmUserMessage : public IUnknown
{
    private: DWORD m_ReferenceCount;
    private: DkmDispatcherObjectFlags::e m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmUserMessage::Create to create this object
    private: DkmUserMessage();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmUserMessage();
    // This object cannot be copied
    private: DkmUserMessage& operator=(const DkmUserMessage&);
    private: DkmUserMessage(const DkmUserMessage&);

    private: DefaultPort::DkmTransportConnection* const m_pConnection;
    private: OPTIONAL DkmProcess* const m_pProcess;
    private: const DkmUserMessageOutputKind::e m_OutputKind;
    private: DkmString* const m_pMessageText;
    private: const UINT32 m_MessageBoxFlags;
    private: const HRESULT m_ErrorCode;
    private: void* m__pExtendedData;

    // Connection used to send the message to the debugger. This will value is usually
    // obtained from DkmProcess.Connection unless the message needs to be sent before the
    // DkmProcess is created.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // [Optional] Process that this message is in reference to.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Indicates where a DkmUserMessage should be output within the debugger IDE.
    public: DECLSPEC_NOTHROW DkmUserMessageOutputKind::e STDMETHODCALLTYPE OutputKind(
        );

    // Text to display inside the message box or inside the output window. If an error
    // code is provided, '%1' will be replaced with the text for the error message. For
    // example: 'Unable to stand on my head. %1'.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE MessageText(
        );

    // Win32 message box flags from winuser.h (ex: MB_OK). These flags are ignored if
    // OutputKind is not set to 'MessageBox'.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MessageBoxFlags(
        );

    // Error code to display a message for. This value should be S_OK (0) if the message
    // is not for an error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ErrorCode(
        );

    // Create a new DkmUserMessage object instance.
    // pConnection     : [In] Connection used to send the message to the debugger. This
    // will value is usually obtained from DkmProcess.Connection unless the message needs
    // to be sent before the DkmProcess is created.
    // pProcess        : [In,Optional] Process that this message is in reference to.
    // OutputKind      : [In] Indicates where a DkmUserMessage should be output within
    // the debugger IDE.
    // pMessageText    : [In] Text to display inside the message box or inside the output
    // window. If an error code is provided, '%1' will be replaced with the text for the
    // error message. For example: 'Unable to stand on my head. %1'.
    // MessageBoxFlags : [In] Win32 message box flags from winuser.h (ex: MB_OK). These
    // flags are ignored if OutputKind is not set to 'MessageBox'.
    // ErrorCode       : [In] Error code to display a message for. This value should be
    // S_OK (0) if the message is not for an error.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_opt_ DkmProcess* pProcess,
        _In_ DkmUserMessageOutputKind::e OutputKind,
        _In_ DkmString* pMessageText,
        _In_ UINT32 MessageBoxFlags,
        _In_ HRESULT ErrorCode,
        _Deref_out_ DkmUserMessage** ppCreatedObject
        );

    // Displays a message to the user inside the Visual Studio debugger IDE. This
    // function does not block waiting for the user to dismiss the error message.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Post(
        );

    // Displays a message to the user inside the Visual Studio debugger IDE. This
    // function waits for the Visual Studio IDE to complete processing this message. This
    // method may not be called from code that runs as part of UI event processing. Doing
    // so will cause a deadlock. This method requires DkmUserMessage.Process to be
    // non-null.
    // pResult         : [Out] Win32 'ID' code from displaying the message box (ex:
    // IDYES). These codes are defined in winuser.h from the Windows SDK.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DisplayPrompt(
        _Out_ UINT32* pResult
        );

    // Displays a message to the user inside the Visual Studio debugger IDE. This method
    // is the Async implementation.  Once it is executed the completion routine will be
    // called with the DkmProcess and the user response (Yes/No).  This method requires
    // DkmUserMessage.Process to be non-null.
    //
    // This method will append a new work item to the specified work list, and return
    // once the work item has been appended. The actual processing of the work item is
    // asynchronous. The caller will be notified that the request is complete through the
    // completion routine.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    // pWorkList       : WorkList to append the new work item to.
    // pCompletionRoutine: Routine to fire when the request is complete. If the request
    // is successfully appended to the work list, this will always fire (including when
    // the operation is canceled). This will never fire if appending the work item fails.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DisplayPrompt(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmDisplayUserMessagePromptAsyncResult>* pCompletionRoutine
        );
}; // end of DkmUserMessage

// Indicates where a DkmUserMessage should be output within the debugger IDE.
enum DkmUserMessageOutputKind::e
{
    // Message should be displayed in the output window.  It will always appear and
    // cannot be filtered by the user.
    UnfilteredOutputWindowMessage = 0,
    // Message should be displayed in the output window.  If the user has chosen to hide
    // exception message, the message will not be displayed. Typically, messages of this
    // kind inform the user that an exception has occurred in the debuggee.
    ExceptionOutputWindowMessage = 1,
    // Message should be displayed in the output window.  If the user has chosen to hide
    // program output, the message will not be displayed. Typically, messages of this
    // kind are sent from the debuggee using API's such as OutputDebugString() or
    // System.Diagnostics.Debugger.WriteLine().
    ProgramOutput = 2,
    // Message should be displayed in a message box.
    MessageBox = 3,
    // Message displayed in message box prompts to enable/disable JustMyCode.
    JustMyCodePrompt = 4,
    // Step filtering-related message.  Will go to output window, unless the user chooses
    // to turn off step-filtering messages.
    StepFilterOutputWindowMessage = 5,
    // Message box informing user that we stepped over a property or operator.  UI layer
    // will handle the logic of suppressing the dialog if it was already shown before.
    StepFilterPrompt = 6,
    // Message is displayed in a message box and the debugger UI will attempt a
    // detach/terminate to stop debugging this process. If the FatalError is being
    // generated from a debug event, the component sending the fatal error may want to
    // suspend the threads of the process so that it doesn't execute further until
    // debugging stops.
    FatalError = 7,
    // This message kind is used when the user aborts an operation that is required in
    // order to debug. Like a FatalError message, the debugger UI the debugger UI will
    // attempt a detach/terminate to stop debugging this process when the event is
    // received.
    FatalOperationAbortOutputMessage = 8,
    // Message is displayed when a user is using the new debugger (Concord) and has hit a
    // breakpoint in a language that not supported.
    NewDebuggerCompatibilityWarning = 9
};

// Represents an address which could not be resolved to a module.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("a36f3140-bcdd-fcdf-a363-869fbaea9906") DkmUnknownInstructionAddress : public DkmInstructionAddress
{
    // Use DkmUnknownInstructionAddress::Create to create this object
    private: DkmUnknownInstructionAddress();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmUnknownInstructionAddress();
    // This object cannot be copied
    private: DkmUnknownInstructionAddress& operator=(const DkmUnknownInstructionAddress&);
    private: DkmUnknownInstructionAddress(const DkmUnknownInstructionAddress&);

    private: void* m__pExtendedData;

    // Attempt to cast a 'DkmInstructionAddress' to a 'DkmUnknownInstructionAddress'. Return
    // NULL if the path object is not a 'DkmUnknownInstructionAddress'.
    // pUnknownAddress : [In,Optional] Object to attempt to cast
    // Return Value : [Optional] Result of the cast.
    public: static DECLSPEC_NOTHROW DkmUnknownInstructionAddress* TryCast(
        DkmInstructionAddress* pInstructionAddress
        )
    {
        if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::UnknownAddress)
            return NULL;

        return static_cast<DkmUnknownInstructionAddress*>(pInstructionAddress);
    }

    // Create a new DkmUnknownInstructionAddress object instance.
    // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
    // environment which is loaded into a DkmProcess and which contains code to be
    // debugged.
    // pCPUInstruction : [In,Optional] CPUInstruction provides the address that the CPU
    // will execute. This is always provided for native instructions. It may be provided
    // for CLR or custom addresses depending on how the address object was created.
    // ppCreatedObject : [Out] Result of this method call.
    // Return value    : S_OK is returned on success, and failure codes are used for any
    // error.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmRuntimeInstance* pRuntimeInstance,
        _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
        _Deref_out_ DkmUnknownInstructionAddress** ppCreatedObject
        );
}; // end of DkmUnknownInstructionAddress


// Contains types related to expression evaluation.
namespace Evaluation {
    // Identifies the compiler (language and vendor) that a method comes from. This is used
    // to select an expression evaluator.
    struct DECLSPEC_UUID("b0873194-c47f-a65a-5def-16644ebe23b8") DkmCompilerId
    {
        // Vendor for the compiler. In some contexts this may be Guid.Empty to indicate that
        // the vendor is unknown.
        GUID VendorId;

        // Language that the code was written in. In some contexts, this may be Guid.Empty to
        // indicate that the language is unknown.
        GUID LanguageId;

        // Compare an instance of the DkmCompilerId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmCompilerId& other
            ) const;

        bool operator==(const DkmCompilerId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmCompilerId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmCompilerId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmCompilerId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmCompilerId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmCompilerId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmCompilerId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmCompilerId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents a query which is produced by an expression evaluator or similar component
    // and set to the target computer to obtain information about the dynamic state of the
    // program (ex: the current value of a register).
    //
    // Derived classes: DkmCompiledCustomInspectionQuery, DkmCompiledILInspectionQuery
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("47a09cc9-e122-16e1-9132-beda4e7b8025") DkmCompiledInspectionQuery : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmCompiledInspectionQuery::Create to create this object
        private: DkmCompiledInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledInspectionQuery& operator=(const DkmCompiledInspectionQuery&);
        private: DkmCompiledInspectionQuery(const DkmCompiledInspectionQuery&);

        // DkmCompiledInspectionQuery is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmCompiledILInspectionQuery'.
        DkmILQuery = 0,
        // Object is an instance of 'DkmCompiledCustomInspectionQuery'.
        CustomQuery = 1
        }; };

        private: const Tag::e m_TagValue;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_QueryKind;
        private: void* m__pExtendedData;

        // DkmCompiledInspectionQuery is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Indicates the type of inspection query. This is used to select a component to
        // process the query.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE QueryKind(
            );

        // Executes a compiled inspection query and returns any results.
        // pParameters     : [In,Optional] Optional array of parameter values to pass to the
        // IL stream.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // Timeout         : [In] This is the timeout to be used for potentially slow
        // operations such as a function evaluation. This value is in milliseconds.
        // FuncEvalFlags   : [In] Flags impacting how function evaluation requests are
        // performed.
        // pResults        : [Out] Results of the evaluations. Each ILEvaluationResult object
        // contains an index that indicates which DkmILInstruction in the instructions
        // parameter this result came from. NOTE: some instructions will not return a result.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pFailureReason  : [Out] If an expected error occurs evaluating the DkmIL,
        // indicates the reason for the failure.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason::e* pFailureReason
            );

        // Executes a compiled inspection query and returns any results.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pParameters     : [In,Optional] Optional array of parameter values to pass to the
        // IL stream.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // Timeout         : [In] This is the timeout to be used for potentially slow
        // operations such as a function evaluation. This value is in milliseconds.
        // FuncEvalFlags   : [In] Flags impacting how function evaluation requests are
        // performed.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _In_ IDkmCompletionRoutine<Evaluation::DkmExecuteQueryAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmCompiledInspectionQuery

    // Indicates the type of inspection query. This is used to select a component to process
    // the query.
    struct DkmCompiledInspectionQueryKind
    {
        // Query is a DkmCompiledILInspectionQuery object.
        // DkmIL is defined as {7e76111e-089f-4ca9-baeb-7b5028eae246}.
        static const GUID DkmIL;
    };
    __declspec(selectany) const GUID DkmCompiledInspectionQueryKind::DkmIL = { 0x7e76111e, 0x89f, 0x4ca9, { 0xba, 0xeb, 0x7b, 0x50, 0x28, 0xea, 0xe2, 0x46 } };

    // Represents the results of parsing one or more visualization files.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3347c534-533c-275b-1828-d1dd73ba2fc0") DkmCompiledVisualizationData : public DkmDataContainer
    {
        // Use DkmCompiledVisualizationData::Create to create this object
        private: DkmCompiledVisualizationData();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledVisualizationData();
        // This object cannot be copied
        private: DkmCompiledVisualizationData& operator=(const DkmCompiledVisualizationData&);
        private: DkmCompiledVisualizationData(const DkmCompiledVisualizationData&);

        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The language for which this visualization data applies to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // The inspection session which owns the lifetime of this object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Guid which uniquely identifies this inspection session.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Closes a DkmCompiledVisualizationData object instance. This will release any
        // resources associated with this object across all components. This includes
        // resources across computer or managed/native marshalling boundaries.
        //
        // DkmCompiledVisualizationData objects are automatically closed when their
        // associated DkmInspectionSession object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmCompiledVisualizationData object instance. The caller is
        // responsible for closing the created object after they are done.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pLanguage       : [In] The language for which this visualization data applies to.
        // pInspectionSession: [In] The inspection session which owns the lifetime of this
        // object.
        // DataItem        : [In] Data object to add to the new DkmCompiledVisualizationData
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmCompiledVisualizationData** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Compiles object visualization data from a human-readable form into a
        // DkmCompiledVisualizationData object.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // VisualizationFiles: [In] List of full paths, on to the Visual Studio computer,
        // that describe information to be used for object visualization. For C++, each item
        // in the array should be the full path to a .natvis file you wish to use when
        // formatting the results of the expression.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Initialize(
            _In_ const DkmArray<DkmString*>& VisualizationFiles
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmCompiledVisualizationData

    // Specifies the relative priority of context-specific visualization data, relative to
    // the default visualization data.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmCompiledVisualizationDataPriority::e
    {
        // Indicates that context-specific visualization data will not be used.
        None = 0,
        // Indicates that context-specific visualization data will be used only as a fallback
        // when regular visualization data is not available.
        Low = 1,
        // Indicates that context-specific visualization data will be prioritized ahead of
        // default visualization data and that default visualization data will only be used
        // as a fallback when context-specific data is not available for the object being
        // visualized.
        High = 2,
        // Indicates that context-specific visualization data will be used exclusively and
        // that default visualization data will not be used at all.
        Exclusive = 3
    };

    // Contains information about a custom UI visualizer which can be displayed for an
    // evaluation result.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4dfdfab9-7dc9-9b57-f046-463c417add1c") DkmCustomUIVisualizerInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmCustomUIVisualizerInfo::Create to create this object
        private: DkmCustomUIVisualizerInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomUIVisualizerInfo();
        // This object cannot be copied
        private: DkmCustomUIVisualizerInfo& operator=(const DkmCustomUIVisualizerInfo&);
        private: DkmCustomUIVisualizerInfo(const DkmCustomUIVisualizerInfo&);

        private: const UINT32 m_Id;
        private: DkmString* const m_pMenuName;
        private: OPTIONAL DkmString* const m_pDescription;
        private: DkmString* const m_pMetric;
        private: void* m__pExtendedData;

        // Unique id for this viewer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The text that will appear in the drop-down menu.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE MenuName(
            );

        // [Optional] The description of the custom viewer.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // The name of the EE metric under which viewer CLSID is stored.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Metric(
            );

        // Create a new DkmCustomUIVisualizerInfo object instance.
        // Id              : [In] Unique id for this viewer.
        // pMenuName       : [In] The text that will appear in the drop-down menu.
        // pDescription    : [In,Optional] The description of the custom viewer.
        // pMetric         : [In] The name of the EE metric under which viewer CLSID is
        // stored.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ DkmString* pMenuName,
            _In_opt_ DkmString* pDescription,
            _In_ DkmString* pMetric,
            _Deref_out_ Evaluation::DkmCustomUIVisualizerInfo** ppCreatedObject
            );
    }; // end of DkmCustomUIVisualizerInfo

    // Represents an address in data.
    //
    // Derived classes: DkmGPUDataAddress
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("90d3adc4-f34b-4b9e-83d3-4ce6f6bcbde2") DkmDataAddress : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDataAddress::Create to create this object
        private: DkmDataAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDataAddress();
        // This object cannot be copied
        private: DkmDataAddress& operator=(const DkmDataAddress&);
        private: DkmDataAddress(const DkmDataAddress&);

        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const UINT64 m_Value;
        private: OPTIONAL DkmInstructionAddress* const m_pInstructionAddress;
        private: void* m__pExtendedData;

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Data address.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Value(
            );

        // [Optional] Set when the data address is an instruction address.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Create a new DkmDataAddress object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // Value           : [In] Data address.
        // pInstructionAddress: [In,Optional] Set when the data address is an instruction
        // address.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 Value,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _Deref_out_ Evaluation::DkmDataAddress** ppCreatedObject
            );
    }; // end of DkmDataAddress

    // Result of an asynchronous DkmInspectionContext.EvaluateExpression call.
    struct DkmEvaluateExpressionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // Object containing the result of the evaluation. This object must be closed by the
        // caller when the caller is done with the object.
        Evaluation::DkmEvaluationResult* pResultObject;
    };

    // Result of an asynchronous DkmInspectionContext.EvaluateReturnValue call.
    struct DkmEvaluateReturnValueAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // [Optional] Object containing the result of the evaluation. This object must be
        // closed by the caller when the caller is done with the object. If not present, the
        // function had no return value.
        OPTIONAL Evaluation::DkmEvaluationResult* pResultObject;
    };

    // Result of an asynchronous DkmEvaluationResultEnumContext.GetItems call.
    struct DkmEvaluationEnumAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The DkmEvaluationResult items to return. Each item must be closed by the caller
        // when the caller is done.
        DkmArray<Evaluation::DkmEvaluationResult*> Items;
    };

    // Flags which effect how an input expression should be parsed, compiled or displayed.
    enum DkmEvaluationFlags::e
    {
        // Input expression should be treated with the default semantics.
        None = 0x0,
        // The text is an expression (not a statement).
        TreatAsExpression = 0x1,
        // The text might contain function name/parameter signatures, and the expression is
        // to be parsed [and later evaluated] as an address.
        TreatFunctionAsAddress = 0x2,
        // The expression evaluator should not evaluate expressions which have side effects,
        // such as assignment statements. The debugger UI will use this flag when the
        // expression needs to be treated with care, such as in data tips. It is up to the
        // expression evaluator to decide what is considered a side effect for their
        // language.
        NoSideEffects = 0x4,
        // Expression evaluators should not attempt a func-eval. If a component mistakenly
        // issues a func-eval with this flag set then the func-eval will not be honored.
        NoFuncEval = 0x8,
        // The expression evaluation is happening in the context of design-time expression
        // evaluation (DTEE). In this scenario, the user enters text in the immediate window
        // in design mode.
        DesignTime = 0x10,
        // Allow the variables to be declared as part of the expression.
        AllowImplicitVariables = 0x20,
        // Force evaluation to occur now. Somebody is requesting it (like the user). Since
        // this flag only impacts the display of the expression, it may be varied between
        // compile and display.
        ForceEvaluationNow = 0x40,
        // Display the type members as is without the aid of a native visualizer.
        ShowValueRaw = 0x80,
        // If the runtime in question supports interpreted func-evaluation, this flag means
        // to perform real func-evaluations rather than interpreting any function calls in
        // the process.
        ForceRealFuncEval = 0x100,
        // Expression evaluators should hide non-public members.
        HideNonPublicMembers = 0x200,
        // Expression evaluators should call ToString method if flag is not present.
        NoToString = 0x400,
        // Indicates that the expression evaluator should not calculate the Value or
        // EditableValue properties of the returned DkmEvaluationResult.  This flag is used
        // as a performance optimization in situations where the value and editable value are
        // not used and do not need to be computed.  When this flag is set, the resultant
        // evaluation result, if successful, will have the empty string for its value and
        // editable value.
        NoFormatting = 0x800,
        // Indicates that when C++ debugging and natvis is used to visualize an object, that
        // the [Raw View] node should be omitted. This flag may be used as a performance
        // optimization in situations where it is not needed.
        NoRawView = 0x1000
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmEvaluationFlags::e);

    // The formatted result of an evaluation, ready to be displayed in an expression
    // evaluation window.
    //
    // Derived classes: DkmSuccessEvaluationResult, DkmFailedEvaluationResult,
    // DkmIntermediateEvaluationResult
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a017f790-1e94-73fc-a4b5-53278ec5548b") DkmEvaluationResult : public DkmDataContainer
    {
        // Use DkmEvaluationResult::Create to create this object
        private: DkmEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEvaluationResult();
        // This object cannot be copied
        private: DkmEvaluationResult& operator=(const DkmEvaluationResult&);
        private: DkmEvaluationResult(const DkmEvaluationResult&);

        // DkmEvaluationResult is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmSuccessEvaluationResult'.
        SuccessResult = 0,
        // Object is an instance of 'DkmFailedEvaluationResult'.
        FailedResult = 1,
        // Object is an instance of 'DkmIntermediateEvaluationResult'.
        IntermediateResult = 2
        }; };

        private: const Tag::e m_TagValue;
        private: Evaluation::DkmInspectionContext* const m_pInspectionContext;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pFullName;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // DkmEvaluationResult is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // Inspection context used to create this evaluation result.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionContext* STDMETHODCALLTYPE InspectionContext(
            );

        // The stack frame this expression result was created on.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // The name of the expression this result applies to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] The full name of the expression this result applies to. This value is
        // used to allow child elements to be added to the watch window (Add Watch from the
        // context menu), and to refresh parts of the evaluation tree. As an example of how
        // FullName differs from name, the name of the 0th element of an array in C++ is
        // '[0]' while the full name would by 'myArrayVariable[0]'.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Guid which uniquely identifies this evaluation result.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Language used to perform inspections.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes the evaluation result object to release the resources associated with it.
        // This method must be invoked by the component which initiated the enumeration (ex:
        // called DkmInspectionContext.EvaluateExpression,
        // DkmEvaluationResultEnumContext.GetItems, etc).
        //
        // DkmEvaluationResult objects are automatically closed when their associated
        // DkmInspectionSession object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Gets an enumeration context used to obtain the children of this evaluation result.
        // This is used in all expression evaluation windows.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pWorkList       : WorkList to append the new work item to.
        // InitialRequestSize: [In] The initial number of children that the caller would like
        // returned. This value can be zero if no children will be initially returned. This
        // value may be larger than the number of children that this expression has, in which
        // case all children should be returned. Very large or negative values should not be
        // used as arrays can have extremely large sizes which would cause out-of-memory if
        // all elements were requested.
        // pInspectionContext: [In] The inspection context to use for computing the children.
        // This may differ from the original inspection context with respect to settings,
        // such as radix, evaluation flags, or timeout.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine
            );

        // Modifies the value of the given evaluation result (assumed to be non-read-only) to
        // match the given string. This is used after the user edits a value in any of the
        // evaluation windows.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pValue          : [In] Textual representation of value to assign to the evaluation
        // result.
        // Timeout         : [In] If a function evaluation is needed to assign the value,
        // specifies the timeout to use.
        // ppErrorText     : [Out,Optional] If the operation failed, this indicates the
        // reason why. This value should be null if the operation succeeded. In native code,
        // an S_OK return value is used when returning error text.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            );

        // This method is used for evaluation results that include
        // DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        // enclosing quotes or escape sequences. This is method is invoked to display one of
        // the various string visualizers in an expression evaluation window (click the
        // magnifying glass icon).
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // ppStringValue   : [Out,Optional] The underlying string value.
        // Return value    : S_OK is returned if *ppStringValue is non-NULL, S_FALSE is
        // returned when *ppStringValue is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _Deref_out_opt_ DkmString** ppStringValue
            );

        // Creates an object id for this particular expression.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateObjectId(
            );

        // Destroys an object id for this particular expression.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DestroyObjectId(
            );
    }; // end of DkmEvaluationResult

    // Specifies the access control level (public, private, etc) of the represented
    // field/method/property. This is principally used by the debugger UI to select icons in
    // the watch and other expression evaluation windows.
    enum DkmEvaluationResultAccessType::e
    {
        // Not applicable (the result of the expression is not a field of a class).
        None = 0,
        // Indicates that the result of the expression is a public field.
        Public = 1,
        // Indicates that the result of the expression is a private field.
        Private = 2,
        // Indicates that the result of the expression is a protected field.
        Protected = 3,
        // Indicates that the result of the expression is a final field.
        Final = 4
    };

    // The category (ex: Data, Method, etc) of the underlying value represented by this
    // evaluation result. This is principally used by the debugger UI to select icons in the
    // watch and other expression evaluation windows.
    enum DkmEvaluationResultCategory::e
    {
        // Indicates that the evaluation result does not belong to a category listed in this
        // enumeration.
        Other = 0,
        // Indicates that the evaluation result represents data.
        Data = 1,
        // Indicates that the evaluation result represents a method.
        Method = 2,
        // Indicates that the evaluation result represents a event.
        Event = 3,
        // Indicates that the evaluation result represents a property.
        Property = 4,
        // Indicates that the evaluation result represents a class.
        Class = 5,
        // Indicates that the evaluation result represents an interface.
        Interface = 6,
        // Node in the evaluation result tree to access fields/properties/etc of a base
        // class.
        BaseClass = 7,
        // Node in the evaluation result tree to access fields/properties/etc of an inner
        // class.
        InnerClass = 8,
        // Node in the evaluation result tree to access fields/properties/etc of the most
        // derived class.
        MostDerivedClass = 9
    };

    // Context object used to enumerate child members of an evaluation result, or to
    // enumerate local variables from a stack frame. This is logically similar to an
    // enumerator, except that access to elements is index-based rather than sequential.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8a77c186-e7a6-31bc-b218-d7ea66212f8b") DkmEvaluationResultEnumContext : public DkmDataContainer
    {
        // Use DkmEvaluationResultEnumContext::Create to create this object
        private: DkmEvaluationResultEnumContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEvaluationResultEnumContext();
        // This object cannot be copied
        private: DkmEvaluationResultEnumContext& operator=(const DkmEvaluationResultEnumContext&);
        private: DkmEvaluationResultEnumContext(const DkmEvaluationResultEnumContext&);

        private: const UINT32 m_Count;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: Evaluation::DkmInspectionContext* const m_pInspectionContext;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The number of items (DkmEvaluationResults) which can be obtained through this
        // DkmEvaluationResultEnumContext.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Count(
            );

        // The stack frame this expression result was created on.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // Inspection context used to create this enumeration context.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionContext* STDMETHODCALLTYPE InspectionContext(
            );

        // Guid which uniquely identifies this enumeration context.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Language used to perform inspections.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes the enum context object to release the resources associated with it. This
        // method must be invoked by the component which initiated the enumeration (ex:
        // called DkmEvaluationResult.GetChildren or DkmInspectionContext.GetFrameLocals).
        //
        // DkmEvaluationResultEnumContext objects are automatically closed when their
        // associated DkmInspectionSession object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmEvaluationResultEnumContext object instance.
        // Count           : [In] The number of items (DkmEvaluationResults) which can be
        // obtained through this DkmEvaluationResultEnumContext.
        // pStackFrame     : [In] The stack frame this expression result was created on.
        // pInspectionContext: [In] Inspection context used to create this enumeration
        // context.
        // DataItem        : [In] Data object to add to the new
        // DkmEvaluationResultEnumContext instance. DkmDataItem::Null() in the case that the
        // caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Count,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppCreatedObject
            );

        // Obtain DkmEvaluationResult items from this enumeration context. This is used to
        // obtain local variables of a stack frame or child members from an evaluation
        // result.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pWorkList       : WorkList to append the new work item to.
        // StartIndex      : [In] The zero-based index of the first item to obtain.
        // Count           : [In] The number of items to try and return. This value may be
        // larger than the total number of remaining items, in which case all remaining items
        // should be returned. Very large or negative values should not be used as arrays can
        // have extremely large sizes which would cause out-of-memory if all elements were
        // requested.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetItems(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmEvaluationResultEnumContext

    // Flags which indicate attributes of an expression evaluation result.
    enum DkmEvaluationResultFlags::e
    {
        // No attribute flags are set.
        None = 0x0,
        // Indicates that the evaluation caused a side effect.
        SideEffect = 0x1,
        // Indicates that the result of this evaluation has children which can be accessed
        // through IDkmLanguageExpressionEvaluator.GetChildrenEnumContext.
        Expandable = 0x2,
        // Indicates that the result of the evaluation is a Boolean value.
        Boolean = 0x4,
        // If the Boolean flag is set, indicates that the result of the evaluation is "true",
        // as opposed to "false".
        BooleanTrue = 0x8,
        // Indicates that the result of the expression represents a conceptual string that
        // can be displayed in the string viewer.  The EE should be prepared to provide the
        // raw string via IDkmLanguageExpressionEvaluator::GetUnderlyingString().
        RawString = 0x10,
        // Indicates that the result of the expression evaluation is an address that can be
        // navigated to in the memory window.
        Address = 0x20,
        // Indicates that the result of the expression evaluation is read-only.  If false,
        // the user will be allowed to modify the value.
        ReadOnly = 0x40,
        // Indicates that the IL interpreter was used to get the result of the expression
        // evaluation.
        ILInterpreter = 0x80,
        // Indicates that the expression contains side effects that were discarded by the IL
        // interpreter.  To flush the side effects, the user should re-evaluate the
        // expression with real func-evals turned on.
        UnflushedSideEffects = 0x100,
        // Indicates that the expression has an object id associated with it.
        HasObjectId = 0x200,
        // Indicates that the expression can have an object id assigned to it.
        CanHaveObjectId = 0x400,
        // Indicates that the expression was rejected because it has a cross thread
        // dependency.
        CrossThreadDependency = 0x800,
        // Indicates that the value is invalid.
        Invalid = 0x1000,
        // Indicates that the object being inspected has a visualizer associated with it.
        // Currently, this flag is only implemented for C++ and is set whenever the result of
        // the evaluation has a natvis entry associated with it.
        Visualized = 0x2000,
        // Indicates that the Evaluation Results was marked as an Error but has an expandable
        // object. An example of this is the VB EE results that is an Exception object.
        ExpandableError = 0x4000
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmEvaluationResultFlags::e);

    // If the result of an expression evaluation is data, indicates where the data is stored.
    // This is principally used by the debugger UI to select icons in the watch and other
    // expression evaluation windows.
    enum DkmEvaluationResultStorageType::e
    {
        // Indicates that the evaluation result does not have a storage type.
        None = 0,
        // Indicates that the evaluation result represents a global variable.
        Global = 1,
        // Indicates that the evaluation result represents a static variable.
        Static = 2,
        // Indicates that the evaluation result represents a register.
        Register = 3
    };

    // Type modifier flags (ex: const). These are principally used by the debugger UI to
    // select icons in the watch and other expression evaluation windows.
    enum DkmEvaluationResultTypeModifierFlags::e
    {
        // None.
        None = 0x0,
        // Indicates that the represented method/property is virtual.
        Virtual = 0x1,
        // Indicates that the represented value is a constant.
        Constant = 0x2,
        // Indicates that the represented method/class is synchronized.
        Synchronized = 0x4,
        // Indicates that the represented field is volatile.
        Volatile = 0x8
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmEvaluationResultTypeModifierFlags::e);

    // Result of an asynchronous DkmCompiledInspectionQuery.Execute call.
    struct DkmExecuteQueryAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Results of the evaluations. Each ILEvaluationResult object contains an index that
        // indicates which DkmILInstruction in the instructions parameter this result came
        // from. NOTE: some instructions will not return a result.
        DkmArray<Evaluation::IL::DkmILEvaluationResult*> Results;

        // If an expected error occurs evaluating the DkmIL, indicates the reason for the
        // failure.
        Evaluation::IL::DkmILFailureReason::e FailureReason;
    };

    // Base class for all expression value homes.
    //
    // Derived classes: DkmFakeValueHome, DkmPointerValueHome
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b39a3432-f736-a099-a999-08b0bd3c13bf") DkmExpressionValueHome : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExpressionValueHome::Create to create this object
        private: DkmExpressionValueHome();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExpressionValueHome();
        // This object cannot be copied
        private: DkmExpressionValueHome& operator=(const DkmExpressionValueHome&);
        private: DkmExpressionValueHome(const DkmExpressionValueHome&);

        // DkmExpressionValueHome is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmPointerValueHome'.
        PointerValueHome = 0,
        // Object is an instance of 'DkmFakeValueHome'.
        FakeValueHome = 1
        }; };

        private: const Tag::e m_TagValue;
        private: void* m__pExtendedData;

        // DkmExpressionValueHome is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );
    }; // end of DkmExpressionValueHome

    // Flags impacting how function evaluation requests are performed.
    enum DkmFuncEvalFlags::e
    {
        // The function evaluation will continue past stopping events (ex: breakpoints will
        // be skipped) and will execute on a single thread (all other threads will be left
        // suspended).
        None = 0x0,
        // Indicates that stopping events should be processed normally during the function
        // evaluation. This option is used for function evaluation requests from the
        // immediate window. When this flag is missing, most stopping events are immediately
        // suppressed. This flag should only be enabled by the AD7 AL.
        AllowStoppingEvents = 0x1,
        // All threads should run during the function evaluation. If this flag is missing,
        // all threads other than the evaluating thread are suspended during the evaluation.
        // A component may use this flag in conjunction with the thread suspension API in
        // order to suspend a subset of the threads in the application. This flag may not be
        // used with function evaluation requests from the event thread.
        RunAllThreads = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmFuncEvalFlags::e);

    // Result of an asynchronous DkmEvaluationResult.GetChildren call.
    struct DkmGetChildrenAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The initial children to return. Each child must be closed by the caller when the
        // caller is done.
        DkmArray<Evaluation::DkmEvaluationResult*> InitialChildren;

        // Context object used to enumerate the children, including the children already
        // returned via the InitialChildren parameter. This object must be closed by the
        // caller of this API when enumeration is complete.
        Evaluation::DkmEvaluationResultEnumContext* pEnumContext;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameArguments call.
    struct DkmGetFrameArgumentsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmEvaluationResult for each argument. Each DkmEvaluationResult must be closed by
        // the caller when done with the object.
        DkmArray<Evaluation::DkmEvaluationResult*> Arguments;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameLocals call.
    struct DkmGetFrameLocalsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Context object used to enumerate child members of an evaluation result, or to
        // enumerate local variables from a stack frame. This is logically similar to an
        // enumerator, except that access to elements is index-based rather than sequential.
        Evaluation::DkmEvaluationResultEnumContext* pEnumContext;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameName call.
    struct DkmGetFrameNameAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Language's representation of the name of this frame.
        DkmString* pFrameName;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameReturnType call.
    struct DkmGetFrameReturnTypeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Language's representation of the return type for this frame.
        OPTIONAL DkmString* pReturnType;
    };

    // Result of an asynchronous DkmLanguage.GetLanguageSettings call.
    struct DkmGetLanguageSettingsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Pairing between the name of a setting and its value.
        DkmArray<DkmLanguageRegistrySetting*> Settings;
    };

    // Context to use for IL evaluation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0791dedd-cf53-fb48-30ad-66b9bb8699a6") DkmILContext : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILContext::Create to create this object
        private: DkmILContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILContext();
        // This object cannot be copied
        private: DkmILContext& operator=(const DkmILContext&);
        private: DkmILContext(const DkmILContext&);

        // Optional section that describes an alternate thread to use for evaluation.
        public: struct ThreadOverride
        {
            // Global-to-kernel thread ID to use for evaluation.
            UINT64 ThreadId;
        };

        private: OPTIONAL const Evaluation::DkmILContext::ThreadOverride* const m_pThreadOverride;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: void* m__pExtendedData;

        // [Optional] Optional section that describes an alternate thread to use for
        // evaluation.
        public: _Ret_opt_ DECLSPEC_NOTHROW const Evaluation::DkmILContext::ThreadOverride* STDMETHODCALLTYPE ThreadOverridePart(
            );

        // Stack frame to use for evaluation.  The specific thread to use may be overridden
        // using the optional ThreadOverride part.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // Create a new DkmILContext object instance.
        // pStackFrame     : [In] Stack frame to use for evaluation.  The specific thread to
        // use may be overridden using the optional ThreadOverride part.
        // pThreadOverride : [In,Optional] Optional section that describes an alternate
        // thread to use for evaluation.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ const Evaluation::DkmILContext::ThreadOverride* pThreadOverride,
            _Deref_out_ Evaluation::DkmILContext** ppCreatedObject
            );
    }; // end of DkmILContext

    // Options and target context to use while performing the inspection operation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0807c826-3338-dd99-2f3a-202ba8fb9da7") DkmInspectionContext : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInspectionContext::Create to create this object
        private: DkmInspectionContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInspectionContext();
        // This object cannot be copied
        private: DkmInspectionContext& operator=(const DkmInspectionContext&);
        private: DkmInspectionContext(const DkmInspectionContext&);

        // Contains additional fields of DkmInspectionContext which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] Specifies an optional list of full paths to visualization files to
            // use, in addition to the default files from the users profile directory and the
            // Visual Studio installation directory.  Precedence between conflicting
            // visualizers in these paths, relative to the standard paths are resolved
            // according to the information specified in
            // 'AdditionalVisualizationDataPriority'.
            OPTIONAL Evaluation::DkmCompiledVisualizationData* const pAdditionalVisualizationData;

            // If AdditionalVisualizationData is specified, specifies the priority of such
            // data, relative to the default search locations.
            const Evaluation::DkmCompiledVisualizationDataPriority::e AdditionalVisualizationDataPriority;
        };

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: DkmThread* const m_pThread;
        private: const UINT32 m_Timeout;
        private: const Evaluation::DkmEvaluationFlags::e m_EvaluationFlags;
        private: const Evaluation::DkmFuncEvalFlags::e m_FuncEvalFlags;
        private: const UINT32 m_Radix;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: OPTIONAL Evaluation::DkmRawReturnValue* const m_pReturnValue;
        private: ___ExtendedData* const m__pExtendedData;

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The thread being examined.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // This is the timeout to be used for potentially slow operations such as a function
        // evaluation. This value is in milliseconds.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Timeout(
            );

        // Flags which effect how an input expression should be parsed, compiled or
        // displayed.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationFlags::e STDMETHODCALLTYPE EvaluationFlags(
            );

        // Flags impacting how function evaluation requests are performed.
        public: DECLSPEC_NOTHROW Evaluation::DkmFuncEvalFlags::e STDMETHODCALLTYPE FuncEvalFlags(
            );

        // The radix to use when formatting integer data. Currently supported values are '16'
        // and '10'.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Radix(
            );

        // Language used to perform inspections.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // [Optional] The last ReturnValue on the thread.  It's valid in the current thread
        // context and be used to evaluate $ReturnValue.
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmRawReturnValue* STDMETHODCALLTYPE ReturnValue(
            );

        // [Optional] Specifies an optional list of full paths to visualization files to use,
        // in addition to the default files from the users profile directory and the Visual
        // Studio installation directory.  Precedence between conflicting visualizers in
        // these paths, relative to the standard paths are resolved according to the
        // information specified in 'AdditionalVisualizationDataPriority'.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmCompiledVisualizationData* STDMETHODCALLTYPE AdditionalVisualizationData(
            );

        // If AdditionalVisualizationData is specified, specifies the priority of such data,
        // relative to the default search locations.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmCompiledVisualizationDataPriority::e STDMETHODCALLTYPE AdditionalVisualizationDataPriority(
            );

        // Create a new DkmInspectionContext object instance.
        // pInspectionSession: [In] The InspectionSession allows the various components which
        // examine data in the target process to store private data with the same lifetime.
        // Inspection sessions are closed when the user attempts to continue the process.
        // pRuntimeInstance: [In] Indicates which runtime monitor will be used to perform
        // this evaluation.
        // pThread         : [In] The thread being examined.
        // Timeout         : [In] This is the timeout to be used for potentially slow
        // operations such as a function evaluation. This value is in milliseconds.
        // EvaluationFlags : [In] Flags which effect how an input expression should be
        // parsed, compiled or displayed.
        // FuncEvalFlags   : [In] Flags impacting how function evaluation requests are
        // performed.
        // Radix           : [In] The radix to use when formatting integer data. Currently
        // supported values are '16' and '10'.
        // pLanguage       : [In] Language used to perform inspections.
        // pReturnValue    : [In,Optional] The last ReturnValue on the thread.  It's valid in
        // the current thread context and be used to evaluate $ReturnValue.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmEvaluationFlags::e EvaluationFlags,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _In_ UINT32 Radix,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_opt_ Evaluation::DkmRawReturnValue* pReturnValue,
            _Deref_out_ Evaluation::DkmInspectionContext** ppCreatedObject
            );

        // Create a new DkmInspectionContext object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionSession: [In] The InspectionSession allows the various components which
        // examine data in the target process to store private data with the same lifetime.
        // Inspection sessions are closed when the user attempts to continue the process.
        // pRuntimeInstance: [In] Indicates which runtime monitor will be used to perform
        // this evaluation.
        // pThread         : [In] The thread being examined.
        // Timeout         : [In] This is the timeout to be used for potentially slow
        // operations such as a function evaluation. This value is in milliseconds.
        // EvaluationFlags : [In] Flags which effect how an input expression should be
        // parsed, compiled or displayed.
        // FuncEvalFlags   : [In] Flags impacting how function evaluation requests are
        // performed.
        // Radix           : [In] The radix to use when formatting integer data. Currently
        // supported values are '16' and '10'.
        // pLanguage       : [In] Language used to perform inspections.
        // pReturnValue    : [In,Optional] The last ReturnValue on the thread.  It's valid in
        // the current thread context and be used to evaluate $ReturnValue.
        // pAdditionalVisualizationData: [In,Optional] Specifies an optional list of full
        // paths to visualization files to use, in addition to the default files from the
        // users profile directory and the Visual Studio installation directory.  Precedence
        // between conflicting visualizers in these paths, relative to the standard paths are
        // resolved according to the information specified in
        // 'AdditionalVisualizationDataPriority'.
        // AdditionalVisualizationDataPriority: [In] If AdditionalVisualizationData is
        // specified, specifies the priority of such data, relative to the default search
        // locations.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmEvaluationFlags::e EvaluationFlags,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _In_ UINT32 Radix,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_opt_ Evaluation::DkmRawReturnValue* pReturnValue,
            _In_opt_ Evaluation::DkmCompiledVisualizationData* pAdditionalVisualizationData,
            _In_ Evaluation::DkmCompiledVisualizationDataPriority::e AdditionalVisualizationDataPriority,
            _Deref_out_ Evaluation::DkmInspectionContext** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Bind the input expression and evaluate it. Then format the resulting value for
        // display in the debugger. This is used for data tips, the watch windows, the
        // immediate window, etc.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pThreads        : [In] The compute threads to use when executing the query.
        // pStackFrame     : [In] Stack frame to match on compute threads.
        // pExpression     : [In] Expression to evaluate.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateExpressionOnThreads(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ IDkmCompletionRoutine<Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Bind the input expression and evaluate it. Then format the resulting value for
        // display in the debugger. This is used for data tips, the watch windows, the
        // immediate window, etc.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pWorkList       : WorkList to append the new work item to.
        // pExpression     : [In] DkmLanguageExpression represents an expression to be parsed
        // and evaluated by an expression evaluator.
        // pStackFrame     : [In] Stack frame to evaluate the expression in.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateExpression(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateExpressionAsyncResult>* pCompletionRoutine
            );

        // Gets an enumeration context used to obtain the local variables of this stack
        // frame. This is used in computing the locals window.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pWorkList       : WorkList to append the new work item to.
        // pStackFrame     : [In] Stack frame to evaluate the expression in.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameLocals(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameLocalsAsyncResult>* pCompletionRoutine
            );

        // Provides information on the arguments of a stack frame. This is currently only
        // exposed through the VS automation model (EnvDTE.StackFrame.Arguments).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pWorkList       : WorkList to append the new work item to.
        // pFrame          : [In] Walked frames which the evaluator is requested to describe.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameArguments(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameArgumentsAsyncResult>* pCompletionRoutine
            );

        // Provides a text representation for a stack frame. This is used when building the
        // formatted call stack.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // pWorkList       : WorkList to append the new work item to.
        // pFrame          : [In] Walked frames which the evaluator is requested to describe.
        // ArgumentFlags   : [In] Flags to indicate what information about the arguments
        // should be included in the frame name.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameName(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmVariableInfoFlags::e ArgumentFlags,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameNameAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Provides a text representation of the return type for one or more stack frame.
        // This is currently only exposed through the VS automation model
        // (EnvDTE.StackFrame.ReturnType).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pFrame          : [In] Walked frames which the evaluator is requested to describe.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameReturnType(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameReturnTypeAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pStackFrame     : [In] Stack frame that provides the context of in which to
        // evaluate the expression.
        // pRawReturnValue : [In] Return value target and cached context.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateReturnValue(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmRawReturnValue* pRawReturnValue,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateReturnValueAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmInspectionContext

    // DkmInspectionSession allows the various components which inspect data to store private
    // data which is associated with a group of evaluations.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("79035fe3-c25f-1535-6595-2b6b79621f50") DkmInspectionSession : public DkmDataContainer
    {
        // Use DkmInspectionSession::Create to create this object
        private: DkmInspectionSession();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInspectionSession();
        // This object cannot be copied
        private: DkmInspectionSession& operator=(const DkmInspectionSession&);
        private: DkmInspectionSession(const DkmInspectionSession&);

        private: DkmProcess* const m_pProcess;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;
        private: void* m_pEnumContextCollection0;
        private: void* m_pResultCollection0;
        private: void* m_pStackContextCollection0;
        private: void* m_pVisualizedExpressionCollection0;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Guid which uniquely identifies this inspection session.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Closes a DkmInspectionSession object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmInspectionSession objects are automatically closed when their associated
        // DkmProcess object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmInspectionSession object instance. The caller is responsible for
        // closing the created object after they are done.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // DataItem        : [In] Data object to add to the new DkmInspectionSession
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmInspectionSession** ppCreatedObject
            );
    }; // end of DkmInspectionSession

    // Describes a programming language.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7dbbd573-0a29-3ba3-6f5d-42c8faf933e0") DkmLanguage : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmLanguage::Create to create this object
        private: DkmLanguage();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLanguage();
        // This object cannot be copied
        private: DkmLanguage& operator=(const DkmLanguage&);
        private: DkmLanguage(const DkmLanguage&);

        private: DkmString* const m_pName;
        private: const Evaluation::DkmCompilerId m_Id;
        private: void* m__pExtendedData;

        // Name of the programming language (ex: C++). This string will appear in the call
        // stack window.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // LanguageId/VendorId pair for this DkmLanguage object. For the default language,
        // both of these values will be Guid.Empty. For all other languages, both of these
        // values are non-zero.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE Id(
            );

        // Create a new DkmLanguage object instance.
        // pName           : [In] Name of the programming language (ex: C++). This string
        // will appear in the call stack window.
        // Id              : [In] LanguageId/VendorId pair for this DkmLanguage object. For
        // the default language, both of these values will be Guid.Empty. For all other
        // languages, both of these values are non-zero.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ const Evaluation::DkmCompilerId& Id,
            _Deref_out_ Evaluation::DkmLanguage** ppCreatedObject
            );

        // Reads language-specific from the registry.  The settings are stored under
        // HKLM\Software\Microsoft\VisualStudio\12.0\AD7Metrics\ExpressionEvaluator\[Language
        // Guid]\[Vendor Guid].
        // pSettings       : [Out] Pairing between the name of a setting and its value.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLanguageSettings(
            _Out_ DkmArray<DkmLanguageRegistrySetting*>* pSettings
            );

        // Reads language-specific from the registry.  The settings are stored under
        // HKLM\Software\Microsoft\VisualStudio\12.0\AD7Metrics\ExpressionEvaluator\[Language
        // Guid]\[Vendor Guid].
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLanguageSettings(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetLanguageSettingsAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmLanguage

    // DkmLanguageExpression represents an expression to be parsed and evaluated by an
    // expression evaluator.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dce7ad4c-45b3-1220-86da-a2cd4ca64ab0") DkmLanguageExpression : public DkmDataContainer
    {
        // Use DkmLanguageExpression::Create to create this object
        private: DkmLanguageExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLanguageExpression();
        // This object cannot be copied
        private: DkmLanguageExpression& operator=(const DkmLanguageExpression&);
        private: DkmLanguageExpression(const DkmLanguageExpression&);

        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: const Evaluation::DkmEvaluationFlags::e m_CompilationFlags;
        private: DkmString* const m_pText;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Describes a programming language.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Flags which effect how the condition text should be compiled by the expression
        // evaluator. During evaluation, the caller must ensure that the DkmEvaluationFlags
        // set on the InspectionContext agree with this value -- that is that they may only
        // differ by the last set of flags which are only relevant to the display of values.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationFlags::e STDMETHODCALLTYPE CompilationFlags(
            );

        // Source text of the parsed expression.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Text(
            );

        // Guid which uniquely identifies this expression object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Closes a DkmLanguageExpression object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Creates a new DkmLanguageExpression object. This can be evaluated with
        // DkmInspectionContext.EvaluateExpression. The caller is responsible for closing the
        // created object after they are done.
        // pLanguage       : [In] Describes a programming language.
        // CompilationFlags: [In] Flags which effect how the condition text should be
        // compiled by the expression evaluator. During evaluation, the caller must ensure
        // that the DkmEvaluationFlags set on the InspectionContext agree with this value --
        // that is that they may only differ by the last set of flags which are only relevant
        // to the display of values.
        // pText           : [In] Source text of the parsed expression.
        // DataItem        : [In] Data object to add to the new DkmLanguageExpression
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ Evaluation::DkmEvaluationFlags::e CompilationFlags,
            _In_ DkmString* pText,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmLanguageExpression** ppCreatedObject
            );
    }; // end of DkmLanguageExpression

    // Unique id for a programming language. These values must also be registered under
    // $(RegRoot)\AD7Metric\ExpressionEvaluator and returned from symbol providers (through
    // GetCompilerId) and language services (through IVsLanguageDebugInfo.GetLanguageID).
    struct DkmLanguageId
    {
        // Visual Basic.
        // VB is defined as {3a12d0b8-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID VB;
        // JScript (ECMA Script).
        // JScript is defined as {3a12d0b6-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID JScript;
        // C.
        // C is defined as {63a08714-fc37-11d2-904c-00c04fa302a1}.
        static const GUID C;
        // C++.
        // Cpp is defined as {3a12d0b7-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID Cpp;
        // T-SQL.
        // SQL is defined as {3a12d0b9-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID SQL;
        // Script.
        // Script is defined as {f7fa31da-c32a-11d0-b442-00a0244a1dd2}.
        static const GUID Script;
        // C#.
        // CSharp is defined as {3f5162f8-07c6-11d3-9053-00c04fa302a1}.
        static const GUID CSharp;
        // Fortran.
        // Fortran is defined as {28731592-73f5-4ed0-a07b-f322c8ff9cac}.
        static const GUID Fortran;
        // Cobol.
        // Cobol is defined as {af046cd1-d0e1-11d2-977c-00a0c9b4d50c}.
        static const GUID Cobol;
        // Pascal.
        // Pascal is defined as {af046cd2-d0e1-11d2-977c-00a0c9b4d50c}.
        static const GUID Pascal;
        // Java.
        // Java is defined as {3a12d0b4-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID Java;
        // MSIL Assembly.
        // ILAssembly is defined as {af046cd3-d0e1-11d2-977c-00a0c9b4d50c}.
        static const GUID ILAssembly;
        // Language used for causality function breakpoints (ASMX).
        // CausalityBreakpoint is defined as {61d3986e-1220-4877-b909-096f0c29b0dd}.
        static const GUID CausalityBreakpoint;
        // Language used for specifying MVID/METHOD_TOKEN. This is used for Indigo. Example:
        // '{6AF7F59F-ED82-4f76-95BE-6BB908DBDC69}/06000001'.
        // MethodId is defined as {ee1ff7c4-775c-449c-a9c9-be4542742f64}.
        static const GUID MethodId;
        // Client side (targeting IE) script.
        // ClientScript is defined as {fdeabccd-1bec-4495-9624-f35e7dcf2c7f}.
        static const GUID ClientScript;
        // HLSL.
        // HLSL is defined as {53cd816a-fb44-4c89-8d93-af7e251de590}.
        static const GUID HLSL;
    };
    __declspec(selectany) const GUID DkmLanguageId::VB = { 0x3a12d0b8, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::JScript = { 0x3a12d0b6, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::C = { 0x63a08714, 0xfc37, 0x11d2, { 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };
    __declspec(selectany) const GUID DkmLanguageId::Cpp = { 0x3a12d0b7, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::SQL = { 0x3a12d0b9, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::Script = { 0xf7fa31da, 0xc32a, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::CSharp = { 0x3f5162f8, 0x7c6, 0x11d3, { 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };
    __declspec(selectany) const GUID DkmLanguageId::Fortran = { 0x28731592, 0x73f5, 0x4ed0, { 0xa0, 0x7b, 0xf3, 0x22, 0xc8, 0xff, 0x9c, 0xac } };
    __declspec(selectany) const GUID DkmLanguageId::Cobol = { 0xaf046cd1, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
    __declspec(selectany) const GUID DkmLanguageId::Pascal = { 0xaf046cd2, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
    __declspec(selectany) const GUID DkmLanguageId::Java = { 0x3a12d0b4, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::ILAssembly = { 0xaf046cd3, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
    __declspec(selectany) const GUID DkmLanguageId::CausalityBreakpoint = { 0x61d3986e, 0x1220, 0x4877, { 0xb9, 0x9, 0x9, 0x6f, 0xc, 0x29, 0xb0, 0xdd } };
    __declspec(selectany) const GUID DkmLanguageId::MethodId = { 0xee1ff7c4, 0x775c, 0x449c, { 0xa9, 0xc9, 0xbe, 0x45, 0x42, 0x74, 0x2f, 0x64 } };
    __declspec(selectany) const GUID DkmLanguageId::ClientScript = { 0xfdeabccd, 0x1bec, 0x4495, { 0x96, 0x24, 0xf3, 0x5e, 0x7d, 0xcf, 0x2c, 0x7f } };
    __declspec(selectany) const GUID DkmLanguageId::HLSL = { 0x53cd816a, 0xfb44, 0x4c89, { 0x8d, 0x93, 0xaf, 0x7e, 0x25, 0x1d, 0xe5, 0x90 } };

    // Pairing between an instruction address and the language that should be used to decode
    // it.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("42745737-3842-1f94-1ea8-2c310a3a61c1") DkmLanguageInstructionAddress : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmLanguageInstructionAddress::Create to create this object
        private: DkmLanguageInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLanguageInstructionAddress();
        // This object cannot be copied
        private: DkmLanguageInstructionAddress& operator=(const DkmLanguageInstructionAddress&);
        private: DkmLanguageInstructionAddress(const DkmLanguageInstructionAddress&);

        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: DkmInstructionAddress* const m_pAddress;
        private: void* m__pExtendedData;

        // Describes a programming language.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Abstract representation of an executable code location (ex: EIP value). If
        // resolved, an Instruction Address will be within a particular module instance. An
        // Instruction Address is always within a particular Runtime Instance.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE Address(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Create a new DkmLanguageInstructionAddress object instance.
        // pLanguage       : [In] Describes a programming language.
        // pAddress        : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ DkmInstructionAddress* pAddress,
            _Deref_out_ Evaluation::DkmLanguageInstructionAddress** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Compile the input expression so that it is ready for evaluation. A typical
        // expression evaluator may lex the input string, parse the tokens, bind the tokens
        // to symbols and possibly transform the expression into an intermediate
        // representation for evaluation. However, since this method returns no result on
        // success, all of this processing is optional and an expression evaluator may delay
        // all of this work to the 'EvaluateExpression' method. The advantage of performing
        // this work during 'Compile' is to issue any expression errors back to this user as
        // soon as possible, and to improve the performance of repeated evaluations.
        // Currently, these advantages show up in the user scenario of breakpoint conditions
        // -- 'Compile' errors can be shown to the user before the dialog closes, and as
        // breakpoints may be hit frequently, there may be noticeable performance advantages
        // of moving work from 'Evaluate' to 'Compile'. 'Compile' may also be used in HPC
        // scenarios where an expression is compiled against one input address and then
        // evaluated against the same method in various other processes.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pExpression     : [In] Expression to compile.
        // ppError         : [Out,Optional] Indicates any error compiling the expression. On
        // successful compilation, this value should be null. In error cases, this value is
        // used to indicate the reason for the compilation failure, and the caller should
        // return S_OK.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Compile(
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _Deref_out_opt_ Evaluation::DkmFailedEvaluationResult** ppError
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Compiles an input breakpoint condition into an inspection query which can be
        // evaluated on the target computer. If the breakpoint condition uses
        // DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should
        // require that the specified condition evaluates to a Boolean value. The created
        // query must return only a single result. For BreakWhenTrue conditions, this must be
        // either a 4-byte or 1-byte value, and any non-zero value is considered true.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pCondition      : [In] Breakpoint condition to compile.
        // ppCompiledCondition: [Out,Optional] The result of the compilation. This is null in
        // the case that the compilation failed. In this case, ErrorText should indicate the
        // reason for the failure.
        // ppErrorText     : [Out,Optional] If the compilation failed, this indicates the
        // reason why. This value should be null if the compile succeeded. If the compile
        // does fail, S_FALSE is returned (native code only).
        // Return value    : S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is
        // returned when *ppCompiledCondition is NULL, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileCondition(
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Provides a text representation for a method symbol. This is used when describing
        // an address in the UI, for example the 'Function' column in the breakpoints window.
        //
        // Location constraint: IDE components may call this method regardless of what type
        // of code is being debugged. This method is also currently supported for debug
        // monitor components, when debugging code running under the CLR; however this
        // functionality may be removed in a future version.
        // ArgumentFlags   : [In] Flags to indicate what information about the arguments
        // should be included in the method name.  As parameter values cannot be obtained
        // without a stack frame and a stack frame is not available here, the "Values" flag
        // will never be present.
        // ppMethodName    : [Out] Language's representation of the name of this method.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodName(
            _In_ Evaluation::DkmVariableInfoFlags::e ArgumentFlags,
            _Deref_out_ DkmString** ppMethodName
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Called during a Step-Into to determine special behavior for a particular function.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pStepIntoFlags  : [Out] Flags which describe how to proceed with a Step-Into
        // action.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStepIntoFlags(
            _Out_ Stepping::DkmLanguageStepIntoFlags::e* pStepIntoFlags
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmLanguageInstructionAddress

    // Set of platform dependent registers that may hold the return value of a function call.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b2c0ed0b-6a96-c138-034a-49a67ab87104") DkmNativeReturnValueRegister : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNativeReturnValueRegister::Create to create this object
        private: DkmNativeReturnValueRegister();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeReturnValueRegister();
        // This object cannot be copied
        private: DkmNativeReturnValueRegister& operator=(const DkmNativeReturnValueRegister&);
        private: DkmNativeReturnValueRegister(const DkmNativeReturnValueRegister&);

        private: const CV_HREG_e m_Identifier;
        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // The code-view register ID constant.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Identifier(
            );

        // The value of the register. The size of the register in bytes can be found by the
        // length of this array.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        // Create a new DkmNativeReturnValueRegister object instance.
        // Identifier      : [In] The code-view register ID constant.
        // pValue          : [In] The value of the register. The size of the register in
        // bytes can be found by the length of this array.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e Identifier,
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ Evaluation::DkmNativeReturnValueRegister** ppCreatedObject
            );
    }; // end of DkmNativeReturnValueRegister

    // DkmRawReturnValue carries sufficient context that can be used to partially reconstruct
    // and visualize a function-call's return value.
    //
    // Derived classes: DkmCustomRawReturnValue, DkmNativeRawReturnValue,
    // DkmRawManagedReturnValue
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("eecc8d2d-81c3-9823-e89f-1438471e579d") DkmRawReturnValue : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmRawReturnValue::Create to create this object
        private: DkmRawReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRawReturnValue();
        // This object cannot be copied
        private: DkmRawReturnValue& operator=(const DkmRawReturnValue&);
        private: DkmRawReturnValue(const DkmRawReturnValue&);

        // DkmRawReturnValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmNativeRawReturnValue'.
        NativeRawReturnValue = 0,
        // Object is an instance of 'DkmCustomRawReturnValue'.
        CustomRawReturnValue = 1,
        // Object is an instance of 'DkmRawManagedReturnValue'.
        ManagedReturnValue = 2
        }; };

        private: const Tag::e m_TagValue;
        private: DkmInstructionAddress* const m_pReturnFrom;
        private: void* m__pExtendedData;

        // DkmRawReturnValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // IP address within the symbol that was returned called and from.  Note that there's
        // no guarantee where in the function this address will be.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE ReturnFrom(
            );
    }; // end of DkmRawReturnValue

    // Flags the expression evaluator passes to the visualizer addin describing the value in
    // question. For instance, this will include if the object is a pointer or if it is a
    // reference.
    enum DkmRootVisualizedExpressionFlags::e
    {
        // No flags set.
        None = 0x1,
        // The expression being evaluated is a pointer. If expression evaluator normally
        // formats the address in the pointer in the value, and then dereferences the pointer
        // for child enumeration. An addin may choose to match this behavior.
        IsPointer = 0x2,
        // The expression being evaluated is a reference. If expression evaluator normally
        // dereferences the pointer for child enumeration and does not display the address in
        // the value column. An addin may choose to match this behavior.
        IsReference = 0x4,
        // The expression being evaluated is an array. If the parser was able to determine a
        // length for this array, it will be in the the ArrayLength property.
        IsArray = 0x8
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmRootVisualizedExpressionFlags::e);

    // Flags that indicate what information is requested for a variable.
    enum DkmVariableInfoFlags::e
    {
        // No flags are set.
        None = 0x0,
        // Provide information about the types of variables.
        Types = 0x1,
        // Types names should be provided as an alias rather than in their full form. For
        // example, return 'std::map<int,int>' instead of
        // 'std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >'.
        // This flag is only valid when paired with the 'Types' flag.
        TypeAliases = 0x2,
        // Provide information about the names of variables.
        Names = 0x4,
        // Provide full names of the variables.
        FullNames = 0x8,
        // Provide information about the values of variables.  This flag is set for
        // GetFrameName() when the user has toggled the option "Show Parameter Values". This
        // flag is never set for calls to GetMethodName().
        Values = 0x10
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmVariableInfoFlags::e);

    // Guid value which, along with the DkmLanguageId, can identify the compiler/interpreter
    // used to compile/interpret the target code. The vendor id is used along with the
    // language id to select expression evaluators. This value is used as many compilers may
    // exist for the same programming language. But even though the compilers may all use the
    // same programming language, they will generally not be able to use the same expression
    // evaluator.
    struct DkmVendorId
    {
        // Indicates that the compiler/interpreter was produced by Microsoft.
        // Microsoft is defined as {994b45c4-e6e9-11d2-903f-00c04fa302a1}.
        static const GUID Microsoft;
    };
    __declspec(selectany) const GUID DkmVendorId::Microsoft = { 0x994b45c4, 0xe6e9, 0x11d2, { 0x90, 0x3f, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };

    // Dispatcher object used for custom visualization through a concord EE addin.
    //
    // Derived classes: DkmChildVisualizedExpression, DkmRootVisualizedExpression
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2db1132d-77a6-ae00-a7f7-b2c910327b56") DkmVisualizedExpression : public DkmDataContainer
    {
        // Use DkmVisualizedExpression::Create to create this object
        private: DkmVisualizedExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmVisualizedExpression();
        // This object cannot be copied
        private: DkmVisualizedExpression& operator=(const DkmVisualizedExpression&);
        private: DkmVisualizedExpression(const DkmVisualizedExpression&);

        // DkmVisualizedExpression is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmRootVisualizedExpression'.
        RootVisualizedExpression = 0,
        // Object is an instance of 'DkmChildVisualizedExpression'.
        ChildVisualizedExpression = 1
        }; };

        private: const Tag::e m_TagValue;
        private: Evaluation::DkmInspectionContext* const m_pInspectionContext;
        private: const GUID m_UniqueId;
        private: const GUID m_VisualizerId;
        private: const GUID m_SourceId;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: OPTIONAL Evaluation::DkmExpressionValueHome* const m_pValueHome;
        private: void* m__pExtendedData;

        // DkmVisualizedExpression is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // Options and target context to use while performing the inspection operation.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionContext* STDMETHODCALLTYPE InspectionContext(
            );

        // Guid which uniquely identifies this instance.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Guid which ties together the addin and the expressions that call that addin. The
        // addin should use the Guid provided in the native visualizer file as a filter.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE VisualizerId(
            );

        // Guid which ties together the expression evaluator that created this object and the
        // object itself. Generally used by expression evaluators to filter their
        // implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression
        // they created.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Stack frame the expression is being evaluated in expression in.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // [Optional] The location at which the value is stored, which can be modified to
        // edit the value.  This should be null for read-only values, such as integer
        // constants.
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmExpressionValueHome* STDMETHODCALLTYPE ValueHome(
            );

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes a DkmVisualizedExpression object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmVisualizedExpression objects are automatically closed when their associated
        // DkmInspectionSession object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Evaluate a visualized expression returning a DkmEvaluationResult for it.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppResultObject  : [Out] Object containing the result of the evaluation. This
        // object must be closed by the caller when the caller is done with the object. The
        // expression evaluator reserves the right to override this instance so do not rely
        // on storing data items in the DkmEvaluationResult instance. Use the
        // DkmVisualizedExpression instance as a data container instead.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateVisualizedExpression(
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Called by the expression evaluator when a visualized expression's children are
        // being expanded, the the value is being set, or the underlying string is being
        // obtained. If the visualizer addin wants complete control of the expression it
        // should return false. It will then receive calls to GetChildren, GetItems,
        // SetValueAsString, and GetUnderlyingString. If the visualizer addin wants to
        // completely defer these operations to the expression evaluator, it should return
        // true. It must also give the expression evaluator back the instance of
        // DkmEvaluationResult that came from the EE via one of the
        // IDkmCustomVisualizerCallback methods. Note that the addin MUST have obtained the
        // default DkmEvaluationResult from the EE if it wants the EE to control the object.
        // Returning true from this method is primarily used by visualizer addins that just
        // tweak something small like the view of a value but don't want to modify expansion
        // or setting values.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pUseDefaultEvaluationBehavior: [Out] Return true to use default expansion, false
        // otherwise.
        // ppDefaultEvaluationResult: [Out,Optional] The instance of DkmEvaluationResult
        // returned from a call to one of the methods of IDkmCustomVisualizerCallback. The
        // expression evaluator can only control DkmEvaluationResults it understands.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UseDefaultEvaluationBehavior(
            _Out_ bool* pUseDefaultEvaluationBehavior,
            _Deref_out_opt_ Evaluation::DkmEvaluationResult** ppDefaultEvaluationResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Gets an enumeration context used to obtain the children of this evaluation result.
        // This is used in all expression evaluation windows.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // InitialRequestSize: [In] The initial number of children that the caller would like
        // returned. This value can be zero if no children will be initially returned. This
        // value may be larger than the number of children that this expression has, in which
        // case all children should be returned. Very large or negative values should not be
        // used as arrays can have extremely large sizes which would cause out-of-memory if
        // all elements were requested.
        // pInspectionContext: [In] The inspection context to use for computing the children.
        // This may differ from the original inspection context with respect to settings,
        // such as radix, evaluation flags, or timeout.
        // pInitialChildren: [Out] The initial children to return.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppEnumContext   : [Out] Context object used to enumerate the children. This object
        // must be closed by the caller of this API when enumeration is complete.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Called to obtain items from a instance of DkmEvaluationResultEnumContext created
        // by an earlier call to GetChildren.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pEnumContext    : [In] The enum context to use for this call. This instance will
        // have been returned from a previous call to DkmVisualizedExpression.
        // StartIndex      : [In] The zero-based index of the first item to obtain.
        // Count           : [In] The number of items to try and return. This value may be
        // larger than the total number of remaining items, in which case all remaining items
        // should be returned. Very large or negative values should not be used as arrays can
        // have extremely large sizes which would cause out-of-memory if all elements were
        // requested.
        // pItems          : [Out] The DkmChildVisualizedExpression items to return.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pItems
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Modifies the value of the given evaluation result (assumed to be non-read-only) to
        // match the given string. This is used after the user edits a value in any of the
        // evaluation windows.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pValue          : [In] Textual representation of value to assign to the evaluation
        // result.
        // Timeout         : [In] If a function evaluation is needed to assign the value,
        // specifies the timeout to use.
        // ppErrorText     : [Out,Optional] If the operation failed, this indicates the
        // reason why. This value should be null if the operation succeeded. In native code,
        // an S_OK return value is used when returning error text.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // This method is used for evaluation results that include
        // DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        // enclosing quotes or escape sequences. This is method is invoked to display one of
        // the various string visualizers in an expression evaluation window (click the
        // magnifying glass icon).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppStringValue   : [Out,Optional] The underlying string value.
        // Return value    : S_OK is returned if *ppStringValue is non-NULL, S_FALSE is
        // returned when *ppStringValue is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _Deref_out_opt_ DkmString** ppStringValue
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Allows custom expression evaluator addins to obtain the symbol interface for the
        // type being visualized. This is not stored in the DkmVisualizedExpression directly
        // to enable addins that live on the remote machine and do not depend on symbols.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // TypeSymbolInterfaceId: [In] The GUID of the TypeSymbolInterface interface
        // requested from the caller. For the Microsoft native C++ expression evaluator, this
        // should be IID_IDiaSymbol.
        // ppTypeSymbolInterface: [Out] The symbol interface of the type that was used to
        // evaluate the expression.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ const GUID& TypeSymbolInterfaceId,
            _Deref_out_ IUnknown** ppTypeSymbolInterface
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // This method allows a visualizer addin use the expression evaluator to compile and
        // evaluate the default value for an expression. The addin can use this result as-is
        // or override fields by creating a new result. The addin can also choose to use the
        // expression evaluator for expansion using the the get children callbacks.
        // pInspectionContext: [In] The inspection context to use for this evaluation.
        // pExpression     : [In] The expression the visualizer addin to would like the
        // expression evaluator to evaluate.
        // pStackFrame     : [In] Stack frame to evaluate the expression in.
        // ppResultObject  : [Out] Object containing the result of the evaluation.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_PROCESS_DESTROYED indicates that the process exited while attempting to
        // evaluate.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateExpressionCallback(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            );

        // This method will construct a default full name for a custom visualized child
        // expression. This name will be the root expression's full name and an expand format
        // string that will cause the expression evaluator to callback to the visualizer to
        // obtain children. The DkmVisualizedExpression instance this is called on should be
        // the parent visualized expression for a child and the root visualized expression
        // for a root.
        // Index           : [In] The index of child for which this full name is created.
        // Ignored in the case of a root item.
        // ppFullName      : [Out] The returned full name string.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDefaultChildFullName(
            _In_ INT32 Index,
            _Deref_out_ DkmString** ppFullName
            );

        // This method allows a visualizer addin use the expression evaluator for expansion.
        // The evaluation result contained within the visualized expression must have come
        // from the expression evaluator via EvaluateExpressionCallback.
        // pDefaultEvaluationResult: [In] The evaluation result returned from the expression
        // evaluator for this expression. The expression evaluator can only control the
        // expansion of evaluations it understands.
        // InitialRequestSize: [In] The initial number of children that the caller would like
        // returned. This value can be zero if no children will be initially returned. This
        // value may be larger than the number of children that this expression has, in which
        // case all children should be returned. Very large or negative values should not be
        // used as arrays can have extremely large sizes which would cause out-of-memory if
        // all elements were requested.
        // pInspectionContext: [In] The inspection context to use for computing the children.
        // This may differ from the original inspection context with respect to settings,
        // such as radix, evaluation flags, or timeout.
        // pInitialChildren: [Out] The initial children to return. Each child must be closed
        // by the caller when the caller is done.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppEnumContext   : [Out] Context object used to enumerate the children. This object
        // must be closed by the caller of this API when enumeration is complete.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildrenCallback(
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            );

        // This method allows a visualizer addin use the expression evaluator for expansion
        // using the passed enumeration context. This is used to obtain local variables of a
        // stack frame or child members from an evaluation result.
        // pEnumContext    : [In] Context object used to enumerate the children.
        // StartIndex      : [In] The zero-based index of the first item to obtain.
        // Count           : [In] The number of items to try and return. This value may be
        // larger than the total number of remaining items, in which case all remaining items
        // should be returned. Very large or negative values should not be used as arrays can
        // have extremely large sizes which would cause out-of-memory if all elements were
        // requested.
        // pItems          : [Out] The DkmEvaluationResult items to return. Each item must be
        // closed by the caller when the caller is done.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetItemsCallback(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pItems
            );

        // Modifies the value of the given evaluation result (assumed to be non-read-only) to
        // match the given string. This is used after the user edits a value in any of the
        // evaluation windows.
        // pDefaultEvaluationResult: [In] The evaluation result returned from the expression
        // evaluator for this expression. The expression evaluator can only control
        // evaluations it understands.
        // pValue          : [In] Textual representation of value to assign to the evaluation
        // result.
        // Timeout         : [In] If a function evaluation is needed to assign the value,
        // specifies the timeout to use.
        // ppErrorText     : [Out,Optional] If the operation failed, this indicates the
        // reason why. This value should be null if the operation succeeded. In native code,
        // an S_OK return value is used when returning error text.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetValueAsStringCallback(
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            );

        // This method is used for evaluation results that include
        // DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        // enclosing quotes or escape sequences. This is method is invoked to display one of
        // the various string visualizers in an expression evaluation window (click the
        // magnifying glass icon).
        // pDefaultEvaluationResult: [In] The evaluation result returned from the expression
        // evaluator for this expression. The expression evaluator can only control
        // evaluations it understands.
        // ppStringValue   : [Out,Optional] The underlying string value.
        // Return value    : S_OK is returned if *ppStringValue is non-NULL, S_FALSE is
        // returned when *ppStringValue is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingStringCallback(
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _Deref_out_opt_ DkmString** ppStringValue
            );
    }; // end of DkmVisualizedExpression


    // Dispatcher object which represents a child node of a visualized expression. Each node
    // returned from GetChildren / GetItems should be an instance of this object..
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("08e6ff27-0cdf-ea67-dc1a-4fa958d3fbbd") DkmChildVisualizedExpression : public Evaluation::DkmVisualizedExpression
    {
        // Use DkmChildVisualizedExpression::Create to create this object
        private: DkmChildVisualizedExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmChildVisualizedExpression();
        // This object cannot be copied
        private: DkmChildVisualizedExpression& operator=(const DkmChildVisualizedExpression&);
        private: DkmChildVisualizedExpression(const DkmChildVisualizedExpression&);

        private: Evaluation::DkmEvaluationResult* const m_pEvaluationResult;
        private: Evaluation::DkmVisualizedExpression* const m_pParent;
        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // The result of evaluating this visualized child. The expression evaluator reserves
        // the right to override this instance so do not rely on storing data items in the
        // DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as a data
        // container instead.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmEvaluationResult* STDMETHODCALLTYPE EvaluationResult(
            );

        // The Parent of this visualized child.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmVisualizedExpression* STDMETHODCALLTYPE Parent(
            );

        // The index of this child in the parent object's child collection. The expression
        // evaluator will use this when processing the full name of a child item. The full
        // name is used when the user clicks on an item and says Add To Watch or when the
        // user types something in the watch window directly. If the visualizer does not
        // provide a full name, then callback to the expression evaluator to construct a
        // default expand expression  The value of the index field will be used to obtain the
        // correct expand expression.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // Attempt to cast a 'DkmVisualizedExpression' to a 'DkmChildVisualizedExpression'. Return
        // NULL if the path object is not a 'DkmChildVisualizedExpression'.
        // pChildVisualizedExpression : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmChildVisualizedExpression* TryCast(
            DkmVisualizedExpression* pVisualizedExpression
            )
        {
            if (pVisualizedExpression == NULL || pVisualizedExpression->TagValue() != Tag::ChildVisualizedExpression)
                return NULL;

            return static_cast<DkmChildVisualizedExpression*>(pVisualizedExpression);
        }

        // Create a new DkmChildVisualizedExpression object instance.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // VisualizerId    : [In] Guid which ties together the addin and the expressions that
        // call that addin. The addin should use the Guid provided in the native visualizer
        // file as a filter.
        // SourceId        : [In] Guid which ties together the expression evaluator that
        // created this object and the object itself. Generally used by expression evaluators
        // to filter their implementation of IDkmCustomVisualizerCallback to only
        // DkmVisualizedExpression they created.
        // pStackFrame     : [In] Stack frame the expression is being evaluated in expression
        // in.
        // pValueHome      : [In,Optional] The location at which the value is stored, which
        // can be modified to edit the value.  This should be null for read-only values, such
        // as integer constants.
        // pEvaluationResult: [In] The result of evaluating this visualized child. The
        // expression evaluator reserves the right to override this instance so do not rely
        // on storing data items in the DkmEvaluationResult instance. Use the
        // DkmVisualizedExpression instance as a data container instead.
        // pParent         : [In] The Parent of this visualized child.
        // Index           : [In] The index of this child in the parent object's child
        // collection. The expression evaluator will use this when processing the full name
        // of a child item. The full name is used when the user clicks on an item and says
        // Add To Watch or when the user types something in the watch window directly. If the
        // visualizer does not provide a full name, then callback to the expression evaluator
        // to construct a default expand expression  The value of the index field will be
        // used to obtain the correct expand expression.
        // DataItem        : [In] Data object to add to the new DkmChildVisualizedExpression
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const GUID& VisualizerId,
            _In_ const GUID& SourceId,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ Evaluation::DkmExpressionValueHome* pValueHome,
            _In_ Evaluation::DkmEvaluationResult* pEvaluationResult,
            _In_ Evaluation::DkmVisualizedExpression* pParent,
            _In_ UINT32 Index,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmChildVisualizedExpression** ppCreatedObject
            );
    }; // end of DkmChildVisualizedExpression

    // An inspection query compiled to a custom format. The RuntimeType indicates the format
    // of the query.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("951e8d5e-e5f3-78d8-3492-0b2615b06e42") DkmCompiledCustomInspectionQuery : public Evaluation::DkmCompiledInspectionQuery
    {
        // Use DkmCompiledCustomInspectionQuery::Create to create this object
        private: DkmCompiledCustomInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledCustomInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledCustomInspectionQuery& operator=(const DkmCompiledCustomInspectionQuery&);
        private: DkmCompiledCustomInspectionQuery(const DkmCompiledCustomInspectionQuery&);

        private: DkmReadOnlyCollection<BYTE>* const m_pInstructions;
        private: void* m__pExtendedData;

        // Body of the query.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Instructions(
            );

        // Attempt to cast a 'DkmCompiledInspectionQuery' to a 'DkmCompiledCustomInspectionQuery'. Return
        // NULL if the path object is not a 'DkmCompiledCustomInspectionQuery'.
        // pCustomQuery : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCompiledCustomInspectionQuery* TryCast(
            DkmCompiledInspectionQuery* pQuery
            )
        {
            if (pQuery == NULL || pQuery->TagValue() != Tag::CustomQuery)
                return NULL;

            return static_cast<DkmCompiledCustomInspectionQuery*>(pQuery);
        }

        // Create a new DkmCompiledCustomInspectionQuery object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // QueryKind       : [In] Indicates the type of inspection query. This is used to
        // select a component to process the query.
        // pInstructions   : [In] Body of the query.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& QueryKind,
            _In_ DkmReadOnlyCollection<BYTE>* pInstructions,
            _Deref_out_ Evaluation::DkmCompiledCustomInspectionQuery** ppCreatedObject
            );
    }; // end of DkmCompiledCustomInspectionQuery

    // DkmCustomRawReturnValue carries sufficient context that can be used to partially
    // reconstruct and visualize a function-call's return value in a custom runtime
    // environment.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("911c2fd8-96c3-e527-3e60-c2dc9c429d21") DkmCustomRawReturnValue : public Evaluation::DkmRawReturnValue
    {
        // Use DkmCustomRawReturnValue::Create to create this object
        private: DkmCustomRawReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomRawReturnValue();
        // This object cannot be copied
        private: DkmCustomRawReturnValue& operator=(const DkmCustomRawReturnValue&);
        private: DkmCustomRawReturnValue(const DkmCustomRawReturnValue&);

        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // Custom raw return value.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmRawReturnValue' to a 'DkmCustomRawReturnValue'. Return
        // NULL if the path object is not a 'DkmCustomRawReturnValue'.
        // pCustomRawReturnValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomRawReturnValue* TryCast(
            DkmRawReturnValue* pRawReturnValue
            )
        {
            if (pRawReturnValue == NULL || pRawReturnValue->TagValue() != Tag::CustomRawReturnValue)
                return NULL;

            return static_cast<DkmCustomRawReturnValue*>(pRawReturnValue);
        }

        // Create a new DkmCustomRawReturnValue object instance.
        // pReturnFrom     : [In] IP address within the symbol that was returned called and
        // from.  Note that there's no guarantee where in the function this address will be.
        // pValue          : [In] Custom raw return value.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmInstructionAddress* pReturnFrom,
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ Evaluation::DkmCustomRawReturnValue** ppCreatedObject
            );
    }; // end of DkmCustomRawReturnValue

    // The formatted result of a failed evaluation, ready to be displayed in an expression
    // evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("066fdcd5-e1d5-a0ba-95c4-f4c4973557fc") DkmFailedEvaluationResult : public Evaluation::DkmEvaluationResult
    {
        // Use DkmFailedEvaluationResult::Create to create this object
        private: DkmFailedEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFailedEvaluationResult();
        // This object cannot be copied
        private: DkmFailedEvaluationResult& operator=(const DkmFailedEvaluationResult&);
        private: DkmFailedEvaluationResult(const DkmFailedEvaluationResult&);

        // Contains additional fields of DkmFailedEvaluationResult which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] A string that describes the type of the value.
            OPTIONAL DkmString* const pType;
        };

        private: DkmString* const m_pErrorMessage;
        private: const Evaluation::DkmEvaluationResultFlags::e m_Flags;
        private: ___ExtendedData* const m__pExtendedData;

        // Specifies the error message to display to the user.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ErrorMessage(
            );

        // Flags which indicate attributes of an expression evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags::e STDMETHODCALLTYPE Flags(
            );

        // [Optional] A string that describes the type of the value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmEvaluationResult' to a 'DkmFailedEvaluationResult'. Return
        // NULL if the path object is not a 'DkmFailedEvaluationResult'.
        // pFailedResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmFailedEvaluationResult* TryCast(
            DkmEvaluationResult* pResult
            )
        {
            if (pResult == NULL || pResult->TagValue() != Tag::FailedResult)
                return NULL;

            return static_cast<DkmFailedEvaluationResult*>(pResult);
        }

        // Create a new DkmFailedEvaluationResult object instance.
        // pInspectionContext: [In] Inspection context used to create this evaluation result.
        // pStackFrame     : [In] The stack frame this expression result was created on.
        // pName           : [In] The name of the expression this result applies to.
        // pFullName       : [In,Optional] The full name of the expression this result
        // applies to. This value is used to allow child elements to be added to the watch
        // window (Add Watch from the context menu), and to refresh parts of the evaluation
        // tree. As an example of how FullName differs from name, the name of the 0th element
        // of an array in C++ is '[0]' while the full name would by 'myArrayVariable[0]'.
        // pErrorMessage   : [In] Specifies the error message to display to the user.
        // Flags           : [In] Flags which indicate attributes of an expression evaluation
        // result.
        // DataItem        : [In] Data object to add to the new DkmFailedEvaluationResult
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmString* pErrorMessage,
            _In_ Evaluation::DkmEvaluationResultFlags::e Flags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmFailedEvaluationResult** ppCreatedObject
            );

        // Create a new DkmFailedEvaluationResult object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionContext: [In] Inspection context used to create this evaluation result.
        // pStackFrame     : [In] The stack frame this expression result was created on.
        // pName           : [In] The name of the expression this result applies to.
        // pFullName       : [In,Optional] The full name of the expression this result
        // applies to. This value is used to allow child elements to be added to the watch
        // window (Add Watch from the context menu), and to refresh parts of the evaluation
        // tree. As an example of how FullName differs from name, the name of the 0th element
        // of an array in C++ is '[0]' while the full name would by 'myArrayVariable[0]'.
        // pErrorMessage   : [In] Specifies the error message to display to the user.
        // Flags           : [In] Flags which indicate attributes of an expression evaluation
        // result.
        // pType           : [In,Optional] A string that describes the type of the value.
        // DataItem        : [In] Data object to add to the new DkmFailedEvaluationResult
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmString* pErrorMessage,
            _In_ Evaluation::DkmEvaluationResultFlags::e Flags,
            _In_opt_ DkmString* pType,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmFailedEvaluationResult** ppCreatedObject
            );
    }; // end of DkmFailedEvaluationResult

    // An instance of DkmExpressionValueHome that does not represent anything real. Normally
    // used to represent values that do not actually exist in the debuggee.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c9ee3ff6-d57e-80e4-f57e-e00fad2f7fab") DkmFakeValueHome : public Evaluation::DkmExpressionValueHome
    {
        // Use DkmFakeValueHome::Create to create this object
        private: DkmFakeValueHome();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFakeValueHome();
        // This object cannot be copied
        private: DkmFakeValueHome& operator=(const DkmFakeValueHome&);
        private: DkmFakeValueHome(const DkmFakeValueHome&);

        private: const UINT64 m_Address;
        private: void* m__pExtendedData;

        // A straight linear address in the debuggee process.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Attempt to cast a 'DkmExpressionValueHome' to a 'DkmFakeValueHome'. Return
        // NULL if the path object is not a 'DkmFakeValueHome'.
        // pFakeValueHome : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmFakeValueHome* TryCast(
            DkmExpressionValueHome* pExpressionValueHome
            )
        {
            if (pExpressionValueHome == NULL || pExpressionValueHome->TagValue() != Tag::FakeValueHome)
                return NULL;

            return static_cast<DkmFakeValueHome*>(pExpressionValueHome);
        }

        // Create a new DkmFakeValueHome object instance.
        // Address         : [In] A straight linear address in the debuggee process.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT64 Address,
            _Deref_out_ Evaluation::DkmFakeValueHome** ppCreatedObject
            );
    }; // end of DkmFakeValueHome

    // The formatted result of an evaluation that must be re-evaluated by a different
    // Expression Evaluator.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1fe38f12-16e3-0c9d-7bdb-91aabf324221") DkmIntermediateEvaluationResult : public Evaluation::DkmEvaluationResult
    {
        // Use DkmIntermediateEvaluationResult::Create to create this object
        private: DkmIntermediateEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmIntermediateEvaluationResult();
        // This object cannot be copied
        private: DkmIntermediateEvaluationResult& operator=(const DkmIntermediateEvaluationResult&);
        private: DkmIntermediateEvaluationResult(const DkmIntermediateEvaluationResult&);

        private: DkmString* const m_pExpression;
        private: Evaluation::DkmLanguage* const m_pIntermediateLanguage;
        private: DkmRuntimeInstance* const m_pTargetRuntime;
        private: void* m__pExtendedData;

        // Expression that should be evaluated by a different Expression Evaluator than the
        // one that generated the DkmIntermediateResult.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Expression(
            );

        // The language of Expression.  This is different from
        // DkmEvaluationResult->Language(), which specifies the language of the initial
        // evaluation. IntermediateLanguage specifies the language of the re-evaluation.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE IntermediateLanguage(
            );

        // The runtime of the Expression Evaluator that would consume the intermediate result
        // and produce a final result.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE TargetRuntime(
            );

        // Attempt to cast a 'DkmEvaluationResult' to a 'DkmIntermediateEvaluationResult'. Return
        // NULL if the path object is not a 'DkmIntermediateEvaluationResult'.
        // pIntermediateResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmIntermediateEvaluationResult* TryCast(
            DkmEvaluationResult* pResult
            )
        {
            if (pResult == NULL || pResult->TagValue() != Tag::IntermediateResult)
                return NULL;

            return static_cast<DkmIntermediateEvaluationResult*>(pResult);
        }

        // Create a new DkmIntermediateEvaluationResult object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionContext: [In] Inspection context used to create this evaluation result.
        // pStackFrame     : [In] The stack frame this expression result was created on.
        // pName           : [In] The name of the expression this result applies to.
        // pFullName       : [In,Optional] The full name of the expression this result
        // applies to. This value is used to allow child elements to be added to the watch
        // window (Add Watch from the context menu), and to refresh parts of the evaluation
        // tree. As an example of how FullName differs from name, the name of the 0th element
        // of an array in C++ is '[0]' while the full name would by 'myArrayVariable[0]'.
        // pExpression     : [In] Expression that should be evaluated by a different
        // Expression Evaluator than the one that generated the DkmIntermediateResult.
        // pIntermediateLanguage: [In] The language of Expression.  This is different from
        // DkmEvaluationResult->Language(), which specifies the language of the initial
        // evaluation. IntermediateLanguage specifies the language of the re-evaluation.
        // pTargetRuntime  : [In] The runtime of the Expression Evaluator that would consume
        // the intermediate result and produce a final result.
        // DataItem        : [In] Data object to add to the new
        // DkmIntermediateEvaluationResult instance. DkmDataItem::Null() in the case that the
        // caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmString* pExpression,
            _In_ Evaluation::DkmLanguage* pIntermediateLanguage,
            _In_ DkmRuntimeInstance* pTargetRuntime,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmIntermediateEvaluationResult** ppCreatedObject
            );
    }; // end of DkmIntermediateEvaluationResult

    // DkmNativeRawReturnValue carries sufficient context that can be used to partially
    // reconstruct and visualize a function-call's return value within the context of Native
    // stepping.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("694dbdcd-80b2-9743-a624-3629d195f5b4") DkmNativeRawReturnValue : public Evaluation::DkmRawReturnValue
    {
        // Use DkmNativeRawReturnValue::Create to create this object
        private: DkmNativeRawReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeRawReturnValue();
        // This object cannot be copied
        private: DkmNativeRawReturnValue& operator=(const DkmNativeRawReturnValue&);
        private: DkmNativeRawReturnValue(const DkmNativeRawReturnValue&);

        private: DkmReadOnlyCollection<Evaluation::DkmNativeReturnValueRegister*>* const m_pRegisters;
        private: DkmReadOnlyCollection<BYTE>* const m_pMemory;
        private: void* m__pExtendedData;

        // Set of platform dependent registers that may hold the return value.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmNativeReturnValueRegister*>* STDMETHODCALLTYPE Registers(
            );

        // The result of copying some (platform dependent) number of bytes at the address
        // referenced by the (platform dependent) return-value register.  May be used to
        // provide visualizations for pointer return values.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Memory(
            );

        // Attempt to cast a 'DkmRawReturnValue' to a 'DkmNativeRawReturnValue'. Return
        // NULL if the path object is not a 'DkmNativeRawReturnValue'.
        // pNativeRawReturnValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeRawReturnValue* TryCast(
            DkmRawReturnValue* pRawReturnValue
            )
        {
            if (pRawReturnValue == NULL || pRawReturnValue->TagValue() != Tag::NativeRawReturnValue)
                return NULL;

            return static_cast<DkmNativeRawReturnValue*>(pRawReturnValue);
        }

        // Create a new DkmNativeRawReturnValue object instance.
        // pReturnFrom     : [In] IP address within the symbol that was returned called and
        // from.  Note that there's no guarantee where in the function this address will be.
        // pRegisters      : [In] Set of platform dependent registers that may hold the
        // return value.
        // pMemory         : [In] The result of copying some (platform dependent) number of
        // bytes at the address referenced by the (platform dependent) return-value register.
        // May be used to provide visualizations for pointer return values.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmInstructionAddress* pReturnFrom,
            _In_ DkmReadOnlyCollection<Evaluation::DkmNativeReturnValueRegister*>* pRegisters,
            _In_ DkmReadOnlyCollection<BYTE>* pMemory,
            _Deref_out_ Evaluation::DkmNativeRawReturnValue** ppCreatedObject
            );
    }; // end of DkmNativeRawReturnValue

    // An instance of DkmExpressionValueHome that defines a linear address in the debuggee.
    // The expression evaluator addin should format the object pointed to by this address.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bea748f3-61f0-5175-ef91-1b4b1f6e4cca") DkmPointerValueHome : public Evaluation::DkmExpressionValueHome
    {
        // Use DkmPointerValueHome::Create to create this object
        private: DkmPointerValueHome();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPointerValueHome();
        // This object cannot be copied
        private: DkmPointerValueHome& operator=(const DkmPointerValueHome&);
        private: DkmPointerValueHome(const DkmPointerValueHome&);

        private: const UINT64 m_Address;
        private: void* m__pExtendedData;

        // A straight linear address in the debuggee process.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Attempt to cast a 'DkmExpressionValueHome' to a 'DkmPointerValueHome'. Return
        // NULL if the path object is not a 'DkmPointerValueHome'.
        // pPointerValueHome : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPointerValueHome* TryCast(
            DkmExpressionValueHome* pExpressionValueHome
            )
        {
            if (pExpressionValueHome == NULL || pExpressionValueHome->TagValue() != Tag::PointerValueHome)
                return NULL;

            return static_cast<DkmPointerValueHome*>(pExpressionValueHome);
        }

        // Create a new DkmPointerValueHome object instance.
        // Address         : [In] A straight linear address in the debuggee process.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT64 Address,
            _Deref_out_ Evaluation::DkmPointerValueHome** ppCreatedObject
            );
    }; // end of DkmPointerValueHome

    // DkmRawManagedReturnValue carries method-call's return value within the context of
    // managed stepping.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bac1944f-d24a-e177-8b80-48d02d5b4839") DkmRawManagedReturnValue : public Evaluation::DkmRawReturnValue
    {
        // Use DkmRawManagedReturnValue::Create to create this object
        private: DkmRawManagedReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRawManagedReturnValue();
        // This object cannot be copied
        private: DkmRawManagedReturnValue& operator=(const DkmRawManagedReturnValue&);
        private: DkmRawManagedReturnValue(const DkmRawManagedReturnValue&);

        private: Clr::DkmManagedReturnValueContext* const m_pContext;
        private: void* m__pExtendedData;

        // Context information wraps method's return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmManagedReturnValueContext* STDMETHODCALLTYPE Context(
            );

        // Attempt to cast a 'DkmRawReturnValue' to a 'DkmRawManagedReturnValue'. Return
        // NULL if the path object is not a 'DkmRawManagedReturnValue'.
        // pManagedReturnValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRawManagedReturnValue* TryCast(
            DkmRawReturnValue* pRawReturnValue
            )
        {
            if (pRawReturnValue == NULL || pRawReturnValue->TagValue() != Tag::ManagedReturnValue)
                return NULL;

            return static_cast<DkmRawManagedReturnValue*>(pRawReturnValue);
        }

        // Create a new DkmRawManagedReturnValue object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pReturnFrom     : [In] IP address within the symbol that was returned called and
        // from.  Note that there's no guarantee where in the function this address will be.
        // pContext        : [In] Context information wraps method's return value.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmInstructionAddress* pReturnFrom,
            _In_ Clr::DkmManagedReturnValueContext* pContext,
            _Deref_out_ Evaluation::DkmRawManagedReturnValue** ppCreatedObject
            );
    }; // end of DkmRawManagedReturnValue

    // Dispatcher object which represents a top-level visualized expression. An instance is
    // created by the expression evaluator when it determines a type should be visualized.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("78ad085c-7b73-5937-a063-e2c7f4ee6556") DkmRootVisualizedExpression : public Evaluation::DkmVisualizedExpression
    {
        // Use DkmRootVisualizedExpression::Create to create this object
        private: DkmRootVisualizedExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRootVisualizedExpression();
        // This object cannot be copied
        private: DkmRootVisualizedExpression& operator=(const DkmRootVisualizedExpression&);
        private: DkmRootVisualizedExpression(const DkmRootVisualizedExpression&);

        private: OPTIONAL Symbols::DkmModule* const m_pModule;
        private: DkmString* const m_pName;
        private: DkmString* const m_pFullName;
        private: const Evaluation::DkmRootVisualizedExpressionFlags::e m_Flags;
        private: const UINT32 m_ArrayLength;
        private: void* m__pExtendedData;

        // [Optional] The module that contains the type symbol.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // The name of the expression up to the root node. Addins can choose to use this name
        // or construct their own.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // The full name of the expression up to the root node. Addins can choose to use this
        // full name or construct their own. However, if the addin uses a different full
        // name, it must be parsed by the expression evaluator.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Flags the expression evaluator passes to the visualizer addin describing the value
        // in question. For instance, this will include if the object is a pointer or if it
        // is a reference.
        public: DECLSPEC_NOTHROW Evaluation::DkmRootVisualizedExpressionFlags::e STDMETHODCALLTYPE Flags(
            );

        // If this is an array and the expression evaluator was able to determine the length
        // of that array, this will be non-zero. Note that are cases where the expression
        // evaluator will not be able to provide this data.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArrayLength(
            );

        // Attempt to cast a 'DkmVisualizedExpression' to a 'DkmRootVisualizedExpression'. Return
        // NULL if the path object is not a 'DkmRootVisualizedExpression'.
        // pRootVisualizedExpression : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRootVisualizedExpression* TryCast(
            DkmVisualizedExpression* pVisualizedExpression
            )
        {
            if (pVisualizedExpression == NULL || pVisualizedExpression->TagValue() != Tag::RootVisualizedExpression)
                return NULL;

            return static_cast<DkmRootVisualizedExpression*>(pVisualizedExpression);
        }

        // Create a new DkmRootVisualizedExpression object instance.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // VisualizerId    : [In] Guid which ties together the addin and the expressions that
        // call that addin. The addin should use the Guid provided in the native visualizer
        // file as a filter.
        // SourceId        : [In] Guid which ties together the expression evaluator that
        // created this object and the object itself. Generally used by expression evaluators
        // to filter their implementation of IDkmCustomVisualizerCallback to only
        // DkmVisualizedExpression they created.
        // pStackFrame     : [In] Stack frame the expression is being evaluated in expression
        // in.
        // pValueHome      : [In,Optional] The location at which the value is stored, which
        // can be modified to edit the value.  This should be null for read-only values, such
        // as integer constants.
        // pModule         : [In,Optional] The module that contains the type symbol.
        // pName           : [In] The name of the expression up to the root node. Addins can
        // choose to use this name or construct their own.
        // pFullName       : [In] The full name of the expression up to the root node. Addins
        // can choose to use this full name or construct their own. However, if the addin
        // uses a different full name, it must be parsed by the expression evaluator.
        // Flags           : [In] Flags the expression evaluator passes to the visualizer
        // addin describing the value in question. For instance, this will include if the
        // object is a pointer or if it is a reference.
        // ArrayLength     : [In] If this is an array and the expression evaluator was able
        // to determine the length of that array, this will be non-zero. Note that are cases
        // where the expression evaluator will not be able to provide this data.
        // DataItem        : [In] Data object to add to the new DkmRootVisualizedExpression
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const GUID& VisualizerId,
            _In_ const GUID& SourceId,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ Evaluation::DkmExpressionValueHome* pValueHome,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ Evaluation::DkmRootVisualizedExpressionFlags::e Flags,
            _In_ UINT32 ArrayLength,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmRootVisualizedExpression** ppCreatedObject
            );
    }; // end of DkmRootVisualizedExpression

    // The formatted result of a successful evaluation, ready to be displayed in an
    // expression evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5d948996-5805-1795-8b6b-535f0bc32bde") DkmSuccessEvaluationResult : public Evaluation::DkmEvaluationResult
    {
        // Use DkmSuccessEvaluationResult::Create to create this object
        private: DkmSuccessEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSuccessEvaluationResult();
        // This object cannot be copied
        private: DkmSuccessEvaluationResult& operator=(const DkmSuccessEvaluationResult&);
        private: DkmSuccessEvaluationResult(const DkmSuccessEvaluationResult&);

        private: const Evaluation::DkmEvaluationResultFlags::e m_Flags;
        private: OPTIONAL DkmString* const m_pValue;
        private: OPTIONAL DkmString* const m_pEditableValue;
        private: OPTIONAL DkmString* const m_pType;
        private: const Evaluation::DkmEvaluationResultCategory::e m_Category;
        private: const Evaluation::DkmEvaluationResultAccessType::e m_Access;
        private: const Evaluation::DkmEvaluationResultStorageType::e m_StorageType;
        private: const Evaluation::DkmEvaluationResultTypeModifierFlags::e m_TypeModifierFlags;
        private: OPTIONAL Evaluation::DkmDataAddress* const m_pAddress;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* const m_pCustomUIVisualizers;
        private: OPTIONAL DkmReadOnlyCollection<DkmModuleInstance*>* const m_pExternalModules;
        private: void* m__pExtendedData;
        private: void* m_pPropertyProxyCollection0;

        // Flags which indicate attributes of an expression evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags::e STDMETHODCALLTYPE Flags(
            );

        // [Optional] String that describes the value.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Value(
            );

        // [Optional] If the value is writable, specifies the default string to be used when
        // you double-click on the value to edit it.  The EE should be able to parse and
        // evaluate this string and get back the current evaluation result.  If the value is
        // read-only, the editable value is ignored and should be null.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE EditableValue(
            );

        // [Optional] A string that describes the type of the value.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // The category (ex: Data, Method, etc) of this evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory::e STDMETHODCALLTYPE Category(
            );

        // The access control level (public, private, etc) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultAccessType::e STDMETHODCALLTYPE Access(
            );

        // The storage type (ex: static) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultStorageType::e STDMETHODCALLTYPE StorageType(
            );

        // Type modifier flags (ex: const) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultTypeModifierFlags::e STDMETHODCALLTYPE TypeModifierFlags(
            );

        // [Optional] If the result is an address (i.e. the address flag is set in Flags),
        // specifies the location of the backing value.  This is used when the evaluation
        // result is used as the input to the memory window or disassembly window.  If it is
        // an instruction address then it must have the CPUInstruction address set.
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmDataAddress* STDMETHODCALLTYPE Address(
            );

        // [Optional] A list of custom viewers for this object.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE CustomUIVisualizers(
            );

        // [Optional] If available, a list of external modules, not including the current
        // module, that are used for the inspection of the object.  Loading symbols for as
        // many modules in this list as possible will enhance the display of the object.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmModuleInstance*>* STDMETHODCALLTYPE ExternalModules(
            );

        // Attempt to cast a 'DkmEvaluationResult' to a 'DkmSuccessEvaluationResult'. Return
        // NULL if the path object is not a 'DkmSuccessEvaluationResult'.
        // pSuccessResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmSuccessEvaluationResult* TryCast(
            DkmEvaluationResult* pResult
            )
        {
            if (pResult == NULL || pResult->TagValue() != Tag::SuccessResult)
                return NULL;

            return static_cast<DkmSuccessEvaluationResult*>(pResult);
        }

        // Create a new DkmSuccessEvaluationResult object instance.
        // pInspectionContext: [In] Inspection context used to create this evaluation result.
        // pStackFrame     : [In] The stack frame this expression result was created on.
        // pName           : [In] The name of the expression this result applies to.
        // pFullName       : [In,Optional] The full name of the expression this result
        // applies to. This value is used to allow child elements to be added to the watch
        // window (Add Watch from the context menu), and to refresh parts of the evaluation
        // tree. As an example of how FullName differs from name, the name of the 0th element
        // of an array in C++ is '[0]' while the full name would by 'myArrayVariable[0]'.
        // Flags           : [In] Flags which indicate attributes of an expression evaluation
        // result.
        // pValue          : [In,Optional] String that describes the value.
        // pEditableValue  : [In,Optional] If the value is writable, specifies the default
        // string to be used when you double-click on the value to edit it.  The EE should be
        // able to parse and evaluate this string and get back the current evaluation result.
        // If the value is read-only, the editable value is ignored and should be null.
        // pType           : [In,Optional] A string that describes the type of the value.
        // Category        : [In] The category (ex: Data, Method, etc) of this evaluation
        // result.
        // Access          : [In] The access control level (public, private, etc) of the
        // evaluation result.
        // StorageType     : [In] The storage type (ex: static) of the evaluation result.
        // TypeModifierFlags: [In] Type modifier flags (ex: const) of the evaluation result.
        // pAddress        : [In,Optional] If the result is an address (i.e. the address flag
        // is set in Flags), specifies the location of the backing value.  This is used when
        // the evaluation result is used as the input to the memory window or disassembly
        // window.  If it is an instruction address then it must have the CPUInstruction
        // address set.
        // pCustomUIVisualizers: [In,Optional] A list of custom viewers for this object.
        // pExternalModules: [In,Optional] If available, a list of external modules, not
        // including the current module, that are used for the inspection of the object.
        // Loading symbols for as many modules in this list as possible will enhance the
        // display of the object.
        // DataItem        : [In] Data object to add to the new DkmSuccessEvaluationResult
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ Evaluation::DkmEvaluationResultFlags::e Flags,
            _In_opt_ DkmString* pValue,
            _In_opt_ DkmString* pEditableValue,
            _In_opt_ DkmString* pType,
            _In_ Evaluation::DkmEvaluationResultCategory::e Category,
            _In_ Evaluation::DkmEvaluationResultAccessType::e Access,
            _In_ Evaluation::DkmEvaluationResultStorageType::e StorageType,
            _In_ Evaluation::DkmEvaluationResultTypeModifierFlags::e TypeModifierFlags,
            _In_opt_ Evaluation::DkmDataAddress* pAddress,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers,
            _In_opt_ DkmReadOnlyCollection<DkmModuleInstance*>* pExternalModules,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmSuccessEvaluationResult** ppCreatedObject
            );
    }; // end of DkmSuccessEvaluationResult

}; // end namespace Evaluation

// Contains the types used in the debugger's intermediate language (IL).
namespace Evaluation { namespace IL {
    // Describes the calling convention for a function evaluation on x86. Ignored for other
    // architectures.
    enum DkmILCallingConvention::e
    {
        // The x86 stdcall calling convention.
        StdCall = 0,
        // The x86 cdecl calling convention.
        CDecl = 1,
        // The x86 thiscall calling convention.
        ThisCall = 2,
        // The x86 fastcall calling convention.
        FastCall = 3
    };

    // An IL catch block, which can be used to recover from errors while executing IL.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1e8dd3ff-e859-f0c7-17a4-a59e0b7d7c62") DkmILCatchBlock : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILCatchBlock::Create to create this object
        private: DkmILCatchBlock();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCatchBlock();
        // This object cannot be copied
        private: DkmILCatchBlock& operator=(const DkmILCatchBlock&);
        private: DkmILCatchBlock(const DkmILCatchBlock&);

        private: const Evaluation::IL::DkmILFailureReason::e m_ErrorCode;
        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // The type of error to catch, "None" to catch all errors.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFailureReason::e STDMETHODCALLTYPE ErrorCode(
            );

        // The index of the IL instruction to jump to when the catch block executes.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Create a new DkmILCatchBlock object instance.
        // ErrorCode       : [In] The type of error to catch, "None" to catch all errors.
        // Target          : [In] The index of the IL instruction to jump to when the catch
        // block executes.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmILFailureReason::e ErrorCode,
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILCatchBlock** ppCreatedObject
            );
    }; // end of DkmILCatchBlock

    // DkmILEvaluationResult represents the result of evaluating one DkmILInstruction.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("892ad886-2235-9411-b588-a1da20887729") DkmILEvaluationResult : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILEvaluationResult::Create to create this object
        private: DkmILEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILEvaluationResult();
        // This object cannot be copied
        private: DkmILEvaluationResult& operator=(const DkmILEvaluationResult&);
        private: DkmILEvaluationResult(const DkmILEvaluationResult&);

        private: const GUID m_SourceId;
        private: DkmReadOnlyCollection<BYTE>* const m_pResultBytes;
        private: void* m__pExtendedData;

        // UniqueId of the DkmILInstruction object that originally pushed the returned value
        // onto the evaluation stack.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // The results of evaluating the DkmILInstruction.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ResultBytes(
            );

        // Create a new DkmILEvaluationResult object instance.
        // SourceId        : [In] UniqueId of the DkmILInstruction object that originally
        // pushed the returned value onto the evaluation stack.
        // pResultBytes    : [In] The results of evaluating the DkmILInstruction.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ DkmReadOnlyCollection<BYTE>* pResultBytes,
            _Deref_out_ Evaluation::IL::DkmILEvaluationResult** ppCreatedObject
            );
    }; // end of DkmILEvaluationResult

    // Indicates a reason why an IL instruction failed to execute.  In addition to these
    // constants, negative values may be used to indicate customized error conditions
    // resulting from the execution of intrinsic functions.
    enum DkmILFailureReason::e
    {
        // The IL was evaluated successfully.
        None = 0,
        // An attempt was made to divide an integer by zero.
        DivideByZero = 1,
        // An attempt to read from the debuggee's memory failed.
        MemoryReadError = 2,
        // An attempt to write to the debuggee's memory failed.
        MemoryWriteError = 3,
        // An attempt to read the value of a register from the debuggee failed.
        RegisterReadError = 4,
        // An attempt to write to the value of a register from the debuggee failed.
        RegisterWriteError = 5,
        // Execution was terminated because the user cancelled the evaluation.
        Aborted = 6,
        // An attempt was made to read a string which was larger than the maximum length.
        StringTooLong = 7,
        // Execution was terminated because the evaluation timeout was exceeded.
        Timeout = 8,
        // A function evaluation is already in progress. Multiple function evaluations are
        // not supported.
        TooManyFuncEval = 9,
        // An attempt to abort the evaluation failed. The process is now in an indeterminate
        // state.
        AbortFailed = 10,
        // This operation is not supported while debugging a minidump.
        MinidumpNotSupported = 11,
        // The evaluation was aborted because an unhandled exception occurred in the process.
        AbortUnhandledException = 12,
        // This operation is not supported on a user-mode scheduled thread.
        UserModeScheduledNotSupported = 13,
        // A DkmILExtractBytes instruction failed because the range of bytes to extract falls
        // outside the bounds of the value.
        ByteExtractionOutOfBounds = 14
    };

    // Flags affecting how arguments to a function evaluation are treated.
    enum DkmILFunctionEvaluationArgumentFlags::e
    {
        // No flags are set.
        Default = 0x0,
        // Set if this argument is a floating point value. This can affect how the value is
        // passed to the function.
        FloatingPoint = 0x1,
        // Set if this argument is a scalar type. On some architectures, this will affect how
        // the parameter is passed.
        Scalar = 0x2,
        // Set if the argument needs to be copied into the debuggee address space and then
        // passed by reference. Used to support string literals in argument parameters.
        CopyToDebuggee = 0x4,
        // Set if this argument is the this pointer for a call.
        ThisPointer = 0x8
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmILFunctionEvaluationArgumentFlags::e);

    // Flags affecting how a function evaluation should occur.
    enum DkmILFunctionEvaluationFlags::e
    {
        // No flags are set.
        Default = 0x0,
        // Set if this function returns a floating point value which changes how the return
        // value is found.
        FloatingPointReturn = 0x1,
        // Set if this function returns a scalar type. On some architectures this changes how
        // the value is returned.
        ScalarReturn = 0x2,
        // Set if the caller needs by-value return values returned as a reference on the
        // stack. The interpreter will make a copy of the return value on the debuggee stack
        // and return a pointer to that value. The value will only be valid in the debuggee
        // address space until the next continue or next function evaluation.
        ReturnAddressOfValue = 0x4,
        // Set if the return value will not be enregistered by the called function regardless
        // of return value size. This is used by the C++ expression evaluator when a class or
        // struct has a copy constructor defined and an instance of that class is being
        // returned by-value. The address of the return value on the stack will be returned
        // from the function evaluation. The value will only be valid in the debuggee address
        // space until the next continue or next function evaluation.
        NoEnregisteredReturn = 0x8,
        // Set if the function being called has a this pointer. The this pointer is the first
        // argument in the in the argument collection.
        HasThisPointer = 0x10,
        // Set if the return value for the function will be an enregistered complex return
        // type. This is used for the calling convention on arm where a composite type made
        // up of a number of elements of the same type is returned in registers. The size of
        // each element must be passed to the function evaluation instruction.
        // FloatingPointReturn is used to determine if the return value is in the in the
        // integer registers of the floating point registers.
        EnregisteredComplexReturn = 0x20
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmILFunctionEvaluationFlags::e);

    // Abstract base class for the concrete debugger immediate language instructions used by
    // expression evaluators to batch query information about the debuggee.
    //
    // Derived classes: DkmILAdd, DkmILAmpAdjustBufferTag, DkmILBeginTry, DkmILBitAnd,
    // DkmILBitFieldRead, DkmILBitFieldReadFromBytes, DkmILBitFieldWrite,
    // DkmILBitFieldWriteToBytes, DkmILBitNot, DkmILBitOr, DkmILBitShiftLeft,
    // DkmILBitShiftRight, DkmILBitXor, DkmILCompareEqual, DkmILCompareGreaterThan,
    // DkmILCompareGreaterThanOrEqual, DkmILCompareLessThan, DkmILCompareLessThanOrEqual,
    // DkmILCompareNotEqual, DkmILConvert, DkmILDivide, DkmILDuplicateTop, DkmILEndTry,
    // DkmILExecuteFunction, DkmILExecuteIntrinsic, DkmILExtractBytes, DkmILHlslBufferRead,
    // DkmILHlslGetGroupId, DkmILHlslGetThreadId, DkmILHlslIndexedRegisterRead,
    // DkmILHlslRegisterRead, DkmILIsFalse, DkmILIsTrue, DkmILJump, DkmILJumpIfFalse,
    // DkmILJumpIfTrue, DkmILLoad, DkmILMemoryRead, DkmILMemoryStringRead, DkmILMemoryWrite,
    // DkmILMultiply, DkmILNop, DkmILPop, DkmILPushConstant, DkmILRegisterRead,
    // DkmILRegisterWrite, DkmILRemainder, DkmILReturnTop, DkmILSave, DkmILSetBytesRegion,
    // DkmILSubtract, DkmILThrow, DkmILTlsGetValue
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fb5a5649-632c-d719-219e-d42a7ffffdc9") DkmILInstruction : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILInstruction::Create to create this object
        private: DkmILInstruction();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInstruction();
        // This object cannot be copied
        private: DkmILInstruction& operator=(const DkmILInstruction&);
        private: DkmILInstruction(const DkmILInstruction&);

        // DkmILInstruction is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmILRegisterRead'.
        RegisterRead = 0,
        // Object is an instance of 'DkmILRegisterWrite'.
        RegisterWrite = 1,
        // Object is an instance of 'DkmILMemoryRead'.
        MemoryRead = 2,
        // Object is an instance of 'DkmILMemoryWrite'.
        MemoryWrite = 3,
        // Object is an instance of 'DkmILMemoryStringRead'.
        MemoryStringRead = 4,
        // Object is an instance of 'DkmILTlsGetValue'.
        TlsGetValue = 5,
        // Object is an instance of 'DkmILBitFieldRead'.
        BitFieldRead = 6,
        // Object is an instance of 'DkmILBitFieldWrite'.
        BitFieldWrite = 7,
        // Object is an instance of 'DkmILPushConstant'.
        PushConstant = 8,
        // Object is an instance of 'DkmILDuplicateTop'.
        DuplicateTop = 9,
        // Object is an instance of 'DkmILPop'.
        Pop = 10,
        // Object is an instance of 'DkmILSave'.
        Save = 11,
        // Object is an instance of 'DkmILLoad'.
        Load = 12,
        // Object is an instance of 'DkmILNop'.
        Nop = 13,
        // Object is an instance of 'DkmILAdd'.
        Add = 14,
        // Object is an instance of 'DkmILSubtract'.
        Subtract = 15,
        // Object is an instance of 'DkmILMultiply'.
        Multiply = 16,
        // Object is an instance of 'DkmILDivide'.
        Divide = 17,
        // Object is an instance of 'DkmILRemainder'.
        Remainder = 18,
        // Object is an instance of 'DkmILExtractBytes'.
        ExtractBytes = 19,
        // Object is an instance of 'DkmILSetBytesRegion'.
        SetBytesRegion = 20,
        // Object is an instance of 'DkmILBitFieldReadFromBytes'.
        BitFieldReadFromBytes = 21,
        // Object is an instance of 'DkmILBitFieldWriteToBytes'.
        BitFieldWriteToBytes = 22,
        // Object is an instance of 'DkmILBitAnd'.
        BitAnd = 23,
        // Object is an instance of 'DkmILBitOr'.
        BitOr = 24,
        // Object is an instance of 'DkmILBitXor'.
        BitXor = 25,
        // Object is an instance of 'DkmILBitShiftLeft'.
        BitShiftLeft = 26,
        // Object is an instance of 'DkmILBitShiftRight'.
        BitShiftRight = 27,
        // Object is an instance of 'DkmILBitNot'.
        BitNot = 28,
        // Object is an instance of 'DkmILIsTrue'.
        IsTrue = 29,
        // Object is an instance of 'DkmILIsFalse'.
        IsFalse = 30,
        // Object is an instance of 'DkmILCompareEqual'.
        CompareEqual = 31,
        // Object is an instance of 'DkmILCompareNotEqual'.
        CompareNotEqual = 32,
        // Object is an instance of 'DkmILCompareGreaterThan'.
        CompareGreaterThan = 33,
        // Object is an instance of 'DkmILCompareGreaterThanOrEqual'.
        CompareGreaterThanOrEqual = 34,
        // Object is an instance of 'DkmILCompareLessThan'.
        CompareLessThan = 35,
        // Object is an instance of 'DkmILCompareLessThanOrEqual'.
        CompareLessThanOrEqual = 36,
        // Object is an instance of 'DkmILConvert'.
        Convert = 37,
        // Object is an instance of 'DkmILReturnTop'.
        ReturnTop = 38,
        // Object is an instance of 'DkmILThrow'.
        Throw = 39,
        // Object is an instance of 'DkmILJump'.
        Jump = 40,
        // Object is an instance of 'DkmILJumpIfTrue'.
        JumpIfTrue = 41,
        // Object is an instance of 'DkmILJumpIfFalse'.
        JumpIfFalse = 42,
        // Object is an instance of 'DkmILExecuteIntrinsic'.
        ExecuteIntrinsic = 43,
        // Object is an instance of 'DkmILBeginTry'.
        BeginTry = 44,
        // Object is an instance of 'DkmILEndTry'.
        EndTry = 45,
        // Object is an instance of 'DkmILExecuteFunction'.
        ExecuteFunction = 46,
        // Object is an instance of 'DkmILHlslRegisterRead'.
        HlslRegisterRead = 47,
        // Object is an instance of 'DkmILHlslIndexedRegisterRead'.
        HlslIndexedRegisterRead = 48,
        // Object is an instance of 'DkmILHlslBufferRead'.
        HlslBufferRead = 49,
        // Object is an instance of 'DkmILHlslGetThreadId'.
        HlslGetThreadId = 50,
        // Object is an instance of 'DkmILHlslGetGroupId'.
        HlslGetGroupId = 51,
        // Object is an instance of 'DkmILAmpAdjustBufferTag'.
        AmpAdjustBufferTag = 52
        }; };

        private: const Tag::e m_TagValue;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // DkmILInstruction is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // Uniquely identifies the DkmILInstruction object. Used as a hash-table key to allow
        // for quickly matching up DkmIL instructions with their matching values.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );
    }; // end of DkmILInstruction

    // A value that can be passed in as a parameter to an IL stream.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2aa6551e-a9cc-b1d5-d880-5ea0f21fd5e6") DkmILParameterValue : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILParameterValue::Create to create this object
        private: DkmILParameterValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILParameterValue();
        // This object cannot be copied
        private: DkmILParameterValue& operator=(const DkmILParameterValue&);
        private: DkmILParameterValue(const DkmILParameterValue&);

        private: const UINT32 m_LocalIndex;
        private: DkmReadOnlyCollection<BYTE>* const m_pValueBytes;
        private: void* m__pExtendedData;

        // The index of the local variable within the IL that will receive the parameter
        // value.  When the IL stream begins executing, the local variable at this index will
        // be preset to the parameter value.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LocalIndex(
            );

        // The bytes representing the value to pass in as the parameter.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ValueBytes(
            );

        // Create a new DkmILParameterValue object instance.
        // LocalIndex      : [In] The index of the local variable within the IL that will
        // receive the parameter value.  When the IL stream begins executing, the local
        // variable at this index will be preset to the parameter value.
        // pValueBytes     : [In] The bytes representing the value to pass in as the
        // parameter.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 LocalIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValueBytes,
            _Deref_out_ Evaluation::IL::DkmILParameterValue** ppCreatedObject
            );
    }; // end of DkmILParameterValue

    // Indicates the underlying primitive type (ex: UInt32) being operated on.
    enum DkmPrimitiveObjectType::e
    {
        // Represents a signed 8-bit integer.
        Int8 = 0,
        // Represents an unsigned 8-bit integer.
        UInt8 = 1,
        // Represents a signed 16-bit integer.
        Int16 = 2,
        // Represents an unsigned signed 16-bit integer.
        UInt16 = 3,
        // Represents a signed 32-bit integer.
        Int32 = 4,
        // Represents an unsigned 32-bit integer.
        UInt32 = 5,
        // Represents a signed 64-bit integer.
        Int64 = 6,
        // Represents an unsigned 64-bit integer.
        UInt64 = 7,
        // Represents a 32-bit single-precision floating-point value.
        Float = 8,
        // Represents a 64-bit double-precision floating-point value.
        Double = 9,
        // Represents a 10-byte floating-point value.
        LongDouble = 10
    };

    // An inspection query compiled to one or more DkmIL instructions.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b004e1ed-1890-adca-c358-d4fd722ecd98") DkmCompiledILInspectionQuery : public Evaluation::DkmCompiledInspectionQuery
    {
        // Use DkmCompiledILInspectionQuery::Create to create this object
        private: DkmCompiledILInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledILInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledILInspectionQuery& operator=(const DkmCompiledILInspectionQuery&);
        private: DkmCompiledILInspectionQuery(const DkmCompiledILInspectionQuery&);

        private: DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* const m_pInstructions;
        private: void* m__pExtendedData;

        // Body of the query.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* STDMETHODCALLTYPE Instructions(
            );

        // Attempt to cast a 'DkmCompiledInspectionQuery' to a 'DkmCompiledILInspectionQuery'. Return
        // NULL if the path object is not a 'DkmCompiledILInspectionQuery'.
        // pDkmILQuery : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCompiledILInspectionQuery* TryCast(
            DkmCompiledInspectionQuery* pQuery
            )
        {
            if (pQuery == NULL || pQuery->TagValue() != Tag::DkmILQuery)
                return NULL;

            return static_cast<DkmCompiledILInspectionQuery*>(pQuery);
        }

        // Create a new DkmCompiledILInspectionQuery object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pInstructions   : [In] Body of the query.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* pInstructions,
            _Deref_out_ Evaluation::IL::DkmCompiledILInspectionQuery** ppCreatedObject
            );

        // Executes a compiled inspection query and returns any results.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // pThreads        : [In] The compute threads to use when executing the query.
        // pParameters     : [In,Optional] Parameters to pass to each thread.  The collection
        // should be empty if unused, or have exactly as many members as the Threads
        // parameter.
        // ppResult        : [Out] Results of the evaluations.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ExecuteQueryOnThreads(
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_opt_ DkmReadOnlyCollection<Evaluation::Group::DkmILParameterValueCollection*>* pParameters,
            _Deref_out_ Evaluation::Group::DkmContextGroupEvaluationILResult** ppResult
            );

        // Executes a compiled inspection query and returns any results.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // pThreads        : [In] The compute threads to use when executing the query.
        // pParameters     : [In,Optional] Parameters to pass to each thread.  The collection
        // should be empty if unused, or have exactly as many members as the Threads
        // parameter.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ExecuteQueryOnThreads(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_opt_ DkmReadOnlyCollection<Evaluation::Group::DkmILParameterValueCollection*>* pParameters,
            _In_ IDkmCompletionRoutine<Evaluation::Group::DkmExecuteQueryOnThreadsAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmCompiledILInspectionQuery

    // Pops two values off the evaluation stack, adds them, and pushes the sum onto the
    // evaluation stack. Both operands popped off the stack must be the size indicated by
    // DkmPrimitiveObjectType. The resultant value will have the same size as the operands.
    // In the event of overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8cea2e5c-6a04-4523-4dad-b55f4052fc33") DkmILAdd : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILAdd::Create to create this object
        private: DkmILAdd();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILAdd();
        // This object cannot be copied
        private: DkmILAdd& operator=(const DkmILAdd&);
        private: DkmILAdd(const DkmILAdd&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of addition to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILAdd'. Return
        // NULL if the path object is not a 'DkmILAdd'.
        // pAdd : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILAdd* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Add)
                return NULL;

            return static_cast<DkmILAdd*>(pILInstruction);
        }

        // Create a new DkmILAdd object instance.
        // Type            : [In] The type of addition to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILAdd** ppCreatedObject
            );
    }; // end of DkmILAdd

    // A request to translate a C++ AMP pointer tag if its buffer has been forwarded.  Pops
    // the 32-bit tag off the stack, pushes the new 32-bit tag on the stack.  Usually a
    // no-op.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("502429a9-011b-79f2-cd30-a5d0536c0376") DkmILAmpAdjustBufferTag : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILAmpAdjustBufferTag::Create to create this object
        private: DkmILAmpAdjustBufferTag();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILAmpAdjustBufferTag();
        // This object cannot be copied
        private: DkmILAmpAdjustBufferTag& operator=(const DkmILAmpAdjustBufferTag&);
        private: DkmILAmpAdjustBufferTag(const DkmILAmpAdjustBufferTag&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILAmpAdjustBufferTag'. Return
        // NULL if the path object is not a 'DkmILAmpAdjustBufferTag'.
        // pAmpAdjustBufferTag : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILAmpAdjustBufferTag* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::AmpAdjustBufferTag)
                return NULL;

            return static_cast<DkmILAmpAdjustBufferTag*>(pILInstruction);
        }

        // Create a new DkmILAmpAdjustBufferTag object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILAmpAdjustBufferTag** ppCreatedObject
            );
    }; // end of DkmILAmpAdjustBufferTag

    // Begins a try block.  If an error occurs within the execution of the try block, control
    // will jump to an appropriate catch block to allow the IL to recover from the error.
    // Exception handling in native IL works as follows: An exception in native IL means that
    // some operation, such as a register read or memory read failed.  Each exception is
    // identified by a 32-bit exception code that describes the problem.  Exception code
    // values are defined according to the DkmILFailureReason enumeration, and additional
    // user-defined values may also be used to handle exception-conditions that are specific
    // to an intrinsic function (e.g. attempt to take the log of 0).
    //
    // By default, when an exception occurs, the IL processing will stop immediately, causing
    // DkmCompiledInspectionQuery::ExecuteQuery() to fail, returning the exception code as an
    // out parameter.  To handle the exception with IL, the IL should execute a DkmILBeginTry
    // instruction to enter a guarded exception-handling state.  The IL processing will
    // remain in this state until a DkmILEndTryBlock instruction is executed.
    //
    // A DkmILBeginTryBlock instruction specifies what to do if an exception occurs within
    // the block.  The block's exception handling logic is defined by a collection of
    // DkmILCatchBlock objects.  Each catch block defines the exception code that the catch
    // block will catch, as well as the offset into the instruction stream where the catch
    // block is located at.
    //
    // Thus, when an exception occurs, we will do the following:
    //
    // 1) Check if we are inside a try block: No: Abort the IL operation and cause
    // DkmCompiledInspectionQuery::ExecuteQuery() to fail. Yes: 2) Examine the list of
    // DkmILCatchBlock objects associated with the try block in sequential order, looking for
    // a catch block that catches the exception code. (If more than one catch block works, we
    // use the first match and ignore the other matches). If we find a match: - Clear the
    // state that says we're in a try block (so any exceptions from the catch handler will go
    // unhandled unless a new try block gets set up) - Remove all values from the IL stack
    // that got pushed after we entered the try block.  Local variables, saved return values,
    // and IL stack values that were already pushed before the try block began are retained.
    // (It is illegal to pop a value off the stack inside a try block that got pushed outside
    // the try block). - Push the exception code on the stack as a 32-bit value - Transfer
    // control to the offset of the catch handler and continue the IL If we don't find a
    // match: - The exception is unhandled.  Abort the IL operation and cause
    // DkmCompiledInspectionQuery::ExecuteQuery() to fail.
    //
    // If during the execution of the inspection query, we detect that the work list has been
    // canceled, we will promptly abort the IL processing.  The IL will not have a chance to
    // handle this.
    //
    // In general, exception handling is allowed when an inspection fails, or an arithmetic
    // error occurs (e.g. division by zero), however, on error conditions that can only arise
    // through invalid IL (e.g. attempt to pop from empty stack), we do not guarantee that
    // exception handling of such errors will be supported.  If an exception occurs that we
    // do not support handling, the IL processing will simply abort.
    //
    // Currently, nested try blocks are not supported, that is, an attempt to execute a
    // DkmILBeginTry while already inside a try block is considered an error.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("16f727a6-1a24-9c23-11b3-1a4cfe666cc6") DkmILBeginTry : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBeginTry::Create to create this object
        private: DkmILBeginTry();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBeginTry();
        // This object cannot be copied
        private: DkmILBeginTry& operator=(const DkmILBeginTry&);
        private: DkmILBeginTry(const DkmILBeginTry&);

        private: DkmReadOnlyCollection<Evaluation::IL::DkmILCatchBlock*>* const m_pCatchBlocks;
        private: void* m__pExtendedData;

        // Ordered list of catch blocks to handle exceptions occurring within the try block.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILCatchBlock*>* STDMETHODCALLTYPE CatchBlocks(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBeginTry'. Return
        // NULL if the path object is not a 'DkmILBeginTry'.
        // pBeginTry : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBeginTry* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BeginTry)
                return NULL;

            return static_cast<DkmILBeginTry*>(pILInstruction);
        }

        // Create a new DkmILBeginTry object instance.
        // pCatchBlocks    : [In] Ordered list of catch blocks to handle exceptions occurring
        // within the try block.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILCatchBlock*>* pCatchBlocks,
            _Deref_out_ Evaluation::IL::DkmILBeginTry** ppCreatedObject
            );
    }; // end of DkmILBeginTry

    // Pops two integer values off of the evaluation stack.  Performs a bitwise and on the
    // two values, and pushes the result onto the stack. The two values popped from the stack
    // must be the same size.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1c046c38-4667-3b0c-3387-6efc9b66c74e") DkmILBitAnd : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitAnd::Create to create this object
        private: DkmILBitAnd();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitAnd();
        // This object cannot be copied
        private: DkmILBitAnd& operator=(const DkmILBitAnd&);
        private: DkmILBitAnd(const DkmILBitAnd&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitAnd'. Return
        // NULL if the path object is not a 'DkmILBitAnd'.
        // pBitAnd : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitAnd* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitAnd)
                return NULL;

            return static_cast<DkmILBitAnd*>(pILInstruction);
        }

        // Create a new DkmILBitAnd object instance.
        // Type            : [In] The type of operands to expect (e.g. 32-bit or 64-bit).
        // Floating-point modes are not allowed.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitAnd** ppCreatedObject
            );
    }; // end of DkmILBitAnd

    // Reads the value of a bit field from memory.  The address of the bit field is popped
    // off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9b7942ff-9ac4-effb-46a9-8f06682d8472") DkmILBitFieldRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldRead::Create to create this object
        private: DkmILBitFieldRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldRead();
        // This object cannot be copied
        private: DkmILBitFieldRead& operator=(const DkmILBitFieldRead&);
        private: DkmILBitFieldRead(const DkmILBitFieldRead&);

        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The bit position to read from.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to read.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // The type of object to read.  Must be an integer and must be at least as large, in
        // bits, as NumBits.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldRead'. Return
        // NULL if the path object is not a 'DkmILBitFieldRead'.
        // pBitFieldRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldRead)
                return NULL;

            return static_cast<DkmILBitFieldRead*>(pILInstruction);
        }

        // Create a new DkmILBitFieldRead object instance.
        // BitPosition     : [In] The bit position to read from.  Must be between 0 and 63.
        // NumBits         : [In] Number of bits to read.  Must be between 1 and 64.
        // Type            : [In] The type of object to read.  Must be an integer and must be
        // at least as large, in bits, as NumBits.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitFieldRead** ppCreatedObject
            );
    }; // end of DkmILBitFieldRead

    // Pops a value off the IL stack.  Then, reads a bit-field directly off that value.  This
    // is different from DkmILBitFieldRead in that the value popped from the stack directly
    // contains the value to read the bits from, rather than a memory address.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("795365b6-659e-619a-ad13-37942b3f7788") DkmILBitFieldReadFromBytes : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldReadFromBytes::Create to create this object
        private: DkmILBitFieldReadFromBytes();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldReadFromBytes();
        // This object cannot be copied
        private: DkmILBitFieldReadFromBytes& operator=(const DkmILBitFieldReadFromBytes&);
        private: DkmILBitFieldReadFromBytes(const DkmILBitFieldReadFromBytes&);

        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // Offset within the state of the value where the bit-field begins.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The bit position to read from.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to read.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // The type of object to read.  Must be an integer and must be at least as large, in
        // bits, as NumBits.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldReadFromBytes'. Return
        // NULL if the path object is not a 'DkmILBitFieldReadFromBytes'.
        // pBitFieldReadFromBytes : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldReadFromBytes* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldReadFromBytes)
                return NULL;

            return static_cast<DkmILBitFieldReadFromBytes*>(pILInstruction);
        }

        // Create a new DkmILBitFieldReadFromBytes object instance.
        // ByteOffset      : [In] Offset within the state of the value where the bit-field
        // begins.
        // BitPosition     : [In] The bit position to read from.  Must be between 0 and 63.
        // NumBits         : [In] Number of bits to read.  Must be between 1 and 64.
        // Type            : [In] The type of object to read.  Must be an integer and must be
        // at least as large, in bits, as NumBits.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitFieldReadFromBytes** ppCreatedObject
            );
    }; // end of DkmILBitFieldReadFromBytes

    // Pops a value off the stack.  Then, pops a memory address off the stack.  Then,
    // modifies the value of the bit field at that memory address, at the given offset and
    // size, to match the value that was just popped off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2be85ffe-5c9c-7f41-cef6-cd2c051e2ee7") DkmILBitFieldWrite : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldWrite::Create to create this object
        private: DkmILBitFieldWrite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldWrite();
        // This object cannot be copied
        private: DkmILBitFieldWrite& operator=(const DkmILBitFieldWrite&);
        private: DkmILBitFieldWrite(const DkmILBitFieldWrite&);

        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: void* m__pExtendedData;

        // The bit position to write to.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to write.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldWrite'. Return
        // NULL if the path object is not a 'DkmILBitFieldWrite'.
        // pBitFieldWrite : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldWrite* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldWrite)
                return NULL;

            return static_cast<DkmILBitFieldWrite*>(pILInstruction);
        }

        // Create a new DkmILBitFieldWrite object instance.
        // BitPosition     : [In] The bit position to write to.  Must be between 0 and 63.
        // NumBits         : [In] Number of bits to write.  Must be between 1 and 64.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _Deref_out_ Evaluation::IL::DkmILBitFieldWrite** ppCreatedObject
            );
    }; // end of DkmILBitFieldWrite

    // Pops a value off the IL stack.  Then pops a second value off the IL stack.  The first
    // value to be popped (second to be pushed) will be treated as an object that contains a
    // bit field described herein.  The second value to be popped (first to be pushed) will
    // be the value of the bit field that will be inserted into the first value.  The result
    // of the modification is then pushed onto the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("470db7c1-3e41-3dde-ac43-bf52c441847d") DkmILBitFieldWriteToBytes : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldWriteToBytes::Create to create this object
        private: DkmILBitFieldWriteToBytes();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldWriteToBytes();
        // This object cannot be copied
        private: DkmILBitFieldWriteToBytes& operator=(const DkmILBitFieldWriteToBytes&);
        private: DkmILBitFieldWriteToBytes(const DkmILBitFieldWriteToBytes&);

        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: void* m__pExtendedData;

        // Offset within the state of the value where the bit-field begins.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The bit position to write to.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to write.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldWriteToBytes'. Return
        // NULL if the path object is not a 'DkmILBitFieldWriteToBytes'.
        // pBitFieldWriteToBytes : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldWriteToBytes* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldWriteToBytes)
                return NULL;

            return static_cast<DkmILBitFieldWriteToBytes*>(pILInstruction);
        }

        // Create a new DkmILBitFieldWriteToBytes object instance.
        // ByteOffset      : [In] Offset within the state of the value where the bit-field
        // begins.
        // BitPosition     : [In] The bit position to write to.  Must be between 0 and 63.
        // NumBits         : [In] Number of bits to write.  Must be between 1 and 64.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _Deref_out_ Evaluation::IL::DkmILBitFieldWriteToBytes** ppCreatedObject
            );
    }; // end of DkmILBitFieldWriteToBytes

    // Pops an integer value off of the evaluation stack.  Inverts all the bits and pushes
    // the result onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ead1642b-da0a-3e0e-0f8c-ab1c3279fb0f") DkmILBitNot : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitNot::Create to create this object
        private: DkmILBitNot();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitNot();
        // This object cannot be copied
        private: DkmILBitNot& operator=(const DkmILBitNot&);
        private: DkmILBitNot(const DkmILBitNot&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitNot'. Return
        // NULL if the path object is not a 'DkmILBitNot'.
        // pBitNot : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitNot* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitNot)
                return NULL;

            return static_cast<DkmILBitNot*>(pILInstruction);
        }

        // Create a new DkmILBitNot object instance.
        // Type            : [In] The type of operands to expect (e.g. 32-bit or 64-bit).
        // Floating-point modes are not allowed.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitNot** ppCreatedObject
            );
    }; // end of DkmILBitNot

    // Pops two integer values off of the evaluation stack.  Performs a bitwise or on the two
    // values, and pushes the result onto the stack. The two values popped from the stack
    // must be the same size.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("59c33aa2-28f3-0da3-ed3a-676ae57f6470") DkmILBitOr : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitOr::Create to create this object
        private: DkmILBitOr();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitOr();
        // This object cannot be copied
        private: DkmILBitOr& operator=(const DkmILBitOr&);
        private: DkmILBitOr(const DkmILBitOr&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitOr'. Return
        // NULL if the path object is not a 'DkmILBitOr'.
        // pBitOr : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitOr* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitOr)
                return NULL;

            return static_cast<DkmILBitOr*>(pILInstruction);
        }

        // Create a new DkmILBitOr object instance.
        // Type            : [In] The type of operands to expect (e.g. 32-bit or 64-bit).
        // Floating-point modes are not allowed.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitOr** ppCreatedObject
            );
    }; // end of DkmILBitOr

    // Pops two integer values off of the evaluation stack.  Shifts the first value left by
    // the second value and pushes the result onto the evaluation stack. The first operand
    // must be the size indicated by by DkmPrimitiveObjectType. The second operand must be
    // 32-bit.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9e02b526-a3d3-1eb3-eaf5-0e817af4e47d") DkmILBitShiftLeft : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitShiftLeft::Create to create this object
        private: DkmILBitShiftLeft();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitShiftLeft();
        // This object cannot be copied
        private: DkmILBitShiftLeft& operator=(const DkmILBitShiftLeft&);
        private: DkmILBitShiftLeft(const DkmILBitShiftLeft&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitShiftLeft'. Return
        // NULL if the path object is not a 'DkmILBitShiftLeft'.
        // pBitShiftLeft : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitShiftLeft* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitShiftLeft)
                return NULL;

            return static_cast<DkmILBitShiftLeft*>(pILInstruction);
        }

        // Create a new DkmILBitShiftLeft object instance.
        // Type            : [In] The type of operands to expect (e.g. 32-bit or 64-bit).
        // Floating-point modes are not allowed.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitShiftLeft** ppCreatedObject
            );
    }; // end of DkmILBitShiftLeft

    // Pops two integer values off of the evaluation stack.  Shifts the first value right by
    // the second value and pushes the result onto the evaluation stack.  The first operand
    // must be the size indicated by by DkmPrimitiveObjectType. The second operand must be
    // 32-bit.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8b4645e9-19a8-ba08-9554-3f17f197f478") DkmILBitShiftRight : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitShiftRight::Create to create this object
        private: DkmILBitShiftRight();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitShiftRight();
        // This object cannot be copied
        private: DkmILBitShiftRight& operator=(const DkmILBitShiftRight&);
        private: DkmILBitShiftRight(const DkmILBitShiftRight&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are
        // not allowed. Also, specifies whether the operation is signed or unsigned.  An
        // unsigned mode means the upper-bit will be filled with a zero; a signed mode means
        // the upper-bit will be preserved.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitShiftRight'. Return
        // NULL if the path object is not a 'DkmILBitShiftRight'.
        // pBitShiftRight : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitShiftRight* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitShiftRight)
                return NULL;

            return static_cast<DkmILBitShiftRight*>(pILInstruction);
        }

        // Create a new DkmILBitShiftRight object instance.
        // Type            : [In] The type of operands to expect (e.g. 32-bit or 64-bit).
        // Floating-point modes are not allowed. Also, specifies whether the operation is
        // signed or unsigned.  An unsigned mode means the upper-bit will be filled with a
        // zero; a signed mode means the upper-bit will be preserved.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitShiftRight** ppCreatedObject
            );
    }; // end of DkmILBitShiftRight

    // Pops two integer values off of the evaluation stack.  Performs a bitwise exclusive-or
    // on the two values, and pushes the result onto the stack. The two values popped from
    // the stack must be the same size.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9f0eb985-42c0-fbc0-1d85-2371aca7e7c1") DkmILBitXor : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitXor::Create to create this object
        private: DkmILBitXor();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitXor();
        // This object cannot be copied
        private: DkmILBitXor& operator=(const DkmILBitXor&);
        private: DkmILBitXor(const DkmILBitXor&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitXor'. Return
        // NULL if the path object is not a 'DkmILBitXor'.
        // pBitXor : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitXor* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitXor)
                return NULL;

            return static_cast<DkmILBitXor*>(pILInstruction);
        }

        // Create a new DkmILBitXor object instance.
        // Type            : [In] The type of operands to expect (e.g. 32-bit or 64-bit).
        // Floating-point modes are not allowed.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILBitXor** ppCreatedObject
            );
    }; // end of DkmILBitXor

    // Pops two values off of the evaluation stack.  If the two values are equal (same size,
    // all the bytes have the same value), pushes a 32-bit 1 onto the stack.  Otherwise,
    // pushes a 32-bit 0 onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7d7d75b-054e-16de-e7ac-157725ddf51c") DkmILCompareEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareEqual::Create to create this object
        private: DkmILCompareEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareEqual();
        // This object cannot be copied
        private: DkmILCompareEqual& operator=(const DkmILCompareEqual&);
        private: DkmILCompareEqual(const DkmILCompareEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareEqual'. Return
        // NULL if the path object is not a 'DkmILCompareEqual'.
        // pCompareEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareEqual)
                return NULL;

            return static_cast<DkmILCompareEqual*>(pILInstruction);
        }

        // Create a new DkmILCompareEqual object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILCompareEqual** ppCreatedObject
            );
    }; // end of DkmILCompareEqual

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is greater than the
    // second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit
    // value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("87da7a59-d3c5-2a9c-098a-b036d51c2bb6") DkmILCompareGreaterThan : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareGreaterThan::Create to create this object
        private: DkmILCompareGreaterThan();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareGreaterThan();
        // This object cannot be copied
        private: DkmILCompareGreaterThan& operator=(const DkmILCompareGreaterThan&);
        private: DkmILCompareGreaterThan(const DkmILCompareGreaterThan&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareGreaterThan'. Return
        // NULL if the path object is not a 'DkmILCompareGreaterThan'.
        // pCompareGreaterThan : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareGreaterThan* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareGreaterThan)
                return NULL;

            return static_cast<DkmILCompareGreaterThan*>(pILInstruction);
        }

        // Create a new DkmILCompareGreaterThan object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILCompareGreaterThan** ppCreatedObject
            );
    }; // end of DkmILCompareGreaterThan

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is greater than or
    // equal to the second operand, pushes a 32-bit value of 1 on the stack; otherwise,
    // pushes a 32-bit value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8b58921f-dea7-4cbc-b533-8211e74e0d46") DkmILCompareGreaterThanOrEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareGreaterThanOrEqual::Create to create this object
        private: DkmILCompareGreaterThanOrEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareGreaterThanOrEqual();
        // This object cannot be copied
        private: DkmILCompareGreaterThanOrEqual& operator=(const DkmILCompareGreaterThanOrEqual&);
        private: DkmILCompareGreaterThanOrEqual(const DkmILCompareGreaterThanOrEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareGreaterThanOrEqual'. Return
        // NULL if the path object is not a 'DkmILCompareGreaterThanOrEqual'.
        // pCompareGreaterThanOrEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareGreaterThanOrEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareGreaterThanOrEqual)
                return NULL;

            return static_cast<DkmILCompareGreaterThanOrEqual*>(pILInstruction);
        }

        // Create a new DkmILCompareGreaterThanOrEqual object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILCompareGreaterThanOrEqual** ppCreatedObject
            );
    }; // end of DkmILCompareGreaterThanOrEqual

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is less than the
    // second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit
    // value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ed47674b-a628-ee40-8e2c-a7282e82f593") DkmILCompareLessThan : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareLessThan::Create to create this object
        private: DkmILCompareLessThan();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareLessThan();
        // This object cannot be copied
        private: DkmILCompareLessThan& operator=(const DkmILCompareLessThan&);
        private: DkmILCompareLessThan(const DkmILCompareLessThan&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareLessThan'. Return
        // NULL if the path object is not a 'DkmILCompareLessThan'.
        // pCompareLessThan : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareLessThan* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareLessThan)
                return NULL;

            return static_cast<DkmILCompareLessThan*>(pILInstruction);
        }

        // Create a new DkmILCompareLessThan object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILCompareLessThan** ppCreatedObject
            );
    }; // end of DkmILCompareLessThan

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is less than the
    // second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit
    // value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a8439ea9-e9e0-7669-8d8e-38780379f045") DkmILCompareLessThanOrEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareLessThanOrEqual::Create to create this object
        private: DkmILCompareLessThanOrEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareLessThanOrEqual();
        // This object cannot be copied
        private: DkmILCompareLessThanOrEqual& operator=(const DkmILCompareLessThanOrEqual&);
        private: DkmILCompareLessThanOrEqual(const DkmILCompareLessThanOrEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareLessThanOrEqual'. Return
        // NULL if the path object is not a 'DkmILCompareLessThanOrEqual'.
        // pCompareLessThanOrEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareLessThanOrEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareLessThanOrEqual)
                return NULL;

            return static_cast<DkmILCompareLessThanOrEqual*>(pILInstruction);
        }

        // Create a new DkmILCompareLessThanOrEqual object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILCompareLessThanOrEqual** ppCreatedObject
            );
    }; // end of DkmILCompareLessThanOrEqual

    // Pops two values off of the evaluation stack.  If the two values are not equal (same
    // size, all the bytes don't have the same value), pushes a 32-bit 1 onto the stack.
    // Otherwise, pushes a 32-bit 0 onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("26714063-5d3c-d8f5-a948-d903c3cd8702") DkmILCompareNotEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareNotEqual::Create to create this object
        private: DkmILCompareNotEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareNotEqual();
        // This object cannot be copied
        private: DkmILCompareNotEqual& operator=(const DkmILCompareNotEqual&);
        private: DkmILCompareNotEqual(const DkmILCompareNotEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareNotEqual'. Return
        // NULL if the path object is not a 'DkmILCompareNotEqual'.
        // pCompareNotEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareNotEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareNotEqual)
                return NULL;

            return static_cast<DkmILCompareNotEqual*>(pILInstruction);
        }

        // Create a new DkmILCompareNotEqual object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILCompareNotEqual** ppCreatedObject
            );
    }; // end of DkmILCompareNotEqual

    // Pops a value off the evaluation stack and converts it from one type to another.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fe9357e0-21e3-b8fb-993e-9abc312fa934") DkmILConvert : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILConvert::Create to create this object
        private: DkmILConvert();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILConvert();
        // This object cannot be copied
        private: DkmILConvert& operator=(const DkmILConvert&);
        private: DkmILConvert(const DkmILConvert&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_OriginalType;
        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_TargetType;
        private: void* m__pExtendedData;

        // The expected type of the object to be popped from the stack. The actual object
        // popped from the stack must have a size that matches this type.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE OriginalType(
            );

        // The type that you want to convert the value to.  This is the type of the object
        // that will be pushed onto the stack.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE TargetType(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILConvert'. Return
        // NULL if the path object is not a 'DkmILConvert'.
        // pConvert : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILConvert* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Convert)
                return NULL;

            return static_cast<DkmILConvert*>(pILInstruction);
        }

        // Create a new DkmILConvert object instance.
        // OriginalType    : [In] The expected type of the object to be popped from the
        // stack. The actual object popped from the stack must have a size that matches this
        // type.
        // TargetType      : [In] The type that you want to convert the value to.  This is
        // the type of the object that will be pushed onto the stack.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e OriginalType,
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e TargetType,
            _Deref_out_ Evaluation::IL::DkmILConvert** ppCreatedObject
            );
    }; // end of DkmILConvert

    // Pops two values off the evaluation stack, divides them, and pushes the result onto the
    // evaluation stack. Both operands popped off the stack must be the size indicated by
    // DkmPrimitiveObjectType.  The first value popped from the stack will be divided by the
    // second value popped, so to evaluate "a / b", you would push a, then push b, then
    // divide. The resultant value will have the same size as the operands.  In the event of
    // overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("71a11e07-4158-8259-9f50-f764b86b0835") DkmILDivide : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILDivide::Create to create this object
        private: DkmILDivide();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILDivide();
        // This object cannot be copied
        private: DkmILDivide& operator=(const DkmILDivide&);
        private: DkmILDivide(const DkmILDivide&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of subtraction to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILDivide'. Return
        // NULL if the path object is not a 'DkmILDivide'.
        // pDivide : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILDivide* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Divide)
                return NULL;

            return static_cast<DkmILDivide*>(pILInstruction);
        }

        // Create a new DkmILDivide object instance.
        // Type            : [In] The type of subtraction to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILDivide** ppCreatedObject
            );
    }; // end of DkmILDivide

    // Make a duplicate copy of the value on the top of the DkmIL stack and push this copy on
    // top of the stack.  If the result of a DkmDuplicateTop gets returned, the GUID
    // associated with the result will be the GUID of the original instruction, not the GUID
    // of the DkmDuplicateTop.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("75aea7e7-c6a1-78cf-bee0-c6025b37a868") DkmILDuplicateTop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILDuplicateTop::Create to create this object
        private: DkmILDuplicateTop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILDuplicateTop();
        // This object cannot be copied
        private: DkmILDuplicateTop& operator=(const DkmILDuplicateTop&);
        private: DkmILDuplicateTop(const DkmILDuplicateTop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILDuplicateTop'. Return
        // NULL if the path object is not a 'DkmILDuplicateTop'.
        // pDuplicateTop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILDuplicateTop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::DuplicateTop)
                return NULL;

            return static_cast<DkmILDuplicateTop*>(pILInstruction);
        }

        // Create a new DkmILDuplicateTop object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILDuplicateTop** ppCreatedObject
            );
    }; // end of DkmILDuplicateTop

    // Ends a try block.  After this, all exceptions will go unhandled unless a new
    // DkmILBeginTry instruction is executed.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("e67ca9b0-423e-11e2-fa72-fef237717a9a") DkmILEndTry : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILEndTry::Create to create this object
        private: DkmILEndTry();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILEndTry();
        // This object cannot be copied
        private: DkmILEndTry& operator=(const DkmILEndTry&);
        private: DkmILEndTry(const DkmILEndTry&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILEndTry'. Return
        // NULL if the path object is not a 'DkmILEndTry'.
        // pEndTry : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILEndTry* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::EndTry)
                return NULL;

            return static_cast<DkmILEndTry*>(pILInstruction);
        }

        // Create a new DkmILEndTry object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILEndTry** ppCreatedObject
            );
    }; // end of DkmILEndTry

    // Pops the address of the function off the eval stack. Then, pops the arguments off the
    // IL stack in reverse order (prior to the DkmILExecuteFunction instruction, arguments
    // should be pushed on the stack in order). Next, executes the function in the debuggee
    // process . The return value for the function is copied to the IL Stack as a byte array.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2d26c57a-7bf3-02dc-3bcb-a593bc8e5ca0") DkmILExecuteFunction : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExecuteFunction::Create to create this object
        private: DkmILExecuteFunction();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExecuteFunction();
        // This object cannot be copied
        private: DkmILExecuteFunction& operator=(const DkmILExecuteFunction&);
        private: DkmILExecuteFunction(const DkmILExecuteFunction&);

        private: const UINT32 m_ArgumentCount;
        private: const UINT32 m_ReturnValueSize;
        private: const Evaluation::IL::DkmILCallingConvention::e m_CallingConvention;
        private: const Evaluation::IL::DkmILFunctionEvaluationFlags::e m_Flags;
        private: DkmReadOnlyCollection<Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e>* const m_pArgumentFlags;
        private: const UINT32 m_UniformComplexReturnElementSize;
        private: void* m__pExtendedData;

        // The number of arguments to pass to the intrinsic function.  These arguments are
        // popped off the IL stack.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArgumentCount(
            );

        // The size of the return value in bytes. This dictates how the return address is
        // found on some architectures. For instance, on x86, a 4 byte or less return value
        // is returned in EAX. An 8 byte return value is returned in EDX:EAX, and for
        // anything larger, a pointer is returned in EAX to an object on the heap, or for by
        // value returns, to an object on the stack after the stack is cleaned up.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ReturnValueSize(
            );

        // The calling convention of the function to be executed. Ignored on non-x86
        // processors that only have a single calling convention.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILCallingConvention::e STDMETHODCALLTYPE CallingConvention(
            );

        // Flags affecting how a function evaluation should occur.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFunctionEvaluationFlags::e STDMETHODCALLTYPE Flags(
            );

        // Flags affecting arguments to a function evaluation. There will be one argument
        // flag for each argument.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e>* STDMETHODCALLTYPE ArgumentFlags(
            );

        // Used for the arm calling convention where a complex type containing all elements
        // the same size are returned enregistered. This is only used if the
        // EnregisteredComplexReturn flag in DkmILFunctionEvaluationFlags is set. This value
        // should return the size of each element in the complex type. FloatingPointReturn is
        // used to determine if the return value is in the in the integer registers of the
        // floating point registers. The IL Interpreter will copy these values onto the stack
        // and return a pointer to that location as if they were not enregistered.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE UniformComplexReturnElementSize(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExecuteFunction'. Return
        // NULL if the path object is not a 'DkmILExecuteFunction'.
        // pExecuteFunction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExecuteFunction* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExecuteFunction)
                return NULL;

            return static_cast<DkmILExecuteFunction*>(pILInstruction);
        }

        // Create a new DkmILExecuteFunction object instance.
        // ArgumentCount   : [In] The number of arguments to pass to the intrinsic function.
        // These arguments are popped off the IL stack.
        // ReturnValueSize : [In] The size of the return value in bytes. This dictates how
        // the return address is found on some architectures. For instance, on x86, a 4 byte
        // or less return value is returned in EAX. An 8 byte return value is returned in
        // EDX:EAX, and for anything larger, a pointer is returned in EAX to an object on the
        // heap, or for by value returns, to an object on the stack after the stack is
        // cleaned up.
        // CallingConvention: [In] The calling convention of the function to be executed.
        // Ignored on non-x86 processors that only have a single calling convention.
        // Flags           : [In] Flags affecting how a function evaluation should occur.
        // pArgumentFlags  : [In] Flags affecting arguments to a function evaluation. There
        // will be one argument flag for each argument.
        // UniformComplexReturnElementSize: [In] Used for the arm calling convention where a
        // complex type containing all elements the same size are returned enregistered. This
        // is only used if the EnregisteredComplexReturn flag in DkmILFunctionEvaluationFlags
        // is set. This value should return the size of each element in the complex type.
        // FloatingPointReturn is used to determine if the return value is in the in the
        // integer registers of the floating point registers. The IL Interpreter will copy
        // these values onto the stack and return a pointer to that location as if they were
        // not enregistered.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ArgumentCount,
            _In_ UINT32 ReturnValueSize,
            _In_ Evaluation::IL::DkmILCallingConvention::e CallingConvention,
            _In_ Evaluation::IL::DkmILFunctionEvaluationFlags::e Flags,
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e>* pArgumentFlags,
            _In_ UINT32 UniformComplexReturnElementSize,
            _Deref_out_ Evaluation::IL::DkmILExecuteFunction** ppCreatedObject
            );
    }; // end of DkmILExecuteFunction

    // Pops the arguments off the IL stack in reverse order (prior to the
    // DkmILExecuteIntrinsic instruction, arguments should be pushed on the stack in order).
    // Then, executes an EE-defined operation that makes use of these values.  Then, pushes
    // the result back onto the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b78030f6-2d05-231a-c0d6-bf554010824e") DkmILExecuteIntrinsic : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExecuteIntrinsic::Create to create this object
        private: DkmILExecuteIntrinsic();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExecuteIntrinsic();
        // This object cannot be copied
        private: DkmILExecuteIntrinsic& operator=(const DkmILExecuteIntrinsic&);
        private: DkmILExecuteIntrinsic(const DkmILExecuteIntrinsic&);

        private: const GUID m_SourceId;
        private: const GUID m_LanguageId;
        private: const UINT32 m_Id;
        private: const UINT32 m_ArgumentCount;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* const m_pSubroutines;
        private: void* m__pExtendedData;

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // The language associated with the intrinsic function.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE LanguageId(
            );

        // A unique identifier for the intrinsic function within the language.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The number of arguments to pass to the intrinsic function.  These arguments are
        // popped off the IL stack.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArgumentCount(
            );

        // [Optional] Optional collection of subroutines that the intrinsic function can call
        // into.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* STDMETHODCALLTYPE Subroutines(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExecuteIntrinsic'. Return
        // NULL if the path object is not a 'DkmILExecuteIntrinsic'.
        // pExecuteIntrinsic : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExecuteIntrinsic* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExecuteIntrinsic)
                return NULL;

            return static_cast<DkmILExecuteIntrinsic*>(pILInstruction);
        }

        // Create a new DkmILExecuteIntrinsic object instance.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // LanguageId      : [In] The language associated with the intrinsic function.
        // Id              : [In] A unique identifier for the intrinsic function within the
        // language.
        // ArgumentCount   : [In] The number of arguments to pass to the intrinsic function.
        // These arguments are popped off the IL stack.
        // pSubroutines    : [In,Optional] Optional collection of subroutines that the
        // intrinsic function can call into.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ const GUID& LanguageId,
            _In_ UINT32 Id,
            _In_ UINT32 ArgumentCount,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Deref_out_ Evaluation::IL::DkmILExecuteIntrinsic** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Executes an intrinsic function.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pILContext      : [In] The stack frame context we are evaluating on.
        // Arguments       : [In] The arguments supplied to the intrinsic function.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pSubroutines    : [In,Optional] Optional array of IL-based subroutines that the
        // intrinsic function may choose to invoke during its operation.
        // pResults        : [Out] The results of the evaluation to be pushed onto the IL
        // stack (in order).
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pFailureReason  : [Out] If an error occurs, specifies the reason for the error.
        // To indicate an error code whose meaning is specific to the particular intrinsic
        // function being executed, return a value less than zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ const DkmArray<Evaluation::IL::DkmILEvaluationResult*>& Arguments,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason::e* pFailureReason
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmILExecuteIntrinsic

    // Pops a value off the IL stack and extracts a subset of the bytes of that value,
    // pushing the result back onto the IL stack. If the entire region of bytes to extract
    // doesn't fall within the bounds of the value popped from the stack, an IL exception of
    // code ByteExtractionOutOfBounds will be thrown.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fe1217c9-bd40-4691-c912-72577c056ee1") DkmILExtractBytes : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExtractBytes::Create to create this object
        private: DkmILExtractBytes();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExtractBytes();
        // This object cannot be copied
        private: DkmILExtractBytes& operator=(const DkmILExtractBytes&);
        private: DkmILExtractBytes(const DkmILExtractBytes&);

        private: const UINT32 m_Offset;
        private: const UINT32 m_Length;
        private: void* m__pExtendedData;

        // The offset of the first byte to extract.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Offset(
            );

        // The number of bytes to extract.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Length(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExtractBytes'. Return
        // NULL if the path object is not a 'DkmILExtractBytes'.
        // pExtractBytes : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExtractBytes* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExtractBytes)
                return NULL;

            return static_cast<DkmILExtractBytes*>(pILInstruction);
        }

        // Create a new DkmILExtractBytes object instance.
        // Offset          : [In] The offset of the first byte to extract.
        // Length          : [In] The number of bytes to extract.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Offset,
            _In_ UINT32 Length,
            _Deref_out_ Evaluation::IL::DkmILExtractBytes** ppCreatedObject
            );
    }; // end of DkmILExtractBytes

    // A request to read data from a shader shared buffer.  The offset in the buffer is
    // popped from the IL stack.  The result is pushed on the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d6e46654-0686-441c-3d86-ff6bf50f4df6") DkmILHlslBufferRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslBufferRead::Create to create this object
        private: DkmILHlslBufferRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslBufferRead();
        // This object cannot be copied
        private: DkmILHlslBufferRead& operator=(const DkmILHlslBufferRead&);
        private: DkmILHlslBufferRead(const DkmILHlslBufferRead&);

        private: const CV_HREG_e m_RegisterId;
        private: const UINT32 m_RegisterIndex;
        private: const UINT32 m_BytesToRead;
        private: void* m__pExtendedData;

        // The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // The index of the register to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RegisterIndex(
            );

        // The number of bytes to read from the shared buffer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BytesToRead(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslBufferRead'. Return
        // NULL if the path object is not a 'DkmILHlslBufferRead'.
        // pHlslBufferRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslBufferRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslBufferRead)
                return NULL;

            return static_cast<DkmILHlslBufferRead*>(pILInstruction);
        }

        // Create a new DkmILHlslBufferRead object instance.
        // RegisterId      : [In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        // RegisterIndex   : [In] The index of the register to read.
        // BytesToRead     : [In] The number of bytes to read from the shared buffer.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 BytesToRead,
            _Deref_out_ Evaluation::IL::DkmILHlslBufferRead** ppCreatedObject
            );
    }; // end of DkmILHlslBufferRead

    // A request to 'read' the current group ID.  The result is pushed on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dd58ab29-83d2-c4d4-e499-e85e5bf99277") DkmILHlslGetGroupId : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslGetGroupId::Create to create this object
        private: DkmILHlslGetGroupId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslGetGroupId();
        // This object cannot be copied
        private: DkmILHlslGetGroupId& operator=(const DkmILHlslGetGroupId&);
        private: DkmILHlslGetGroupId(const DkmILHlslGetGroupId&);

        private: const GPU::DkmHlslThreadIdComponents::e m_GroupIdComponents;
        private: void* m__pExtendedData;

        // Specifies what portion of the thread group ID should be pushed on the stack.
        public: DECLSPEC_NOTHROW GPU::DkmHlslThreadIdComponents::e STDMETHODCALLTYPE GroupIdComponents(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslGetGroupId'. Return
        // NULL if the path object is not a 'DkmILHlslGetGroupId'.
        // pHlslGetGroupId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslGetGroupId* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslGetGroupId)
                return NULL;

            return static_cast<DkmILHlslGetGroupId*>(pILInstruction);
        }

        // Create a new DkmILHlslGetGroupId object instance.
        // GroupIdComponents: [In] Specifies what portion of the thread group ID should be
        // pushed on the stack.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ GPU::DkmHlslThreadIdComponents::e GroupIdComponents,
            _Deref_out_ Evaluation::IL::DkmILHlslGetGroupId** ppCreatedObject
            );
    }; // end of DkmILHlslGetGroupId

    // A request to 'read' the current thread ID.  The result is pushed on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2c425193-043f-3d02-59b1-cedd50363ca6") DkmILHlslGetThreadId : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslGetThreadId::Create to create this object
        private: DkmILHlslGetThreadId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslGetThreadId();
        // This object cannot be copied
        private: DkmILHlslGetThreadId& operator=(const DkmILHlslGetThreadId&);
        private: DkmILHlslGetThreadId(const DkmILHlslGetThreadId&);

        private: const bool m_UseDispatchId;
        private: const bool m_UseFlatModel;
        private: const GPU::DkmHlslThreadIdComponents::e m_ThreadIdComponents;
        private: void* m__pExtendedData;

        // Indicates whether the thread ID should be returned relative to the dispatch (true)
        // or relative to the tile (false).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE UseDispatchId(
            );

        // Instructs the debugger to fetch the thread id in flat format (if true), or as a
        // vector (if false).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE UseFlatModel(
            );

        // Specifies what portion of the thread ID should be pushed on the stack.
        public: DECLSPEC_NOTHROW GPU::DkmHlslThreadIdComponents::e STDMETHODCALLTYPE ThreadIdComponents(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslGetThreadId'. Return
        // NULL if the path object is not a 'DkmILHlslGetThreadId'.
        // pHlslGetThreadId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslGetThreadId* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslGetThreadId)
                return NULL;

            return static_cast<DkmILHlslGetThreadId*>(pILInstruction);
        }

        // Create a new DkmILHlslGetThreadId object instance.
        // UseDispatchId   : [In] Indicates whether the thread ID should be returned relative
        // to the dispatch (true) or relative to the tile (false).
        // UseFlatModel    : [In] Instructs the debugger to fetch the thread id in flat
        // format (if true), or as a vector (if false).
        // ThreadIdComponents: [In] Specifies what portion of the thread ID should be pushed
        // on the stack.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ bool UseDispatchId,
            _In_ bool UseFlatModel,
            _In_ GPU::DkmHlslThreadIdComponents::e ThreadIdComponents,
            _Deref_out_ Evaluation::IL::DkmILHlslGetThreadId** ppCreatedObject
            );
    }; // end of DkmILHlslGetThreadId

    // A request to read the value of a specific register.  The index of the first vector
    // element to read is popped from the IL stack.  The result is pushed on the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("64daf200-37b1-379f-b698-4a181200b8db") DkmILHlslIndexedRegisterRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslIndexedRegisterRead::Create to create this object
        private: DkmILHlslIndexedRegisterRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslIndexedRegisterRead();
        // This object cannot be copied
        private: DkmILHlslIndexedRegisterRead& operator=(const DkmILHlslIndexedRegisterRead&);
        private: DkmILHlslIndexedRegisterRead(const DkmILHlslIndexedRegisterRead&);

        private: const CV_HREG_e m_RegisterId;
        private: const UINT32 m_RegisterIndex;
        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BytesToRead;
        private: const UINT32 m_VectorElements;
        private: void* m__pExtendedData;

        // The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // The index of the register to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RegisterIndex(
            );

        // The offset in bytes from the beginning of the register to begin reading.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The number of bytes to be read from each vector register.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BytesToRead(
            );

        // The number of vector elements to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VectorElements(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslIndexedRegisterRead'. Return
        // NULL if the path object is not a 'DkmILHlslIndexedRegisterRead'.
        // pHlslIndexedRegisterRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslIndexedRegisterRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslIndexedRegisterRead)
                return NULL;

            return static_cast<DkmILHlslIndexedRegisterRead*>(pILInstruction);
        }

        // Create a new DkmILHlslIndexedRegisterRead object instance.
        // RegisterId      : [In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        // RegisterIndex   : [In] The index of the register to read.
        // ByteOffset      : [In] The offset in bytes from the beginning of the register to
        // begin reading.
        // BytesToRead     : [In] The number of bytes to be read from each vector register.
        // VectorElements  : [In] The number of vector elements to read.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BytesToRead,
            _In_ UINT32 VectorElements,
            _Deref_out_ Evaluation::IL::DkmILHlslIndexedRegisterRead** ppCreatedObject
            );
    }; // end of DkmILHlslIndexedRegisterRead

    // A request to read the value of a specific register.  The result is pushed on the IL
    // stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("967c6835-6825-8a43-1d23-c4b5f9fb2719") DkmILHlslRegisterRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslRegisterRead::Create to create this object
        private: DkmILHlslRegisterRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslRegisterRead();
        // This object cannot be copied
        private: DkmILHlslRegisterRead& operator=(const DkmILHlslRegisterRead&);
        private: DkmILHlslRegisterRead(const DkmILHlslRegisterRead&);

        private: const CV_HREG_e m_RegisterId;
        private: const UINT32 m_RegisterIndex;
        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BytesToRead;
        private: const UINT32 m_FirstElement;
        private: const UINT32 m_VectorElements;
        private: void* m__pExtendedData;

        // The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // The index of the register to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RegisterIndex(
            );

        // The offset in bytes from the beginning of the register to begin reading.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The number of bytes to be read from each vector register.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BytesToRead(
            );

        // The index of the first vector element.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FirstElement(
            );

        // The number of vector elements to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VectorElements(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslRegisterRead'. Return
        // NULL if the path object is not a 'DkmILHlslRegisterRead'.
        // pHlslRegisterRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslRegisterRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslRegisterRead)
                return NULL;

            return static_cast<DkmILHlslRegisterRead*>(pILInstruction);
        }

        // Create a new DkmILHlslRegisterRead object instance.
        // RegisterId      : [In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        // RegisterIndex   : [In] The index of the register to read.
        // ByteOffset      : [In] The offset in bytes from the beginning of the register to
        // begin reading.
        // BytesToRead     : [In] The number of bytes to be read from each vector register.
        // FirstElement    : [In] The index of the first vector element.
        // VectorElements  : [In] The number of vector elements to read.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BytesToRead,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _Deref_out_ Evaluation::IL::DkmILHlslRegisterRead** ppCreatedObject
            );
    }; // end of DkmILHlslRegisterRead

    // Pops a value off of the evaluation stack.  If the value is zero, pushes a 32-bit value
    // of 1 on the stack. Otherwise, pushes a 32-bit value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("58671534-8e49-9c48-c2a8-201d29bac5ef") DkmILIsFalse : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILIsFalse::Create to create this object
        private: DkmILIsFalse();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILIsFalse();
        // This object cannot be copied
        private: DkmILIsFalse& operator=(const DkmILIsFalse&);
        private: DkmILIsFalse(const DkmILIsFalse&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILIsFalse'. Return
        // NULL if the path object is not a 'DkmILIsFalse'.
        // pIsFalse : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILIsFalse* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::IsFalse)
                return NULL;

            return static_cast<DkmILIsFalse*>(pILInstruction);
        }

        // Create a new DkmILIsFalse object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILIsFalse** ppCreatedObject
            );
    }; // end of DkmILIsFalse

    // Pops a value off of the evaluation stack.  If the value is non-zero, pushes a 32-bit
    // value of 1 on the stack. Otherwise, pushes a 32-bit value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fefef4e7-d812-5005-f1c2-e817b63e0e5c") DkmILIsTrue : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILIsTrue::Create to create this object
        private: DkmILIsTrue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILIsTrue();
        // This object cannot be copied
        private: DkmILIsTrue& operator=(const DkmILIsTrue&);
        private: DkmILIsTrue(const DkmILIsTrue&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILIsTrue'. Return
        // NULL if the path object is not a 'DkmILIsTrue'.
        // pIsTrue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILIsTrue* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::IsTrue)
                return NULL;

            return static_cast<DkmILIsTrue*>(pILInstruction);
        }

        // Create a new DkmILIsTrue object instance.
        // Type            : [In] The type of comparison to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILIsTrue** ppCreatedObject
            );
    }; // end of DkmILIsTrue

    // Jumps to another instruction in the instruction stream.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("36bb21a4-629b-d3fe-7cba-97191f007349") DkmILJump : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILJump::Create to create this object
        private: DkmILJump();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILJump();
        // This object cannot be copied
        private: DkmILJump& operator=(const DkmILJump&);
        private: DkmILJump(const DkmILJump&);

        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // Location in the instruction stream to jump to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILJump'. Return
        // NULL if the path object is not a 'DkmILJump'.
        // pJump : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILJump* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Jump)
                return NULL;

            return static_cast<DkmILJump*>(pILInstruction);
        }

        // Create a new DkmILJump object instance.
        // Target          : [In] Location in the instruction stream to jump to.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILJump** ppCreatedObject
            );
    }; // end of DkmILJump

    // Pops a value off the IL stack.  Then, jumps to another instruction in the instruction
    // stream only if the value bytes are all zero.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("80cc8616-ef15-670e-16dc-8d1d852e80b1") DkmILJumpIfFalse : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILJumpIfFalse::Create to create this object
        private: DkmILJumpIfFalse();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILJumpIfFalse();
        // This object cannot be copied
        private: DkmILJumpIfFalse& operator=(const DkmILJumpIfFalse&);
        private: DkmILJumpIfFalse(const DkmILJumpIfFalse&);

        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // Location in the instruction stream to jump to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILJumpIfFalse'. Return
        // NULL if the path object is not a 'DkmILJumpIfFalse'.
        // pJumpIfFalse : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILJumpIfFalse* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::JumpIfFalse)
                return NULL;

            return static_cast<DkmILJumpIfFalse*>(pILInstruction);
        }

        // Create a new DkmILJumpIfFalse object instance.
        // Target          : [In] Location in the instruction stream to jump to.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILJumpIfFalse** ppCreatedObject
            );
    }; // end of DkmILJumpIfFalse

    // Pops a value off the IL stack.  Then, jumps to another instruction in the instruction
    // stream only if the value bytes are not all zero.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("01aaf69c-9a98-03d9-2bbd-49b74de78028") DkmILJumpIfTrue : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILJumpIfTrue::Create to create this object
        private: DkmILJumpIfTrue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILJumpIfTrue();
        // This object cannot be copied
        private: DkmILJumpIfTrue& operator=(const DkmILJumpIfTrue&);
        private: DkmILJumpIfTrue(const DkmILJumpIfTrue&);

        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // Location in the instruction stream to jump to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILJumpIfTrue'. Return
        // NULL if the path object is not a 'DkmILJumpIfTrue'.
        // pJumpIfTrue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILJumpIfTrue* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::JumpIfTrue)
                return NULL;

            return static_cast<DkmILJumpIfTrue*>(pILInstruction);
        }

        // Create a new DkmILJumpIfTrue object instance.
        // Target          : [In] Location in the instruction stream to jump to.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILJumpIfTrue** ppCreatedObject
            );
    }; // end of DkmILJumpIfTrue

    // Loads a value from an index previously saved from a DkmSave instruction and pushes the
    // value to the top of the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("242ede22-4afa-dcb0-6e75-e5b718815bee") DkmILLoad : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILLoad::Create to create this object
        private: DkmILLoad();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILLoad();
        // This object cannot be copied
        private: DkmILLoad& operator=(const DkmILLoad&);
        private: DkmILLoad(const DkmILLoad&);

        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // The index at which to save the value.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILLoad'. Return
        // NULL if the path object is not a 'DkmILLoad'.
        // pLoad : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILLoad* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Load)
                return NULL;

            return static_cast<DkmILLoad*>(pILInstruction);
        }

        // Create a new DkmILLoad object instance.
        // Index           : [In] The index at which to save the value.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Index,
            _Deref_out_ Evaluation::IL::DkmILLoad** ppCreatedObject
            );
    }; // end of DkmILLoad

    // A request to read a sequence of bytes from memory.  The address to read from is popped
    // off the DkmIL stack and must have a size of 4 if the debuggee is 32-bit, or 8 if the
    // debuggee is 64-bit.  The bytes that are read from memory are pushed onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("773a4206-89a8-80c4-a828-6ea6728935aa") DkmILMemoryRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMemoryRead::Create to create this object
        private: DkmILMemoryRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMemoryRead();
        // This object cannot be copied
        private: DkmILMemoryRead& operator=(const DkmILMemoryRead&);
        private: DkmILMemoryRead(const DkmILMemoryRead&);

        private: const UINT32 m_Size;
        private: const DkmReadMemoryFlags::e m_Flags;
        private: void* m__pExtendedData;

        // Number of bytes to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        public: DECLSPEC_NOTHROW DkmReadMemoryFlags::e STDMETHODCALLTYPE Flags(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMemoryRead'. Return
        // NULL if the path object is not a 'DkmILMemoryRead'.
        // pMemoryRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMemoryRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::MemoryRead)
                return NULL;

            return static_cast<DkmILMemoryRead*>(pILInstruction);
        }

        // Create a new DkmILMemoryRead object instance.
        // Size            : [In] Number of bytes to read.
        // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Size,
            _In_ DkmReadMemoryFlags::e Flags,
            _Deref_out_ Evaluation::IL::DkmILMemoryRead** ppCreatedObject
            );
    }; // end of DkmILMemoryRead

    // A request to read a null-terminated string from the target process. The address to
    // read from is popped off the DkmIL stack and must have a size of 4 if the debuggee is
    // 32-bit, or 8 if the debuggee is 64-bit.  The bytes that are read from memory are
    // pushed onto the stack. This will include the null-terminator if this value is read.
    // The null-terminator will be missing when DkmReadMemoryFlags.AllowPartialRead is true,
    // and either the MaxCharacters is hit, or unreadable memory is hit before the null
    // terminator.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a64d7c04-4e5a-4a75-936c-5eeeb7121f65") DkmILMemoryStringRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMemoryStringRead::Create to create this object
        private: DkmILMemoryStringRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMemoryStringRead();
        // This object cannot be copied
        private: DkmILMemoryStringRead& operator=(const DkmILMemoryStringRead&);
        private: DkmILMemoryStringRead(const DkmILMemoryStringRead&);

        private: const DkmReadMemoryFlags::e m_Flags;
        private: const UINT16 m_CharacterSize;
        private: const UINT32 m_MaxCharacters;
        private: void* m__pExtendedData;

        // Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        public: DECLSPEC_NOTHROW DkmReadMemoryFlags::e STDMETHODCALLTYPE Flags(
            );

        // Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2
        // (UTF-16) or 4 (UTF-32).
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE CharacterSize(
            );

        // The maximum number of characters to read from the target process. When
        // DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null
        // terminator isn't found within this range with DkmILFailureReason.StringTooLong.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MaxCharacters(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMemoryStringRead'. Return
        // NULL if the path object is not a 'DkmILMemoryStringRead'.
        // pMemoryStringRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMemoryStringRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::MemoryStringRead)
                return NULL;

            return static_cast<DkmILMemoryStringRead*>(pILInstruction);
        }

        // Create a new DkmILMemoryStringRead object instance.
        // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        // CharacterSize   : [In] Number of bytes in each character. This should be set to 1
        // (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).
        // MaxCharacters   : [In] The maximum number of characters to read from the target
        // process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail
        // if a null terminator isn't found within this range with
        // DkmILFailureReason.StringTooLong.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadMemoryFlags::e Flags,
            _In_ UINT16 CharacterSize,
            _In_ UINT32 MaxCharacters,
            _Deref_out_ Evaluation::IL::DkmILMemoryStringRead** ppCreatedObject
            );
    }; // end of DkmILMemoryStringRead

    // A request to write a sequence of bytes from memory.  Pops a value off the stack.
    // Then, pops an address of the stack.  Writes the value popped off the stack to debuggee
    // memory at the address popped off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9b5f6ebc-fd01-fca2-baec-9d02957bffc4") DkmILMemoryWrite : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMemoryWrite::Create to create this object
        private: DkmILMemoryWrite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMemoryWrite();
        // This object cannot be copied
        private: DkmILMemoryWrite& operator=(const DkmILMemoryWrite&);
        private: DkmILMemoryWrite(const DkmILMemoryWrite&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMemoryWrite'. Return
        // NULL if the path object is not a 'DkmILMemoryWrite'.
        // pMemoryWrite : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMemoryWrite* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::MemoryWrite)
                return NULL;

            return static_cast<DkmILMemoryWrite*>(pILInstruction);
        }

        // Create a new DkmILMemoryWrite object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILMemoryWrite** ppCreatedObject
            );
    }; // end of DkmILMemoryWrite

    // Pops two values off the evaluation stack, multiplies them, and pushes the product onto
    // the evaluation stack. Both operands popped off the stack must be the size indicated by
    // DkmPrimitiveObjectType. In the event of overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3fcf6521-45e9-d844-be16-1f0523c98ff3") DkmILMultiply : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMultiply::Create to create this object
        private: DkmILMultiply();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMultiply();
        // This object cannot be copied
        private: DkmILMultiply& operator=(const DkmILMultiply&);
        private: DkmILMultiply(const DkmILMultiply&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of subtraction to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMultiply'. Return
        // NULL if the path object is not a 'DkmILMultiply'.
        // pMultiply : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMultiply* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Multiply)
                return NULL;

            return static_cast<DkmILMultiply*>(pILInstruction);
        }

        // Create a new DkmILMultiply object instance.
        // Type            : [In] The type of subtraction to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILMultiply** ppCreatedObject
            );
    }; // end of DkmILMultiply

    // Placeholder instruction that does no operation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("54573ae7-a6fa-c7c5-4473-3846e8a76f1f") DkmILNop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILNop::Create to create this object
        private: DkmILNop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILNop();
        // This object cannot be copied
        private: DkmILNop& operator=(const DkmILNop&);
        private: DkmILNop(const DkmILNop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILNop'. Return
        // NULL if the path object is not a 'DkmILNop'.
        // pNop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILNop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Nop)
                return NULL;

            return static_cast<DkmILNop*>(pILInstruction);
        }

        // Create a new DkmILNop object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILNop** ppCreatedObject
            );
    }; // end of DkmILNop

    // Pop the value on top of the DkmIL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6eb40730-7c81-beb5-91be-bf369d34f741") DkmILPop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILPop::Create to create this object
        private: DkmILPop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILPop();
        // This object cannot be copied
        private: DkmILPop& operator=(const DkmILPop&);
        private: DkmILPop(const DkmILPop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILPop'. Return
        // NULL if the path object is not a 'DkmILPop'.
        // pPop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILPop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Pop)
                return NULL;

            return static_cast<DkmILPop*>(pILInstruction);
        }

        // Create a new DkmILPop object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILPop** ppCreatedObject
            );
    }; // end of DkmILPop

    // Pushes a constant value onto the DkmIL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("debef887-9da9-04e2-fff2-6e510affdffe") DkmILPushConstant : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILPushConstant::Create to create this object
        private: DkmILPushConstant();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILPushConstant();
        // This object cannot be copied
        private: DkmILPushConstant& operator=(const DkmILPushConstant&);
        private: DkmILPushConstant(const DkmILPushConstant&);

        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // The value to push onto the DkmIL stack.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILPushConstant'. Return
        // NULL if the path object is not a 'DkmILPushConstant'.
        // pPushConstant : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILPushConstant* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::PushConstant)
                return NULL;

            return static_cast<DkmILPushConstant*>(pILInstruction);
        }

        // Create a new DkmILPushConstant object instance.
        // pValue          : [In] The value to push onto the DkmIL stack.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ Evaluation::IL::DkmILPushConstant** ppCreatedObject
            );
    }; // end of DkmILPushConstant

    // A request to read the value of a specific register.  The result is pushed on the DkmIL
    // stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("65088917-dd5b-32c3-b300-21da5242d959") DkmILRegisterRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILRegisterRead::Create to create this object
        private: DkmILRegisterRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILRegisterRead();
        // This object cannot be copied
        private: DkmILRegisterRead& operator=(const DkmILRegisterRead&);
        private: DkmILRegisterRead(const DkmILRegisterRead&);

        private: const CV_HREG_e m_RegisterId;
        private: void* m__pExtendedData;

        // The code-view definition of which register to read.  Values are defined in
        // cvconst.h.  This is architecture dependent.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILRegisterRead'. Return
        // NULL if the path object is not a 'DkmILRegisterRead'.
        // pRegisterRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILRegisterRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::RegisterRead)
                return NULL;

            return static_cast<DkmILRegisterRead*>(pILInstruction);
        }

        // Create a new DkmILRegisterRead object instance.
        // RegisterId      : [In] The code-view definition of which register to read.  Values
        // are defined in cvconst.h.  This is architecture dependent.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _Deref_out_ Evaluation::IL::DkmILRegisterRead** ppCreatedObject
            );
    }; // end of DkmILRegisterRead

    // Pops a value off the IL stack.  Then, writes the value to the given register of the
    // given thread.  The write will be visible to the debuggee from the top frame of that
    // thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6c08742c-250e-5f2c-98bb-b2a714901eab") DkmILRegisterWrite : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILRegisterWrite::Create to create this object
        private: DkmILRegisterWrite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILRegisterWrite();
        // This object cannot be copied
        private: DkmILRegisterWrite& operator=(const DkmILRegisterWrite&);
        private: DkmILRegisterWrite(const DkmILRegisterWrite&);

        private: const CV_HREG_e m_RegisterId;
        private: void* m__pExtendedData;

        // The code-view definition of which register to write.  Values are defined in
        // cvconst.h.  This is architecture dependent.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILRegisterWrite'. Return
        // NULL if the path object is not a 'DkmILRegisterWrite'.
        // pRegisterWrite : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILRegisterWrite* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::RegisterWrite)
                return NULL;

            return static_cast<DkmILRegisterWrite*>(pILInstruction);
        }

        // Create a new DkmILRegisterWrite object instance.
        // RegisterId      : [In] The code-view definition of which register to write.
        // Values are defined in cvconst.h.  This is architecture dependent.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _Deref_out_ Evaluation::IL::DkmILRegisterWrite** ppCreatedObject
            );
    }; // end of DkmILRegisterWrite

    // Pops two values off the evaluation stack and computes the second value popped off the
    // stack modulo the first value popped off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2fc16220-cbf9-15e8-f428-84628d374f31") DkmILRemainder : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILRemainder::Create to create this object
        private: DkmILRemainder();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILRemainder();
        // This object cannot be copied
        private: DkmILRemainder& operator=(const DkmILRemainder&);
        private: DkmILRemainder(const DkmILRemainder&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of operands to consume (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILRemainder'. Return
        // NULL if the path object is not a 'DkmILRemainder'.
        // pRemainder : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILRemainder* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Remainder)
                return NULL;

            return static_cast<DkmILRemainder*>(pILInstruction);
        }

        // Create a new DkmILRemainder object instance.
        // Type            : [In] The type of operands to consume (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILRemainder** ppCreatedObject
            );
    }; // end of DkmILRemainder

    // Pop the value on top of the DkmIL stack and return it as an instance of
    // DkmILEvaluationResult.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("deb13411-2568-d114-0ab1-ab891ce11a2c") DkmILReturnTop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILReturnTop::Create to create this object
        private: DkmILReturnTop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILReturnTop();
        // This object cannot be copied
        private: DkmILReturnTop& operator=(const DkmILReturnTop&);
        private: DkmILReturnTop(const DkmILReturnTop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILReturnTop'. Return
        // NULL if the path object is not a 'DkmILReturnTop'.
        // pReturnTop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILReturnTop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ReturnTop)
                return NULL;

            return static_cast<DkmILReturnTop*>(pILInstruction);
        }

        // Create a new DkmILReturnTop object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILReturnTop** ppCreatedObject
            );
    }; // end of DkmILReturnTop

    // Saves the value at the top of the stack in a temporary slot at the given index, from
    // which it can later be loaded back.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("60b4a51a-025c-34a3-6b05-284cf64fd50f") DkmILSave : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILSave::Create to create this object
        private: DkmILSave();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILSave();
        // This object cannot be copied
        private: DkmILSave& operator=(const DkmILSave&);
        private: DkmILSave(const DkmILSave&);

        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // The index at which to save the value.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILSave'. Return
        // NULL if the path object is not a 'DkmILSave'.
        // pSave : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILSave* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Save)
                return NULL;

            return static_cast<DkmILSave*>(pILInstruction);
        }

        // Create a new DkmILSave object instance.
        // Index           : [In] The index at which to save the value.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Index,
            _Deref_out_ Evaluation::IL::DkmILSave** ppCreatedObject
            );
    }; // end of DkmILSave

    // Pops a value off the IL stack.  Then pops an offset, followed by a blob of bytes.
    // Modifies the first value so that the segment at the offset is replaced with the blob
    // of bytes provided.  Pushes the resultant value back onto the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d49f8ec4-1fab-cf70-86c4-6b615460c079") DkmILSetBytesRegion : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILSetBytesRegion::Create to create this object
        private: DkmILSetBytesRegion();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILSetBytesRegion();
        // This object cannot be copied
        private: DkmILSetBytesRegion& operator=(const DkmILSetBytesRegion&);
        private: DkmILSetBytesRegion(const DkmILSetBytesRegion&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILSetBytesRegion'. Return
        // NULL if the path object is not a 'DkmILSetBytesRegion'.
        // pSetBytesRegion : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILSetBytesRegion* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::SetBytesRegion)
                return NULL;

            return static_cast<DkmILSetBytesRegion*>(pILInstruction);
        }

        // Create a new DkmILSetBytesRegion object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILSetBytesRegion** ppCreatedObject
            );
    }; // end of DkmILSetBytesRegion

    // Pops two values off the evaluation stack, subtracts them, and pushes the difference
    // onto the evaluation stack. Both operands popped off the stack must be the size
    // indicated by DkmPrimitiveObjectType.  The first value popped from the stack will be
    // subtracted from the second value popped, so to evaluate "a - b", you would push a,
    // then push b, then subtract. The resultant value will have the same size as the
    // operands.  In the event of overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8dd587d3-eb37-aba6-37b6-b6cae1950c3e") DkmILSubtract : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILSubtract::Create to create this object
        private: DkmILSubtract();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILSubtract();
        // This object cannot be copied
        private: DkmILSubtract& operator=(const DkmILSubtract&);
        private: DkmILSubtract(const DkmILSubtract&);

        private: const Evaluation::IL::DkmPrimitiveObjectType::e m_Type;
        private: void* m__pExtendedData;

        // The type of subtraction to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILSubtract'. Return
        // NULL if the path object is not a 'DkmILSubtract'.
        // pSubtract : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILSubtract* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Subtract)
                return NULL;

            return static_cast<DkmILSubtract*>(pILInstruction);
        }

        // Create a new DkmILSubtract object instance.
        // Type            : [In] The type of subtraction to perform (e.g. integer vs.
        // floating-point).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType::e Type,
            _Deref_out_ Evaluation::IL::DkmILSubtract** ppCreatedObject
            );
    }; // end of DkmILSubtract

    // Throws a native IL exception within the given failure code.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b786a0a1-1605-bbee-238d-dbb759497dfb") DkmILThrow : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILThrow::Create to create this object
        private: DkmILThrow();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILThrow();
        // This object cannot be copied
        private: DkmILThrow& operator=(const DkmILThrow&);
        private: DkmILThrow(const DkmILThrow&);

        private: const Evaluation::IL::DkmILFailureReason::e m_FailureCode;
        private: void* m__pExtendedData;

        // Indicates a reason why an IL instruction failed to execute.  In addition to these
        // constants, negative values may be used to indicate customized error conditions
        // resulting from the execution of intrinsic functions.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFailureReason::e STDMETHODCALLTYPE FailureCode(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILThrow'. Return
        // NULL if the path object is not a 'DkmILThrow'.
        // pThrow : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILThrow* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Throw)
                return NULL;

            return static_cast<DkmILThrow*>(pILInstruction);
        }

        // Create a new DkmILThrow object instance.
        // FailureCode     : [In] Indicates a reason why an IL instruction failed to execute.
        // In addition to these constants, negative values may be used to indicate customized
        // error conditions resulting from the execution of intrinsic functions.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmILFailureReason::e FailureCode,
            _Deref_out_ Evaluation::IL::DkmILThrow** ppCreatedObject
            );
    }; // end of DkmILThrow

    // Pushes an index of a TLS slot off the IL stack.  Reads the value of that TLS slot for
    // the thread of the current stack frame and pushes the result onto the IL stack. If the
    // TLS index is not valid, the result is undefined.  It may read a random value from
    // memory, or fail. The value that is pushed on the stack is a pointer-sized value (4
    // bytes if the debuggee is 32-bit, 8 bytes if the debuggee is 64-bit).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a9dbc0f2-c7be-c76b-5cff-9e45cef41a33") DkmILTlsGetValue : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILTlsGetValue::Create to create this object
        private: DkmILTlsGetValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILTlsGetValue();
        // This object cannot be copied
        private: DkmILTlsGetValue& operator=(const DkmILTlsGetValue&);
        private: DkmILTlsGetValue(const DkmILTlsGetValue&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILTlsGetValue'. Return
        // NULL if the path object is not a 'DkmILTlsGetValue'.
        // pTlsGetValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILTlsGetValue* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::TlsGetValue)
                return NULL;

            return static_cast<DkmILTlsGetValue*>(pILInstruction);
        }

        // Create a new DkmILTlsGetValue object instance.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILTlsGetValue** ppCreatedObject
            );
    }; // end of DkmILTlsGetValue

};}; // end namespace Evaluation::IL

// Contains the types used to evaluation the same expression across multiple threads.
namespace Evaluation { namespace Group {
    // The results for a set of threads that match a specific context.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2bed0f45-7abe-5710-434c-3a254db68898") DkmContextGroupEvaluationILResult : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmContextGroupEvaluationILResult::Create to create this object
        private: DkmContextGroupEvaluationILResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmContextGroupEvaluationILResult();
        // This object cannot be copied
        private: DkmContextGroupEvaluationILResult& operator=(const DkmContextGroupEvaluationILResult&);
        private: DkmContextGroupEvaluationILResult(const DkmContextGroupEvaluationILResult&);

        private: const HRESULT m_EvaluationResults;
        private: DkmReadOnlyCollection<Evaluation::Group::DkmThreadEvaluationResultCollection*>* const m_pResultData;
        private: void* m__pExtendedData;

        // Result of the evaluation on this set of threads.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluationResults(
            );

        // An array of result data structures that indicate the source instruction and the
        // data buffer for all threads.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::Group::DkmThreadEvaluationResultCollection*>* STDMETHODCALLTYPE ResultData(
            );

        // Create a new DkmContextGroupEvaluationILResult object instance.
        // EvaluationResults: [In] Result of the evaluation on this set of threads.
        // pResultData     : [In] An array of result data structures that indicate the source
        // instruction and the data buffer for all threads.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ HRESULT EvaluationResults,
            _In_ DkmReadOnlyCollection<Evaluation::Group::DkmThreadEvaluationResultCollection*>* pResultData,
            _Deref_out_ Evaluation::Group::DkmContextGroupEvaluationILResult** ppCreatedObject
            );
    }; // end of DkmContextGroupEvaluationILResult

    // The results for a set of threads that match a specific context.
    //
    // Derived classes: DkmFailedContextGroupEvaluationResult,
    // DkmSuccessContextGroupEvaluationResult
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bb891190-1064-c1b9-132e-f2e637c597e0") DkmContextGroupEvaluationResult : public DkmDataContainer
    {
        // Use DkmContextGroupEvaluationResult::Create to create this object
        private: DkmContextGroupEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmContextGroupEvaluationResult();
        // This object cannot be copied
        private: DkmContextGroupEvaluationResult& operator=(const DkmContextGroupEvaluationResult&);
        private: DkmContextGroupEvaluationResult(const DkmContextGroupEvaluationResult&);

        // DkmContextGroupEvaluationResult is an abstract base class. This enum indicates
        // which derived class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmSuccessContextGroupEvaluationResult'.
        SuccessContextGroupEvalResult = 0,
        // Object is an instance of 'DkmFailedContextGroupEvaluationResult'.
        FailedContextGroupEvalResult = 1
        }; };

        private: const Tag::e m_TagValue;
        private: DkmReadOnlyCollection<UINT64>* const m_pThreadIds;
        private: const HRESULT m_EvaluationResults;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pFullName;
        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // DkmContextGroupEvaluationResult is an abstract base class. This enum indicates
        // which derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The thread IDs for the evaluation results.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE ThreadIds(
            );

        // Result of the evaluation on this set of threads.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluationResults(
            );

        // The name of the expression this result applies to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] The full name of the expression this result applies to. This value is
        // used to allow child elements to be added to the watch window (Add Watch from the
        // context menu), and to refresh parts of the evaluation tree. As an example of how
        // FullName differs from name, the name of the 0th element of an array in C++ is
        // '[0]' while the full name would by 'myArrayVariable[0]'.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Guid which uniquely identifies this evaluation result.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes the compute thread evaluation result object to release the resources
        // associated with it. This method must be invoked by the component which initiated
        // the enumeration (ex: called DkmInspectionContext.EvaluateExpression,
        // DkmEvaluationResultEnumContext.GetItems, etc).
        //
        // DkmContextGroupEvaluationResult objects are automatically closed when their
        // associated DkmRuntimeInstance object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );
    }; // end of DkmContextGroupEvaluationResult

    // Result of an asynchronous DkmInspectionContext.EvaluateExpressionOnThreads call.
    struct DkmEvaluateExpressionOnThreadsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // Object containing the results of the evaluation. This object must be closed by the
        // caller when the caller is done with the object.
        DkmReadOnlyCollection<Evaluation::Group::DkmContextGroupEvaluationResult*>* pResults;
    };

    // Result of an asynchronous DkmCompiledILInspectionQuery.ExecuteQueryOnThreads call.
    struct DkmExecuteQueryOnThreadsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Results of the evaluations.
        Evaluation::Group::DkmContextGroupEvaluationILResult* pResult;
    };

    // A collection of parameters that should be used together.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("79c52e77-96fa-6709-ca94-85d3a8ae6a5e") DkmILParameterValueCollection : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILParameterValueCollection::Create to create this object
        private: DkmILParameterValueCollection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILParameterValueCollection();
        // This object cannot be copied
        private: DkmILParameterValueCollection& operator=(const DkmILParameterValueCollection&);
        private: DkmILParameterValueCollection(const DkmILParameterValueCollection&);

        private: OPTIONAL DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* const m_pParameters;
        private: void* m__pExtendedData;

        // [Optional] The parameter collection.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* STDMETHODCALLTYPE Parameters(
            );

        // Create a new DkmILParameterValueCollection object instance.
        // pParameters     : [In,Optional] The parameter collection.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _Deref_out_ Evaluation::Group::DkmILParameterValueCollection** ppCreatedObject
            );
    }; // end of DkmILParameterValueCollection

    // The set of results from a single thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5abed340-3864-41c5-af3c-486f0d0cb101") DkmThreadEvaluationResultCollection : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmThreadEvaluationResultCollection::Create to create this object
        private: DkmThreadEvaluationResultCollection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmThreadEvaluationResultCollection();
        // This object cannot be copied
        private: DkmThreadEvaluationResultCollection& operator=(const DkmThreadEvaluationResultCollection&);
        private: DkmThreadEvaluationResultCollection(const DkmThreadEvaluationResultCollection&);

        private: DkmReadOnlyCollection<Evaluation::IL::DkmILEvaluationResult*>* const m_pResults;
        private: const Evaluation::IL::DkmILFailureReason::e m_FailureReason;
        private: void* m__pExtendedData;

        // The set of results from processing the query on the given thread.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILEvaluationResult*>* STDMETHODCALLTYPE Results(
            );

        // If an expected error occurs evaluating the DkmIL, indicates the reason for the
        // failure.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFailureReason::e STDMETHODCALLTYPE FailureReason(
            );

        // Create a new DkmThreadEvaluationResultCollection object instance.
        // pResults        : [In] The set of results from processing the query on the given
        // thread.
        // FailureReason   : [In] If an expected error occurs evaluating the DkmIL, indicates
        // the reason for the failure.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _In_ Evaluation::IL::DkmILFailureReason::e FailureReason,
            _Deref_out_ Evaluation::Group::DkmThreadEvaluationResultCollection** ppCreatedObject
            );
    }; // end of DkmThreadEvaluationResultCollection

    // The formatted result of a failed evaluation, ready to be displayed in an expression
    // evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bcbf5652-8501-77e0-2256-0e6455e7909a") DkmFailedContextGroupEvaluationResult : public Evaluation::Group::DkmContextGroupEvaluationResult
    {
        // Use DkmFailedContextGroupEvaluationResult::Create to create this object
        private: DkmFailedContextGroupEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFailedContextGroupEvaluationResult();
        // This object cannot be copied
        private: DkmFailedContextGroupEvaluationResult& operator=(const DkmFailedContextGroupEvaluationResult&);
        private: DkmFailedContextGroupEvaluationResult(const DkmFailedContextGroupEvaluationResult&);

        private: DkmString* const m_pErrorMessage;
        private: const bool m_HasSideEffects;
        private: void* m__pExtendedData;

        // Specifies the error message to display to the user.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ErrorMessage(
            );

        // Specifies the evaluation failed because it would cause side effects and side
        // effects are not allowed.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE HasSideEffects(
            );

        // Attempt to cast a 'DkmContextGroupEvaluationResult' to a 'DkmFailedContextGroupEvaluationResult'. Return
        // NULL if the path object is not a 'DkmFailedContextGroupEvaluationResult'.
        // pFailedContextGroupEvalResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmFailedContextGroupEvaluationResult* TryCast(
            DkmContextGroupEvaluationResult* pContextGroupEvalResult
            )
        {
            if (pContextGroupEvalResult == NULL || pContextGroupEvalResult->TagValue() != Tag::FailedContextGroupEvalResult)
                return NULL;

            return static_cast<DkmFailedContextGroupEvaluationResult*>(pContextGroupEvalResult);
        }

        // Create a new DkmFailedContextGroupEvaluationResult object instance.
        // pThreadIds      : [In] The thread IDs for the evaluation results.
        // EvaluationResults: [In] Result of the evaluation on this set of threads.
        // pName           : [In] The name of the expression this result applies to.
        // pFullName       : [In,Optional] The full name of the expression this result
        // applies to. This value is used to allow child elements to be added to the watch
        // window (Add Watch from the context menu), and to refresh parts of the evaluation
        // tree. As an example of how FullName differs from name, the name of the 0th element
        // of an array in C++ is '[0]' while the full name would by 'myArrayVariable[0]'.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pErrorMessage   : [In] Specifies the error message to display to the user.
        // HasSideEffects  : [In] Specifies the evaluation failed because it would cause side
        // effects and side effects are not allowed.
        // DataItem        : [In] Data object to add to the new
        // DkmFailedContextGroupEvaluationResult instance. DkmDataItem::Null() in the case
        // that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<UINT64>* pThreadIds,
            _In_ HRESULT EvaluationResults,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmString* pErrorMessage,
            _In_ bool HasSideEffects,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::Group::DkmFailedContextGroupEvaluationResult** ppCreatedObject
            );
    }; // end of DkmFailedContextGroupEvaluationResult

    // The formatted result of a successful evaluation, ready to be displayed in an
    // expression evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0f911a5f-f32c-2647-470c-5524bac4b351") DkmSuccessContextGroupEvaluationResult : public Evaluation::Group::DkmContextGroupEvaluationResult
    {
        // Use DkmSuccessContextGroupEvaluationResult::Create to create this object
        private: DkmSuccessContextGroupEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSuccessContextGroupEvaluationResult();
        // This object cannot be copied
        private: DkmSuccessContextGroupEvaluationResult& operator=(const DkmSuccessContextGroupEvaluationResult&);
        private: DkmSuccessContextGroupEvaluationResult(const DkmSuccessContextGroupEvaluationResult&);

        private: const Evaluation::DkmEvaluationResultFlags::e m_Flags;
        private: DkmReadOnlyCollection<DkmString*>* const m_pValues;
        private: OPTIONAL DkmString* const m_pType;
        private: const Evaluation::DkmEvaluationResultCategory::e m_Category;
        private: const Evaluation::DkmEvaluationResultAccessType::e m_Access;
        private: const Evaluation::DkmEvaluationResultStorageType::e m_StorageType;
        private: const Evaluation::DkmEvaluationResultTypeModifierFlags::e m_TypeModifierFlags;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* const m_pCustomUIVisualizers;
        private: void* m__pExtendedData;

        // Flags which indicate attributes of an expression evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags::e STDMETHODCALLTYPE Flags(
            );

        // The formatted values for each thread.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE Values(
            );

        // [Optional] A string that describes the type of the value.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // The category (ex: Data, Method, etc) of this evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory::e STDMETHODCALLTYPE Category(
            );

        // The access control level (public, private, etc) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultAccessType::e STDMETHODCALLTYPE Access(
            );

        // The storage type (ex: static) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultStorageType::e STDMETHODCALLTYPE StorageType(
            );

        // Type modifier flags (ex: const) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultTypeModifierFlags::e STDMETHODCALLTYPE TypeModifierFlags(
            );

        // [Optional] A list of custom viewers for this object.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE CustomUIVisualizers(
            );

        // Attempt to cast a 'DkmContextGroupEvaluationResult' to a 'DkmSuccessContextGroupEvaluationResult'. Return
        // NULL if the path object is not a 'DkmSuccessContextGroupEvaluationResult'.
        // pSuccessContextGroupEvalResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmSuccessContextGroupEvaluationResult* TryCast(
            DkmContextGroupEvaluationResult* pContextGroupEvalResult
            )
        {
            if (pContextGroupEvalResult == NULL || pContextGroupEvalResult->TagValue() != Tag::SuccessContextGroupEvalResult)
                return NULL;

            return static_cast<DkmSuccessContextGroupEvaluationResult*>(pContextGroupEvalResult);
        }

        // Create a new DkmSuccessContextGroupEvaluationResult object instance.
        // pThreadIds      : [In] The thread IDs for the evaluation results.
        // EvaluationResults: [In] Result of the evaluation on this set of threads.
        // pName           : [In] The name of the expression this result applies to.
        // pFullName       : [In,Optional] The full name of the expression this result
        // applies to. This value is used to allow child elements to be added to the watch
        // window (Add Watch from the context menu), and to refresh parts of the evaluation
        // tree. As an example of how FullName differs from name, the name of the 0th element
        // of an array in C++ is '[0]' while the full name would by 'myArrayVariable[0]'.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // Flags           : [In] Flags which indicate attributes of an expression evaluation
        // result.
        // pValues         : [In] The formatted values for each thread.
        // pType           : [In,Optional] A string that describes the type of the value.
        // Category        : [In] The category (ex: Data, Method, etc) of this evaluation
        // result.
        // Access          : [In] The access control level (public, private, etc) of the
        // evaluation result.
        // StorageType     : [In] The storage type (ex: static) of the evaluation result.
        // TypeModifierFlags: [In] Type modifier flags (ex: const) of the evaluation result.
        // pCustomUIVisualizers: [In,Optional] A list of custom viewers for this object.
        // DataItem        : [In] Data object to add to the new
        // DkmSuccessContextGroupEvaluationResult instance. DkmDataItem::Null() in the case
        // that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<UINT64>* pThreadIds,
            _In_ HRESULT EvaluationResults,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Evaluation::DkmEvaluationResultFlags::e Flags,
            _In_ DkmReadOnlyCollection<DkmString*>* pValues,
            _In_opt_ DkmString* pType,
            _In_ Evaluation::DkmEvaluationResultCategory::e Category,
            _In_ Evaluation::DkmEvaluationResultAccessType::e Access,
            _In_ Evaluation::DkmEvaluationResultStorageType::e StorageType,
            _In_ Evaluation::DkmEvaluationResultTypeModifierFlags::e TypeModifierFlags,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::Group::DkmSuccessContextGroupEvaluationResult** ppCreatedObject
            );
    }; // end of DkmSuccessContextGroupEvaluationResult

};}; // end namespace Evaluation::Group

// Contains the types used for dealing with symbolic information in the debugger. This
// includes all types related to handling documents and text ranges. This namespace
// contains only the runtime environment agnostic types, with additional types found in
// the 'Native', 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Symbols {
    // Windows dlls/exes contain a section for debugging information. Inside this section
    // there are zero or more IMAGE_DEBUG_DIRECTORY structures, and inside each of these
    // structures there is a 32-bit 'Type' field which indicates the format of the
    // information within the debug directory. DkmImageDebugDirectoryFormat is used to map
    // from this 'Type' value to the symbol provider which is used to handle this type of
    // debugging information. The debugger initializes a collection of
    // DkmImageDebugDirectoryFormat structs on startup by reading the
    // '%VSRegistryRoot%\Debugger\Image Debug Directory Formats' registry keys.
    struct DECLSPEC_UUID("66bdcf7e-ac43-b629-7205-57cec0699a35") DkmImageDebugDirectoryFormat
    {
        // 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example,
        // IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete
        // listing.
        UINT32 TypeValue;

        // Symbol provider id to use for this.
        GUID SymbolProvider;

        // Release all reference-counted fields within the DkmImageDebugDirectoryFormat structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmImageDebugDirectoryFormat* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Value of a calculated MD5 hash. MD5 hashes are used for the document checksum feature,
    // which is a non-security purpose. MD5 should no longer be used for any security related
    // purpose.
    struct DECLSPEC_UUID("9804843a-3774-8a13-087b-dc688a492af9") DkmMD5HashValue
    {
        // First 32-bits of the calculated hash.
        UINT32 Value0;

        // Second 32-bits of the calculated hash.
        UINT32 Value1;

        // Third 32-bits of the calculated hash.
        UINT32 Value2;

        // Forth 32-bits of the calculated hash.
        UINT32 Value3;

        // Compare an instance of the DkmMD5HashValue struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmMD5HashValue& other
            ) const;

        bool operator==(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmMD5HashValue structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmMD5HashValue* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document checksum
    // feature, which is a non-security purpose. SHA-1 should no longer be used for any
    // security related purpose.
    struct DECLSPEC_UUID("db7a1f38-cb63-d4c8-70aa-b52af7e0b9ed") DkmSHA1HashValue
    {
        // First 32-bits of the calculated hash.
        UINT32 Value0;

        // Second 32-bits of the calculated hash.
        UINT32 Value1;

        // Third 32-bits of the calculated hash.
        UINT32 Value2;

        // Forth 32-bits of the calculated hash.
        UINT32 Value3;

        // Fifth 32-bits of the calculated hash.
        UINT32 Value4;

        // Compare an instance of the DkmSHA1HashValue struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmSHA1HashValue& other
            ) const;

        bool operator==(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmSHA1HashValue structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmSHA1HashValue* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Guid pair used to uniquely identify a particular DkmModule instance.
    struct DECLSPEC_UUID("67e8ae96-fe88-e528-5190-458bd95dd9f2") DkmModuleId
    {
        // Module version Identifier from the symbol file. This uniquely identifies the
        // symbol file. For Microsoft C++ or Microsoft .NET Framework binaries, this is a
        // unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe
        // is built. A new value is generated each time that the dll/exe is compiled.
        GUID Mvid;

        // Identifies the symbol provider (and therefore symbol format) used to examine these
        // symbols.
        GUID SymbolProvider;

        // Compare an instance of the DkmModuleId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmModuleId& other
            ) const;

        bool operator==(const DkmModuleId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmModuleId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmModuleId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmModuleId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmModuleId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmModuleId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmModuleId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmModuleId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // The start/end line/column ranges for a contiguous span of text.
    struct DECLSPEC_UUID("5196533e-11e8-53b0-6620-ba454830e33b") DkmTextSpan
    {
        // 1-based integer for the starting source line.
        UINT32 StartLine;

        // 1-based integer for the ending source column.
        UINT32 EndLine;

        // 1-based integer for the starting source column. If column information is missing
        // (ex: language service doesn't support it), this value should be set to 0.
        UINT32 StartColumn;

        // 1-based integer for the ending source column. If column information is missing
        // (ex: language service doesn't support it), this value should be set to 0.
        UINT32 EndColumn;

        // Compare an instance of the DkmTextSpan struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmTextSpan& other
            ) const;

        bool operator==(const DkmTextSpan& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmTextSpan& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmTextSpan& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmTextSpan& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmTextSpan& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmTextSpan& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmTextSpan structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmTextSpan* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmCodeViewCompilerId is used to translate information that is within the S_COMPILE*
    // code view records into a DkmCompilerId. This allows the debugger to load an
    // appropriate expression evaluator for a stack frame. Symbol providers may obtain this
    // collection through DkmEngineSettings. Expression evaluators may add additional entries
    // to this collection by having their setup add sub key(s) to the
    // '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.
    struct DECLSPEC_UUID("a47cc33b-5978-a1cb-c006-c1869c6778f0") DkmCodeViewCompilerId
    {
        // Language enumeration value which is in the code view record. For example,
        // CV_CFL_CXX is used for C++.
        BYTE LanguageEnumeration;

        // Name string within the code view record. '*' may be used to match against any name
        // string.
        DkmString* pCompilerName;

        // CompilerId (Vendor/Language Guid pair) to map the LanguageEnumeration/CompilerName
        // to.
        Evaluation::DkmCompilerId CompilerId;

        // Release all reference-counted fields within the DkmCodeViewCompilerId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmCodeViewCompilerId* pItem
            );
    };

    // An RVA and size pair representing a symbol returned from DkmModule GetFunctionInfo.
    struct DECLSPEC_UUID("dbeefc90-b141-1a6e-1b47-7b4cd20f6fba") DkmRVASizePair
    {
        // The relative virtual address of a symbol.
        UINT32 RVA;

        // The size of a symbol.
        UINT32 Size;

        // Release all reference-counted fields within the DkmRVASizePair structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmRVASizePair* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // A offset/size pair which is returned from the symbol provider to a debug monitor to
    // indicate a range of instructions which the debugger should not stop at.
    struct DECLSPEC_UUID("1707052e-b14e-90df-d96a-82807318f017") DkmSteppingRange
    {
        // The start of a stepping range. The meaning is dependant on the the underlying
        // runtime being stepped. For MSIL, this in the beginning IL offset relative to the
        // start of the method. For native code, this is an RVA.
        UINT32 StartOffset;

        // The length of a stepping range. The meaning is dependant on the the underlying
        // runtime being stepped. For both native code and MSIL, this is a byte count of the
        // number of instructions in the range. For MSIL, UInt32.MaxValue is used to indicate
        // that the range should extend to the end of the method.
        UINT32 Length;

        // The source line number of the stepping range. The meaning is dependant on the the
        // underlying runtime being stepped. For both native code and MSIL, this is the
        // source line number of instructions in the range. For MSIL, UInt32.MaxValue is used
        // to indicate that the range should extend to the end of the method.
        UINT32 LineNumber;

        // Release all reference-counted fields within the DkmSteppingRange structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmSteppingRange* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Indicates how strong of a match there was between the DkmDocumentQuery and the
    // resulting DkmResolvedDocument.
    enum DkmDocumentMatchStrength::e
    {
        // Document matched on file name and extension, but not on any part of the path, or
        // on checksum.
        FileName = 0,
        // Document matched on file name and at least one level of directory name, but not
        // the full path nor the checksum.
        SubPath = 1,
        // Document matched on full path but not on checksum.
        FullPath = 2,
        // Document matched on checksum value in addition to at least a filename match.
        Checksum = 3,
        // Input path represented a URL for a dynamic document and the resulting document
        // exactly matched this query. This value is currently never returned from the
        // Microsoft PDB symbol provider but is reserved for future use.
        ExactURL = 4
    };

    // Contains the symbol path collection and the cache path.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1e0ac5bb-9169-359d-7689-c1407b244f62") DkmEngineSymbolSettings : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmEngineSymbolSettings::Create to create this object
        private: DkmEngineSymbolSettings();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEngineSymbolSettings();
        // This object cannot be copied
        private: DkmEngineSymbolSettings& operator=(const DkmEngineSymbolSettings&);
        private: DkmEngineSymbolSettings(const DkmEngineSymbolSettings&);

        private: DkmReadOnlyCollection<DkmString*>* const m_pSymbolPaths;
        private: DkmString* const m_pSymbolCachePath;
        private: DkmReadOnlyCollection<DkmString*>* const m_pIncludeList;
        private: DkmReadOnlyCollection<DkmString*>* const m_pExcludeList;
        private: const bool m_ManualLoading;
        private: const bool m_LoadAdjacentSymbols;
        private: void* m__pExtendedData;

        // A collection of the paths to search for symbols.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE SymbolPaths(
            );

        // The path of the symbol cache.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SymbolCachePath(
            );

        // A collection of modules to include when manual symbol loading is enabled.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE IncludeList(
            );

        // A collection of modules to exclude when automatic symbol loading is enabled.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE ExcludeList(
            );

        // True if manual symbol loading is enabled. False otherwise.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ManualLoading(
            );

        // True if all symbols adjacent to the matching module or at the path specified in
        // the binary should be loaded regardless of include/exclude status.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE LoadAdjacentSymbols(
            );

        // Create a new DkmEngineSymbolSettings object instance.
        // pSymbolPaths    : [In] A collection of the paths to search for symbols.
        // pSymbolCachePath: [In] The path of the symbol cache.
        // pIncludeList    : [In] A collection of modules to include when manual symbol
        // loading is enabled.
        // pExcludeList    : [In] A collection of modules to exclude when automatic symbol
        // loading is enabled.
        // ManualLoading   : [In] True if manual symbol loading is enabled. False otherwise.
        // LoadAdjacentSymbols: [In] True if all symbols adjacent to the matching module or
        // at the path specified in the binary should be loaded regardless of include/exclude
        // status.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<DkmString*>* pSymbolPaths,
            _In_ DkmString* pSymbolCachePath,
            _In_ DkmReadOnlyCollection<DkmString*>* pIncludeList,
            _In_ DkmReadOnlyCollection<DkmString*>* pExcludeList,
            _In_ bool ManualLoading,
            _In_ bool LoadAdjacentSymbols,
            _Deref_out_ Symbols::DkmEngineSymbolSettings** ppCreatedObject
            );
    }; // end of DkmEngineSymbolSettings

    // Result of an asynchronous DkmModule.FindDocuments call.
    struct DkmFindDocumentsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] A collection of the documents that matched the query.
        DkmArray<Symbols::DkmResolvedDocument*> Documents;
    };

    // Result of an asynchronous DkmResolvedDocument.FindSymbols call.
    struct DkmFindSymbolsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_TEXT_SPAN_NOT_LOADED indicates that
        // TextSpan is not currently loaded in the specified script document.
        // E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan could not be mapped to a
        // location in the specified script document. E_SCRIPT_FILE_DIFFERENT_CONTENT
        // indicates that the content in the script file loaded by the target process doesn't
        // match the provided Text.
        HRESULT ErrorCode;

        // [Optional] The found instruction symbols which are within the specified text span.
        DkmArray<Symbols::DkmInstructionSymbol*> InstructionSymbols;

        // [Optional] The source location of each returned instruction symbol. The length of
        // this array should be the same of the returned instruction symbol array.
        DkmArray<Symbols::DkmSourcePosition*> SymbolLocation;
    };

    // Result of an asynchronous DkmModule.GetFunctionInfo call.
    struct DkmGetFunctionInfoAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The RVA / size pairs from the query.
        DkmArray<Symbols::DkmRVASizePair> Results;
    };

    // Result of an asynchronous DkmModule.GetMethodSymbolStoreData call.
    struct DkmGetMethodSymbolStoreDataAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmClrMethodScopeData[] describes a scope within a method. These are defined using
        // ISymUnmanagedWriter::OpenScope/CloseScope.
        DkmArray<Clr::DkmClrMethodScopeData> Scopes;
    };

    // Result of an asynchronous DkmModule.GetMethodSymbolStoreDataPreRemap call.
    struct DkmGetMethodSymbolStoreDataPreRemapAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Method token after the Remap.
        UINT32 RemapToken;

        // DkmClrMethodScopeData[] describes a scope within a method. These are defined using
        // ISymUnmanagedWriter::OpenScope/CloseScope.
        DkmArray<Clr::DkmClrMethodScopeData> Scopes;
    };

    // Result of an asynchronous DkmInstructionSymbol.GetSourcePosition call.
    struct DkmGetSourcePositionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if this address is the first address in the line's range. False otherwise.
        bool StartOfLine;

        // [Optional] Source code position which corresponds to a code element. The could
        // represent a location which has been extracted from a symbol (PDB) file, or it
        // could be the location of a breakpoint in the IDE.
        OPTIONAL Symbols::DkmSourcePosition* pSourcePosition;
    };

    // Result of an asynchronous DkmInstructionSymbol.GetSourcePositionCallback call.
    struct DkmGetSourcePositionCallbackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if this address is the first address in the line's range. False otherwise.
        bool StartOfLine;

        // [Optional] Source code position which corresponds to a code element. The could
        // represent a location which has been extracted from a symbol (PDB) file, or it
        // could be the location of a breakpoint in the IDE.
        OPTIONAL Symbols::DkmSourcePosition* pSourcePosition;
    };

    // Result of an asynchronous DkmModule.GetTokenSymbolStoreAttribute call.
    struct DkmGetTokenSymbolStoreAttributeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The value of the requested symbol store attribute.
        DkmArray<BYTE> Data;
    };

    // Result of an asynchronous DkmInstructionSymbol.GetUserCodeSourcePositionCallback call.
    struct DkmGetUserCodeSourcePositionCallbackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Source code position which corresponds to a code element. The could
        // represent a location which has been extracted from a symbol (PDB) file, or it
        // could be the location of a breakpoint in the IDE.
        OPTIONAL Symbols::DkmSourcePosition* pSourcePosition;
    };

    // Result of an asynchronous DkmInstructionSymbol.HasLineInfo call.
    struct DkmHasLineInfoAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if there is line info for this location.
        bool Result;
    };

    // DkmInstructionSymbol represents a method in the target process.
    //
    // Derived classes: DkmClrInstructionSymbol, DkmClrNcInstructionSymbol,
    // DkmCustomInstructionSymbol, DkmNativeInstructionSymbol, DkmScriptInstructionSymbol
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c55d7b4d-246f-0e5a-e37e-c9d9f2d996c6") DkmInstructionSymbol : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInstructionSymbol::Create to create this object
        private: DkmInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInstructionSymbol();
        // This object cannot be copied
        private: DkmInstructionSymbol& operator=(const DkmInstructionSymbol&);
        private: DkmInstructionSymbol(const DkmInstructionSymbol&);

        // DkmInstructionSymbol is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmNativeInstructionSymbol'.
        NativeInstruction = 0,
        // Object is an instance of 'DkmClrInstructionSymbol'.
        ClrInstruction = 1,
        // Object is an instance of 'DkmScriptInstructionSymbol'.
        ScriptInstruction = 2,
        // Object is an instance of 'DkmCustomInstructionSymbol'.
        CustomInstruction = 3
        }; };

        private: const Tag::e m_TagValue;
        private: Symbols::DkmModule* const m_pModule;
        private: const GUID m_RuntimeType;
        private: void* m__pExtendedData;

        // DkmInstructionSymbol is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The DkmModule class represents a code bundle (ex: dll or exe) which is or once was
        // loaded into one or more processes. The DkmModule class is the central object to
        // the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded.
        // If a code bundle loads into three different processes (or the same process but
        // with three different base addresses or three different app domains) but the symbol
        // handler thinks of all of these as being identical, there will be only one module
        // object.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // The Runtime Id identifies the execution environment for a particular piece of
        // code. Runtime Ids are used by the dispatcher to decide which monitor to dispatch
        // to. Note that the ordering of the runtime ID Guids is somewhat significant as this
        // dictates which runtime gets the first shot during arbitration. Thus, if one wants
        // to declare a new runtime instance which is built on the CLR, the runtime id should
        // be less than DkmRuntimeId.Clr.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE RuntimeType(
            );

        // Binds an instruction symbol to a particular module instance. An instruction symbol
        // is connected to a DkmModule rather than a DkmModuleInstance, so it is not bound to
        // a particular process, app domain, or module base address.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // ppAddress       : [Out] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Bind(
            _In_ DkmModuleInstance* pModuleInstance,
            _Deref_out_ DkmInstructionAddress** ppAddress
            );

        // This method returns address information to the GPU debug monitor.
        // pInstructionAddress: [In,Optional] Abstract representation of an executable code
        // location (ex: EIP value). If resolved, an Instruction Address will be within a
        // particular module instance. An Instruction Address is always within a particular
        // Runtime Instance.
        // pNextInstruction: [In] The next instruction address which is used to determine
        // inline function call.
        // pMetadata       : [Out,Optional] The address type information.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUInstructionMetadataCallback(
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ Symbols::DkmInstructionSymbol* pNextInstruction,
            _Out_ GPU::DkmGPUAddressType::e* pMetadata
            );

        // Queries the symbol provider to determine the ranges of instructions which do not
        // correspond to any user source statements and are used by the base debug monitor to
        // always step through during stepping.
        // pRanges         : [Out] Array of no source ranges to always step through. This
        // array will be empty if there are no no-source ranges for the given instruction.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNoSourceRanges(
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file or not in
        // user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // ppSourcePosition: [Out,Optional] Source code position which corresponds to a code
        // element. The could represent a location which has been extracted from a symbol
        // (PDB) file, or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is
        // returned when *ppSourcePosition is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUserCodeSourcePositionCallback(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file or not in
        // user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUserCodeSourcePositionCallback(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetUserCodeSourcePositionCallbackAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Return the name of the symbol as it should appear in the disassembly window. For
        // Microsoft C++ code, this is based on the public symbol name.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // ppLabel         : [Out,Optional] The label to use for this instruction.
        // Return value    : S_OK is returned if *ppLabel is non-NULL, S_FALSE is returned
        // when *ppLabel is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDisassemblyLabel(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ DkmString** ppLabel
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Returns the compiler id (LanguageId/VendorId) of a given symbol.
        //
        // For the Microsoft PDB reader, if the PDB was created by a compiler which used
        // ISymUnmanagedWriter, then the PDB reader will be able to determine the correct
        // DkmCompilerId from the LanguageId/VendorId pair passed from
        // ISymUnmanagedWriter.DefineDocument.
        //
        // If the PDB was created by a compiler which did not use ISymUnmanagedWriter, the
        // PDB reader may be able to obtain the DkmCompilerId from the S_COMPILE* PDB
        // records. For this to work, the compiler must first emit the S_COMPILE* record for
        // each compiland. The compiler needs to be sure to correctly fill out the language
        // enumeration value, and the compiler string. The compiler should ensure that the
        // compiler string is sufficiently specific to use for selecting an expression
        // evaluator; it is recommended to include a company name. After emitting the
        // Enum/Name pair, the setup for the expression evaluator should then register this
        // pair with the debugger. To do so, the expression evaluator should set this
        // registry key: %VSRegistryRoot%\Debugger\CodeView
        // Compilers\%CodeViewLanguageCode%:%CompilerName% and define the
        // VendorId/LanguageId.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pCompilerId     : [Out] LanguageId/VendorId for the compiler which produced the
        // code for this symbol. If this is unknown (ex: no symbols info for this block),
        // both values will be Guid.Empty. Otherwise, both values should be non-zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCompilerId(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ Evaluation::DkmCompilerId* pCompilerId
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns if this instruction symbol is in hidden code. For instance, in managed
        // code, the line number 0xfeefee marks a source line as hidden.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsHiddenCode(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ IDkmCompletionRoutine<Symbols::DkmIsHiddenCodeAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Queries the symbol provider to determine the ranges of instructions which the base
        // debug monitor should step through to implement a step.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // RangeBoundary   : [In] Indicates to the symbol provider the type of instructions
        // to include in the 'no-step' regions.
        // IncludeInline   : [In] True if the symbol provider should stop the stepping range
        // when it encounters an inline functions. False otherwise. The Native DM will pass
        // true for a step in so steps will stop in inline functions. It will pass false when
        // doing a step-over so the stepper will not stop in inline functions.
        // pRanges         : [Out] Array of ranges to step through. This array will be empty
        // if there is no source information for the given instruction.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppingRanges(
            _In_ Symbols::DkmSteppingRangeBoundary::e RangeBoundary,
            _In_ bool IncludeInline,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // Queries the symbol provider to determine if we have line info. Used by debug
        // monitor to decide if location can be considered user code.
        //
        // Location constraint: For ordinary symbols, can be called from any component.  For
        // dynamic symbols, can only be called on the server side.
        // pResult         : [Out] True if there is line info for this location.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HasLineInfo(
            _Out_ bool* pResult
            );

        // Queries the symbol provider to determine if we have line info. Used by debug
        // monitor to decide if location can be considered user code.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: For ordinary symbols, can be called from any component.  For
        // dynamic symbols, can only be called on the server side.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HasLineInfo(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Symbols::DkmHasLineInfoAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // This method returns the IL offset range that contains the current IL offset as
        // specified in the instruction address.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pResult         : [Out] A offset/size pair which is returned from the symbol
        // provider to a debug monitor to indicate a range of instructions which the debugger
        // should not stop at.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentStatementRange(
            _Out_ Symbols::DkmSteppingRange* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file then null
        // is returned (S_FALSE return code in native).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // Flags           : [In] Flags which affect the behavior of 'GetSourcePosition'.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pStartOfLine    : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // ppSourcePosition: [Out,Optional] Source code position which corresponds to a code
        // element. The could represent a location which has been extracted from a symbol
        // (PDB) file, or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is
        // returned when *ppSourcePosition is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePosition(
            _In_ Symbols::DkmSourcePositionFlags::e Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file then null
        // is returned (S_FALSE return code in native).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // Flags           : [In] Flags which affect the behavior of 'GetSourcePosition'.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePosition(
            _In_ DkmWorkList* pWorkList,
            _In_ Symbols::DkmSourcePositionFlags::e Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetSourcePositionAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file then null
        // is returned (S_FALSE return code in native).
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Flags           : [In] Flags which affect the behavior of 'GetSourcePosition'.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pStartOfLine    : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // ppSourcePosition: [Out,Optional] Source code position which corresponds to a code
        // element. The could represent a location which has been extracted from a symbol
        // (PDB) file, or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is
        // returned when *ppSourcePosition is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePositionCallback(
            _In_ Symbols::DkmSourcePositionFlags::e Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file then null
        // is returned (S_FALSE return code in native).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // Flags           : [In] Flags which affect the behavior of 'GetSourcePosition'.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePositionCallback(
            _In_ DkmWorkList* pWorkList,
            _In_ Symbols::DkmSourcePositionFlags::e Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetSourcePositionCallbackAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmInstructionSymbol

    // Result of an asynchronous DkmInstructionSymbol.IsHiddenCode call.
    struct DkmIsHiddenCodeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Flags for DebuggerStepThrough DebuggerHidden, and/or DebuggerNonUserCode
        // attributes set on method or class or marked hidden due to the 0xfeefee sequence
        // point.
        Clr::DkmNonUserCodeFlags::e NonUserCodeFlags;

        // [Optional] The symbol for the next non-hidden source line. This is null if the
        // current line is not hidden.
        OPTIONAL Symbols::DkmInstructionSymbol* pNextLine;
    };

    // Result of an asynchronous DkmInstructionAddress.IsUserCode call.
    struct DkmIsUserCodeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if the provided instruction address is user code.
        bool UserCode;
    };

    // The DkmModule class represents a code bundle (ex: dll or exe) which is or once was
    // loaded into one or more processes. The DkmModule class is the central object to the
    // symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a
    // code bundle loads into three different processes (or the same process but with three
    // different base addresses or three different app domains) but the symbol handler thinks
    // of all of these as being identical, there will be only one module object.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9fdf7d9f-e5ab-b363-6282-1da170173343") DkmModule : public DkmDataContainer
    {
        // Use DkmModule::Create to create this object
        private: DkmModule();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmModule();
        // This object cannot be copied
        private: DkmModule& operator=(const DkmModule&);
        private: DkmModule(const DkmModule&);

        private: const Symbols::DkmModuleId m_Id;
        private: DkmString* const m_pName;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: OPTIONAL DefaultPort::DkmTransportConnection* const m_pConnection;
        private: void* m__pExtendedData;
        private: void* m_pResolvedDocumentCollection0;
        private: void* m_pScriptDocumentCollection0;

        // Guid pair used to uniquely identify a particular DkmModule instance.
        public: DECLSPEC_NOTHROW const Symbols::DkmModuleId& STDMETHODCALLTYPE Id(
            );

        // Name of the module.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // LanguageId/VendorId for the compiler which produced all of the code in this
        // module. This is Guid.Empty/Guid.Empty if the module may contain a mixture of
        // languages. This will almost always be Guid.Empty/Guid.Empty for PDB-based modules.
        // It generally used by dynamic languages to avoid network round trips to discover
        // the language of each symbol.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // [Optional] For modules where symbols are loaded remotely, the connection property
        // is used to determine where the Connection originated from. Otherwise this will be
        // NULL.
        public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Find a DkmModule object. If no object with the given input key is present,
        // FindModule will fail.
        // Id              : [In] Search key used to find the element.
        // ppModule        : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindModule(
            _In_ const Symbols::DkmModuleId& Id,
            _Deref_out_ Symbols::DkmModule** ppModule
            );

        // GetModules enumerates all the created DkmModule objects.
        // pModules        : [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModules(
            _Out_ DkmArray<Symbols::DkmModule*>* pModules
            );

        // Creates a new DkmModule object, which represents the symbols for one or more
        // loaded modules (module instances). These objects are created by symbol providers.
        // After the DkmModule object is created, symbol providers should call
        // DkmModuleInstance.SetModule to associate the DkmModuleInstance and DkmModule
        // together.
        //
        // This method will send a ModuleCreate event.
        // Id              : [In] Guid pair used to uniquely identify a particular DkmModule
        // instance.
        // pName           : [In] Name of the module.
        // CompilerId      : [In] LanguageId/VendorId for the compiler which produced all of
        // the code in this module. This is Guid.Empty/Guid.Empty if the module may contain a
        // mixture of languages. This will almost always be Guid.Empty/Guid.Empty for
        // PDB-based modules. It generally used by dynamic languages to avoid network round
        // trips to discover the language of each symbol.
        // pConnection     : [In,Optional] For modules where symbols are loaded remotely, the
        // connection property is used to determine where the Connection originated from.
        // Otherwise this will be NULL.
        // DataItem        : [In] Data object to add to the new DkmModule instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const Symbols::DkmModuleId& Id,
            _In_ DkmString* pName,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Symbols::DkmModule** ppCreatedObject
            );

        // GetScriptDocuments enumerates the DkmScriptDocument elements of this DkmModule
        // object.
        // pScriptDocuments: [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetScriptDocuments(
            _Out_ DkmArray<Script::DkmScriptDocument*>* pScriptDocuments
            );

        // Returns the scopes within a method. There will always be at least one scope.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // MethodId        : [In] DkmClrMethodId is a token/version pair which is used to
        // uniquely identify the symbol store's understanding of a particular CLR method
        // within a module.
        // pScopes         : [Out] DkmClrMethodScopeData[] describes a scope within a method.
        // These are defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreData(
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            );

        // Returns the scopes within a method. There will always be at least one scope.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // MethodId        : [In] DkmClrMethodId is a token/version pair which is used to
        // uniquely identify the symbol store's understanding of a particular CLR method
        // within a module.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreData(
            _In_ DkmWorkList* pWorkList,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetMethodSymbolStoreDataAsyncResult>* pCompletionRoutine
            );

        // Returns the first method in the first document.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pMethod         : [Out] DkmClrMethodId is a token/version pair which is used to
        // uniquely identify the symbol store's understanding of a particular CLR method
        // within a module.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFirstMethodInFirstDocument(
            _Out_ Clr::DkmClrMethodId* pMethod
            );

        // Returns the scopes within a method. There will always be at least one scope.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // MethodId        : [In] Method Id PreRemap.
        // pRemapToken     : [Out] Method token after the Remap.
        // pScopes         : [Out] DkmClrMethodScopeData[] describes a scope within a method.
        // These are defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreDataPreRemap(
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ UINT32* pRemapToken,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            );

        // Returns the scopes within a method. There will always be at least one scope.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // MethodId        : [In] Method Id PreRemap.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreDataPreRemap(
            _In_ DkmWorkList* pWorkList,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetMethodSymbolStoreDataPreRemapAsyncResult>* pCompletionRoutine
            );

        // Gets a custom attribute based upon its name. Not to be confused with Metadata
        // custom attributes, these attributes are held in the symbol store.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // ParentToken     : [In] The token of the method where the symbol store attribute is
        // stored.
        // IsPreRemap      : [In] True if the specified token value is not a real method
        // token but rather was internally computed by the compiler before the method was
        // emitted using the CLR image creation APIs.
        // pAttributeName  : [In] The name of the attribute to find.
        // pData           : [Out] The value of the requested symbol store attribute.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTokenSymbolStoreAttribute(
            _In_ UINT32 ParentToken,
            _In_ bool IsPreRemap,
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            );

        // Gets a custom attribute based upon its name. Not to be confused with Metadata
        // custom attributes, these attributes are held in the symbol store.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // ParentToken     : [In] The token of the method where the symbol store attribute is
        // stored.
        // IsPreRemap      : [In] True if the specified token value is not a real method
        // token but rather was internally computed by the compiler before the method was
        // emitted using the CLR image creation APIs.
        // pAttributeName  : [In] The name of the attribute to find.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTokenSymbolStoreAttribute(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 ParentToken,
            _In_ bool IsPreRemap,
            _In_ DkmString* pAttributeName,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetTokenSymbolStoreAttributeAsyncResult>* pCompletionRoutine
            );

        // Translate accelerator pointer tag into HLSL register attributes.
        // InputTag        : [In] Accelerator pointer tag found in symbols.
        // InstructionPointer: [In] current instruction pointer used to get scope for pointer
        // translation.
        // pRegisterType   : [Out] HLSL register type.
        // pRegisterIndex  : [Out] HLSL register index.
        // pFirstElement   : [Out] Index of first vector element.
        // pVectorElements : [Out] Number of vector elements.
        // pByteOffset     : [Out] Offset in bytes.
        // pVectorElementSize: [Out] Size of each vector element.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByIP(
            _In_ UINT32 InputTag,
            _In_ UINT32 InstructionPointer,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            );

        // This method returns compiler flags of the given GPU module.
        // ppCompilerOptions: [Out,Optional] returns the compiler flags.
        // Return value    : S_OK is returned if *ppCompilerOptions is non-NULL, S_FALSE is
        // returned when *ppCompilerOptions is NULL, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCompilerOptions(
            _Deref_out_opt_ DkmString** ppCompilerOptions
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Translate accelerator pointer tag into HLSL register attributes using relative
        // virtual address.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // InputTag        : [In] Accelerator pointer tag found in symbols.
        // Rva             : [In] RVA to use for filtering; ignored if zero.
        // pRegisterType   : [Out] HLSL register type.
        // pRegisterIndex  : [Out] HLSL register index.
        // pFirstElement   : [Out] Index of first vector element.
        // pVectorElements : [Out] Number of vector elements.
        // pByteOffset     : [Out] Offset in bytes.
        // pVectorElementSize: [Out] Size of each vector element.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByRva(
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Verify if the accelerator pointer tag is valid.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // InputTag        : [In] Accelerator pointer tag found in symbols.
        // Rva             : [In] RVA to use for filtering; ignored if zero.
        // pIsValid        : [Out] True if the given accelerator tag is valid at the given
        // RVA.  If RVA is zero, checks if the tag is valid anywhere including as a
        // dynamically created tag.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsValidAcceleratorTag(
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ bool* pIsValid
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Gets a C++ AMP address for a register.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // RegisterType    : [In] Type of HLSL register.
        // RegisterIndex   : [In] Index of HLSL register.
        // FirstElement    : [In] Index of first vector element.
        // VectorElements  : [In] Number of vector elements.
        // ByteOffset      : [In] Offset from beginning of register.
        // VectorElementSize: [In] Size of vector element.
        // Rva             : [In] RVA to use for mapping register information and tag
        // address.
        // StartLiveRange  : [In] Start of live range for the symbol.
        // EndLiveRange    : [In] End of live range for the symbol.
        // pAddress        : [Out] Address for register.
        // pIsNewDynamicTag: [Out] Is the address newly generated using dynamic tag.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPointerToHLSLRegister(
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 Rva,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange,
            _Out_ UINT64* pAddress,
            _Out_ bool* pIsNewDynamicTag
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Sets a C++ AMP address for a register.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // Address         : [In] Address for register.
        // RegisterType    : [In] Type of HLSL register.
        // RegisterIndex   : [In] Index of HLSL register.
        // FirstElement    : [In] Index of first vector element.
        // VectorElements  : [In] Number of vector elements.
        // ByteOffset      : [In] Offset from beginning of register.
        // VectorElementSize: [In] Size of vector element.
        // StartLiveRange  : [In] Start of live range for the symbol.
        // EndLiveRange    : [In] End of live range for the symbol.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPointerToHLSLRegister(
            _In_ UINT64 Address,
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Gets a C++ AMP address for a register.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pSize           : [Out] Maximum tag value found in actual C++ AMP pointers plus
        // one.
        // pSizeOfForwardedTags: [Out] Maximum tag value that may be subject to buffer
        // forwarding plus one.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAcceleratorTagTableSize(
            _Out_ UINT32* pSize,
            _Out_ UINT32* pSizeOfForwardedTags
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // GetInstructionOffsetForRva is used by components to query symbol provider to
        // perform instruction offset and RVA translation for DPC++.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // RVA             : [In] The RVA within a module.
        // pInstructionOffset: [Out] The instruction offset from stub function.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionOffsetForRva(
            _In_ UINT32 RVA,
            _Out_ UINT32* pInstructionOffset
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // A DkmModule is the symbol handler's representation of a module, and is not bound
        // to any process, connection or runtime instance. This method returns all the
        // DkmModuleInstances which map to this DkmModule. A DkmModule can be bound to zero
        // instances in the case that all of the modules are now unloaded. In this case,
        // GetModuleInstances will return an empty array (S_FALSE return code in native).
        // pModules        : [Out] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pModules contains any elements, S_FALSE is
        // indicates the array is empty, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModuleInstances(
            _Out_ DkmArray<DkmModuleInstance*>* pModules
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Undecorates a symbol name.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pDecoratedName  : [In] The name to be undecorated.
        // Options         : [In] Options to change the undecorated name. These are specific
        // to the implementation being used. For Microsoft PDB, pass one or more of the
        // values described in the documentation for DbgHelp.dll UnDecorateSymbolName or one
        // of these three extended options: UNDNAME2_STRIP_ILT  0x10000  - to remove the
        // leading ILT from Incremental Linking Thunks UNDNAME2_STRIP_CONST 0x20000 - to
        // remove leading "const" from the front of the string UNDNAME2_STRINGS  0x30000 - to
        // use pooled strings by name.
        // ppUndecoratedName: [Out] The undecorated name.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UndecorateName(
            _In_ DkmString* pDecoratedName,
            _In_ UINT32 Options,
            _Deref_out_ DkmString** ppUndecoratedName
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Return the RVA for an S_PUBLIC32 for a particular name by string.
        // pPublicName     : [In] The name of the public symbol to lookup.
        // ppAddress       : [Out,Optional] The native instruction symbol for this public
        // symbol.
        // Return value    : S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned
        // when *ppAddress is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPublicSymbolByNameCallback(
            _In_ DkmString* pPublicName,
            _Deref_out_opt_ Native::DkmNativeInstructionSymbol** ppAddress
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns the contents of the source server stream data for a module if the stream
        // exists.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pModuleInstance : [In] The module instance for which symbol server data is being
        // requested.
        // pStreamData     : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourceServerData(
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ DkmArray<BYTE>* pStreamData
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns document objects from search parameters contained in the document query.
        // If the symbol file does not contain a reference to this document the returned
        // document object will be NULL (S_FALSE return code in native). The returned
        // document objects must be explicitly closed by the caller when the caller is done
        // with the document.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pSourceFileId   : [In] Identifies a source file and provides the information which
        // a symbol handler could use to search a symbol file (PDB) for information on this
        // source file.
        // pDocuments      : [Out] A collection of the documents that matched the query.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pDocuments contains any elements, S_FALSE is
        // indicates the array is empty, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindDocuments(
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Out_ DkmArray<Symbols::DkmResolvedDocument*>* pDocuments
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns document objects from search parameters contained in the document query.
        // If the symbol file does not contain a reference to this document the returned
        // document object will be NULL (S_FALSE return code in native). The returned
        // document objects must be explicitly closed by the caller when the caller is done
        // with the document.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pSourceFileId   : [In] Identifies a source file and provides the information which
        // a symbol handler could use to search a symbol file (PDB) for information on this
        // source file.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindDocuments(
            _In_ DkmWorkList* pWorkList,
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _In_ IDkmCompletionRoutine<Symbols::DkmFindDocumentsAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns the path to the symbol file which backs a DkmModule object.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppFilePath      : [Out] Full path to the symbol file (ex:
        // c:\myproj\bin\debug\myproj.pdb).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolFilePath(
            _Deref_out_ DkmString** ppFilePath
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetEntryPointSymbols is used by the breakpoint manager to find the entry point
        // symbol(s) in the launching executable. For managed code, this symbol is defined
        // using ISymUnmanagedWriter::SetUserEntryPoint. For native code, this symbol is
        // found by looking for the various 'main' function (main, WinMain, etc). A third can
        // override the entry point either by implementing their own symbol provider or by
        // implementing IDkmEntryPointQuery.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pPossibleEntryPoints: [Out] DkmInstructionSymbol[] represents a method in the
        // target process.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pPossibleEntryPoints contains any elements,
        // S_FALSE is indicates the array is empty, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEntryPointSymbols(
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pPossibleEntryPoints
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Search a module's symbols for a function with the specified name. Returns the RVA
        // and size if it is found.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pFunctionName   : [In] The name of the function to search for.
        // pResults        : [Out] The RVA / size pairs from the query.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunctionInfo(
            _In_ DkmString* pFunctionName,
            _Out_ DkmArray<Symbols::DkmRVASizePair>* pResults
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Search a module's symbols for a function with the specified name. Returns the RVA
        // and size if it is found.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pFunctionName   : [In] The name of the function to search for.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunctionInfo(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pFunctionName,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetFunctionInfoAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // GetSymbolInterface is used to obtain a raw COM interface to a symbol store. This
        // is useful to either callers that find the symbol abstraction presented by the
        // debugger to be either too restrictive for their needs, or simply undesirable due
        // to how their component is implemented.
        //
        // Location constraint: This method must be called from the same process where the
        // symbol provider has opened the symbol file. For Native PDB files, this means that
        // the API must be called from the IDE process. For Managed symbols, this API is
        // implemented in the IDE process except for server-side compiled ASP.NET code, and
        // dynamic languages (ex: IronPython).
        // InterfaceID     : [In] The GUID of the desired interface. Microsoft supports
        // IID_IDiaSession for Native DkmModule's, and IID_ISymUnmanagedReader for Managed
        // modules.
        // ppSymbolInterface: [Out] Returned symbol interface. This may be cast to the
        // interface pointer corresponding to 'InterfaceID'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppSymbolInterface
            );
    }; // end of DkmModule

    // Object which represents the result of a source file query against a symbol file (PDB).
    // The resolved document object might encapsulate multiple document records with the
    // symbol file. For example, in C++ compilation, each time that a header file is included
    // there is another reference within the PDB. However, there is only one
    // DkmResolvedDocument object for the header file.
    //
    // Derived classes: DkmResolvedMappedDocument
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("79baa60b-1e97-ac96-0d95-996e6b997c33") DkmResolvedDocument : public DkmDataContainer
    {
        // Use DkmResolvedDocument::Create to create this object
        private: DkmResolvedDocument();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmResolvedDocument();
        // This object cannot be copied
        private: DkmResolvedDocument& operator=(const DkmResolvedDocument&);
        private: DkmResolvedDocument(const DkmResolvedDocument&);

        private: Symbols::DkmModule* const m_pModule;
        private: const GUID m_UniqueId;
        private: DkmString* const m_pDocumentName;
        private: OPTIONAL Script::DkmScriptDocument* const m_pScriptDocument;
        private: const Symbols::DkmDocumentMatchStrength::e m_MatchStrength;
        private: const Symbols::DkmResolvedDocumentWarning::e m_Warning;
        private: const bool m_TextRequested;
        private: void* m__pExtendedData;

        // The DkmModule class represents a code bundle (ex: dll or exe) which is or once was
        // loaded into one or more processes. The DkmModule class is the central object to
        // the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded.
        // If a code bundle loads into three different processes (or the same process but
        // with three different base addresses or three different app domains) but the symbol
        // handler thinks of all of these as being identical, there will be only one module
        // object.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Guid which uniquely identifies this object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Name of the source file. This is generally a full path, but in some scenarios it
        // make be a partial path or just a name with extension (ex: example.cpp). In the
        // case of a dynamic document (ex: running script from internet explorer) 'Path'
        // could be a URL rather than a local file path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DocumentName(
            );

        // [Optional] Script document which this resolved document represents. This should be
        // null for non script-based symbol providers.
        public: _Ret_opt_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE ScriptDocument(
            );

        // Indicates how strong of a match there was between the DkmDocumentQuery and the
        // resulting DkmResolvedDocument.
        public: DECLSPEC_NOTHROW Symbols::DkmDocumentMatchStrength::e STDMETHODCALLTYPE MatchStrength(
            );

        // Warning that occurred during the match. Depending on context, these may need to be
        // surfaced to the user.
        public: DECLSPEC_NOTHROW Symbols::DkmResolvedDocumentWarning::e STDMETHODCALLTYPE Warning(
            );

        // If true, return the source text.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE TextRequested(
            );

        // Closes the resolved document object. This method must be invoked when the
        // component which requested the resolved document is done with the object.
        //
        // DkmResolvedDocument objects are automatically closed when their associated
        // DkmModule object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Creates a new resolved document object. Resolved document objects are created by a
        // symbol provider. They are a data container so that a symbol provider may back the
        // resolved document with their own internal state.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pDocumentName   : [In] Name of the source file. This is generally a full path, but
        // in some scenarios it make be a partial path or just a name with extension (ex:
        // example.cpp). In the case of a dynamic document (ex: running script from internet
        // explorer) 'Path' could be a URL rather than a local file path.
        // pScriptDocument : [In,Optional] Script document which this resolved document
        // represents. This should be null for non script-based symbol providers.
        // MatchStrength   : [In] Indicates how strong of a match there was between the
        // DkmDocumentQuery and the resulting DkmResolvedDocument.
        // Warning         : [In] Warning that occurred during the match. Depending on
        // context, these may need to be surfaced to the user.
        // TextRequested   : [In] If true, return the source text.
        // DataItem        : [In] Data object to add to the new DkmResolvedDocument instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pDocumentName,
            _In_opt_ Script::DkmScriptDocument* pScriptDocument,
            _In_ Symbols::DkmDocumentMatchStrength::e MatchStrength,
            _In_ Symbols::DkmResolvedDocumentWarning::e Warning,
            _In_ bool TextRequested,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Symbols::DkmResolvedDocument** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Finds the symbols within the document which best match the input text span.
        //
        // For IL-based languages, the symbol handler always return the DkmInstructionSymbol
        // for sequence points. It will prefer sequence points which exactly match the text
        // span followed by the sequence point or points which is left-most and which is
        // inside the input span.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // TextSpan        : [In] The text range (lines/column) to search for.
        // pText           : [In,Optional] The text to search for. When available, this will
        // be provided if ResolvedDocument.TextRequested is set.
        // pInstructionSymbols: [Out] The found instruction symbols which are within the
        // specified text span.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pSymbolLocation : [Out] The source location of each returned instruction symbol.
        // The length of this array should be the same of the returned instruction symbol
        // array.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pInstructionSymbols contains any elements,
        // S_FALSE is indicates the array is empty, and failure codes are used for any error.
        // E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        // specified script document. E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan
        // could not be mapped to a location in the specified script document.
        // E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file
        // loaded by the target process doesn't match the provided Text.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSymbols(
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _In_opt_ DkmString* pText,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pInstructionSymbols,
            _Out_ DkmArray<Symbols::DkmSourcePosition*>* pSymbolLocation
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Finds the symbols within the document which best match the input text span.
        //
        // For IL-based languages, the symbol handler always return the DkmInstructionSymbol
        // for sequence points. It will prefer sequence points which exactly match the text
        // span followed by the sequence point or points which is left-most and which is
        // inside the input span.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // TextSpan        : [In] The text range (lines/column) to search for.
        // pText           : [In,Optional] The text to search for. When available, this will
        // be provided if ResolvedDocument.TextRequested is set.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSymbols(
            _In_ DkmWorkList* pWorkList,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _In_opt_ DkmString* pText,
            _In_ IDkmCompletionRoutine<Symbols::DkmFindSymbolsAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmResolvedDocument

    // Warning that occurred during the match. Depending on context, these may need to be
    // surfaced to the user.
    enum DkmResolvedDocumentWarning::e
    {
        // No warning occurred during the match.
        None = 0,
        // Both the symbol file and input request contained a source file checksum, however
        // the checksum values did not match each other.
        ChecksumMismatch = 1,
        // Both the symbol file and input request contained a source file checksum, and the
        // symbol file contained a match to this checksum value. However, the symbol file
        // also contained information about an identically named document with a different
        // checksum value. This can occur in partial rebuild scenarios and may result in
        // strange behavior.
        MultipleChecksums = 2
    };

    // Identifies a source file and provides the information which a symbol handler could use
    // to search a symbol file (PDB) for information on this source file.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a892d8cf-b6fd-7e20-e0da-6ceca6a7c0c4") DkmSourceFileId : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSourceFileId::Create to create this object
        private: DkmSourceFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSourceFileId();
        // This object cannot be copied
        private: DkmSourceFileId& operator=(const DkmSourceFileId&);
        private: DkmSourceFileId(const DkmSourceFileId&);

        // MD5 hash value for this document.
        public: struct MD5Hash
        {
            // Value of a calculated MD5 hash. MD5 hashes are used for the document checksum
            // feature, which is a non-security purpose. MD5 should no longer be used for any
            // security related purpose.
            Symbols::DkmMD5HashValue Value;
        };

        // SHA-1 hash value for this document.
        public: struct SHA1Hash
        {
            // Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document
            // checksum feature, which is a non-security purpose. SHA-1 should no longer be
            // used for any security related purpose.
            Symbols::DkmSHA1HashValue Value;
        };

        private: OPTIONAL const Symbols::DkmSourceFileId::MD5Hash* const m_pMD5Hash;
        private: OPTIONAL const Symbols::DkmSourceFileId::SHA1Hash* const m_pSHA1Hash;
        private: DkmString* const m_pDocumentName;
        private: OPTIONAL Script::DkmScriptDocument* const m_pScriptDocument;
        private: void* m__pExtendedData;

        // [Optional] MD5 hash value for this document.
        public: _Ret_opt_ DECLSPEC_NOTHROW const Symbols::DkmSourceFileId::MD5Hash* STDMETHODCALLTYPE MD5HashPart(
            );

        // [Optional] SHA-1 hash value for this document.
        public: _Ret_opt_ DECLSPEC_NOTHROW const Symbols::DkmSourceFileId::SHA1Hash* STDMETHODCALLTYPE SHA1HashPart(
            );

        // Name of the source file. This is generally a full path, but in some scenarios it
        // make be a partial path or just a name with extension (ex: example.cpp). In the
        // case of a dynamic document (ex: running script from internet explorer) 'Path'
        // could be a URL rather than a local file path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DocumentName(
            );

        // [Optional] Script document object which this DkmSourceFileId wraps. For requests
        // to find document requests, this can be non-NULL when the text position to search
        // for is from the dynamic view of a document. For address->text position requests,
        // this will be non-null when the the address is in a script document.
        public: _Ret_opt_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE ScriptDocument(
            );

        // Create a new DkmSourceFileId object instance.
        // pDocumentName   : [In] Name of the source file. This is generally a full path, but
        // in some scenarios it make be a partial path or just a name with extension (ex:
        // example.cpp). In the case of a dynamic document (ex: running script from internet
        // explorer) 'Path' could be a URL rather than a local file path.
        // pScriptDocument : [In,Optional] Script document object which this DkmSourceFileId
        // wraps. For requests to find document requests, this can be non-NULL when the text
        // position to search for is from the dynamic view of a document. For address->text
        // position requests, this will be non-null when the the address is in a script
        // document.
        // pMD5Hash        : [In,Optional] MD5 hash value for this document.
        // pSHA1Hash       : [In,Optional] SHA-1 hash value for this document.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDocumentName,
            _In_opt_ Script::DkmScriptDocument* pScriptDocument,
            _In_opt_ const Symbols::DkmSourceFileId::MD5Hash* pMD5Hash,
            _In_opt_ const Symbols::DkmSourceFileId::SHA1Hash* pSHA1Hash,
            _Deref_out_ Symbols::DkmSourceFileId** ppCreatedObject
            );
    }; // end of DkmSourceFileId

    // Source code position which corresponds to a code element. The could represent a
    // location which has been extracted from a symbol (PDB) file, or it could be the
    // location of a breakpoint in the IDE.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7995b6c8-93dc-ac77-d59b-b99ce6ec9e48") DkmSourcePosition : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSourcePosition::Create to create this object
        private: DkmSourcePosition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSourcePosition();
        // This object cannot be copied
        private: DkmSourcePosition& operator=(const DkmSourcePosition&);
        private: DkmSourcePosition(const DkmSourcePosition&);

        private: Symbols::DkmSourceFileId* const m_pSourceFileId;
        private: const Symbols::DkmTextSpan m_TextSpan;
        private: void* m__pExtendedData;

        // Identifies a source file and provides the information which a symbol handler could
        // use to search a symbol file (PDB) for information on this source file.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmSourceFileId* STDMETHODCALLTYPE SourceFileId(
            );

        // The start/end line/column ranges for a contiguous span of text.
        public: DECLSPEC_NOTHROW const Symbols::DkmTextSpan& STDMETHODCALLTYPE TextSpan(
            );

        // Name of the source file. This is generally a full path, but in some scenarios it
        // make be a partial path or just a name with extension (ex: example.cpp). In the
        // case of a dynamic document (ex: running script from internet explorer) 'Path'
        // could be a URL rather than a local file path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DocumentName(
            );

        // Create a new DkmSourcePosition object instance.
        // pSourceFileId   : [In] Identifies a source file and provides the information which
        // a symbol handler could use to search a symbol file (PDB) for information on this
        // source file.
        // TextSpan        : [In] The start/end line/column ranges for a contiguous span of
        // text.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _Deref_out_ Symbols::DkmSourcePosition** ppCreatedObject
            );
    }; // end of DkmSourcePosition

    // Flags which affect the behavior of 'GetSourcePosition'.
    enum DkmSourcePositionFlags::e
    {
        // Instructs the symbol provider to use the default behavior of GetSourcePosition.
        None = 0x0,
        // Instructs the symbol provider to extend the source range to include surrounding
        // source code in addition to the source statement which corresponds to the
        // instruction symbol. This option is used in the disassembly window.
        ExtendedSourceRange = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmSourcePositionFlags::e);

    // Indicates to the symbol provider the type of instructions to include in the 'no-step'
    // regions.
    enum DkmSteppingRangeBoundary::e
    {
        // Step should complete at the first non-hidden instruction in the method. This value
        // is used when stepping into a new function.
        FunctionStart = 0,
        // Step should complete on the next statement.
        NextStatement = 1,
        // Step should complete on the next line.
        NextLine = 2,
        // Step should complete at the first instruction after the inline method. This value
        // is used when stepping out an inline function.
        InlineFunctionOut = 3
    };

    // Contains information needed to locate symbols for this module. On Win32, this
    // information is contained within the IMAGE_DEBUG_DIRECTORY.
    //
    // Derived classes: DkmCustomSymbolFileId, DkmDynamicSymbolFileId, DkmPdbFileId
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("950eb6d7-86fd-e311-6d68-d8b12705fa7e") DkmSymbolFileId : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSymbolFileId::Create to create this object
        private: DkmSymbolFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSymbolFileId();
        // This object cannot be copied
        private: DkmSymbolFileId& operator=(const DkmSymbolFileId&);
        private: DkmSymbolFileId(const DkmSymbolFileId&);

        // DkmSymbolFileId is an abstract base class. This enum indicates which derived class
        // this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmPdbFileId'.
        PdbFileId = 0,
        // Object is an instance of 'DkmDynamicSymbolFileId'.
        DynamicSymbolFileId = 1,
        // Object is an instance of 'DkmCustomSymbolFileId'.
        CustomSymbolFileId = 2
        }; };

        private: const Tag::e m_TagValue;
        private: const GUID m_SymbolProviderId;
        private: void* m__pExtendedData;

        // DkmSymbolFileId is an abstract base class. This enum indicates which derived class
        // this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // Unique identifier for symbol files/symbol providers.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SymbolProviderId(
            );
    }; // end of DkmSymbolFileId

    // Unique identifier for symbol files/symbol providers.
    struct DkmSymbolProviderId
    {
        // Reads symbol information from PDB/DBG files to decode native binaries.
        // NativePDB is defined as {49d083cd-f393-4383-ad44-a47eb2bc828d}.
        static const GUID NativePDB;
        // Reads symbol information from PDB files to decode .NET Framework (CLR) binaries.
        // ClrPDB is defined as {65d1b391-203b-447f-b728-8ef09afd0700}.
        static const GUID ClrPDB;
        // Provides symbol resolution from Metadata and a remote symbol store for .NET
        // Framework (CLR) binaries. This is used for dynamically compiled managed code. It
        // is also used for ASP.NET scenario where code is compiled on server side.
        // ClrRemoteSymbolStore is defined as {44c755dc-5352-4cb4-b2a3-e191a830e4c2}.
        static const GUID ClrRemoteSymbolStore;
        // Provides symbol resolution for Microsoft ActiveScript based dynamic code.
        // ActiveScript is defined as {19f50567-6366-44eb-8cde-17b4aed587f8}.
        static const GUID ActiveScript;
        // Reads symbol information from PDB in D3D blob to decode HLSL binaries.
        // HlslPDB is defined as {2257dd93-7ecc-4188-8b6b-c28eb4eb150b}.
        static const GUID HlslPDB;
        // Reads symbol information from PDB files to decode DPC++ binaries.
        // DpcppPDB is defined as {343c264f-ea05-497b-b6c5-467d7d2f449c}.
        static const GUID DpcppPDB;
        // Provides symbol resolution for Microsoft ActiveScript based dynamic code.  This is
        // the symbol provider used when interop debugging Script code with other runtimes.
        // ActiveScriptInterop is defined as {92c7681f-2316-4ff6-bd6c-5b771ba9418a}.
        static const GUID ActiveScriptInterop;
        // Reads symbol information from a native-compiled CLR PDB file.
        // ClrNcPDB is defined as {ea0c854b-5b02-45f6-9d05-73218267c89d}.
        static const GUID ClrNcPDB;
        // Reads symbol information from PDB files to decode DPC++ binaries. This is
        // associated with GPU interop D3D runtime.
        // DpcppInteropPDB is defined as {4cd19a22-4496-4357-ad5b-ff10856d62d9}.
        static const GUID DpcppInteropPDB;
    };
    __declspec(selectany) const GUID DkmSymbolProviderId::NativePDB = { 0x49d083cd, 0xf393, 0x4383, { 0xad, 0x44, 0xa4, 0x7e, 0xb2, 0xbc, 0x82, 0x8d } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ClrPDB = { 0x65d1b391, 0x203b, 0x447f, { 0xb7, 0x28, 0x8e, 0xf0, 0x9a, 0xfd, 0x7, 0x0 } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ClrRemoteSymbolStore = { 0x44c755dc, 0x5352, 0x4cb4, { 0xb2, 0xa3, 0xe1, 0x91, 0xa8, 0x30, 0xe4, 0xc2 } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ActiveScript = { 0x19f50567, 0x6366, 0x44eb, { 0x8c, 0xde, 0x17, 0xb4, 0xae, 0xd5, 0x87, 0xf8 } };
    __declspec(selectany) const GUID DkmSymbolProviderId::HlslPDB = { 0x2257dd93, 0x7ecc, 0x4188, { 0x8b, 0x6b, 0xc2, 0x8e, 0xb4, 0xeb, 0x15, 0xb } };
    __declspec(selectany) const GUID DkmSymbolProviderId::DpcppPDB = { 0x343c264f, 0xea05, 0x497b, { 0xb6, 0xc5, 0x46, 0x7d, 0x7d, 0x2f, 0x44, 0x9c } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ActiveScriptInterop = { 0x92c7681f, 0x2316, 0x4ff6, { 0xbd, 0x6c, 0x5b, 0x77, 0x1b, 0xa9, 0x41, 0x8a } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ClrNcPDB = { 0xea0c854b, 0x5b02, 0x45f6, { 0x9d, 0x5, 0x73, 0x21, 0x82, 0x67, 0xc8, 0x9d } };
    __declspec(selectany) const GUID DkmSymbolProviderId::DpcppInteropPDB = { 0x4cd19a22, 0x4496, 0x4357, { 0xad, 0x5b, 0xff, 0x10, 0x85, 0x6d, 0x62, 0xd9 } };

    // The custom debug info is populated when a module loads and the debug monitor does not
    // understand the content of the debug directory.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c25228a7-de43-2abc-1da8-5cb744e0e75e") DkmCustomSymbolFileId : public Symbols::DkmSymbolFileId
    {
        // Use DkmCustomSymbolFileId::Create to create this object
        private: DkmCustomSymbolFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomSymbolFileId();
        // This object cannot be copied
        private: DkmCustomSymbolFileId& operator=(const DkmCustomSymbolFileId&);
        private: DkmCustomSymbolFileId(const DkmCustomSymbolFileId&);

        private: const UINT32 m_Type;
        private: DkmReadOnlyCollection<BYTE>* const m_pData;
        private: void* m__pExtendedData;

        // 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example,
        // IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete
        // listing.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Type(
            );

        // Raw bytes from the PE file header.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Data(
            );

        // Attempt to cast a 'DkmSymbolFileId' to a 'DkmCustomSymbolFileId'. Return
        // NULL if the path object is not a 'DkmCustomSymbolFileId'.
        // pCustomSymbolFileId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomSymbolFileId* TryCast(
            DkmSymbolFileId* pSymbolFileId
            )
        {
            if (pSymbolFileId == NULL || pSymbolFileId->TagValue() != Tag::CustomSymbolFileId)
                return NULL;

            return static_cast<DkmCustomSymbolFileId*>(pSymbolFileId);
        }

        // Create a new DkmCustomSymbolFileId object instance.
        // SymbolProviderId: [In] Unique identifier for symbol files/symbol providers.
        // Type            : [In] 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example,
        // IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete
        // listing.
        // pData           : [In] Raw bytes from the PE file header.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SymbolProviderId,
            _In_ UINT32 Type,
            _In_ DkmReadOnlyCollection<BYTE>* pData,
            _Deref_out_ Symbols::DkmCustomSymbolFileId** ppCreatedObject
            );
    }; // end of DkmCustomSymbolFileId

    // This is used for in-memory dynamic modules when doing managed debugging.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("22e890de-40f9-2415-edf0-d3b5014acd22") DkmDynamicSymbolFileId : public Symbols::DkmSymbolFileId
    {
        // Use DkmDynamicSymbolFileId::Create to create this object
        private: DkmDynamicSymbolFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDynamicSymbolFileId();
        // This object cannot be copied
        private: DkmDynamicSymbolFileId& operator=(const DkmDynamicSymbolFileId&);
        private: DkmDynamicSymbolFileId(const DkmDynamicSymbolFileId&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmSymbolFileId' to a 'DkmDynamicSymbolFileId'. Return
        // NULL if the path object is not a 'DkmDynamicSymbolFileId'.
        // pDynamicSymbolFileId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmDynamicSymbolFileId* TryCast(
            DkmSymbolFileId* pSymbolFileId
            )
        {
            if (pSymbolFileId == NULL || pSymbolFileId->TagValue() != Tag::DynamicSymbolFileId)
                return NULL;

            return static_cast<DkmDynamicSymbolFileId*>(pSymbolFileId);
        }

        // Create a new DkmDynamicSymbolFileId object instance.
        // SymbolProviderId: [In] Unique identifier for symbol files/symbol providers.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SymbolProviderId,
            _Deref_out_ Symbols::DkmDynamicSymbolFileId** ppCreatedObject
            );
    }; // end of DkmDynamicSymbolFileId

    // Contains the information which is in the 'RSDS' section of the module's debug
    // directory. The Mvid portion of this information is in the Mvid immutable.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3c1bf10d-a25c-9c9f-3f20-27ad8165d1df") DkmPdbFileId : public Symbols::DkmSymbolFileId
    {
        // Use DkmPdbFileId::Create to create this object
        private: DkmPdbFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPdbFileId();
        // This object cannot be copied
        private: DkmPdbFileId& operator=(const DkmPdbFileId&);
        private: DkmPdbFileId(const DkmPdbFileId&);

        private: const GUID m_Mvid;
        private: const UINT32 m_Age;
        private: DkmString* const m_pPdbName;
        private: void* m__pExtendedData;

        // Module Version Identifier from the loaded module. This is a unique value which is
        // embedded in an exe/dll by linkers/compilers when the dll/exe is built. A new value
        // is generated each time that the dll/exe is compiled.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Mvid(
            );

        // Age of the PDB. This is essentially a timestamp value which is embedded in an
        // exe/dll by linkers/compilers when the dll/exe is built.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Age(
            );

        // The name of the PDB file containing the debug information. This value is often a
        // file path (ex: c:\myproject\bin\debug\myproject.pdb), but in some build
        // environments it may be shortened to just a file name (ex: kernel32.pdb).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE PdbName(
            );

        // Attempt to cast a 'DkmSymbolFileId' to a 'DkmPdbFileId'. Return
        // NULL if the path object is not a 'DkmPdbFileId'.
        // pPdbFileId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPdbFileId* TryCast(
            DkmSymbolFileId* pSymbolFileId
            )
        {
            if (pSymbolFileId == NULL || pSymbolFileId->TagValue() != Tag::PdbFileId)
                return NULL;

            return static_cast<DkmPdbFileId*>(pSymbolFileId);
        }

        // Create a new DkmPdbFileId object instance.
        // SymbolProviderId: [In] Unique identifier for symbol files/symbol providers.
        // Mvid            : [In] Module Version Identifier from the loaded module. This is a
        // unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe
        // is built. A new value is generated each time that the dll/exe is compiled.
        // Age             : [In] Age of the PDB. This is essentially a timestamp value which
        // is embedded in an exe/dll by linkers/compilers when the dll/exe is built.
        // pPdbName        : [In] The name of the PDB file containing the debug information.
        // This value is often a file path (ex: c:\myproject\bin\debug\myproject.pdb), but in
        // some build environments it may be shortened to just a file name (ex:
        // kernel32.pdb).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SymbolProviderId,
            _In_ const GUID& Mvid,
            _In_ UINT32 Age,
            _In_ DkmString* pPdbName,
            _Deref_out_ Symbols::DkmPdbFileId** ppCreatedObject
            );
    }; // end of DkmPdbFileId

    // Resolved document object which is created from a successful call to
    // DkmModule.FindMappedDocuments or DkmScriptDocument.TryMappedResolve. This contains the
    // information to map requests in server-side documents into requests on the client-side
    // document.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a2390517-8273-fd47-12dc-fc0d945fa1a1") DkmResolvedMappedDocument : public Symbols::DkmResolvedDocument
    {
        // Use DkmResolvedMappedDocument::Create to create this object
        private: DkmResolvedMappedDocument();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmResolvedMappedDocument();
        // This object cannot be copied
        private: DkmResolvedMappedDocument& operator=(const DkmResolvedMappedDocument&);
        private: DkmResolvedMappedDocument(const DkmResolvedMappedDocument&);

        private: OPTIONAL DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>* const m_pScriptBlocks;
        private: void* m__pExtendedData;

        // [Optional] Collection of script blocks in the project item document.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>* STDMETHODCALLTYPE ScriptBlocks(
            );

        // Creates a new resolved mapped document object. This API is typically called by the
        // script local agent.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pDocumentName   : [In] Name of the source file. This is generally a full path, but
        // in some scenarios it make be a partial path or just a name with extension (ex:
        // example.cpp). In the case of a dynamic document (ex: running script from internet
        // explorer) 'Path' could be a URL rather than a local file path.
        // pScriptDocument : [In,Optional] Script document which this resolved document
        // represents. This should be null for non script-based symbol providers.
        // MatchStrength   : [In] Indicates how strong of a match there was between the
        // DkmDocumentQuery and the resulting DkmResolvedDocument.
        // Warning         : [In] Warning that occurred during the match. Depending on
        // context, these may need to be surfaced to the user.
        // TextRequested   : [In] If true, return the source text.
        // pScriptBlocks   : [In,Optional] Collection of script blocks in the project item
        // document.
        // DataItem        : [In] Data object to add to the new DkmResolvedMappedDocument
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pDocumentName,
            _In_opt_ Script::DkmScriptDocument* pScriptDocument,
            _In_ Symbols::DkmDocumentMatchStrength::e MatchStrength,
            _In_ Symbols::DkmResolvedDocumentWarning::e Warning,
            _In_ bool TextRequested,
            _In_opt_ DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>* pScriptBlocks,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Symbols::DkmResolvedMappedDocument** ppCreatedObject
            );
    }; // end of DkmResolvedMappedDocument

}; // end namespace Symbols

// Contains types used for resolving function names to instruction addresses/symbols such
// as for setting function breakpoints.
namespace FunctionResolution {
    // Flags which affect how a search should be performed.
    enum DkmAddressSearchFlags::e
    {
        // Input expression contains a wildcard search to bind.
        UseWildcard = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmAddressSearchFlags::e);

    // Result of an asynchronous DkmRuntimeFunctionResolutionRequest.OnFunctionResolved call.
    struct DkmOnFunctionResolvedAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeFunctionResolutionRequest.OnResolverMessage call.
    struct DkmOnResolverMessageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // DkmRuntimeFunctionResolutionRequest represents an expression to be parsed and
    // evaluated by a runtime based expression evaluator and is bound to a particular
    // process. Resolutions will send DkmModuleInstance::FunctionResolved events.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b102c225-ea38-8242-7787-f48cda1e12e9") DkmRuntimeFunctionResolutionRequest : public DkmDataContainer
    {
        // Use DkmRuntimeFunctionResolutionRequest::Create to create this object
        private: DkmRuntimeFunctionResolutionRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeFunctionResolutionRequest();
        // This object cannot be copied
        private: DkmRuntimeFunctionResolutionRequest& operator=(const DkmRuntimeFunctionResolutionRequest&);
        private: DkmRuntimeFunctionResolutionRequest(const DkmRuntimeFunctionResolutionRequest&);

        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: DkmString* const m_pFunctionName;
        private: const UINT32 m_LineOffset;
        private: DkmString* const m_pModuleName;
        private: const FunctionResolution::DkmAddressSearchFlags::e m_SearchFlags;
        private: void* m__pExtendedData;

        // Uniquely identifies the DkmRuntimeFunctionResolutionRequest object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Language/Vendor of the request. Vendor is usually set to Guid.Empty. Language and
        // vendor will be set to Guid.Empty for function breakpoints set with an 'Unknown'
        // language.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // The name of the function to resolve to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // The line offset from the start of the function to bind to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LineOffset(
            );

        // The name of the module to resolve to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // Flags which affect how a search should be performed.
        public: DECLSPEC_NOTHROW FunctionResolution::DkmAddressSearchFlags::e STDMETHODCALLTYPE SearchFlags(
            );

        // Closes the DkmRuntimeFunctionResolutionRequest object. Once this is closed, no new
        // resolutions will be sent.
        //
        // DkmRuntimeFunctionResolutionRequest objects are automatically closed when their
        // associated DkmProcess object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmRuntimeFunctionResolutionRequest object instance. The caller is
        // responsible for closing the created object after they are done.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // CompilerId      : [In] Language/Vendor of the request. Vendor is usually set to
        // Guid.Empty. Language and vendor will be set to Guid.Empty for function breakpoints
        // set with an 'Unknown' language.
        // pFunctionName   : [In] The name of the function to resolve to.
        // LineOffset      : [In] The line offset from the start of the function to bind to.
        // pModuleName     : [In] The name of the module to resolve to.
        // SearchFlags     : [In] Flags which affect how a search should be performed.
        // DataItem        : [In] Data object to add to the new
        // DkmRuntimeFunctionResolutionRequest instance. DkmDataItem::Null() in the case that
        // the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_ DkmString* pFunctionName,
            _In_ UINT32 LineOffset,
            _In_ DkmString* pModuleName,
            _In_ FunctionResolution::DkmAddressSearchFlags::e SearchFlags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ FunctionResolution::DkmRuntimeFunctionResolutionRequest** ppCreatedObject
            );

        // Called by the breakpoint manager to add a pending resolve request. Expression
        // evaluators, or other components will immediately try to bind the breakpoint
        // against current modules, and will bind the breakpoint to additional locations as
        // modules load. The caller of this interface should implement
        // IDkmRuntimeFunctionResolverClient to obtain the results of the resolution.
        //
        // Implementations of this interface should stop attempting to bind the breakpoint
        // when the DkmRuntimeFunctionResolutionRequest object is closed.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnableResolution(
            _In_ DkmWorkList* pWorkList
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by runtime function resolvers when a new resolution has been discovered for
        // a DkmRuntimeFunctionResolutionRequest instance.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pAddress        : [In] The address the request bound to. Multiple addresses will
        // result in multiple calls to this function.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnFunctionResolved(
            _In_ DkmInstructionAddress* pAddress
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by runtime function resolvers when a new resolution has been discovered for
        // a DkmRuntimeFunctionResolutionRequest instance.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pAddress        : [In] The address the request bound to. Multiple addresses will
        // result in multiple calls to this function.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnFunctionResolved(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmInstructionAddress* pAddress,
            _In_ IDkmCompletionRoutine<FunctionResolution::DkmOnFunctionResolvedAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by runtime function resolvers when the resolver wishes to notify its client
        // an error/warning occurred while attempting to resolve the breakpoint.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Level           : [In] Describes the severity of a message sent from a breakpoint
        // manager back to the source component. This list is sorted in order of priority, as
        // the UI will only display the most important warning. All warnings are ignored if
        // the breakpoint is bound.
        // pMessage        : [In] Message string to display to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnResolverMessage(
            _In_ Breakpoints::DkmBreakpointMessageLevel::e Level,
            _In_ DkmString* pMessage
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by runtime function resolvers when the resolver wishes to notify its client
        // an error/warning occurred while attempting to resolve the breakpoint.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // Level           : [In] Describes the severity of a message sent from a breakpoint
        // manager back to the source component. This list is sorted in order of priority, as
        // the UI will only display the most important warning. All warnings are ignored if
        // the breakpoint is bound.
        // pMessage        : [In] Message string to display to the user.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnResolverMessage(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointMessageLevel::e Level,
            _In_ DkmString* pMessage,
            _In_ IDkmCompletionRoutine<FunctionResolution::DkmOnResolverMessageAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmRuntimeFunctionResolutionRequest

    // DkmSymbolFunctionResolutionRequest represents an expression to be parsed and evaluated
    // by a symbol based expression evaluator and is not bound to a particular process. Used
    // to perform function breakpoint binds.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("365bd4a2-61ab-b70d-48f4-ed41bfdf9a87") DkmSymbolFunctionResolutionRequest : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSymbolFunctionResolutionRequest::Create to create this object
        private: DkmSymbolFunctionResolutionRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSymbolFunctionResolutionRequest();
        // This object cannot be copied
        private: DkmSymbolFunctionResolutionRequest& operator=(const DkmSymbolFunctionResolutionRequest&);
        private: DkmSymbolFunctionResolutionRequest(const DkmSymbolFunctionResolutionRequest&);

        private: DkmProcess* const m_pProcess;
        private: OPTIONAL Symbols::DkmModule* const m_pModule;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: DkmString* const m_pFunctionName;
        private: const UINT32 m_LineOffset;
        private: DkmString* const m_pModuleName;
        private: const FunctionResolution::DkmAddressSearchFlags::e m_SearchFlags;
        private: void* m__pExtendedData;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // [Optional] The module to bind against. If null, then all modules should be
        // checked. If the module's name does not match the module name parameter, no bind
        // will occur.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Describes a programming language.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Source text of the parsed expression.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // The line offset from the start of the function to bind to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LineOffset(
            );

        // Module name to bind in.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // Flags which affect how a search should be performed.
        public: DECLSPEC_NOTHROW FunctionResolution::DkmAddressSearchFlags::e STDMETHODCALLTYPE SearchFlags(
            );

        // Create a new DkmSymbolFunctionResolutionRequest object instance.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pModule         : [In,Optional] The module to bind against. If null, then all
        // modules should be checked. If the module's name does not match the module name
        // parameter, no bind will occur.
        // pLanguage       : [In] Describes a programming language.
        // pFunctionName   : [In] Source text of the parsed expression.
        // LineOffset      : [In] The line offset from the start of the function to bind to.
        // pModuleName     : [In] Module name to bind in.
        // SearchFlags     : [In] Flags which affect how a search should be performed.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ DkmString* pFunctionName,
            _In_ UINT32 LineOffset,
            _In_ DkmString* pModuleName,
            _In_ FunctionResolution::DkmAddressSearchFlags::e SearchFlags,
            _Deref_out_ FunctionResolution::DkmSymbolFunctionResolutionRequest** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Resolve an address string to zero or more address symbols. This is used to bind
        // function breakpoints.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pAddresses      : [Out] DkmInstructionSymbol[] represents a method in the target
        // process.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Resolve(
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pAddresses
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmSymbolFunctionResolutionRequest

}; // end namespace FunctionResolution

// Contains the types used for call stack walking and call stack frame formatting. This
// also includes types related to processor registers, as registers are tracked per-stack
// frame.
namespace CallStack {
    // Collection of settings that affect how the stack provider formats a DkmStackFrame.
    struct DECLSPEC_UUID("b65c8b37-5df0-a9ca-4492-eda38962e5b0") DkmFrameFormatOptions
    {
        // Flags that indicate what information is requested for a variable.
        Evaluation::DkmVariableInfoFlags::e ArgumentFlags;

        // Flags which affect how the stack provider create DkmStackFrame objects.
        CallStack::DkmFrameNameFormatOptions::e FrameNameFormat;

        // Flags which effect how an input expression should be parsed, compiled or
        // displayed.
        Evaluation::DkmEvaluationFlags::e EvaluationFlags;

        // This is the timeout to be used for potentially slow operations such as a function
        // evaluation. This value is in milliseconds.
        UINT32 Timeout;

        // The radix to use when formatting integer data. Currently supported values are '16'
        // and '10'.
        UINT32 Radix;

        // Release all reference-counted fields within the DkmFrameFormatOptions structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmFrameFormatOptions* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Return result from IDkmMonitorStackWalk.
    struct DECLSPEC_UUID("d4dd7f13-e45e-1045-821a-45827846ead6") DkmMonitorStackWalkResult
    {
        // Status code for the walk.
        CallStack::DkmStackWalkStatus::e Status;

        // [Optional] NextRegisters is required when 'Status' is 'FrameFound'. NextRegisters
        // is used to inform other walkers where the previous walker left off. If an walker
        // fails to return the next registers then the walk will be truncated.
        OPTIONAL CallStack::DkmFrameRegisters* pNextRegisters;

        // [Optional] FrameObject is required when 'Status' is 'FrameFound'. This object
        // contains information about the stack frame.
        OPTIONAL CallStack::DkmStackWalkFrame* pFrameObject;

        // NextStackPointer is required when 'Status' is 'OutsideOfRuntime'. This is used by
        // the stack frame merger to advance the stack walk when frames are encountered which
        // cannot be monitor walked (walking requires symbols). The stack frame merger will
        // not invoke the walker again until it has progressed to this stack pointer value,
        // and the walker should update its state so that the next call to 'WalkNextFrame'
        // retrieves the frame at this position.
        UINT64 NextStackPointer;

        // Release all reference-counted fields within the DkmMonitorStackWalkResult structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmMonitorStackWalkResult* pItem
            );
    };

    // The limit/base address for the memory containing a thread's stack.
    struct DECLSPEC_UUID("25b9f321-da7e-7b52-ac8c-381d9cbbc176") DkmStackMemoryRange
    {
        // The address where this thread's stack began. Since stacks grow down in Windows,
        // these value will be larger than the limit.
        UINT64 StackBase;

        // The minimum address which is allocated in the stack's range.
        UINT64 StackLimit;

        // Compare an instance of the DkmStackMemoryRange struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmStackMemoryRange& other
            ) const;

        bool operator==(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmStackMemoryRange structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmStackMemoryRange* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Provides a context for walking async return stacks and task creation stacks.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("be372de0-27f8-fcb3-6a35-27128111cd17") DkmAsyncStackWalkContext : public DkmDataContainer
    {
        // Use DkmAsyncStackWalkContext::Create to create this object
        private: DkmAsyncStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmAsyncStackWalkContext();
        // This object cannot be copied
        private: DkmAsyncStackWalkContext& operator=(const DkmAsyncStackWalkContext&);
        private: DkmAsyncStackWalkContext(const DkmAsyncStackWalkContext&);

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const GUID m_TaskProviderId;
        private: OPTIONAL CallStack::DkmStackWalkFrame* const m_pTaskIdentityStackFrame;
        private: OPTIONAL CallStack::DkmStackWalkFrame* const m_pInternalStackFrame;
        private: OPTIONAL Evaluation::DkmSuccessEvaluationResult* const m_pFrameObject;
        private: OPTIONAL ParallelTasks::DkmTask* const m_pTask;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmSuccessEvaluationResult*>* const m_pReturnStackFunctions;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The inspection session that owns this task object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Extensible GUID indicating the task provider which a task is from.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE TaskProviderId(
            );

        // [Optional] If this stack walk context refers to a task that is associated with a
        // particular stack frame, specifies the stack frame that this task object is
        // associated with.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE TaskIdentityStackFrame(
            );

        // [Optional] Internal stack frame used to perform inspection operations on async
        // frames in the return stack, for example, the CLR requires an ICorDebugFrame to
        // read static fields.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE InternalStackFrame(
            );

        // [Optional] Optional evaluation result representing the frame that this stack walk
        // context refers to.  When C++ debugging, this is used to support inspection inside
        // of return stack frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE FrameObject(
            );

        // [Optional] Optional task to use for inspection of async frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW ParallelTasks::DkmTask* STDMETHODCALLTYPE Task(
            );

        // [Optional] For native async frames, specifies an list of available functions in
        // the return stack, from which captured local variables may be extracted from.  Null
        // for managed and JavaScript.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmSuccessEvaluationResult*>* STDMETHODCALLTYPE ReturnStackFunctions(
            );

        // The runtime instance associated with this task object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Guid which uniquely identifies this evaluation result.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Create a new DkmAsyncStackWalkContext object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionSession: [In] The inspection session that owns this task object.
        // TaskProviderId  : [In] Extensible GUID indicating the task provider which a task
        // is from.
        // pTaskIdentityStackFrame: [In,Optional] If this stack walk context refers to a task
        // that is associated with a particular stack frame, specifies the stack frame that
        // this task object is associated with.
        // pInternalStackFrame: [In,Optional] Internal stack frame used to perform inspection
        // operations on async frames in the return stack, for example, the CLR requires an
        // ICorDebugFrame to read static fields.
        // pFrameObject    : [In,Optional] Optional evaluation result representing the frame
        // that this stack walk context refers to.  When C++ debugging, this is used to
        // support inspection inside of return stack frames.
        // pTask           : [In,Optional] Optional task to use for inspection of async
        // frames.
        // pReturnStackFunctions: [In,Optional] For native async frames, specifies an list of
        // available functions in the return stack, from which captured local variables may
        // be extracted from.  Null for managed and JavaScript.
        // pRuntimeInstance: [In] The runtime instance associated with this task object.
        // DataItem        : [In] Data object to add to the new DkmAsyncStackWalkContext
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const GUID& TaskProviderId,
            _In_opt_ CallStack::DkmStackWalkFrame* pTaskIdentityStackFrame,
            _In_opt_ CallStack::DkmStackWalkFrame* pInternalStackFrame,
            _In_opt_ Evaluation::DkmSuccessEvaluationResult* pFrameObject,
            _In_opt_ ParallelTasks::DkmTask* pTask,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmSuccessEvaluationResult*>* pReturnStackFunctions,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmAsyncStackWalkContext** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Gets the logged creation stack of this task.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pWorkList       : WorkList to append the new work item to.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskCreationStack(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskCreationStackAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns a list of frames that will execute when this task completes.  The order
        // that the frames will execute in is arbitrary and might not be the order returned
        // here.  Only frames that will execute as a direct result of this task are included,
        // not frames that will execute as a result of another task that will execute after
        // this task completes.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pWorkList       : WorkList to append the new work item to.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskContinuationFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskContinuationFramesAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Gets the async call stack of this thread.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API can normally only be called on the client side
        // normally.  It can be called on the remote side for script.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pWorkList       : WorkList to append the new work item to.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncCallStack(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetAsyncCallStackAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmAsyncStackWalkContext

    // Holds the list of implementations of the IDkmCallStackFilter interface which may be
    // called by a component. This object is used to call these stack frame filters.
    class DkmCallStackFilterList : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: const DWORD m_count;

        // Use DkmCallStackFilterList::Create to create this object
        private: DkmCallStackFilterList();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCallStackFilterList();
        // This object cannot be copied
        private: DkmCallStackFilterList& operator=(const DkmCallStackFilterList&);
        private: DkmCallStackFilterList(const DkmCallStackFilterList&);

        // Returns the number of implemantions of the IDkmCallStackFilter interface which
        // may be called through this object.
        public: inline DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE Count(
            )
        {
            return m_count;
        }

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Provides a filter with the next stack frame. A filter can simply pass this frame
        // on through, it can suppress the frame by returning nothing, or it can provide its
        // own set of annotated frames. The stack provider will ignore
        // NotImplementedException (E_NOTIMPL). All other errors will truncate stack walk.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ImplementationIndex: [In] Zero-based index into the collection of {0}
        // implementations that the caller wishes to be invoked. This should be less than the
        // 'Count' property.
        // pStackContext   : [In] DkmStackContext objects are created by components that wish
        // to request the stack from the stack provider. A component needs to close the
        // context after they have completed the stack walk. To obtain the stack a component
        // should create this object and then call GetNextFrames.
        // pInput          : [In,Optional] Input is the next frame to examine. After all
        // frame have been filtered, this function will be called one last time with a null
        // input frame. This lets the filter know that the call stack is fully processed.
        // pResult         : [Out] DkmStackWalkFrame[] represents a frame on a call stack
        // which has been walked, but may not have been formatted or filtered. Formatted
        // frames are represented by DkmStackFrame instead.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pResult contains any elements, S_FALSE is
        // indicates the array is empty, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FilterNextFrame(
            _In_ UINT32 ImplementationIndex,
            _In_ CallStack::DkmStackContext* pStackContext,
            _In_opt_ CallStack::DkmStackWalkFrame* pInput,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Create a new DkmCallStackFilterList object instance.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ CallStack::DkmCallStackFilterList** ppCreatedObject
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    };

    // Options for how the call stack should be filtered.
    enum DkmCallStackFilterOptions::e
    {
        // No filter option flags are set.
        None = 0x0,
        // Remove frames from the call stack which are in hidden code.
        FilterHiddenFrames = 0x1,
        // Remove non-user code from the call stack.
        FilterNonuserCode = 0x2,
        // Indicates that async frames should be included in the call stack.
        IncludeAsyncFrames = 0x4,
        // If JustMyCode is enabled, indicates that the frames on the topmost block of
        // nonuser code should still be shown.
        ShowTopNonUserBlock = 0x8,
        // If JustMyCode is enabled and ShowTopNonUserBlock is also specified, indicates that
        // frames involved with the implementation of throwing an exception should still be
        // collapsed.
        HideNonUserExceptionImplementationFrames = 0x10
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmCallStackFilterOptions::e);

    // Flags which affect how the stack provider create DkmStackFrame objects.
    enum DkmFrameNameFormatOptions::e
    {
        // No additional information is included in the frame name.
        None = 0x0,
        // Include the module name in the frame name.
        Module = 0x1,
        // Include the number of lines at the end of the frame name.
        Lines = 0x2,
        // Include the byte offset at the end of the frame name.
        ByteOffsets = 0x4,
        // Include the return type in the frame name.
        ReturnType = 0x8,
        // Include the return type field in the frame object.
        ReturnTypeField = 0x10,
        // Include the document position in the frame object.
        DocumentPositionField = 0x20
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmFrameNameFormatOptions::e);

    // DkmFrameRegisters represents the registers of a stack frame.
    //
    // Derived classes: DkmArmFrameRegisters, DkmX64FrameRegisters, DkmX86FrameRegisters
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bb64ab72-8d4e-6997-9f89-79436f38133e") DkmFrameRegisters : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmFrameRegisters::Create to create this object
        private: DkmFrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFrameRegisters();
        // This object cannot be copied
        private: DkmFrameRegisters& operator=(const DkmFrameRegisters&);
        private: DkmFrameRegisters(const DkmFrameRegisters&);

        // DkmFrameRegisters is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmArmFrameRegisters'.
        ArmRegisters = 0,
        // Object is an instance of 'DkmX86FrameRegisters'.
        X86Registers = 1,
        // Object is an instance of 'DkmX64FrameRegisters'.
        X64Registers = 2
        }; };

        private: const Tag::e m_TagValue;
        private: DkmReadOnlyCollection<CallStack::DkmUnwoundRegister*>* const m_pUnwoundRegisters;
        private: void* m__pExtendedData;

        // DkmFrameRegisters is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The register set that was actually unwound by the unwinder.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<CallStack::DkmUnwoundRegister*>* STDMETHODCALLTYPE UnwoundRegisters(
            );

        // Returns the processor-independent instruction pointer which is stored in this
        // frame register object.
        // pValue          : [Out] Instruction pointer value which is stored in the specified
        // registers structure (ex: EIP on x86, RIP on x64).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionPointer(
            _Out_ UINT64* pValue
            );

        // Returns the processor-independent stack pointer which is stored in this frame
        // register object.
        // pValue          : [Out] Stack pointer value which is stored in the specified
        // registers structure (ex: ESP on x86, RSP on x64).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStackPointer(
            _Out_ UINT64* pValue
            );

        // A helper function for searching the array of unwound register values for a
        // DkmStackWalkFrame. If the register was not unwound, a failed HRESULT is returned.
        // Id              : [In] The unique constant for the requested register. Normally,
        // this is a cvconst value such as CV_REG_EIP.
        // pBuffer         : [In,Out] A buffer that receives the value of the register.
        // Size            : [In] The size of the value in bytes.
        // pBytesRead      : [Out,Optional] The caller allocated buffer that receives the
        // contents of the requested register.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRegisterValue(
            _In_ UINT32 Id,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            );
    }; // end of DkmFrameRegisters

    // Result of an asynchronous DkmAsyncStackWalkContext.GetAsyncCallStack call.
    struct DkmGetAsyncCallStackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will display in the call stack window.  May be any combination of
        // creation stack frames, return stack frames, or annotated frames.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Result of an asynchronous DkmAsyncStackWalkContext.GetContinuationFramesFromTaskObject
    // call.
    struct DkmGetContinuationFramesFromTaskObjectAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will execute when this task completes.
        DkmArray<Clr::DkmManagedReturnStackFrame*> ContinuationFrames;
    };
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Result of an asynchronous DkmThread.GetCurrentLocation call.
    struct DkmGetCurrentLocationAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The name of the current location.
        DkmString* pLocationName;
    };
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Result of an asynchronous DkmAsyncStackWalkContext.GetManagedTaskContinuationFrames
    // call.
    struct DkmGetManagedTaskContinuationFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will execute when this task completes.
        DkmArray<Clr::DkmManagedReturnStackFrame*> ContinuationFrames;
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Result of an asynchronous DkmStackContext.GetNextFrames call.
    struct DkmGetNextFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] DkmStackFrame[] represents a frame on the call stack after filtering
        // and translation.
        DkmArray<CallStack::DkmStackFrame*> Frames;
    };
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Result of an asynchronous DkmAsyncStackWalkContext.GetTaskContinuationFrames call.
    struct DkmGetTaskContinuationFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will execute when this task completes.
        DkmArray<CallStack::DkmStackWalkFrame*> ContinuationFrames;
    };

    // Result of an asynchronous DkmAsyncStackWalkContext.GetTaskCreationStack call.
    struct DkmGetTaskCreationStackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The creation stack of this task.
        DkmArray<CallStack::DkmStackWalkFrame*> CreationStack;
    };

    // Result of an asynchronous DkmStackWalkContext.HeuristicWalkFrames call.
    struct DkmHeuristicWalkFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmStackWalkFrame[] represents a frame on a call stack which has been walked, but
        // may not have been formatted or filtered. Formatted frames are represented by
        // DkmStackFrame instead.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;

        // [Optional] NextRegisters indicates the registers of the next frame (the caller of
        // 'FrameObject'). This will be null if the stack is complete, or if the
        // EndStackPointer was reached.
        OPTIONAL CallStack::DkmFrameRegisters* pNextRegisters;

        // Returns true if the monitor reached the end of the stack.
        bool EndOfStack;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // DkmMonitorStackWalkContext allows the various components DkmSymbolStackWalkContext
    // with this call stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4ce2f85d-5b40-4a4c-5eba-79e9228e48b1") DkmMonitorStackWalkContext : public DkmDataContainer
    {
        // Use DkmMonitorStackWalkContext::Create to create this object
        private: DkmMonitorStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmMonitorStackWalkContext();
        // This object cannot be copied
        private: DkmMonitorStackWalkContext& operator=(const DkmMonitorStackWalkContext&);
        private: DkmMonitorStackWalkContext(const DkmMonitorStackWalkContext&);

        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pThreadContext;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The initial Win32 CONTEXT to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Guid which uniquely identifies this DkmMonitorStackWalkContext.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Closes a DkmMonitorStackWalkContext object instance. This will release any
        // resources associated with this object across all components. This includes
        // resources across computer or managed/native marshalling boundaries.
        //
        // DkmMonitorStackWalkContext objects are automatically closed when their associated
        // DkmThread object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmMonitorStackWalkContext object instance. The caller is responsible
        // for closing the created object after they are done.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pThreadContext  : [In,Optional] The initial Win32 CONTEXT to use when performing
        // the stack walk. This value is normally 'null' but can be set in order to view
        // another call stack (ex: .cxr).
        // DataItem        : [In] Data object to add to the new DkmMonitorStackWalkContext
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmMonitorStackWalkContext** ppCreatedObject
            );

        // Initialize is invoked on each walker exactly once at the beginning of the walk
        // process. This gives each walker a chance to initialize any state.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            );

        // UpdatePosition is invoked by the stack merger after another walker has walked one
        // or more frames, and so this walker must be updated before invoking WalkNextFrame.
        // Runtimes that maintain their own internal stack range state within in the target
        // process will likely have nothing to do within this method.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            );

        // Attempt to walk the next stack frame. The DkmMonitorStackWalkResult structure
        // indicates if this monitor was able to walk the frame.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pResult         : [Out] Return result from IDkmMonitorStackWalk.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _Out_ CallStack::DkmMonitorStackWalkResult* pResult
            );
    }; // end of DkmMonitorStackWalkContext
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache call.
    struct DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Array of walked frames. For, unresolved frames, both InstructionAddress and
        // Description will be null.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;

        // Returns true if the monitor reached the end of the stack.
        bool EndOfStack;

        // [Optional] The actual hash of the call stack.  This may be NULL for runtimes that
        // don't support call stack hashing.
        OPTIONAL CallStack::DkmStackHash* pActualStackHash;

        // The DkmStackWalkContext object that can used later to continue the walk. If the
        // cache is valid, this is the original context.  If the cache is invalid, this will
        // be a new DkmStackWalkContext object.
        CallStack::DkmStackWalkContext* pActualStackWalkContext;

        // True if the cache was valid, false if not.
        bool IsCacheValid;
    };

    // Result of an asynchronous DkmStackWalkContext.RuntimeWalkNextFrames call.
    struct DkmRuntimeWalkNextFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Array of walked frames. For, unresolved frames, both InstructionAddress and
        // Description will be null.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;

        // Returns true if the monitor reached the end of the stack.
        bool EndOfStack;
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // DkmStackContext objects are created by components that wish to request the stack from
    // the stack provider. A component needs to close the context after they have completed
    // the stack walk. To obtain the stack a component should create this object and then
    // call GetNextFrames.
    //
    // Derived classes: DkmStackTraceContext
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("90f8ca28-617f-0b13-f421-fa6f1159973e") DkmStackContext : public DkmDataContainer
    {
        // Use DkmStackContext::Create to create this object
        private: DkmStackContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackContext();
        // This object cannot be copied
        private: DkmStackContext& operator=(const DkmStackContext&);
        private: DkmStackContext(const DkmStackContext&);

        // Contains additional fields of DkmStackContext which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] If we are fetching the continuation frames or task creation frames,
            // specifies the context for the async stack walk operation.
            OPTIONAL CallStack::DkmAsyncStackWalkContext* const pAsyncContext;

            // Which type of stack walk we are doing.  If the operation is
            // AsyncReturnStackWalk or AsyncTaskCreationStackWalk, "Task" must be non-null.
            // Otherwise, "AsyncContext" must be NULL.
            const CallStack::DkmStackWalkOperation::e Operation;
        };

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: DkmThread* const m_pThread;
        private: const CallStack::DkmCallStackFilterOptions::e m_FilterOptions;
        private: const CallStack::DkmFrameFormatOptions m_FormatOptions;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pThreadContext;
        private: const GUID m_UniqueId;
        private: ___ExtendedData* const m__pExtendedData;

        // DkmInspectionSession allows the various components which inspect data to store
        // private data which is associated with a group of evaluations.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Options for how the call stack should be filtered.
        public: DECLSPEC_NOTHROW CallStack::DkmCallStackFilterOptions::e STDMETHODCALLTYPE FilterOptions(
            );

        // Collection of settings that affect how the stack provider formats a DkmStackFrame.
        public: DECLSPEC_NOTHROW const CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE FormatOptions(
            );

        // [Optional] The initial thread context to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Guid which uniquely identifies this DkmStackContext.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] If we are fetching the continuation frames or task creation frames,
        // specifies the context for the async stack walk operation.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE AsyncContext(
            );

        // Which type of stack walk we are doing.  If the operation is AsyncReturnStackWalk
        // or AsyncTaskCreationStackWalk, "Task" must be non-null.  Otherwise, "AsyncContext"
        // must be NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW CallStack::DkmStackWalkOperation::e STDMETHODCALLTYPE Operation(
            );

        // Closes a DkmStackContext object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmStackContext objects are automatically closed when their associated
        // DkmInspectionSession object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmStackContext object instance. The caller is responsible for
        // closing the created object after they are done.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // FilterOptions   : [In] Options for how the call stack should be filtered.
        // FormatOptions   : [In] Collection of settings that affect how the stack provider
        // formats a DkmStackFrame.
        // pThreadContext  : [In,Optional] The initial thread context to use when performing
        // the stack walk. This value is normally 'null' but can be set in order to view
        // another call stack (ex: .cxr).
        // DataItem        : [In] Data object to add to the new DkmStackContext instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmCallStackFilterOptions::e FilterOptions,
            _In_ const CallStack::DkmFrameFormatOptions& FormatOptions,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackContext** ppCreatedObject
            );

        // Create a new DkmStackContext object instance. The caller is responsible for
        // closing the created object after they are done.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // FilterOptions   : [In] Options for how the call stack should be filtered.
        // FormatOptions   : [In] Collection of settings that affect how the stack provider
        // formats a DkmStackFrame.
        // pThreadContext  : [In,Optional] The initial thread context to use when performing
        // the stack walk. This value is normally 'null' but can be set in order to view
        // another call stack (ex: .cxr).
        // pAsyncContext   : [In,Optional] If we are fetching the continuation frames or task
        // creation frames, specifies the context for the async stack walk operation.
        // Operation       : [In] Which type of stack walk we are doing.  If the operation is
        // AsyncReturnStackWalk or AsyncTaskCreationStackWalk, "Task" must be non-null.
        // Otherwise, "AsyncContext" must be NULL.
        // DataItem        : [In] Data object to add to the new DkmStackContext instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmCallStackFilterOptions::e FilterOptions,
            _In_ const CallStack::DkmFrameFormatOptions& FormatOptions,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_opt_ CallStack::DkmAsyncStackWalkContext* pAsyncContext,
            _In_ CallStack::DkmStackWalkOperation::e Operation,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackContext** ppCreatedObject
            );

        // Obtain the next frames from the call stack. If this is the first call on a
        // particular DkmStackContext then this will return the first frames. This method is
        // the recommended way to obtain the call stack because the stack provider maintains
        // a cache of the physical stack.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // RequestSize     : [In] RequestSize is the number of frames that the caller would
        // like returned. The implementation of GetNextFrames may return fewer frames in the
        // case that stack does not contain that many frames. Negative values, or request to
        // read more than MaxFrames (currently 5,000) will be capped to MaxFrames.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSize,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetNextFramesAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmStackContext
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Information used to determine whether a cache of a call stack is valid.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("de840e2b-b1b5-f981-88aa-b9de5940c762") DkmStackHash : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStackHash::Create to create this object
        private: DkmStackHash();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackHash();
        // This object cannot be copied
        private: DkmStackHash& operator=(const DkmStackHash&);
        private: DkmStackHash(const DkmStackHash&);

        private: DkmThread* const m_pThread;
        private: const CallStack::DkmStackMemoryRange m_StackMemoryRange;
        private: const Symbols::DkmMD5HashValue m_RegisterHash;
        private: const Symbols::DkmMD5HashValue m_MemoryHash;
        private: void* m__pExtendedData;

        // The thread the cache applies to.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // The range of the thread's stack.
        public: DECLSPEC_NOTHROW const CallStack::DkmStackMemoryRange& STDMETHODCALLTYPE StackMemoryRange(
            );

        // MD5 hash of the thread's CONTEXT structure at the point in which the cache was
        // created.
        public: DECLSPEC_NOTHROW const Symbols::DkmMD5HashValue& STDMETHODCALLTYPE RegisterHash(
            );

        // MD5 hash of the stack memory of the thread at the point in which the cache was
        // created.
        public: DECLSPEC_NOTHROW const Symbols::DkmMD5HashValue& STDMETHODCALLTYPE MemoryHash(
            );

        // Create a new DkmStackHash object instance.
        // pThread         : [In] The thread the cache applies to.
        // StackMemoryRange: [In] The range of the thread's stack.
        // RegisterHash    : [In] MD5 hash of the thread's CONTEXT structure at the point in
        // which the cache was created.
        // MemoryHash      : [In] MD5 hash of the stack memory of the thread at the point in
        // which the cache was created.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ const CallStack::DkmStackMemoryRange& StackMemoryRange,
            _In_ const Symbols::DkmMD5HashValue& RegisterHash,
            _In_ const Symbols::DkmMD5HashValue& MemoryHash,
            _Deref_out_ CallStack::DkmStackHash** ppCreatedObject
            );
    }; // end of DkmStackHash

    // DkmStackWalkContext allows the various components which walk, filter, or examine call
    // stacks to store private data which is associated with this call stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("33ebb282-734b-c2f3-66cd-c42eb8a3d490") DkmStackWalkContext : public DkmDataContainer
    {
        // Use DkmStackWalkContext::Create to create this object
        private: DkmStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkContext();
        // This object cannot be copied
        private: DkmStackWalkContext& operator=(const DkmStackWalkContext&);
        private: DkmStackWalkContext(const DkmStackWalkContext&);

        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pThreadContext;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;
        private: void* m_pSymbolStackWalkContextCollection0;

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The initial Win32 CONTEXT to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Guid which uniquely identifies this DkmStackWalkContext.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Closes a DkmStackWalkContext object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmStackWalkContext objects are automatically closed when their associated
        // DkmThread object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmStackWalkContext object instance.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pThreadContext  : [In,Optional] The initial Win32 CONTEXT to use when performing
        // the stack walk. This value is normally 'null' but can be set in order to view
        // another call stack (ex: .cxr).
        // DataItem        : [In] Data object to add to the new DkmStackWalkContext instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackWalkContext** ppCreatedObject
            );

        // Find a DkmSymbolStackWalkContext element within this DkmStackWalkContext. If no
        // element with the given input key is present, FindSymbolStackWalkContext will fail.
        // SymbolProviderId: [In] Search key used to find the element.
        // ppSymbolStackWalkContext: [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSymbolStackWalkContext(
            _In_ const GUID& SymbolProviderId,
            _Deref_out_ CallStack::DkmSymbolStackWalkContext** ppSymbolStackWalkContext
            );

        // Attempt to walk through a region of the stack using a heuristic stack walk
        // algorithm. This is used in x86 when no symbols are available. It is not
        // implemented on other platforms as PDATA allows walking of all frames.
        // pRegisters      : [In] Registers to attempt to walk from.
        // RequestSize     : [In] RequestSize is the number of frames that the caller would
        // like returned. The implementation of HeuristicWalkFrames may return fewer frames
        // in the case that stack does not contain that many frames.
        // EndStackPointer : [In] Stack address to stop the unwinding at. This value is
        // UInt64.MaxValue if the no end stack pointer is present.
        // pFrames         : [Out] DkmStackWalkFrame[] represents a frame on a call stack
        // which has been walked, but may not have been formatted or filtered. Formatted
        // frames are represented by DkmStackFrame instead.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppNextRegisters : [Out,Optional] NextRegisters indicates the registers of the next
        // frame (the caller of 'FrameObject'). This will be null if the stack is complete,
        // or if the EndStackPointer was reached.
        // pEndOfStack     : [Out] Returns true if the monitor reached the end of the stack.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HeuristicWalkFrames(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 RequestSize,
            _In_ UINT64 EndStackPointer,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Out_ bool* pEndOfStack
            );

        // Attempt to walk through a region of the stack using a heuristic stack walk
        // algorithm. This is used in x86 when no symbols are available. It is not
        // implemented on other platforms as PDATA allows walking of all frames.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pRegisters      : [In] Registers to attempt to walk from.
        // RequestSize     : [In] RequestSize is the number of frames that the caller would
        // like returned. The implementation of HeuristicWalkFrames may return fewer frames
        // in the case that stack does not contain that many frames.
        // EndStackPointer : [In] Stack address to stop the unwinding at. This value is
        // UInt64.MaxValue if the no end stack pointer is present.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HeuristicWalkFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 RequestSize,
            _In_ UINT64 EndStackPointer,
            _In_ IDkmCompletionRoutine<CallStack::DkmHeuristicWalkFramesAsyncResult>* pCompletionRoutine
            );

        // Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call
        // stack is still valid.
        // RequestSizeHintIfCacheIsValid: [In] RequestSizeHintIfCacheIsValid is a hint as to
        // the number of frame that the caller needs. This value is treated as a hint because
        // this API can return frames which are not yet walked, so this API may return more
        // or less than the hint value.  A request size hint of 0 means not to do any stack
        // walking at all if the cache is valid.
        // RequestSizeHintIfCacheIsInvalid: [In] RequestSizeHintIfCacheIsInvalid is a hint as
        // to the number of frame that the caller needs. This value is treated as a hint
        // because this API can return frames which are not yet walked, so this API may
        // return more or less than the hint value.
        // pCachedHash     : [In,Optional] Cached call stack hash, will not walk the stack if
        // cache is still valid.  This parameter is optional.  If null, we will still compute
        // the actual hash and do the stack walk, but will skip the comparing of the actual
        // hash against the cached hash to suppress the stack walk.
        // pFrames         : [Out] Array of walked frames. For, unresolved frames, both
        // InstructionAddress and Description will be null.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pEndOfStack     : [Out] Returns true if the monitor reached the end of the stack.
        // ppActualStackHash: [Out,Optional] The actual hash of the call stack.  This may be
        // NULL for runtimes that don't support call stack hashing.
        // ppActualStackWalkContext: [Out] The DkmStackWalkContext object that can used later
        // to continue the walk. If the cache is valid, this is the original context.  If the
        // cache is invalid, this will be a new DkmStackWalkContext object.
        // pIsCacheValid   : [Out] True if the cache was valid, false if not.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFramesAndCheckCache(
            _In_ UINT32 RequestSizeHintIfCacheIsValid,
            _In_ UINT32 RequestSizeHintIfCacheIsInvalid,
            _In_opt_ CallStack::DkmStackHash* pCachedHash,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack,
            _Deref_out_opt_ CallStack::DkmStackHash** ppActualStackHash,
            _Deref_out_ CallStack::DkmStackWalkContext** ppActualStackWalkContext,
            _Out_ bool* pIsCacheValid
            );

        // Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call
        // stack is still valid.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // RequestSizeHintIfCacheIsValid: [In] RequestSizeHintIfCacheIsValid is a hint as to
        // the number of frame that the caller needs. This value is treated as a hint because
        // this API can return frames which are not yet walked, so this API may return more
        // or less than the hint value.  A request size hint of 0 means not to do any stack
        // walking at all if the cache is valid.
        // RequestSizeHintIfCacheIsInvalid: [In] RequestSizeHintIfCacheIsInvalid is a hint as
        // to the number of frame that the caller needs. This value is treated as a hint
        // because this API can return frames which are not yet walked, so this API may
        // return more or less than the hint value.
        // pCachedHash     : [In,Optional] Cached call stack hash, will not walk the stack if
        // cache is still valid.  This parameter is optional.  If null, we will still compute
        // the actual hash and do the stack walk, but will skip the comparing of the actual
        // hash against the cached hash to suppress the stack walk.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFramesAndCheckCache(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSizeHintIfCacheIsValid,
            _In_ UINT32 RequestSizeHintIfCacheIsInvalid,
            _In_opt_ CallStack::DkmStackHash* pCachedHash,
            _In_ IDkmCompletionRoutine<CallStack::DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult>* pCompletionRoutine
            );

        // Attempt to walk the stack without the use of symbols. This will call into various
        // components that know how to walk portions of the stack (ex: CLR frames will be
        // walked by the CLR debug monitor). An 'unresolved' frame will be left for portions
        // of the stack which cannot be walked without information stored within the symbol
        // file. These 'unresolved' frames have no InstructionAddress or Description.
        // RequestSizeHint : [In] RequestSizeHint is a hint as to the number of frame that
        // the caller needs. This value is treated as a hint because this API can return
        // frames which are not yet walked, so this API may return more or less than the hint
        // value.
        // pFrames         : [Out] Array of walked frames. For, unresolved frames, both
        // InstructionAddress and Description will be null.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pEndOfStack     : [Out] Returns true if the monitor reached the end of the stack.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFrames(
            _In_ UINT32 RequestSizeHint,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack
            );

        // Attempt to walk the stack without the use of symbols. This will call into various
        // components that know how to walk portions of the stack (ex: CLR frames will be
        // walked by the CLR debug monitor). An 'unresolved' frame will be left for portions
        // of the stack which cannot be walked without information stored within the symbol
        // file. These 'unresolved' frames have no InstructionAddress or Description.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // RequestSizeHint : [In] RequestSizeHint is a hint as to the number of frame that
        // the caller needs. This value is treated as a hint because this API can return
        // frames which are not yet walked, so this API may return more or less than the hint
        // value.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSizeHint,
            _In_ IDkmCompletionRoutine<CallStack::DkmRuntimeWalkNextFramesAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmStackWalkContext

    // DkmStackWalkFrame represents a frame on a call stack which has been walked, but may
    // not have been formatted or filtered. Formatted frames are represented by DkmStackFrame
    // instead.
    //
    // Derived classes: DkmStackFrame
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("48b55030-ecac-2387-4e63-bfdc3c172598") DkmStackWalkFrame : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStackWalkFrame::Create to create this object
        private: DkmStackWalkFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkFrame();
        // This object cannot be copied
        private: DkmStackWalkFrame& operator=(const DkmStackWalkFrame&);
        private: DkmStackWalkFrame(const DkmStackWalkFrame&);

        // Contains additional fields of DkmStackWalkFrame which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] If we have an annotated frame, specifies an optional module
            // instance to associate with this frame.  If present, the user will be able to
            // load binaries or symbols for this module by right-clicking on this frame in
            // the call stack window.  This is NULL for non-annotated frames.
            OPTIONAL DkmModuleInstance* const pAnnotatedModule;

            // [Optional] Optional context for walking async return stacks and task creation
            // stacks.
            OPTIONAL CallStack::DkmAsyncStackWalkContext* const pAsyncContext;

            // [Optional] Optional object to attach to a DkmStackWalkFrame, allowing
            // components to associate additional private data with the frame.
            OPTIONAL CallStack::DkmStackWalkFrameData* const pData;
        };

        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmInstructionAddress* const m_pInstructionAddress;
        private: const UINT64 m_FrameBase;
        private: const UINT32 m_FrameSize;
        private: const CallStack::DkmStackWalkFrameFlags::e m_Flags;
        private: OPTIONAL DkmString* const m_pDescription;
        private: OPTIONAL CallStack::DkmFrameRegisters* const m_pRegisters;
        private: OPTIONAL DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* const m_pAnnotations;
        private: ___ExtendedData* const m__pExtendedData;

        // The thread that this stack frame is on.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The instruction of this frame. This can be omitted for annotated
        // frames.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Base stack pointer of the frame. This is used by the SDM to sort the frame, and it
        // is used by the stack merger to assess walk progress, so this value is required
        // even for annotated frames. This value should only be invalid in the case that the
        // debuggee's stack is corrupt.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameBase(
            );

        // Number of bytes of the stack consumed by this frame. This value will be zero for
        // annotated frames, or if the value is unknown.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FrameSize(
            );

        // Flags properties of a DkmStackWalkFrame.
        public: DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameFlags::e STDMETHODCALLTYPE Flags(
            );

        // [Optional] Description of the frame which will be displayed in the call stack
        // window. This should be provided for annotated frames.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // [Optional] Registers of the walked frame. These should be provided for
        // non-annotated frames.
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmFrameRegisters* STDMETHODCALLTYPE Registers(
            );

        // [Optional] A read only collection of stack frame annotations. These are defined by
        // an unwinder and are specific to that unwinder. An example usage is how inline
        // frame data is passed from inline stack filter to the formatter.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* STDMETHODCALLTYPE Annotations(
            );

        // [Optional] If we have an annotated frame, specifies an optional module instance to
        // associate with this frame.  If present, the user will be able to load binaries or
        // symbols for this module by right-clicking on this frame in the call stack window.
        // This is NULL for non-annotated frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleInstance* STDMETHODCALLTYPE AnnotatedModule(
            );

        // [Optional] Optional context for walking async return stacks and task creation
        // stacks.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE AsyncContext(
            );

        // [Optional] Optional object to attach to a DkmStackWalkFrame, allowing components
        // to associate additional private data with the frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Data(
            );

        // [Optional] The DkmRuntimeInstance class represents an execution environment which
        // is loaded into a DkmProcess and which contains code to be debugged.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // [Optional] The module containing this address. Addresses without a module cannot
        // have symbols (even for custom addresses). CLR addresses will always have a module.
        // Native addresses will not have a module if either the CPU jumped to an invalid
        // address (ex: NULL), or if the CPU is executing dynamically-emitted code.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Create a new DkmStackWalkFrame object instance.
        // pThread         : [In] The thread that this stack frame is on.
        // pInstructionAddress: [In,Optional] The instruction of this frame. This can be
        // omitted for annotated frames.
        // FrameBase       : [In] Base stack pointer of the frame. This is used by the SDM to
        // sort the frame, and it is used by the stack merger to assess walk progress, so
        // this value is required even for annotated frames. This value should only be
        // invalid in the case that the debuggee's stack is corrupt.
        // FrameSize       : [In] Number of bytes of the stack consumed by this frame. This
        // value will be zero for annotated frames, or if the value is unknown.
        // Flags           : [In] Flags properties of a DkmStackWalkFrame.
        // pDescription    : [In,Optional] Description of the frame which will be displayed
        // in the call stack window. This should be provided for annotated frames.
        // pRegisters      : [In,Optional] Registers of the walked frame. These should be
        // provided for non-annotated frames.
        // pAnnotations    : [In,Optional] A read only collection of stack frame annotations.
        // These are defined by an unwinder and are specific to that unwinder. An example
        // usage is how inline frame data is passed from inline stack filter to the
        // formatter.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT64 FrameBase,
            _In_ UINT32 FrameSize,
            _In_ CallStack::DkmStackWalkFrameFlags::e Flags,
            _In_opt_ DkmString* pDescription,
            _In_opt_ CallStack::DkmFrameRegisters* pRegisters,
            _In_opt_ DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppCreatedObject
            );

        // Create a new DkmStackWalkFrame object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pThread         : [In] The thread that this stack frame is on.
        // pInstructionAddress: [In,Optional] The instruction of this frame. This can be
        // omitted for annotated frames.
        // FrameBase       : [In] Base stack pointer of the frame. This is used by the SDM to
        // sort the frame, and it is used by the stack merger to assess walk progress, so
        // this value is required even for annotated frames. This value should only be
        // invalid in the case that the debuggee's stack is corrupt.
        // FrameSize       : [In] Number of bytes of the stack consumed by this frame. This
        // value will be zero for annotated frames, or if the value is unknown.
        // Flags           : [In] Flags properties of a DkmStackWalkFrame.
        // pDescription    : [In,Optional] Description of the frame which will be displayed
        // in the call stack window. This should be provided for annotated frames.
        // pRegisters      : [In,Optional] Registers of the walked frame. These should be
        // provided for non-annotated frames.
        // pAnnotations    : [In,Optional] A read only collection of stack frame annotations.
        // These are defined by an unwinder and are specific to that unwinder. An example
        // usage is how inline frame data is passed from inline stack filter to the
        // formatter.
        // pAnnotatedModule: [In,Optional] If we have an annotated frame, specifies an
        // optional module instance to associate with this frame.  If present, the user will
        // be able to load binaries or symbols for this module by right-clicking on this
        // frame in the call stack window.  This is NULL for non-annotated frames.
        // pAsyncContext   : [In,Optional] Optional context for walking async return stacks
        // and task creation stacks.
        // pData           : [In,Optional] Optional object to attach to a DkmStackWalkFrame,
        // allowing components to associate additional private data with the frame.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT64 FrameBase,
            _In_ UINT32 FrameSize,
            _In_ CallStack::DkmStackWalkFrameFlags::e Flags,
            _In_opt_ DkmString* pDescription,
            _In_opt_ CallStack::DkmFrameRegisters* pRegisters,
            _In_opt_ DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations,
            _In_opt_ DkmModuleInstance* pAnnotatedModule,
            _In_opt_ CallStack::DkmAsyncStackWalkContext* pAsyncContext,
            _In_opt_ CallStack::DkmStackWalkFrameData* pData,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppCreatedObject
            );

        // OnSetNextStatementCompleted is a general purpose method to allow components to
        // clear state after a set next statement completed. The DkmStackWalkFrame will be
        // the frame prior to to the SetNextStatement call.
        //
        // Location constraint: This API should generally be called only from client-side
        // components. However, it is safe for a monitor-side component to call this API if
        // the set next statement is being called from an event handler.
        // pNewStatement   : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSetNextStatementCompleted(
            _In_ DkmInstructionAddress* pNewStatement
            );

        // InterceptCurrentException is used to unwind to this frame as if there was an
        // exception handler at that frame.
        // InterceptAction : [In] Specifies exception interception actions.
        // pCookie         : [Out] Cookie that represents this intercept request. The value
        // is returned when an exception interception completed event is sent.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InterceptCurrentException(
            _In_ Exceptions::DkmExceptionInterceptActionFlags::e InterceptAction,
            _Out_ UINT64* pCookie
            );

        // Returns the address that represents the location if an exception were to be
        // intercepted to this frame.
        // ppNewAddress    : [Out] Possible new address if an exception was unwound to this
        // frame.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnwindAddress(
            _Deref_out_ DkmInstructionAddress** ppNewAddress
            );

        // SetNextStatement moves the IP of a stack frame. The stack frame is always the leaf
        // stack frame on a particular thread.
        // pNewStatement   : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetNextStatement(
            _In_ DkmInstructionAddress* pNewStatement
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // CanSetNextStatement determines if it is possible to move the IP of a stack frame.
        // The stack frame is always the leaf stack frame on a particular thread. This API
        // may only be implemented within the engine process. The Result out parameter should
        // be S_OK or the value of a failed HRESULT that the UI can map to an error message.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pNewStatement   : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // pResult         : [Out] The error code to return to the UI. This should be S_OK or
        // the value of a failed HRESULT that the UI can map to an error message.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CanSetNextStatement(
            _In_ DkmInstructionAddress* pNewStatement,
            _Out_ UINT32* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Format a DkmStackWalkFrame into a DkmStackFrame. Formatting a frame is one step of
        // what the stack provider does during GetNextFrames. This method can be used to
        // format a frame in a different way than was originally performed by the stack
        // provider in GetNextFrames.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // Options         : [In] Collection of settings that affect how the stack provider
        // formats a DkmStackFrame.
        // ppFormattedFrame: [Out] DkmStackFrame represents a frame on the call stack after
        // filtering and translation.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Format(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const CallStack::DkmFrameFormatOptions& Options,
            _Deref_out_ CallStack::DkmStackFrame** ppFormattedFrame
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Return a DkmInstructionSymbol for a stack frame. If the stack frame has no
        // instruction address (annotated frame) or the instruction address has no associated
        // DkmModule, then GetInstructionSymbol will return null (S_FALSE in native code).
        // ppSymbol        : [Out,Optional] DkmInstructionSymbol represents a method in the
        // target process.
        // Return value    : S_OK is returned if *ppSymbol is non-NULL, S_FALSE is returned
        // when *ppSymbol is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionSymbol(
            _Deref_out_opt_ Symbols::DkmInstructionSymbol** ppSymbol
            );

        // GetInspectionInterface is used to obtain a ICorDebugFrame or other
        // implementation-specific interfaces which a component can use to deeply inspect the
        // stack frame.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        //
        // Location constraint: This API must be called from the same process where the
        // target runtime implements stack walk. For managed debugging, this means that when
        // debugging 64-bit or remote processes, this API must be called from a debug monitor
        // component.
        // pSession        : [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // InterfaceID     : [In] The GUID of the desired interface. IID_ICorDebugFrame can
        // be used to obtain the CorDebug frame interface for a managed frame. Other debug
        // monitors or stack walkers may provide their own interface.
        // ppFrameInterface: [Out] Returned frame interface. This may be cast to the
        // interface pointer corresponding to 'InterfaceID'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInspectionInterface(
            _In_ Evaluation::DkmInspectionSession* pSession,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppFrameInterface
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Determines whether or not a frame is user code.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionSession: [In,Optional] Optional inspection session which may be used
        // for caching purposes.  The same inspection session is reused when computing the
        // user status of multiple frames in succession.
        // pUser           : [Out] True if the frame is user code, false if the frame is
        // nonuser code.
        // pExceptionImplementation: [Out] True if the frame is library code that implements
        // the throwing of exceptions.  This will cause the frame to be collapsed if we are
        // stopped here in response to an exception being thrown.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ComputeUserStatus(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pUser,
            _Out_ bool* pExceptionImplementation
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmStackWalkFrame

    // A Guid / Value pair set by a frame filter or unwinder. Can be used to pass custom
    // flags about the frame from one component to another.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b3b38131-4bcb-4dba-a409-4bdba19e7323") DkmStackWalkFrameAnnotation : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStackWalkFrameAnnotation::Create to create this object
        private: DkmStackWalkFrameAnnotation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkFrameAnnotation();
        // This object cannot be copied
        private: DkmStackWalkFrameAnnotation& operator=(const DkmStackWalkFrameAnnotation&);
        private: DkmStackWalkFrameAnnotation(const DkmStackWalkFrameAnnotation&);

        private: const GUID m_Id;
        private: const UINT64 m_Value;
        private: void* m__pExtendedData;

        // The Guid that uniquely identifies this annotation flag. This is specific to the
        // creator of the stack walk frame.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Id(
            );

        // The value of this annotation. The meaning of this value is specific to the
        // creator.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Value(
            );

        // Create a new DkmStackWalkFrameAnnotation object instance.
        // Id              : [In] The Guid that uniquely identifies this annotation flag.
        // This is specific to the creator of the stack walk frame.
        // Value           : [In] The value of this annotation. The meaning of this value is
        // specific to the creator.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& Id,
            _In_ UINT64 Value,
            _Deref_out_ CallStack::DkmStackWalkFrameAnnotation** ppCreatedObject
            );
    }; // end of DkmStackWalkFrameAnnotation

    // Optional reference object that can be used to attach data items to a
    // DkmStackWalkFrame.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("15ea147e-b48b-2d5c-b52a-a2fee87713b2") DkmStackWalkFrameData : public DkmDataContainer
    {
        // Use DkmStackWalkFrameData::Create to create this object
        private: DkmStackWalkFrameData();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkFrameData();
        // This object cannot be copied
        private: DkmStackWalkFrameData& operator=(const DkmStackWalkFrameData&);
        private: DkmStackWalkFrameData(const DkmStackWalkFrameData&);

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The inspection session that owns this frame data object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Guid which uniquely identifies this evaluation result.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Create a new DkmStackWalkFrameData object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionSession: [In] The inspection session that owns this frame data object.
        // DataItem        : [In] Data object to add to the new DkmStackWalkFrameData
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackWalkFrameData** ppCreatedObject
            );
    }; // end of DkmStackWalkFrameData

    // Flags properties of a DkmStackWalkFrame.
    enum DkmStackWalkFrameFlags::e
    {
        // No flags are set on this stack frame.
        None = 0x0,
        // Stack frame is the top frame in the call stack. This is used to detect the top
        // frame when the full stack frame collection is not available. Unwinders should set
        // this on top frame when doing an unwind. Unwinders must decide if it makes sense
        // for logical frames (such as inline frames) that appear above physical frame should
        // also be marked. Doing so would result in multiple frames being marked as a top
        // frame.
        TopFrame = 0x1,
        // Stack frame is located within hidden code.
        Hidden = 0x2,
        // Stack frame is located within non-user code.
        NonuserCode = 0x4,
        // Stack frame is an inlined optimized frame, not a physical frame.
        InlineOptimized = 0x8,
        // Stack frame is used to indicate that the maximum number of walked stack frame has
        // been exceeded.
        MaxFramesExceeded = 0x10,
        // Stack frame can be unwound to after an exception has been thrown.
        ExceptionUnwindTarget = 0x20,
        // Stack frame is an annotated frame that shows what is being evaluated example
        // 'Evaluation of: xyz'.
        FuncEvalFrame = 0x40,
        // Indicates that this frame is part of an async return stack and is not actually
        // executing on the current thread.
        ReturnStackFrame = 0x80,
        // Indicates that this frame was logged from the call stack of the creation of an
        // async task and is not actually executing on the current thread at this time.
        TaskCreationStackFrame = 0x100,
        // Indicates that it is not yet known whether or not the frame is user code or
        // non-user code.  The stack provider will call back to find out.
        UserStatusNotDetermined = 0x200,
        // Indicates that we are an annotated frame indicating that frames below may be
        // missing or incorrect due binaries or symbols not being loaded for a module.
        SymbolsNotLoadedAnnotation = 0x400,
        // Indicates that we are in nonuser code that is known to be part of the
        // implementation of throwing exceptions.
        NonUserExceptionImplementation = 0x800,
        // Indicates that this is an annotated frame denoting an async call (i.e. [Async
        // Call]).
        AsyncCallAnnotatedFrame = 0x1000,
        // Indicates that this is an annotated frame denoting resuming an async method (i.e.
        // [Resuming async method]).
        AsyncContinuationAnnotatedFrame = 0x2000
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmStackWalkFrameFlags::e);

    // Indicates a type of stack walking operation.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmStackWalkOperation::e
    {
        // A regular stack walk of a thread.
        Standard = 0,
        // A walk of a task's async return stack.
        TaskContinuations = 1,
        // A walk of the logged stack from when a task was created.
        TaskCreation = 2,
        // A walk of the logic async frames related to a thread that should be displayed in
        // the call stack window.
        Async = 3,
        // A walk of a stack trace consisting of a caller-defined list of frames.
        StackTrace = 4
    };

    // Return status from a monitor walk operation.
    enum DkmStackWalkStatus::e
    {
        // The walker found a frame within its runtime.
        FrameFound = 0,
        // The walker determined that the current frame is outside of it's runtime. Lower
        // priority walkers will be given a chance to walk.
        OutsideOfRuntime = 1,
        // The walker determined that the end of the stack has been reached. StackWalking
        // should stop.
        EndOfStack = 2
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // DkmSymbolStackWalkContext allows the various symbol providers which walk the call
    // stack to store private data which is associated with this call stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ca6905ca-dfde-bacc-31e6-fef0ad7fee7e") DkmSymbolStackWalkContext : public DkmDataContainer
    {
        // Use DkmSymbolStackWalkContext::Create to create this object
        private: DkmSymbolStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSymbolStackWalkContext();
        // This object cannot be copied
        private: DkmSymbolStackWalkContext& operator=(const DkmSymbolStackWalkContext&);
        private: DkmSymbolStackWalkContext(const DkmSymbolStackWalkContext&);

        private: CallStack::DkmStackWalkContext* const m_pStackWalkContext;
        private: const GUID m_SymbolProviderId;
        private: void* m__pExtendedData;

        // DkmStackWalkContext allows the various components which walk, filter, or examine
        // call stacks to store private data which is associated with this call stack.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkContext* STDMETHODCALLTYPE StackWalkContext(
            );

        // Unique identifier for symbol files/symbol providers.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SymbolProviderId(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The initial Win32 CONTEXT to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Closes a DkmSymbolStackWalkContext object instance. This will release any
        // resources associated with this object across all components. This includes
        // resources across computer or managed/native marshalling boundaries.
        //
        // DkmSymbolStackWalkContext objects are automatically closed when their associated
        // DkmStackWalkContext object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmSymbolStackWalkContext object instance. The caller is responsible
        // for closing the created object after they are done.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pStackWalkContext: [In] DkmStackWalkContext allows the various components which
        // walk, filter, or examine call stacks to store private data which is associated
        // with this call stack.
        // SymbolProviderId: [In] Unique identifier for symbol files/symbol providers.
        // DataItem        : [In] Data object to add to the new DkmSymbolStackWalkContext
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ const GUID& SymbolProviderId,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmSymbolStackWalkContext** ppCreatedObject
            );

        // Initialize is invoked on each walker exactly once at the beginning of the walk
        // process. This gives each walker a chance to initialize any state.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            );

        // UpdatePosition is invoked by the stack provider after another walker has walked
        // one or more frames, and so this walker must be updated before invoking
        // WalkNextFrame.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // pInstructionAddress: [In] Address from the instruction pointer in the registers.
        // This will be either a 'Native' or 'Unresolved' address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize,
            _In_ DkmInstructionAddress* pInstructionAddress
            );

        // Walk the next stack frame from the call stack.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppNextRegisters : [Out,Optional] NextRegisters indicates the registers of the next
        // frame (the caller of 'FrameObject'). It is used to invoke UpdatePosition if the
        // next frame is owned by a different symbol provider. A null NextRegisters value
        // indicates that the returned frame is the last frame of the call stack, so the
        // stack walk will end here.
        // ppFrameObject   : [Out,Optional] Created frame object for the current registers.
        // Return value    : S_OK is returned if *ppFrameObject is non-NULL, S_FALSE is
        // returned when *ppFrameObject is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Deref_out_opt_ CallStack::DkmStackWalkFrame** ppFrameObject
            );
    }; // end of DkmSymbolStackWalkContext
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // DkmUnwoundRegister represents a register of a stack frame that was unwound by an
    // unwinder.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("00abc6e8-c394-faef-ccf4-e3180221cc60") DkmUnwoundRegister : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmUnwoundRegister::Create to create this object
        private: DkmUnwoundRegister();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmUnwoundRegister();
        // This object cannot be copied
        private: DkmUnwoundRegister& operator=(const DkmUnwoundRegister&);
        private: DkmUnwoundRegister(const DkmUnwoundRegister&);

        private: const CV_HREG_e m_Identifier;
        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // the code-view register constant for this value.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Identifier(
            );

        // A byte array representing the contents of the register. The size of the register
        // in bytes can be found by the length of this array.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        // Create a new DkmUnwoundRegister object instance.
        // Identifier      : [In] the code-view register constant for this value.
        // pValue          : [In] A byte array representing the contents of the register. The
        // size of the register in bytes can be found by the length of this array.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e Identifier,
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ CallStack::DkmUnwoundRegister** ppCreatedObject
            );
    }; // end of DkmUnwoundRegister

    // Arm registers.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("991eff54-4b89-fc8e-3d59-f6b8dae67265") DkmArmFrameRegisters : public CallStack::DkmFrameRegisters
    {
        // Use DkmArmFrameRegisters::Create to create this object
        private: DkmArmFrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmArmFrameRegisters();
        // This object cannot be copied
        private: DkmArmFrameRegisters& operator=(const DkmArmFrameRegisters&);
        private: DkmArmFrameRegisters(const DkmArmFrameRegisters&);

        private: const UINT32 m_Pc;
        private: const UINT32 m_Sp;
        private: void* m__pExtendedData;

        // Instruction Pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Pc(
            );

        // Stack Pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Sp(
            );

        // Attempt to cast a 'DkmFrameRegisters' to a 'DkmArmFrameRegisters'. Return
        // NULL if the path object is not a 'DkmArmFrameRegisters'.
        // pArmRegisters : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmArmFrameRegisters* TryCast(
            DkmFrameRegisters* pRegisters
            )
        {
            if (pRegisters == NULL || pRegisters->TagValue() != Tag::ArmRegisters)
                return NULL;

            return static_cast<DkmArmFrameRegisters*>(pRegisters);
        }
    }; // end of DkmArmFrameRegisters

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // DkmStackFrame represents a frame on the call stack after filtering and translation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9e32fe11-196e-a0ec-b83c-0792427e91a2") DkmStackFrame : public CallStack::DkmStackWalkFrame
    {
        // Use DkmStackFrame::Create to create this object
        private: DkmStackFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackFrame();
        // This object cannot be copied
        private: DkmStackFrame& operator=(const DkmStackFrame&);
        private: DkmStackFrame(const DkmStackFrame&);

        private: const CallStack::DkmFrameFormatOptions m_Options;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: DkmString* const m_pFrameName;
        private: OPTIONAL DkmString* const m_pReturnType;
        private: OPTIONAL Symbols::DkmSourcePosition* const m_pSourcePosition;
        private: void* m__pExtendedData;

        // Collection of settings that affect how the stack provider formats a DkmStackFrame.
        public: DECLSPEC_NOTHROW const CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE Options(
            );

        // LanguageId/VendorId for the compiler which produced the code for this stack frame.
        // If this is unknown (ex: no symbols loaded for this module), both values will be
        // Guid.Empty. Otherwise, both values should be non-zero.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // Name of the stack frame. DkmStackFrame.FormatOptions determines the format of the
        // function name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FrameName(
            );

        // [Optional] Name of the stack frame's return type. This is only provided when
        // DkmFrameNameFormatOptions.ReturnTypeField is set.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ReturnType(
            );

        // [Optional] Source code location for this stack frame. This is only provided when
        // DkmFrameNameFormatOptions.DocumentPositionField is set.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSourcePosition* STDMETHODCALLTYPE SourcePosition(
            );

        // Create a new DkmStackFrame object instance.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pFrame          : [In] Frame represents a frame on the call stack after filtering
        // and translation.
        // Options         : [In] Collection of settings that affect how the stack provider
        // formats a DkmStackFrame.
        // CompilerId      : [In] LanguageId/VendorId for the compiler which produced the
        // code for this stack frame. If this is unknown (ex: no symbols loaded for this
        // module), both values will be Guid.Empty. Otherwise, both values should be
        // non-zero.
        // pFrameName      : [In] Name of the stack frame. DkmStackFrame.FormatOptions
        // determines the format of the function name.
        // pReturnType     : [In,Optional] Name of the stack frame's return type. This is
        // only provided when DkmFrameNameFormatOptions.ReturnTypeField is set.
        // pSourcePosition : [In,Optional] Source code location for this stack frame. This is
        // only provided when DkmFrameNameFormatOptions.DocumentPositionField is set.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ const CallStack::DkmFrameFormatOptions& Options,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_ DkmString* pFrameName,
            _In_opt_ DkmString* pReturnType,
            _In_opt_ Symbols::DkmSourcePosition* pSourcePosition,
            _Deref_out_ CallStack::DkmStackFrame** ppCreatedObject
            );

        // A method that calculates and returns the effective addresses for the requested
        // address. The effective address is the calculated address that an instruction
        // operand represents. For instance, on x86, an instruction may be of the form
        // dwordptr [esp-12]. The effective address of this operand will be the result of
        // subtracting 12 from esp. The number of operands and effective addresses are
        // architecture specific.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pAddress        : [In] The address for which to obtain the effective addresses.
        // ppEffectiveAddresses: [Out] The collection of effective addresses for this
        // instruction if any.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEffectiveAddresses(
            _In_ DkmInstructionAddress* pAddress,
            _Deref_out_ DkmReadOnlyCollection<Disassembly::DkmEffectiveAddress>** ppEffectiveAddresses
            );
    }; // end of DkmStackFrame
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // A stack context backed by an explicit list of frames, for example, a captured stack
    // trace from an exception.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b79ed48e-5eee-89c8-d677-883341894619") DkmStackTraceContext : public CallStack::DkmStackContext
    {
        // Use DkmStackTraceContext::Create to create this object
        private: DkmStackTraceContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackTraceContext();
        // This object cannot be copied
        private: DkmStackTraceContext& operator=(const DkmStackTraceContext&);
        private: DkmStackTraceContext(const DkmStackTraceContext&);

        private: DkmReadOnlyCollection<DkmInstructionAddress*>* const m_pFrames;
        private: void* m__pExtendedData;

        // The captured frames to use.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmInstructionAddress*>* STDMETHODCALLTYPE Frames(
            );

        // Create a new DkmStackTraceContext object instance. The caller is responsible for
        // closing the created object after they are done.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // FilterOptions   : [In] Options for how the call stack should be filtered.
        // FormatOptions   : [In] Collection of settings that affect how the stack provider
        // formats a DkmStackFrame.
        // pThreadContext  : [In,Optional] The initial thread context to use when performing
        // the stack walk. This value is normally 'null' but can be set in order to view
        // another call stack (ex: .cxr).
        // pAsyncContext   : [In,Optional] If we are fetching the continuation frames or task
        // creation frames, specifies the context for the async stack walk operation.
        // Operation       : [In] Which type of stack walk we are doing.  If the operation is
        // AsyncReturnStackWalk or AsyncTaskCreationStackWalk, "Task" must be non-null.
        // Otherwise, "AsyncContext" must be NULL.
        // pFrames         : [In] The captured frames to use.
        // DataItem        : [In] Data object to add to the new DkmStackTraceContext
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmCallStackFilterOptions::e FilterOptions,
            _In_ const CallStack::DkmFrameFormatOptions& FormatOptions,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_opt_ CallStack::DkmAsyncStackWalkContext* pAsyncContext,
            _In_ CallStack::DkmStackWalkOperation::e Operation,
            _In_ DkmReadOnlyCollection<DkmInstructionAddress*>* pFrames,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackTraceContext** ppCreatedObject
            );
    }; // end of DkmStackTraceContext
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // X64 registers. For leaf frames, all registers will be available. For non-leaf frames,
    // only the registers actually unwound by the unwinder will be available. Unwound
    // registers can be found in the DkmFrameRegisters' UnwoundRegisters collection. Rip and
    // Rsp are provided because they are always unwound and accessed often.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("23cfb317-a11e-4213-b192-2da6a78f5a9a") DkmX64FrameRegisters : public CallStack::DkmFrameRegisters
    {
        // Use DkmX64FrameRegisters::Create to create this object
        private: DkmX64FrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmX64FrameRegisters();
        // This object cannot be copied
        private: DkmX64FrameRegisters& operator=(const DkmX64FrameRegisters&);
        private: DkmX64FrameRegisters(const DkmX64FrameRegisters&);

        private: const UINT64 m_Rip;
        private: const UINT64 m_Rsp;
        private: void* m__pExtendedData;

        // Instruction pointer.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Rip(
            );

        // Stack pointer.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Rsp(
            );

        // Attempt to cast a 'DkmFrameRegisters' to a 'DkmX64FrameRegisters'. Return
        // NULL if the path object is not a 'DkmX64FrameRegisters'.
        // pX64Registers : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmX64FrameRegisters* TryCast(
            DkmFrameRegisters* pRegisters
            )
        {
            if (pRegisters == NULL || pRegisters->TagValue() != Tag::X64Registers)
                return NULL;

            return static_cast<DkmX64FrameRegisters*>(pRegisters);
        }
    }; // end of DkmX64FrameRegisters

    // X86 registers. For leaf frames, all registers will be available. For non-leaf frames,
    // only the registers actually unwound by the unwinder will be available. Unwound
    // registers can be found in the DkmFrameRegisters' UnwoundRegisters collection. Eip and
    // Esp are provided because they are always unwound and accessed often.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6e768c76-d179-e13b-d745-e4bb2b687e16") DkmX86FrameRegisters : public CallStack::DkmFrameRegisters
    {
        // Use DkmX86FrameRegisters::Create to create this object
        private: DkmX86FrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmX86FrameRegisters();
        // This object cannot be copied
        private: DkmX86FrameRegisters& operator=(const DkmX86FrameRegisters&);
        private: DkmX86FrameRegisters(const DkmX86FrameRegisters&);

        private: const UINT32 m_Eip;
        private: const UINT32 m_Esp;
        private: const UINT32 m_VFrame;
        private: void* m__pExtendedData;

        // Instruction pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Eip(
            );

        // Stack pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Esp(
            );

        // VFrame virtual register.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VFrame(
            );

        // Attempt to cast a 'DkmFrameRegisters' to a 'DkmX86FrameRegisters'. Return
        // NULL if the path object is not a 'DkmX86FrameRegisters'.
        // pX86Registers : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmX86FrameRegisters* TryCast(
            DkmFrameRegisters* pRegisters
            )
        {
            if (pRegisters == NULL || pRegisters->TagValue() != Tag::X86Registers)
                return NULL;

            return static_cast<DkmX86FrameRegisters*>(pRegisters);
        }
    }; // end of DkmX86FrameRegisters

}; // end namespace CallStack

// Contains types related to processing exceptions coming from the target process. This
// includes both setting triggers to be notified when specific exceptions are raised as
// well as describing exceptions coming out of the target. This namespace contains only
// the runtime environment agnostic types, with additional types found in the 'Native',
// 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Exceptions {
    // Result of an asynchronous DkmProcess.AddExceptionTrigger call.
    struct DkmAddExceptionTriggerAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Indicates the type of exception.
    struct DkmExceptionCategory
    {
        // C++ Exception.
        // Cpp is defined as {3a12d0b7-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID Cpp;
        // Win32 Exception.
        // Win32 is defined as {3b476d35-a401-11d2-aad4-00c04f990171}.
        static const GUID Win32;
        // Common Language Runtime Exception.
        // Clr is defined as {449ec4cc-30d2-4032-9256-ee18eb41b62b}.
        static const GUID Clr;
        // Native Run-Time Check.
        // NativeRuntimeCheck is defined as {63a08714-fc37-11d2-904c-00c04fa302a1}.
        static const GUID NativeRuntimeCheck;
        // Managed Debugging Assistant (MDA). These are notifications that come of the CLR to
        // notify the user of problems.
        // ManagedDebuggingAssistant is defined as {6ece07a9-0ede-45c4-8296-818d8fc401d4}.
        static const GUID ManagedDebuggingAssistant;
        // ActiveScript Exception.
        // ActiveScript is defined as {9e32aeae-0a90-49d4-9e2a-041c812eb0cc}.
        static const GUID ActiveScript;
        // GPU Exception.
        // Gpu is defined as {d7b0137a-4054-41fc-aa2f-a4c1c8b72138}.
        static const GUID Gpu;
    };
    __declspec(selectany) const GUID DkmExceptionCategory::Cpp = { 0x3a12d0b7, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmExceptionCategory::Win32 = { 0x3b476d35, 0xa401, 0x11d2, { 0xaa, 0xd4, 0x0, 0xc0, 0x4f, 0x99, 0x1, 0x71 } };
    __declspec(selectany) const GUID DkmExceptionCategory::Clr = { 0x449ec4cc, 0x30d2, 0x4032, { 0x92, 0x56, 0xee, 0x18, 0xeb, 0x41, 0xb6, 0x2b } };
    __declspec(selectany) const GUID DkmExceptionCategory::NativeRuntimeCheck = { 0x63a08714, 0xfc37, 0x11d2, { 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };
    __declspec(selectany) const GUID DkmExceptionCategory::ManagedDebuggingAssistant = { 0x6ece07a9, 0xede, 0x45c4, { 0x82, 0x96, 0x81, 0x8d, 0x8f, 0xc4, 0x1, 0xd4 } };
    __declspec(selectany) const GUID DkmExceptionCategory::ActiveScript = { 0x9e32aeae, 0xa90, 0x49d4, { 0x9e, 0x2a, 0x4, 0x1c, 0x81, 0x2e, 0xb0, 0xcc } };
    __declspec(selectany) const GUID DkmExceptionCategory::Gpu = { 0xd7b0137a, 0x4054, 0x41fc, { 0xaa, 0x2f, 0xa4, 0xc1, 0xc8, 0xb7, 0x21, 0x38 } };

    // Provides information about an exception which was raised in the target process. This
    // information includes details of what exception was raised and the current stage of
    // exception processing.
    //
    // Derived classes: DkmClrExceptionInformation, DkmCppExceptionInformation,
    // DkmCustomExceptionInformation, DkmGPUMemoryAccessExceptionInformation,
    // DkmWin32ExceptionInformation
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("02e0d36d-e7ec-ebb8-105e-1b6ac73701ff") DkmExceptionInformation : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExceptionInformation::Create to create this object
        private: DkmExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionInformation();
        // This object cannot be copied
        private: DkmExceptionInformation& operator=(const DkmExceptionInformation&);
        private: DkmExceptionInformation(const DkmExceptionInformation&);

        // DkmExceptionInformation is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmWin32ExceptionInformation'.
        Win32Exception = 0,
        // Object is an instance of 'DkmClrExceptionInformation'.
        ClrException = 1,
        // Object is an instance of 'DkmCppExceptionInformation'.
        CppException = 2,
        // Object is an instance of 'DkmGPUMemoryAccessExceptionInformation'.
        GPUMemoryAccessException = 3,
        // Object is an instance of 'DkmCustomExceptionInformation'.
        CustomException = 4
        }; };

        private: const Tag::e m_TagValue;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_ExceptionCategory;
        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmInstructionAddress* const m_pInstructionAddress;
        private: OPTIONAL DkmString* const m_pName;
        private: const UINT32 m_Code;
        private: const Exceptions::DkmExceptionProcessingStage::e m_ProcessingStage;
        private: OPTIONAL Exceptions::DkmExceptionInformation* const m_pImplementationException;
        private: void* m__pExtendedData;

        // DkmExceptionInformation is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] Address where the exception occurred. This will always be present for
        // C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these
        // may originate from inside the runtime.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // [Optional] Name of the exception. For C++ or CLR exceptions, this is the type
        // name. This value will be null for exception categories that identify exceptions by
        // code (ex: Win32).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // 32-bit integer code for the exception. For Win32 exceptions, this is the code
        // passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for
        // exception categories that identify exceptions by string (ex: CLR).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Code(
            );

        // The debugger receives notifications from the target process at various stages
        // within exception processing (ex: exception thrown, exception unhandled). This
        // enumeration indicates the stage(s) for a notification.
        public: DECLSPEC_NOTHROW Exceptions::DkmExceptionProcessingStage::e STDMETHODCALLTYPE ProcessingStage(
            );

        // [Optional] Information about the underlying exception used to implement a higher
        // level exception. For example, CLR and C++ exceptions may be implemented on top of
        // Win32 exceptions. So this may store the DkmWin32ExceptionInformation for CLR or
        // C++ exceptions.
        public: _Ret_opt_ DECLSPEC_NOTHROW Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE ImplementationException(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Raise a DebugMonitorException event. Components which implement the event sync
        // interface will receive the event notification. Control will return once all
        // components have been notified.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnDebugMonitorException(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Raise a ExceptionContinued event. Components which implement the event sync
        // interface will receive the event notification. Control will return once all
        // components have been notified.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContinued(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // Determines if processing for this exception may be modified by the debugger. For
        // example, if this user has performed an action (such as set next statement) that
        // required the exception to be implicitly squashed, this may return false. This
        // method may also return false if the runtime does not permit the exception from
        // being squashed.
        // pResult         : [Out] True if the debug monitor is able to modify the processing
        // of this exceptions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CanModifyProcessing(
            _Out_ bool* pResult
            );

        // Updates the state of the target process so that when execution is resumed, the
        // target process will not continue standard exception processing (ex: handler
        // search, stack unwinding). This method needs to be called before resuming
        // execution.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SquashProcessing(
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides a string description for an exception. This is used when tracing the
        // exception to the output window.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppValue         : [Out] String description of the exception.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDescription(
            _Deref_out_ DkmString** ppValue
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides additional information about an exception which will appear when Visual
        // Studio stops on the exception. For CLR exceptions, this contains the 'Message'
        // property from the System.Exception which was thrown.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppValue         : [Out,Optional] String description of the exception. If no other
        // information is available, null is returned.
        // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
        // when *ppValue is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdditionalInformation(
            _Deref_out_opt_ DkmString** ppValue
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides developer-oriented additional information about the exception.  This info
        // should be displayed along with GetDescription and GetAdditionalInformation to
        // clarify the cause of the error.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppRestrictedDescription: [Out,Optional] RestrictedErrorInfo description of the
        // exception. Due to security restrictions, this may not be available even if
        // RestrictedErrorInfo is available for the exception.
        // ppRestrictedErrorReference: [Out,Optional] If present, used to retrieve
        // IRestrictedErrorInfo via the RoResolvedRestrictedErrorInfoReference API.
        // ppRestrictedCapabilitySid: [Out,Optional] If present specifies the missing
        // capability.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetWinRTErrorInfo(
            _Deref_out_opt_ DkmString** ppRestrictedDescription,
            _Deref_out_opt_ DkmString** ppRestrictedErrorReference,
            _Deref_out_opt_ DkmString** ppRestrictedCapabilitySid
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Raise a OutOfBandException event. Components which implement the event sync
        // interface will receive the event notification. Control will return once all
        // components have been notified.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnOutOfBandException(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // Obtains the captured stack trace associated with the exception, if one is
        // available.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // ppStackTrace    : [Out,Optional] An array of frames that were running at the time
        // the exception got thrown.
        // Return value    : S_OK is returned if *ppStackTrace is non-NULL, S_FALSE is
        // returned when *ppStackTrace is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetExceptionStackTrace(
            _Deref_out_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>** ppStackTrace
            );
    }; // end of DkmExceptionInformation

    // Specifies exception interception actions.
    enum DkmExceptionInterceptActionFlags::e
    {
        // No flags set.
        None = 0x0,
        // Intercept exception.
        Intercept = 0x1,
        // Cancel intercept request.
        CancelIntercept = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmExceptionInterceptActionFlags::e);

    // The debugger receives notifications from the target process at various stages within
    // exception processing (ex: exception thrown, exception unhandled). This enumeration
    // indicates the stage(s) for a notification.
    enum DkmExceptionProcessingStage::e
    {
        // An exception was thrown. This notification occurs for all types of exceptions.
        Thrown = 0x1,
        // The target process has begun searching for an exception handler and this search
        // has entered user code. This notification is provided only for exception categories
        // which support Just My Code. Currently, only the CLR & Script exception categories
        // support Just My Code.
        //
        // In CLR devices scenarios or when Just My Code stepping is disabled in the UI, the
        // back end will not have support for Just My Code. In this case, when an exception
        // is thrown, both the 'Thrown' and 'UserCodeSearch' flags will be set.
        UserCodeSearch = 0x2,
        // The target process is about to swallow the exception at an app domain transition.
        AppDomainTransition = 0x4,
        // The target process is about to pass the exception from managed code into unmanaged
        // code.
        ManagedUnmanagedTransition = 0x8,
        // An exception handler has been found outside of user code. This notification is
        // provided only for exception categories which support Just My Code. Currently, only
        // the CLR exception category supports Just My Code.\n.
        UserUnhandled = 0x10,
        // No handler was found for this exception.
        Unhandled = 0x20,
        // Exception should be visible to users. When set, the exception will be sent to the
        // output window if the user doesn't wish to stop at the exception.
        UserVisible = 0x40
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmExceptionProcessingStage::e);

    // Describes an exception or collection of exceptions which a component wants to break
    // on. When a higher level components wants to be notified about certain exceptions, it
    // should create one or more exception triggers, and then enable these triggers
    // (DkmProcess.EnableExceptionTriggers). After this, when the exception occurs, a
    // ExceptionTriggerHit exception will be fired whenever this trigger is met.
    //
    // Derived classes: DkmExceptionCategoryTrigger, DkmExceptionCodeTrigger,
    // DkmExceptionGlobalTrigger, DkmExceptionNameTrigger
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("736be8c2-b44a-3d59-24b1-e132fbe225fc") DkmExceptionTrigger : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExceptionTrigger::Create to create this object
        private: DkmExceptionTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionTrigger();
        // This object cannot be copied
        private: DkmExceptionTrigger& operator=(const DkmExceptionTrigger&);
        private: DkmExceptionTrigger(const DkmExceptionTrigger&);

        // DkmExceptionTrigger is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmExceptionGlobalTrigger'.
        GlobalTrigger = 0,
        // Object is an instance of 'DkmExceptionCategoryTrigger'.
        CategoryTrigger = 1,
        // Object is an instance of 'DkmExceptionNameTrigger'.
        NameTrigger = 2,
        // Object is an instance of 'DkmExceptionCodeTrigger'.
        CodeTrigger = 3
        }; };

        private: const Tag::e m_TagValue;
        private: const Exceptions::DkmExceptionProcessingStage::e m_ProcessingStage;
        private: OPTIONAL DkmThread* const m_pThread;
        private: void* m__pExtendedData;

        // DkmExceptionTrigger is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The debugger receives notifications from the target process at various stages
        // within exception processing (ex: exception thrown, exception unhandled). This
        // enumeration is a bit mask of which of these stages the trigger should fire for.
        public: DECLSPEC_NOTHROW Exceptions::DkmExceptionProcessingStage::e STDMETHODCALLTYPE ProcessingStage(
            );

        // [Optional] Thread on which this trigger applies. If null, the trigger will be
        // examined for all threads.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );
    }; // end of DkmExceptionTrigger

    // Provides information about an exception trigger which was satisfied (hit) by an
    // exception coming from the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4d7aee60-dc8d-794c-98c2-7f4704eeb5d1") DkmExceptionTriggerHit : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExceptionTriggerHit::Create to create this object
        private: DkmExceptionTriggerHit();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionTriggerHit();
        // This object cannot be copied
        private: DkmExceptionTriggerHit& operator=(const DkmExceptionTriggerHit&);
        private: DkmExceptionTriggerHit(const DkmExceptionTriggerHit&);

        // Contains additional fields of DkmExceptionTriggerHit which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The stack trace of the exception, if available.
            OPTIONAL DkmReadOnlyCollection<DkmInstructionAddress*>* const pStackTrace;
        };

        private: Exceptions::DkmExceptionInformation* const m_pException;
        private: DkmString* const m_pDescription;
        private: OPTIONAL DkmString* const m_pRestrictedErrorDescription;
        private: OPTIONAL DkmString* const m_pCapabilitySid;
        private: OPTIONAL DkmString* const m_pRestrictedReference;
        private: OPTIONAL DkmString* const m_pAdditionalInformation;
        private: const GUID m_SourceId;
        private: ___ExtendedData* const m__pExtendedData;

        // Provides information about an exception which was raised in the target process.
        // This information includes details of what exception was raised and the current
        // stage of exception processing.
        public: _Ret_ DECLSPEC_NOTHROW Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE Exception(
            );

        // Description string for the exception. This is obtained from
        // IDkmExceptionFormatter.GetDescription.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // [Optional] Optional WinRT Restricted Description for the error, obtained from the
        // IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedErrorDescription(
            );

        // [Optional] Specifies the missing capability if there is one which resulted in a
        // runtime exception.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CapabilitySid(
            );

        // [Optional] Specifies the restricted reference. This is provided instead of the
        // RestrictedDescription and any CapabilitySid. A scenario for this is when the
        // debuggee process is not running in same session as debugger process. Components
        // above will need to use this to work out the restricted description and any missing
        // capability.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedReference(
            );

        // [Optional] Optional additional information about this exception. For CLR
        // exceptions, this contains the 'Message' property from the System.Exception which
        // was thrown. This information is obtained from
        // IDkmExceptionFormatter.GetAdditionalInformation.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AdditionalInformation(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // [Optional] The stack trace of the exception, if available.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmInstructionAddress*>* STDMETHODCALLTYPE StackTrace(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Create a new DkmExceptionTriggerHit object instance.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // pDescription    : [In] Description string for the exception. This is obtained from
        // IDkmExceptionFormatter.GetDescription.
        // pRestrictedErrorDescription: [In,Optional] Optional WinRT Restricted Description
        // for the error, obtained from the
        // IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.
        // pCapabilitySid  : [In,Optional] Specifies the missing capability if there is one
        // which resulted in a runtime exception.
        // pRestrictedReference: [In,Optional] Specifies the restricted reference. This is
        // provided instead of the RestrictedDescription and any CapabilitySid. A scenario
        // for this is when the debuggee process is not running in same session as debugger
        // process. Components above will need to use this to work out the restricted
        // description and any missing capability.
        // pAdditionalInformation: [In,Optional] Optional additional information about this
        // exception. For CLR exceptions, this contains the 'Message' property from the
        // System.Exception which was thrown. This information is obtained from
        // IDkmExceptionFormatter.GetAdditionalInformation.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmString* pDescription,
            _In_opt_ DkmString* pRestrictedErrorDescription,
            _In_opt_ DkmString* pCapabilitySid,
            _In_opt_ DkmString* pRestrictedReference,
            _In_opt_ DkmString* pAdditionalInformation,
            _In_ const GUID& SourceId,
            _Deref_out_ Exceptions::DkmExceptionTriggerHit** ppCreatedObject
            );

        // Create a new DkmExceptionTriggerHit object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // pDescription    : [In] Description string for the exception. This is obtained from
        // IDkmExceptionFormatter.GetDescription.
        // pRestrictedErrorDescription: [In,Optional] Optional WinRT Restricted Description
        // for the error, obtained from the
        // IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.
        // pCapabilitySid  : [In,Optional] Specifies the missing capability if there is one
        // which resulted in a runtime exception.
        // pRestrictedReference: [In,Optional] Specifies the restricted reference. This is
        // provided instead of the RestrictedDescription and any CapabilitySid. A scenario
        // for this is when the debuggee process is not running in same session as debugger
        // process. Components above will need to use this to work out the restricted
        // description and any missing capability.
        // pAdditionalInformation: [In,Optional] Optional additional information about this
        // exception. For CLR exceptions, this contains the 'Message' property from the
        // System.Exception which was thrown. This information is obtained from
        // IDkmExceptionFormatter.GetAdditionalInformation.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pStackTrace     : [In,Optional] The stack trace of the exception, if available.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmString* pDescription,
            _In_opt_ DkmString* pRestrictedErrorDescription,
            _In_opt_ DkmString* pCapabilitySid,
            _In_opt_ DkmString* pRestrictedReference,
            _In_opt_ DkmString* pAdditionalInformation,
            _In_ const GUID& SourceId,
            _In_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>* pStackTrace,
            _Deref_out_ Exceptions::DkmExceptionTriggerHit** ppCreatedObject
            );

        // Raise a ExceptionTriggerHit event. Components which implement the event sync
        // interface will receive the event notification. This method will enqueue the event
        // and control will immediately return to the caller.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Send(
            );
    }; // end of DkmExceptionTriggerHit

    // Describes an entire category (ex: .NET exceptions, Win32 exceptions) that a component
    // wants to break on.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("64994a94-4363-dfda-0dc1-00f49cc6ff43") DkmExceptionCategoryTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionCategoryTrigger::Create to create this object
        private: DkmExceptionCategoryTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionCategoryTrigger();
        // This object cannot be copied
        private: DkmExceptionCategoryTrigger& operator=(const DkmExceptionCategoryTrigger&);
        private: DkmExceptionCategoryTrigger(const DkmExceptionCategoryTrigger&);

        private: const GUID m_ExceptionCategory;
        private: void* m__pExtendedData;

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionCategoryTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionCategoryTrigger'.
        // pCategoryTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionCategoryTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::CategoryTrigger)
                return NULL;

            return static_cast<DkmExceptionCategoryTrigger*>(pTrigger);
        }

        // Create a new DkmExceptionCategoryTrigger object instance.
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration is a bit mask of which of these stages the trigger
        // should fire for.
        // pThread         : [In,Optional] Thread on which this trigger applies. If null, the
        // trigger will be examined for all threads.
        // ExceptionCategory: [In] Indicates the type of exception.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _In_ const GUID& ExceptionCategory,
            _Deref_out_ Exceptions::DkmExceptionCategoryTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionCategoryTrigger

    // Describe an exception that a component wants to break on by its exception code. Code
    // triggers are used for exception categories which use exception codes to identify
    // exceptions (ex: Win32 exceptions). Code triggers will not fire for exception
    // categories which use a name string to identify exceptions (ex: CLR exceptions).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4862250b-5bf2-b9f9-4da6-6fdd7e39b841") DkmExceptionCodeTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionCodeTrigger::Create to create this object
        private: DkmExceptionCodeTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionCodeTrigger();
        // This object cannot be copied
        private: DkmExceptionCodeTrigger& operator=(const DkmExceptionCodeTrigger&);
        private: DkmExceptionCodeTrigger(const DkmExceptionCodeTrigger&);

        private: const GUID m_ExceptionCategory;
        private: const UINT32 m_Code;
        private: void* m__pExtendedData;

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // 32-bit integer code for the exception. For Win32 exceptions, this is the code
        // passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for
        // exception categories that identify exceptions by string (ex: CLR).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Code(
            );

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionCodeTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionCodeTrigger'.
        // pCodeTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionCodeTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::CodeTrigger)
                return NULL;

            return static_cast<DkmExceptionCodeTrigger*>(pTrigger);
        }

        // Create a new DkmExceptionCodeTrigger object instance.
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration is a bit mask of which of these stages the trigger
        // should fire for.
        // pThread         : [In,Optional] Thread on which this trigger applies. If null, the
        // trigger will be examined for all threads.
        // ExceptionCategory: [In] Indicates the type of exception.
        // Code            : [In] 32-bit integer code for the exception. For Win32
        // exceptions, this is the code passed to RaiseException
        // (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that
        // identify exceptions by string (ex: CLR).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _In_ const GUID& ExceptionCategory,
            _In_ UINT32 Code,
            _Deref_out_ Exceptions::DkmExceptionCodeTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionCodeTrigger

    // An exception trigger which will fire regardless of exception category, exception name,
    // or exception code. Thus, this type of exception trigger can only be conditioned based
    // on processing stage or thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7e756301-6822-678f-4fdf-ebfe25bdc021") DkmExceptionGlobalTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionGlobalTrigger::Create to create this object
        private: DkmExceptionGlobalTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionGlobalTrigger();
        // This object cannot be copied
        private: DkmExceptionGlobalTrigger& operator=(const DkmExceptionGlobalTrigger&);
        private: DkmExceptionGlobalTrigger(const DkmExceptionGlobalTrigger&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionGlobalTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionGlobalTrigger'.
        // pGlobalTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionGlobalTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::GlobalTrigger)
                return NULL;

            return static_cast<DkmExceptionGlobalTrigger*>(pTrigger);
        }

        // Create a new DkmExceptionGlobalTrigger object instance.
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration is a bit mask of which of these stages the trigger
        // should fire for.
        // pThread         : [In,Optional] Thread on which this trigger applies. If null, the
        // trigger will be examined for all threads.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _Deref_out_ Exceptions::DkmExceptionGlobalTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionGlobalTrigger

    // Describes an exception that a component wants to break on by its name. NameTriggers
    // are used for exception categories that use names to identify exceptions. For example,
    // CLR exceptions and C++ exceptions are identified by type name. Name triggers will not
    // fire for code-based exception categories (ex: Win32 exceptions).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dcffa6ae-e45d-fd4f-a23e-82779a332801") DkmExceptionNameTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionNameTrigger::Create to create this object
        private: DkmExceptionNameTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionNameTrigger();
        // This object cannot be copied
        private: DkmExceptionNameTrigger& operator=(const DkmExceptionNameTrigger&);
        private: DkmExceptionNameTrigger(const DkmExceptionNameTrigger&);

        private: const GUID m_ExceptionCategory;
        private: DkmString* const m_pName;
        private: void* m__pExtendedData;

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // Name of the exception. For C++ or CLR exceptions, this is the type name. This
        // value will be null for exception categories that identify exceptions by code (ex:
        // Win32 exceptions).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionNameTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionNameTrigger'.
        // pNameTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionNameTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::NameTrigger)
                return NULL;

            return static_cast<DkmExceptionNameTrigger*>(pTrigger);
        }

        // Create a new DkmExceptionNameTrigger object instance.
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration is a bit mask of which of these stages the trigger
        // should fire for.
        // pThread         : [In,Optional] Thread on which this trigger applies. If null, the
        // trigger will be examined for all threads.
        // ExceptionCategory: [In] Indicates the type of exception.
        // pName           : [In] Name of the exception. For C++ or CLR exceptions, this is
        // the type name. This value will be null for exception categories that identify
        // exceptions by code (ex: Win32 exceptions).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _In_ const GUID& ExceptionCategory,
            _In_ DkmString* pName,
            _Deref_out_ Exceptions::DkmExceptionNameTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionNameTrigger

}; // end namespace Exceptions

// Contains the types related to setting breakpoints. This includes both the high-level
// breakpoint classes (DkmPendingBreakpoint, etc) that offer the same capabilities as
// user-set breakpoints, as well as the lower-level DkmRuntimeBreakpoint classes that the
// high-level breakpoints are implemented upon.
namespace Breakpoints {
    // Represents a breakpoint which has been bound (resolved) to a particular code
    // instruction address or a particular data element. For example, in C++ templates one
    // could create a DkmPendingBreakpoint for a source line. The breakpoint manager would
    // resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int')
    // or many (ex: template is used with many template arguments) location. Each location
    // would have a DkmBoundBreakpoint object.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("91c8952c-4e18-00f7-ac71-8d0d38694e4c") DkmBoundBreakpoint : public DkmDataContainer
    {
        // Use DkmBoundBreakpoint::Create to create this object
        private: DkmBoundBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBoundBreakpoint();
        // This object cannot be copied
        private: DkmBoundBreakpoint& operator=(const DkmBoundBreakpoint&);
        private: DkmBoundBreakpoint(const DkmBoundBreakpoint&);

        private: Breakpoints::DkmPendingBreakpoint* const m_pPendingBreakpoint;
        private: const GUID m_UniqueId;
        private: OPTIONAL Breakpoints::DkmRuntimeBreakpoint* const m_pTarget;
        private: OPTIONAL Symbols::DkmSourcePosition* const m_pSourcePosition;
        private: void* m__pExtendedData;

        // High level breakpoint object which is tied to a user-level construct (ex: source
        // file, function name) which may map to zero or more code-level constructs
        // (DkmBoundBreakpoint) and which may be tracked over time.
        public: _Ret_ DECLSPEC_NOTHROW Breakpoints::DkmPendingBreakpoint* STDMETHODCALLTYPE PendingBreakpoint(
            );

        // Guid which uniquely identifies this bound breakpoint object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] The low-level runtime breakpoint which backs this high-level bound
        // breakpoint.
        public: _Ret_opt_ DECLSPEC_NOTHROW Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE Target(
            );

        // [Optional] An optional reference to the document and text position this breakpoint
        // bound to. This should be set unless the bound location does not have source
        // information.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSourcePosition* STDMETHODCALLTYPE SourcePosition(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that
        // the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to
        // indicate that the breakpoint should bind against all languages. 'VendorId' is
        // nearly always left as Guid.Empty, which indicates that only the language is known
        // (not the compiler).
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Closes the bound breakpoint. This is done by breakpoint manager.
        //
        // DkmBoundBreakpoint objects are automatically closed when their associated
        // DkmPendingBreakpoint object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Called by a breakpoint manager to create a DkmBoundBreakpoint object for each
        // location that a DkmPendingBreakpoint binds to.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // pTarget         : [In,Optional] The low-level runtime breakpoint which backs this
        // high-level bound breakpoint.
        // pSourcePosition : [In,Optional] An optional reference to the document and text
        // position this breakpoint bound to. This should be set unless the bound location
        // does not have source information.
        // DataItem        : [In] Data object to add to the new DkmBoundBreakpoint instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_opt_ Breakpoints::DkmRuntimeBreakpoint* pTarget,
            _In_opt_ Symbols::DkmSourcePosition* pSourcePosition,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmBoundBreakpoint** ppCreatedObject
            );

        // Raise a BoundBreakpointHit event. Components which implement the event sync
        // interface will receive the event notification. This method will enqueue the event
        // and control will immediately return to the caller.
        //
        // This method may only be called by the component which created the object.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the thread which hit the breakpoint. Currently,
        // only managed runtime instances ever set this. This is used to quickly determine if
        // exception specific logic should apply without making another network round-trip.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnHit(
            _In_ DkmThread* pThread,
            _In_ bool HasException
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Enables the bound breakpoint so that it can be hit. If the bound breakpoint is
        // already enabled, this operation has no effect.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnableBoundBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Disable the bound breakpoint so that it will no longer hit. If the bound
        // breakpoint is already disabled, this operation has no effect.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisableBoundBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Query to determine if the bound breakpoint is enabled.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pResult         : [Out] 'true' if the breakpoint is enabled.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsEnabled(
            _Out_ bool* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Initialize or update or clear the condition on a breakpoint.  If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCondition(
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Initialize, update or clear the hit count condition on a breakpoint. If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Modifies the value for a breakpoint hit count.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // NewValue        : [In] New value for the hit count.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountValue(
            _In_ UINT32 NewValue
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns the number of times that a bound breakpoint has been hit. This value
        // should not include any times when the breakpoint's instruction was executed, but
        // the breakpoint's condition indicated that the debugger should not stop.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHitCountValue(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmBoundBreakpoint

    // Conditions under which a breakpoint should fire.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6f47e50b-85ef-ba6d-e36a-8121fa195bb2") DkmBreakpointCondition : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmBreakpointCondition::Create to create this object
        private: DkmBreakpointCondition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBreakpointCondition();
        // This object cannot be copied
        private: DkmBreakpointCondition& operator=(const DkmBreakpointCondition&);
        private: DkmBreakpointCondition(const DkmBreakpointCondition&);

        private: const Breakpoints::DkmBreakpointConditionOperator::e m_Operator;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: const Evaluation::DkmEvaluationFlags::e m_CompilationFlags;
        private: DkmString* const m_pText;
        private: const UINT32 m_Timeout;
        private: void* m__pExtendedData;

        // Indicates how the breakpoint text should be used ('BreakWhenTrue' or
        // 'BreakWhenChanged').
        public: DECLSPEC_NOTHROW Breakpoints::DkmBreakpointConditionOperator::e STDMETHODCALLTYPE Operator(
            );

        // Language of the breakpoint condition. May be Guid.Empty/Guid.Empty to indicate
        // that the language of the stack frame should be used. If present, the vendor id
        // must be defined.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // Flags which effect how the condition text should be compiled by the expression
        // evaluator.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationFlags::e STDMETHODCALLTYPE CompilationFlags(
            );

        // Source text of the parsed expression.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Text(
            );

        // This is the timeout to be used for potentially slow operations such as a function
        // evaluation. This value is in milliseconds.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Timeout(
            );

        // Create a new DkmBreakpointCondition object instance.
        // Operator        : [In] Indicates how the breakpoint text should be used
        // ('BreakWhenTrue' or 'BreakWhenChanged').
        // CompilerId      : [In] Language of the breakpoint condition. May be
        // Guid.Empty/Guid.Empty to indicate that the language of the stack frame should be
        // used. If present, the vendor id must be defined.
        // CompilationFlags: [In] Flags which effect how the condition text should be
        // compiled by the expression evaluator.
        // pText           : [In] Source text of the parsed expression.
        // Timeout         : [In] This is the timeout to be used for potentially slow
        // operations such as a function evaluation. This value is in milliseconds.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmBreakpointConditionOperator::e Operator,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_ Evaluation::DkmEvaluationFlags::e CompilationFlags,
            _In_ DkmString* pText,
            _In_ UINT32 Timeout,
            _Deref_out_ Breakpoints::DkmBreakpointCondition** ppCreatedObject
            );
    }; // end of DkmBreakpointCondition

    // Indicates how the breakpoint text should be used ('BreakWhenTrue' or
    // 'BreakWhenChanged').
    enum DkmBreakpointConditionOperator::e
    {
        // Breakpoint should fire when the expression evaluates to Boolean 'true'.
        BreakWhenTrue = 0,
        // Breakpoint should fire when the value of the input expression changes.
        BreakWhenChanged = 1
    };

    // Object used to send file update notifications to breakpoint managers.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2dde565b-c382-7dbb-2841-647a7322b64e") DkmBreakpointFileUpdateNotification : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmBreakpointFileUpdateNotification::Create to create this object
        private: DkmBreakpointFileUpdateNotification();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBreakpointFileUpdateNotification();
        // This object cannot be copied
        private: DkmBreakpointFileUpdateNotification& operator=(const DkmBreakpointFileUpdateNotification&);
        private: DkmBreakpointFileUpdateNotification(const DkmBreakpointFileUpdateNotification&);

        private: DkmReadOnlyCollection<DkmString*>* const m_pFilePaths;
        private: void* m__pExtendedData;

        // File path to the various files which have been updated.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE FilePaths(
            );

        // Create a new DkmBreakpointFileUpdateNotification object instance.
        // pFilePaths      : [In] File path to the various files which have been updated.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<DkmString*>* pFilePaths,
            _Deref_out_ Breakpoints::DkmBreakpointFileUpdateNotification** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Provides notification that one or more files containing breakpoints have been
        // updated.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Send(
            _In_ DkmWorkList* pWorkList
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmBreakpointFileUpdateNotification

    // Values of the breakpoints hit count which should cause the breakpoint to fire.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2a0d19d5-b8ad-6fbe-5dec-a918f083ca4b") DkmBreakpointHitCountCondition : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmBreakpointHitCountCondition::Create to create this object
        private: DkmBreakpointHitCountCondition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBreakpointHitCountCondition();
        // This object cannot be copied
        private: DkmBreakpointHitCountCondition& operator=(const DkmBreakpointHitCountCondition&);
        private: DkmBreakpointHitCountCondition(const DkmBreakpointHitCountCondition&);

        private: const Breakpoints::DkmBreakpointHitCountConditionOperator::e m_Operator;
        private: const UINT32 m_Operand;
        private: void* m__pExtendedData;

        // Operator to use between the current hit count and the condition operand to decide
        // if the hit count condition has been satisfied.
        public: DECLSPEC_NOTHROW Breakpoints::DkmBreakpointHitCountConditionOperator::e STDMETHODCALLTYPE Operator(
            );

        // Value to apply against the current hit when evaluating this condition.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Operand(
            );

        // Create a new DkmBreakpointHitCountCondition object instance.
        // Operator        : [In] Operator to use between the current hit count and the
        // condition operand to decide if the hit count condition has been satisfied.
        // Operand         : [In] Value to apply against the current hit when evaluating this
        // condition.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmBreakpointHitCountConditionOperator::e Operator,
            _In_ UINT32 Operand,
            _Deref_out_ Breakpoints::DkmBreakpointHitCountCondition** ppCreatedObject
            );
    }; // end of DkmBreakpointHitCountCondition

    // Operator to use between the current hit count and the condition operand to decide if
    // the hit count condition has been satisfied.
    enum DkmBreakpointHitCountConditionOperator::e
    {
        // Break when 'CurrentHitCount == Operand'.
        Equal = 0,
        // Break when 'CurrentHitCount >= Operand'.
        EqualOrGreater = 1,
        // Break when 'CurrentHitCount % Operand == 0'.
        Modulo = 2
    };

    // Describes the severity of a message sent from a breakpoint manager back to the source
    // component. This list is sorted in order of priority, as the UI will only display the
    // most important warning. All warnings are ignored if the breakpoint is bound.
    enum DkmBreakpointMessageLevel::e
    {
        // This is the message level for the least significant breakpoint warnings. This
        // level is used for catch-all messages such as the 'The specified module has not
        // been loaded' message. This is equivalent to BPET_SEV_LOW in AD7.
        WarningLevel1 = 0,
        // This is the message level reserved for 3rd party components that wish to provide
        // their own catch-all errors. Warning levels go from 1 to 16 and in order of
        // increasing severity (1 = Lowest, 15 = Highest).
        WarningLevel2 = 1,
        // Level 3 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel3 = 2,
        // Level 4 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel4 = 3,
        // Level 5 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel5 = 4,
        // Level 6 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel6 = 5,
        // Level 7 warning. This is equivalent to BPET_SEV_GENERAL in AD7. Warning levels go
        // from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).
        WarningLevel7 = 6,
        // Level 8 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel8 = 7,
        // Level 9 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel9 = 8,
        // Level 10 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel10 = 9,
        // Level 11 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel11 = 10,
        // Level 12 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel12 = 11,
        // Level 13 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel13 = 12,
        // Level 14 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel14 = 13,
        // Highest warning level. This is equivalent to BPET_SEV_HIGH in AD7. Warning levels
        // go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).
        WarningLevel15 = 14,
        // Lowest level breakpoint error.
        LowError = 15,
        // Typical level for errors binding breakpoints.
        StandardError = 16,
        // Highest level breakpoint error.
        HighestError = 17
    };

    // Describes the reason for a breakpoint to be unbound.
    enum DkmBreakpointUnboundReason::e
    {
        // Breakpoint is being unbound because the target code element has been unloaded.
        CodeUnload = 0,
        // Breakpoint is being unbound because it is being rebound to a different location.
        // (For example, this can happen after an ENC when the breakpoint moves, or if this
        // breakpoint was originally bound with a less than perfect file name match.)
        // Generally, the IDE will discard any persisted information about this breakpoint.
        Rebind = 1
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.ClearConditions call.
    struct DkmClearRuntimeBreakpointConditionsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.ClearHitCountCondition call.
    struct DkmClearRuntimeBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Number of times that the breakpoint has been hit as of the time that the condition
        // was removed.
        UINT32 CurrentHitCount;
    };

    // Mask of reasons why the data breakpoint should fire. For example, if 'Write' is set,
    // then the breakpoint will fire when the memory location is written.
    enum DkmDataAccessStopMask::e
    {
        // Stop when the CPU writes to the specified address.
        Write = 0x1,
        // Stop when the CPU reads or writes to the specified address.
        ReadWrite = 0x2,
        // Stop when the CPU tries to execute an instruction at the specified address.
        Execute = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmDataAccessStopMask::e);

    // Result of an asynchronous DkmBoundBreakpoint.Disable call.
    struct DkmDisableBoundBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.Disable call.
    struct DkmDisablePendingBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.Disable call.
    struct DkmDisableRuntimeBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmBoundBreakpoint.Enable call.
    struct DkmEnableBoundBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.Enable call.
    struct DkmEnablePendingBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.Enable call.
    struct DkmEnableRuntimeBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_BP_MODULE_UNLOADED indicates that the
        // module instance specified by the breakpoint is no longer loaded.
        // E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        // specified script document.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.Enroll call.
    struct DkmEnrollPendingBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Result of an asynchronous DkmRuntimeBreakpoint.EvaluateConditionAndSelectThread call.
    struct DkmEvaluateConditionAndSelectThreadAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] The thread whose condition is true. The value is null in the case that
        // no thread is found to have a true condition.
        OPTIONAL DkmThread* pConditionMetThread;
    };
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a condition which is evaluated on the target computer. These objects are
    // used for languages where the expression evaluator is implemented on the target.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d838eb1d-9ec7-751c-1896-5057bf597376") DkmEvaluationBreakpointCondition : public DkmDataContainer
    {
        // Use DkmEvaluationBreakpointCondition::Create to create this object
        private: DkmEvaluationBreakpointCondition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEvaluationBreakpointCondition();
        // This object cannot be copied
        private: DkmEvaluationBreakpointCondition& operator=(const DkmEvaluationBreakpointCondition&);
        private: DkmEvaluationBreakpointCondition(const DkmEvaluationBreakpointCondition&);

        private: Breakpoints::DkmRuntimeBreakpoint* const m_pRuntimeBreakpoint;
        private: Breakpoints::DkmBreakpointCondition* const m_pSource;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Runtime breakpoint that this condition is used on.
        public: _Ret_ DECLSPEC_NOTHROW Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE RuntimeBreakpoint(
            );

        // The breakpoint condition which is evaluated.
        public: _Ret_ DECLSPEC_NOTHROW Breakpoints::DkmBreakpointCondition* STDMETHODCALLTYPE Source(
            );

        // Language used to parse the condition.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Guid which uniquely identifies this condition object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes a DkmEvaluationBreakpointCondition object instance. This will release any
        // resources associated with this object across all components. This includes
        // resources across computer or managed/native marshalling boundaries.
        //
        // DkmEvaluationBreakpointCondition objects are automatically closed when their
        // associated DkmRuntimeBreakpoint object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmEvaluationBreakpointCondition object instance. The caller is
        // responsible for closing the created object after they are done.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pRuntimeBreakpoint: [In] Runtime breakpoint that this condition is used on.
        // pSource         : [In] The breakpoint condition which is evaluated.
        // pLanguage       : [In] Language used to parse the condition.
        // DataItem        : [In] Data object to add to the new
        // DkmEvaluationBreakpointCondition instance. DkmDataItem::Null() in the case that
        // the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointCondition* pSource,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmEvaluationBreakpointCondition** ppCreatedObject
            );

        // Parses an input breakpoint condition so that it can later be evaluated. If the
        // breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the
        // expression evaluator should require that the specified condition evaluates to a
        // Boolean value. The created query must return only a single result. For
        // BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any
        // non-zero value is considered true.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppErrorText     : [Out,Optional] If the condition could not be parsed, this
        // indicates the reason why. This value should be null if the compile succeeded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Parse(
            _Deref_out_opt_ DkmString** ppErrorText
            );

        // Evaluates a condition to decide if the debugger should stop.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pStackFrame     : [In] The stack frame to use when evaluating the condition.
        // pStop           : [Out] True if the breakpoint condition indicated that the IDE
        // should stop.
        // ppErrorText     : [Out,Optional] If the condition could not be evaluated, this
        // indicates the reason why. This value should be null if the compile succeeded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Evaluate(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ bool* pStop,
            _Deref_out_opt_ DkmString** ppErrorText
            );
    }; // end of DkmEvaluationBreakpointCondition
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous DkmBoundBreakpoint.GetHitCountValue call.
    struct DkmGetBoundBreakpointHitCountValueAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Number of times that the breakpoint has been hit.
        UINT32 CurrentHitCount;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.GetHitCountConditionStatus call.
    struct DkmGetRuntimeBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Number of times that the breakpoint has been hit.
        UINT32 CurrentHitCount;
    };

    // High level breakpoint object which is tied to a user-level construct (ex: source file,
    // function name) which may map to zero or more code-level constructs
    // (DkmBoundBreakpoint) and which may be tracked over time.
    //
    // Derived classes: DkmPendingAddressBreakpoint, DkmPendingAddressNameBreakpoint,
    // DkmPendingDataBreakpoint, DkmPendingFileLineBreakpoint, DkmPendingFunctionBreakpoint
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c9e1ffa4-f943-14bc-5566-00a802dfc66f") DkmPendingBreakpoint : public DkmDataContainer
    {
        // Use DkmPendingBreakpoint::Create to create this object
        private: DkmPendingBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingBreakpoint();
        // This object cannot be copied
        private: DkmPendingBreakpoint& operator=(const DkmPendingBreakpoint&);
        private: DkmPendingBreakpoint(const DkmPendingBreakpoint&);

        // DkmPendingBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmPendingFileLineBreakpoint'.
        FileLineBreakpoint = 0,
        // Object is an instance of 'DkmPendingFunctionBreakpoint'.
        FunctionBreakpoint = 1,
        // Object is an instance of 'DkmPendingAddressBreakpoint'.
        AddressBreakpoint = 2,
        // Object is an instance of 'DkmPendingAddressNameBreakpoint'.
        AddressNameBreakpoint = 3,
        // Object is an instance of 'DkmPendingDataBreakpoint'.
        DataBreakpoint = 4
        }; };

        private: const Tag::e m_TagValue;
        private: DkmProcess* const m_pProcess;
        private: const GUID m_UniqueId;
        private: const GUID m_SourceId;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: OPTIONAL DkmThread* const m_pThread;
        private: const bool m_IsBarrier;
        private: void* m__pExtendedData;
        private: void* m_pBoundBreakpointCollection0;

        // DkmPendingBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Guid which uniquely identifies this pending breakpoint object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that
        // the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to
        // indicate that the breakpoint should bind against all languages. 'VendorId' is
        // nearly always left as Guid.Empty, which indicates that only the language is known
        // (not the compiler).
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // [Optional] Thread on which this breakpoint should fire. If null, the breakpoint
        // will fire on all threads.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Indicates if this breakpoint is a barrier that should be set on the hardware, this
        // works for GPU debugging.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsBarrier(
            );

        // Closes a DkmPendingBreakpoint object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmPendingBreakpoint objects are automatically closed when their associated
        // DkmProcess object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // GetBoundBreakpoints enumerates the DkmBoundBreakpoint elements of this
        // DkmPendingBreakpoint object.
        // pBoundBreakpoints: [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetBoundBreakpoints(
            _Out_ DkmArray<Breakpoints::DkmBoundBreakpoint*>* pBoundBreakpoints
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Sets the state of the pending breakpoint so that instances of the breakpoint that
        // bind in the future will get hit. If the pending breakpoint is not yet enrolled,
        // then this method will also enroll the breakpoint. Enrolling a pending breakpoint
        // consists of attempting to resolve the breakpoint against any modules which are
        // currently loaded and adding the breakpoint to the list of breakpoints which the
        // breakpoint manager will bind on any module load. If the pending breakpoint is
        // already enrolled, existing bound breakpoints will not automatically get enabled.
        // Bound breakpoints must get enabled separately.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnablePendingBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Disable the pending breakpoint object so that it will no longer fire. If the
        // pending breakpoint is already bound, any bound breakpoints will be implicitly
        // disabled.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisablePendingBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // This method will enroll the pending breakpoint without enabling it. The result is
        // a breakpoint which the breakpoint manager will attempt to resolve, but which will
        // not fire. Enrolling a pending breakpoint consists of attempting to resolve the
        // breakpoint against any modules which are currently loaded and adding the
        // breakpoint to the list of breakpoints which the breakpoint manager will bind on
        // any module load.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enroll(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnrollPendingBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Initialize, update or clear the language-level condition on all bound breakpoints
        // of this condition breakpoint.  If the same breakpoint has both a language-level
        // condition, and a hit count condition, the language-level condition is applied
        // first.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCondition(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Initialize, update or clear the hit count condition on all bound breakpoints of
        // this pending breakpoint. If the same breakpoint has both a language-level
        // condition, and a hit count condition, the language-level condition is applied
        // first.
        //
        // Note that the hit count condition acts independently on each bound breakpoint,
        // rather than being aggregated together on the pending breakpoint. For example, if
        // the hit count is configured to stop at hit #2, and the breakpoint to two separate
        // locations, each of which hit the breakpoint once, the UI will still not have gone
        // into break mode because neither individual bound breakpoint has hit twice.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Notification from the breakpoint manager when a breakpoint has been bound. In the
        // case of user-set breakpoints, this notification will be sent to the AD7 AL, and
        // the AD7 AL will fire a IDebugBreakpointBoundEvent2 to the Visual Studio Debugger
        // UI.
        // BoundBreakpoints: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointBound(
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints
            );

        // Notification from the breakpoint manager which indicates that the given breakpoint
        // is being unbound.
        // BoundBreakpoints: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Reason          : [In] Describes the reason for a breakpoint to be unbound.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointUnbound(
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints,
            _In_ Breakpoints::DkmBreakpointUnboundReason::e Reason
            );

        // Notification from the breakpoint manager concerning the status of binding the
        // breakpoint.
        // Level           : [In] Describes the severity of a message sent from a breakpoint
        // manager back to the source component. This list is sorted in order of priority, as
        // the UI will only display the most important warning. All warnings are ignored if
        // the breakpoint is bound.
        // pMessage        : [In] Message string to display to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointMessage(
            _In_ Breakpoints::DkmBreakpointMessageLevel::e Level,
            _In_ DkmString* pMessage
            );
    }; // end of DkmPendingBreakpoint

    // Result of an asynchronous DkmRuntimeBreakpoint.RequestBreakpointEventOnModifiedThread
    // call.
    struct DkmRequestBreakpointEventOnModifiedThreadAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Low-level breakpoint object which is supported by debug monitors.
    //
    // Derived classes: DkmRuntimeHardwareDataBreakpoint, DkmRuntimeInstructionBreakpoint
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c4815219-c5fd-3e96-9b86-fd6a36eef464") DkmRuntimeBreakpoint : public DkmDataContainer
    {
        // Use DkmRuntimeBreakpoint::Create to create this object
        private: DkmRuntimeBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeBreakpoint();
        // This object cannot be copied
        private: DkmRuntimeBreakpoint& operator=(const DkmRuntimeBreakpoint&);
        private: DkmRuntimeBreakpoint(const DkmRuntimeBreakpoint&);

        // DkmRuntimeBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmRuntimeInstructionBreakpoint'.
        InstructionBreakpoint = 0,
        // Object is an instance of 'DkmRuntimeHardwareDataBreakpoint'.
        NativeDataBreakpoint = 1
        }; };

        private: const Tag::e m_TagValue;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_UniqueId;
        private: const GUID m_SourceId;
        private: OPTIONAL DkmThread* const m_pThread;
        private: void* m__pExtendedData;
        private: void* m_pEvaluationConditionCollection0;

        // DkmRuntimeBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Guid which uniquely identifies this pending breakpoint object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // [Optional] Thread on which this breakpoint should fire. If null, the breakpoint
        // will fire on all threads.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Closes the breakpoint object instance. This will release any resources associated
        // with this object across all components. If the breakpoint is currently enabled, it
        // will be implicitly disabled.
        //
        // DkmRuntimeBreakpoint objects are automatically closed when their associated
        // DkmRuntimeInstance object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // This method is similar to SetCompiledCondition, but is used in cases where the
        // instruction address is not known up front, such as data breakpoints. In these
        // cases, when the breakpoint is first hit at a particular address, a call will be
        // made to the breakpoint client to obtain a new compiled condition for this address
        // (IDkmBreakpointConditionProcessorClient.GetCompiledCondition).  This is used for
        // languages which are evaluated in the IDE process (ex: C++).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledConditionPending(
            );

        // This method is similar to SetCompiledCondition, but is used in cases where the
        // instruction address is not known up front, such as data breakpoints. In these
        // cases, when the breakpoint is first hit at a particular address, a call will be
        // made to the breakpoint client to obtain a new compiled condition for this address
        // (IDkmBreakpointConditionProcessorClient.GetCompiledCondition).  This is used for
        // languages which are evaluated in the IDE process (ex: C++).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledConditionPending(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetCompiledConditionPendingAsyncResult>* pCompletionRoutine
            );

        // Sets a breakpoint condition which is evaluated on the target computer. This is
        // used for .NET languages.
        // pCondition      : [In] Conditions under which a breakpoint should fire.
        // ppErrorText     : [Out,Optional] If the condition could not be parsed, this
        // indicates the reason why. This value should be null if the compile succeeded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetEvaluationCondition(
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            );

        // Sets a breakpoint condition which is evaluated on the target computer. This is
        // used for .NET languages.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCondition      : [In] Conditions under which a breakpoint should fire.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetEvaluationCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetEvaluationConditionAsyncResult>* pCompletionRoutine
            );

        // Clear any compiled/evaluation condition associated with the specified
        // DkmRuntimeBreakpoint. This method is implicitly called when the
        // DkmRuntimeBreakpoint is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearConditions(
            );

        // Clear any compiled/evaluation condition associated with the specified
        // DkmRuntimeBreakpoint. This method is implicitly called when the
        // DkmRuntimeBreakpoint is closed.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearConditions(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmClearRuntimeBreakpointConditionsAsyncResult>* pCompletionRoutine
            );

        // Initialize or update the hit count condition/value on a breakpoint. If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first. The condition is implicitly removed if
        // the DkmRuntimeBreakpoint is closed.
        // pCondition      : [In] Condition to apply to this breakpoint.
        // HitCountValue   : [In] The initial value of the breakpoint's hit count. A value of
        // -1/MAXDWORD indicates that the current hit count value should be preserved.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ UINT32 HitCountValue
            );

        // Initialize or update the hit count condition/value on a breakpoint. If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first. The condition is implicitly removed if
        // the DkmRuntimeBreakpoint is closed.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCondition      : [In] Condition to apply to this breakpoint.
        // HitCountValue   : [In] The initial value of the breakpoint's hit count. A value of
        // -1/MAXDWORD indicates that the current hit count value should be preserved.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ UINT32 HitCountValue,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );

        // Clears the hit count condition on a breakpoint.
        // pCondition      : [In] Condition to apply to this breakpoint.
        // pCurrentHitCount: [Out] Number of times that the breakpoint has been hit as of the
        // time that the condition was removed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearHitCountCondition(
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _Out_ UINT32* pCurrentHitCount
            );

        // Clears the hit count condition on a breakpoint.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCondition      : [In] Condition to apply to this breakpoint.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearHitCountCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmClearRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );

        // Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit
        // count condition. This function will fail if the DkmRuntimeBreakpoint does not
        // currently have a hit count condition.
        // pCurrentHitCount: [Out] Number of times that the breakpoint has been hit.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHitCountConditionStatus(
            _Out_ UINT32* pCurrentHitCount
            );

        // Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit
        // count condition. This function will fail if the DkmRuntimeBreakpoint does not
        // currently have a hit count condition.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHitCountConditionStatus(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmGetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Call back invoked from the breakpoint condition processor to the breakpoint
        // manager (or other component which calls SetCompiledConditionPending) when the
        // breakpoint condition needs to be re-compiled for a new instruction address.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pInstructionAddress: [In] The instruction address to compile the condition
        // against.
        // pConditionOperator: [Out] Operator to use when evaluating the condition.
        // ppCompiledCondition: [Out,Optional] The compiled condition to be used for the
        // specified instruction address. This value is null in the case that the condition
        // failed to compile. In this case, the condition processor should stop on the
        // breakpoint.
        // Return value    : S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is
        // returned when *ppCompiledCondition is NULL, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCompiledCondition(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _Out_ Breakpoints::DkmBreakpointConditionOperator::e* pConditionOperator,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Call back invoked from the breakpoint condition processor to the breakpoint
        // manager when a breakpoint condition encounters a runtime error.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pErrorMessage   : [In] The message to display to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointConditionFailed(
            _In_ DkmString* pErrorMessage
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // The breakpoint condition processor decides not to break on the given thread but
        // another thread of the same warp, so the breakpoint condition processor instructs
        // the base debug monitor to re-send the breakpoint event on the other thread.
        // pModifiedBreakThread: [In] The base debug monitor should re-send breakpoint event
        // on this thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RequestBreakpointEventOnModifiedThread(
            _In_ DkmThread* pModifiedBreakThread
            );

        // The breakpoint condition processor decides not to break on the given thread but
        // another thread of the same warp, so the breakpoint condition processor instructs
        // the base debug monitor to re-send the breakpoint event on the other thread.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pModifiedBreakThread: [In] The base debug monitor should re-send breakpoint event
        // on this thread.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RequestBreakpointEventOnModifiedThread(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pModifiedBreakThread,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmRequestBreakpointEventOnModifiedThreadAsyncResult>* pCompletionRoutine
            );

        // Enables a breakpoint. Breakpoints start off initially disabled, so this method
        // must be called before the breakpoint can be set. Enabling a breakpoint is
        // typically implemented in the debug monitor by modifying the state of the target
        // process. For example inserting an 'int3' instruction into the code stream. If the
        // breakpoint is already enabled, this operation has no effect.
        //
        // Once a breakpoint has been enabled, the debug monitor will raise a
        // RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger
        // condition (ex: target instruction is executed) is met. Multiple
        // DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug
        // monitor will raise a different RuntimeBreakpoint event for each breakpoint object.
        // Similarly, if a step complete and a breakpoint both complete on the same
        // instruction, the debug monitor will raise both events.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        // breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        // not currently loaded in the specified script document.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            );

        // Enables a breakpoint. Breakpoints start off initially disabled, so this method
        // must be called before the breakpoint can be set. Enabling a breakpoint is
        // typically implemented in the debug monitor by modifying the state of the target
        // process. For example inserting an 'int3' instruction into the code stream. If the
        // breakpoint is already enabled, this operation has no effect.
        //
        // Once a breakpoint has been enabled, the debug monitor will raise a
        // RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger
        // condition (ex: target instruction is executed) is met. Multiple
        // DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug
        // monitor will raise a different RuntimeBreakpoint event for each breakpoint object.
        // Similarly, if a step complete and a breakpoint both complete on the same
        // instruction, the debug monitor will raise both events.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // This method may only be called by the component which created the object.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnableRuntimeBreakpointAsyncResult>* pCompletionRoutine
            );

        // Determines if the given DkmRuntimeBreakpoint could be enabled. This is used from
        // within the breakpoints dialog to validate breakpoints before the dialog is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        // breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        // not currently loaded in the specified script document.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Test(
            );

        // Determines if the given DkmRuntimeBreakpoint could be enabled. This is used from
        // within the breakpoints dialog to validate breakpoints before the dialog is closed.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Test(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmTestRuntimeBreakpointAsyncResult>* pCompletionRoutine
            );

        // Disables a breakpoint. Disabling a breakpoint is typically implemented by
        // modifying the state of the target process so the breakpoint will no longer fire.
        // For example, removing a previously inserted 'int3' from the instruction stream. If
        // the breakpoint is already disabled, this operation has no effect. In addition to
        // this method, a breakpoint is implicitly disabled when it is closed.
        //
        // If multiple breakpoints are set on the same instruction, disabling one breakpoint
        // does not affect the other breakpoints set on this instruction.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            );

        // Disables a breakpoint. Disabling a breakpoint is typically implemented by
        // modifying the state of the target process so the breakpoint will no longer fire.
        // For example, removing a previously inserted 'int3' from the instruction stream. If
        // the breakpoint is already disabled, this operation has no effect. In addition to
        // this method, a breakpoint is implicitly disabled when it is closed.
        //
        // If multiple breakpoints are set on the same instruction, disabling one breakpoint
        // does not affect the other breakpoints set on this instruction.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // This method may only be called by the component which created the object.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisableRuntimeBreakpointAsyncResult>* pCompletionRoutine
            );

        // Raise a RuntimeBreakpoint event. Components which implement the event sync
        // interface will receive the event notification. This method will enqueue the event
        // and control will immediately return to the caller.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the thread which hit the breakpoint. Currently,
        // only managed runtime instances ever set this. This is used to quickly determine if
        // exception specific logic should apply without making another network round-trip.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnHit(
            _In_ DkmThread* pThread,
            _In_ bool HasException
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // The base debug monitor asks the breakpoint condition processor to evaluate on all
        // stopped threads, and selects the thread whose condition is true.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        // pFirstStoppedThread: [In] The first stopped thread.
        // ppConditionMetThread: [Out,Optional] The thread whose condition is true. The value
        // is null in the case that no thread is found to have a true condition.
        // Return value    : S_OK is returned if *ppConditionMetThread is non-NULL, S_FALSE
        // is returned when *ppConditionMetThread is NULL, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateConditionAndSelectThread(
            _In_ DkmThread* pFirstStoppedThread,
            _Deref_out_opt_ DkmThread** ppConditionMetThread
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // The base debug monitor asks the breakpoint condition processor to evaluate on all
        // stopped threads, and selects the thread whose condition is true.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        // pWorkList       : WorkList to append the new work item to.
        // pFirstStoppedThread: [In] The first stopped thread.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateConditionAndSelectThread(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pFirstStoppedThread,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEvaluateConditionAndSelectThreadAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmRuntimeBreakpoint

    // Result of an asynchronous DkmRuntimeInstructionBreakpoint.SetCompiledCondition call.
    struct DkmSetCompiledConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.SetCompiledConditionPending call.
    struct DkmSetCompiledConditionPendingAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.SetEvaluationCondition call.
    struct DkmSetEvaluationConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] If the condition could not be parsed, this indicates the reason why.
        // This value should be null if the compile succeeded.
        OPTIONAL DkmString* pErrorText;
    };

    // Result of an asynchronous DkmPendingBreakpoint.SetCondition call.
    struct DkmSetPendingBreakpointConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.SetHitCountCondition call.
    struct DkmSetPendingBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.SetHitCountCondition call.
    struct DkmSetRuntimeBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.Test call.
    struct DkmTestRuntimeBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_BP_MODULE_UNLOADED indicates that the
        // module instance specified by the breakpoint is no longer loaded.
        // E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        // specified script document.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous
    // DkmRuntimeInstructionBreakpoint.TryClearConditionOnTargetDevice call.
    struct DkmTryClearConditionOnTargetDeviceAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous
    // DkmRuntimeInstructionBreakpoint.TryPushConditionToTargetDevice call.
    struct DkmTryPushConditionToTargetDeviceAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Pending breakpoint which is requested to bind against a particular instruction
    // address. Within the IDE, these breakpoints are set from the call stack window,
    // disassembly window, or by entering a hex address into the function breakpoint dialog.
    // Because the DkmInstructionAddress is given as input, these breakpoints can support
    // Runtimes which cannot persist their addresses to a string (ex: an interpreter).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5e4de51b-8d82-5d38-8041-3a42c18d3f47") DkmPendingAddressBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingAddressBreakpoint::Create to create this object
        private: DkmPendingAddressBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingAddressBreakpoint();
        // This object cannot be copied
        private: DkmPendingAddressBreakpoint& operator=(const DkmPendingAddressBreakpoint&);
        private: DkmPendingAddressBreakpoint(const DkmPendingAddressBreakpoint&);

        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: void* m__pExtendedData;

        // Abstract representation of an executable code location (ex: EIP value). If the
        // instruction address is unresolved (DkmUnknownInstructionAddress) and contains a
        // CPU instruction, the breakpoint manager will attempt to bind the instruction if a
        // module within that range loads.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingAddressBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingAddressBreakpoint'.
        // pAddressBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingAddressBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::AddressBreakpoint)
                return NULL;

            return static_cast<DkmPendingAddressBreakpoint*>(pPendingBreakpoint);
        }

        // Creates a new pending breakpoint object. After creation, the returned object will
        // still be disabled and will not be tracked by the breakpoint manager. To complete
        // initialization, the caller should set additional properties on the breakpoint and
        // 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        // after they are done.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // CompilerId      : [In] Identifies the source language (ex: C#) and compiler vendor
        // (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left
        // as Guid.Empty to indicate that the breakpoint should bind against all languages.
        // 'VendorId' is nearly always left as Guid.Empty, which indicates that only the
        // language is known (not the compiler).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // IsBarrier       : [In] Indicates if this breakpoint is a barrier that should be
        // set on the hardware, this works for GPU debugging.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If the instruction address is unresolved
        // (DkmUnknownInstructionAddress) and contains a CPU instruction, the breakpoint
        // manager will attempt to bind the instruction if a module within that range loads.
        // DataItem        : [In] Data object to add to the new DkmPendingAddressBreakpoint
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingAddressBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingAddressBreakpoint

    // Pending breakpoint which is requested to bind against the code element at a specific
    // instruction address string. Within the IDE, these breakpoints are created when the
    // user sets a breakpoint in the call stack or disassembly window, and then the debugger
    // is asked to rebind the breakpoint in another debug session or in another process
    // within the same debug session.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("243712b0-a935-6c92-7fc4-6ffb461126ac") DkmPendingAddressNameBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingAddressNameBreakpoint::Create to create this object
        private: DkmPendingAddressNameBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingAddressNameBreakpoint();
        // This object cannot be copied
        private: DkmPendingAddressNameBreakpoint& operator=(const DkmPendingAddressNameBreakpoint&);
        private: DkmPendingAddressNameBreakpoint(const DkmPendingAddressNameBreakpoint&);

        private: DkmString* const m_pModuleName;
        private: DkmString* const m_pAddressName;
        private: OPTIONAL DkmString* const m_pFunctionName;
        private: void* m__pExtendedData;

        // Name of the module to search for the breakpoint.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // String representation of the address to bind to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AddressName(
            );

        // [Optional] Name of the function which contains the address.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingAddressNameBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingAddressNameBreakpoint'.
        // pAddressNameBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingAddressNameBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::AddressNameBreakpoint)
                return NULL;

            return static_cast<DkmPendingAddressNameBreakpoint*>(pPendingBreakpoint);
        }

        // Creates a new pending breakpoint object. After creation, the returned object will
        // still be disabled and will not be tracked by the breakpoint manager. To complete
        // initialization, the caller should set additional properties on the breakpoint and
        // 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        // after they are done.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // CompilerId      : [In] Identifies the source language (ex: C#) and compiler vendor
        // (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left
        // as Guid.Empty to indicate that the breakpoint should bind against all languages.
        // 'VendorId' is nearly always left as Guid.Empty, which indicates that only the
        // language is known (not the compiler).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // IsBarrier       : [In] Indicates if this breakpoint is a barrier that should be
        // set on the hardware, this works for GPU debugging.
        // pModuleName     : [In] Name of the module to search for the breakpoint.
        // pAddressName    : [In] String representation of the address to bind to.
        // pFunctionName   : [In,Optional] Name of the function which contains the address.
        // DataItem        : [In] Data object to add to the new
        // DkmPendingAddressNameBreakpoint instance. DkmDataItem::Null() in the case that the
        // caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ DkmString* pModuleName,
            _In_ DkmString* pAddressName,
            _In_opt_ DkmString* pFunctionName,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingAddressNameBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingAddressNameBreakpoint

    // Pending breakpoint which is tied to a data expression instead of a code expression.
    // Data breakpoints fire when the specified element is written to.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("afd7a281-dbf3-946b-9464-8ca12287616b") DkmPendingDataBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingDataBreakpoint::Create to create this object
        private: DkmPendingDataBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingDataBreakpoint();
        // This object cannot be copied
        private: DkmPendingDataBreakpoint& operator=(const DkmPendingDataBreakpoint&);
        private: DkmPendingDataBreakpoint(const DkmPendingDataBreakpoint&);

        private: DkmString* const m_pDataElementLocation;
        private: const UINT32 m_Size;
        private: void* m__pExtendedData;

        // Indicates the location of the data value to watch.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DataElementLocation(
            );

        // Specifies the size of the location, in bytes, to monitor for access. Valid sizes
        // may depend on the target processor (x86, x64, etc) and type of code being
        // debugging. For example, native code utilizes the CPU's breakpoint registers, and
        // x86-based processor supports sizes of 1, 2, and 4.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingDataBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingDataBreakpoint'.
        // pDataBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingDataBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::DataBreakpoint)
                return NULL;

            return static_cast<DkmPendingDataBreakpoint*>(pPendingBreakpoint);
        }

        // Creates a new pending breakpoint object. After creation, the returned object will
        // still be disabled and will not be tracked by the breakpoint manager. To complete
        // initialization, the caller should set additional properties on the breakpoint and
        // 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        // after they are done.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // CompilerId      : [In] Identifies the source language (ex: C#) and compiler vendor
        // (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left
        // as Guid.Empty to indicate that the breakpoint should bind against all languages.
        // 'VendorId' is nearly always left as Guid.Empty, which indicates that only the
        // language is known (not the compiler).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // IsBarrier       : [In] Indicates if this breakpoint is a barrier that should be
        // set on the hardware, this works for GPU debugging.
        // pDataElementLocation: [In] Indicates the location of the data value to watch.
        // Size            : [In] Specifies the size of the location, in bytes, to monitor
        // for access. Valid sizes may depend on the target processor (x86, x64, etc) and
        // type of code being debugging. For example, native code utilizes the CPU's
        // breakpoint registers, and x86-based processor supports sizes of 1, 2, and 4.
        // DataItem        : [In] Data object to add to the new DkmPendingDataBreakpoint
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ DkmString* pDataElementLocation,
            _In_ UINT32 Size,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingDataBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingDataBreakpoint

    // Pending breakpoint which is requested to bind against code elements that point back to
    // a text span within a source file.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ea7b0aee-1cc5-a887-4dff-930fc23a6278") DkmPendingFileLineBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingFileLineBreakpoint::Create to create this object
        private: DkmPendingFileLineBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingFileLineBreakpoint();
        // This object cannot be copied
        private: DkmPendingFileLineBreakpoint& operator=(const DkmPendingFileLineBreakpoint&);
        private: DkmPendingFileLineBreakpoint(const DkmPendingFileLineBreakpoint&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingFileLineBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingFileLineBreakpoint'.
        // pFileLineBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingFileLineBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::FileLineBreakpoint)
                return NULL;

            return static_cast<DkmPendingFileLineBreakpoint*>(pPendingBreakpoint);
        }

        // Creates a new pending breakpoint object. After creation, the returned object will
        // still be disabled and will not be tracked by the breakpoint manager. To complete
        // initialization, the caller should set additional properties on the breakpoint and
        // 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        // after they are done.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // CompilerId      : [In] Identifies the source language (ex: C#) and compiler vendor
        // (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left
        // as Guid.Empty to indicate that the breakpoint should bind against all languages.
        // 'VendorId' is nearly always left as Guid.Empty, which indicates that only the
        // language is known (not the compiler).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // IsBarrier       : [In] Indicates if this breakpoint is a barrier that should be
        // set on the hardware, this works for GPU debugging.
        // DataItem        : [In] Data object to add to the new DkmPendingFileLineBreakpoint
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingFileLineBreakpoint** ppCreatedObject
            );

        // Returns the current location of a file/line breakpoint. In edit and continue
        // scenarios, the location of the text marker may change within a debug session.
        // ppCurrentPosition: [Out] Source code position which corresponds to a code element.
        // The could represent a location which has been extracted from a symbol (PDB) file,
        // or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentSourcePosition(
            _Deref_out_ Symbols::DkmSourcePosition** ppCurrentPosition
            );

        // Returns the current text at the location of a file/line breakpoint.
        // ppCurrentText   : [Out,Optional] The current source text.
        // Return value    : S_OK is returned if *ppCurrentText is non-NULL, S_FALSE is
        // returned when *ppCurrentText is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentSourceText(
            _Deref_out_opt_ DkmString** ppCurrentText
            );
    }; // end of DkmPendingFileLineBreakpoint

    // Pending breakpoint which is requested to bind against code elements that have a
    // specific function name.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b463b9e3-5b9f-e0e4-f0e9-4f38c63ef443") DkmPendingFunctionBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingFunctionBreakpoint::Create to create this object
        private: DkmPendingFunctionBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingFunctionBreakpoint();
        // This object cannot be copied
        private: DkmPendingFunctionBreakpoint& operator=(const DkmPendingFunctionBreakpoint&);
        private: DkmPendingFunctionBreakpoint(const DkmPendingFunctionBreakpoint&);

        private: OPTIONAL DkmString* const m_pModuleName;
        private: DkmString* const m_pFunctionName;
        private: const UINT32 m_LineOffset;
        private: void* m__pExtendedData;

        // [Optional] Name of the module to search for the breakpoint. If null, all modules
        // will be searched.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // Name of the function to bind to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // The line of the function to bind to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LineOffset(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingFunctionBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingFunctionBreakpoint'.
        // pFunctionBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingFunctionBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::FunctionBreakpoint)
                return NULL;

            return static_cast<DkmPendingFunctionBreakpoint*>(pPendingBreakpoint);
        }

        // Creates a new pending breakpoint object. After creation, the returned object will
        // still be disabled and will not be tracked by the breakpoint manager. To complete
        // initialization, the caller should set additional properties on the breakpoint and
        // 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        // after they are done.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // CompilerId      : [In] Identifies the source language (ex: C#) and compiler vendor
        // (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left
        // as Guid.Empty to indicate that the breakpoint should bind against all languages.
        // 'VendorId' is nearly always left as Guid.Empty, which indicates that only the
        // language is known (not the compiler).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // IsBarrier       : [In] Indicates if this breakpoint is a barrier that should be
        // set on the hardware, this works for GPU debugging.
        // pModuleName     : [In,Optional] Name of the module to search for the breakpoint.
        // If null, all modules will be searched.
        // pFunctionName   : [In] Name of the function to bind to.
        // LineOffset      : [In] The line of the function to bind to.
        // DataItem        : [In] Data object to add to the new DkmPendingFunctionBreakpoint
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_opt_ DkmString* pModuleName,
            _In_ DkmString* pFunctionName,
            _In_ UINT32 LineOffset,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingFunctionBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingFunctionBreakpoint

    // Low-level data breakpoint which is set using the hardware breakpoint registers of the
    // CPU.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3346103d-7c30-4ee9-c3dd-e8e7e9f66a5e") DkmRuntimeHardwareDataBreakpoint : public Breakpoints::DkmRuntimeBreakpoint
    {
        // Use DkmRuntimeHardwareDataBreakpoint::Create to create this object
        private: DkmRuntimeHardwareDataBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeHardwareDataBreakpoint();
        // This object cannot be copied
        private: DkmRuntimeHardwareDataBreakpoint& operator=(const DkmRuntimeHardwareDataBreakpoint&);
        private: DkmRuntimeHardwareDataBreakpoint(const DkmRuntimeHardwareDataBreakpoint&);

        private: const UINT64 m_Address;
        private: const Breakpoints::DkmDataAccessStopMask::e m_Access;
        private: const UINT32 m_Size;
        private: void* m__pExtendedData;

        // Address to stop on. This address must be suitably aligned to match the Size
        // parameter (example: if Size is 4, Address must be a multiple of 4).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Mask of reasons why the data breakpoint should fire. For example, if 'Write' is
        // set, then the breakpoint will fire when the memory location is written.
        public: DECLSPEC_NOTHROW Breakpoints::DkmDataAccessStopMask::e STDMETHODCALLTYPE Access(
            );

        // Specifies the size of the location, in bytes, to monitor for access. On an
        // x86-based processor, this parameter can be 1, 2, or 4. However, if Access is
        // DkmDataAccessStopMask.Execute, Size must be 1. On an x64-based processor, this
        // parameter can be 1, 2, 4, or 8. However, if Access equals Access is
        // DkmDataAccessStopMask.Execute, Size must be 1. On an Itanium-based processor, this
        // parameter can be any power of 2, from 1 to 0x80000000.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Attempt to cast a 'DkmRuntimeBreakpoint' to a 'DkmRuntimeHardwareDataBreakpoint'. Return
        // NULL if the path object is not a 'DkmRuntimeHardwareDataBreakpoint'.
        // pNativeDataBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRuntimeHardwareDataBreakpoint* TryCast(
            DkmRuntimeBreakpoint* pRuntimeBreakpoint
            )
        {
            if (pRuntimeBreakpoint == NULL || pRuntimeBreakpoint->TagValue() != Tag::NativeDataBreakpoint)
                return NULL;

            return static_cast<DkmRuntimeHardwareDataBreakpoint*>(pRuntimeBreakpoint);
        }

        // Creates a new DkmRuntimeHardwareDataBreakpoint object. After creation, the
        // breakpoint is in the disabled state, and must be explicitly enabled. The caller is
        // responsible for closing the created object after they are done.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // Address         : [In] Address to stop on. This address must be suitably aligned
        // to match the Size parameter (example: if Size is 4, Address must be a multiple of
        // 4).
        // Access          : [In] Mask of reasons why the data breakpoint should fire. For
        // example, if 'Write' is set, then the breakpoint will fire when the memory location
        // is written.
        // Size            : [In] Specifies the size of the location, in bytes, to monitor
        // for access. On an x86-based processor, this parameter can be 1, 2, or 4. However,
        // if Access is DkmDataAccessStopMask.Execute, Size must be 1. On an x64-based
        // processor, this parameter can be 1, 2, 4, or 8. However, if Access equals Access
        // is DkmDataAccessStopMask.Execute, Size must be 1. On an Itanium-based processor,
        // this parameter can be any power of 2, from 1 to 0x80000000.
        // DataItem        : [In] Data object to add to the new
        // DkmRuntimeHardwareDataBreakpoint instance. DkmDataItem::Null() in the case that
        // the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& SourceId,
            _In_opt_ DkmThread* pThread,
            _In_ UINT64 Address,
            _In_ Breakpoints::DkmDataAccessStopMask::e Access,
            _In_ UINT32 Size,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmRuntimeHardwareDataBreakpoint** ppCreatedObject
            );
    }; // end of DkmRuntimeHardwareDataBreakpoint

    // Low-level breakpoint which is set on an instruction address.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4c0b1e65-9d9c-2a4b-9ea0-8b9ead27ca39") DkmRuntimeInstructionBreakpoint : public Breakpoints::DkmRuntimeBreakpoint
    {
        // Use DkmRuntimeInstructionBreakpoint::Create to create this object
        private: DkmRuntimeInstructionBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeInstructionBreakpoint();
        // This object cannot be copied
        private: DkmRuntimeInstructionBreakpoint& operator=(const DkmRuntimeInstructionBreakpoint&);
        private: DkmRuntimeInstructionBreakpoint(const DkmRuntimeInstructionBreakpoint&);

        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: const bool m_IsBarrier;
        private: void* m__pExtendedData;

        // Abstract representation of an executable code location (ex: EIP value). If
        // resolved, an Instruction Address will be within a particular module instance. An
        // Instruction Address is always within a particular Runtime Instance.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Indicates if this instruction breakpoint works as a barrier, used in GPU debugging
        // scenarios.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsBarrier(
            );

        // Attempt to cast a 'DkmRuntimeBreakpoint' to a 'DkmRuntimeInstructionBreakpoint'. Return
        // NULL if the path object is not a 'DkmRuntimeInstructionBreakpoint'.
        // pInstructionBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRuntimeInstructionBreakpoint* TryCast(
            DkmRuntimeBreakpoint* pRuntimeBreakpoint
            )
        {
            if (pRuntimeBreakpoint == NULL || pRuntimeBreakpoint->TagValue() != Tag::InstructionBreakpoint)
                return NULL;

            return static_cast<DkmRuntimeInstructionBreakpoint*>(pRuntimeBreakpoint);
        }

        // Creates a new DkmRuntimeInstructionBreakpoint object. After creation, the
        // breakpoint is in the disabled state, and must be explicitly enabled. The caller is
        // responsible for closing the created object after they are done.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pThread         : [In,Optional] Thread on which this breakpoint should fire. If
        // null, the breakpoint will fire on all threads.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // IsBarrier       : [In] Indicates if this instruction breakpoint works as a
        // barrier, used in GPU debugging scenarios.
        // DataItem        : [In] Data object to add to the new
        // DkmRuntimeInstructionBreakpoint instance. DkmDataItem::Null() in the case that the
        // caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_opt_ DkmThread* pThread,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ bool IsBarrier,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmRuntimeInstructionBreakpoint** ppCreatedObject
            );

        // This sets an associated compiled condition on the specified runtime instruction
        // breakpoint. The breakpoint condition processor will then test the condition
        // whenever it is hit. This is used for languages which are evaluated in the IDE
        // process (ex: C++).
        // pCompiledCondition: [In] Compiled query used to evaluate the condition.
        // ConditionOperator: [In] Operator to use when evaluating the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledCondition(
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator
            );

        // This sets an associated compiled condition on the specified runtime instruction
        // breakpoint. The breakpoint condition processor will then test the condition
        // whenever it is hit. This is used for languages which are evaluated in the IDE
        // process (ex: C++).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompiledCondition: [In] Compiled query used to evaluate the condition.
        // ConditionOperator: [In] Operator to use when evaluating the condition.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetCompiledConditionAsyncResult>* pCompletionRoutine
            );

        // This tries to push the associated condition on the specified runtime instruction
        // breakpoint to the target. This is useful for GPU debugging since testing the
        // condition on the target (GPU hardware or VSD3D ref) is much more efficient than
        // doing it in the debugger. Once this method succeeds, breakpoint event will only be
        // received by the debugger when the condition tests to be true on the debuggee; if
        // it fails, the debugger can still test the condition.
        // pCompiledCondition: [In] Compiled query used to evaluate the condition.
        // ConditionOperator: [In] Operator to use when evaluating the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryPushConditionToTargetDevice(
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator
            );

        // This tries to push the associated condition on the specified runtime instruction
        // breakpoint to the target. This is useful for GPU debugging since testing the
        // condition on the target (GPU hardware or VSD3D ref) is much more efficient than
        // doing it in the debugger. Once this method succeeds, breakpoint event will only be
        // received by the debugger when the condition tests to be true on the debuggee; if
        // it fails, the debugger can still test the condition.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompiledCondition: [In] Compiled query used to evaluate the condition.
        // ConditionOperator: [In] Operator to use when evaluating the condition.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryPushConditionToTargetDevice(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmTryPushConditionToTargetDeviceAsyncResult>* pCompletionRoutine
            );

        // Clear any condition associated with the specified DkmRuntimeInstructionBreakpoint.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryClearConditionOnTargetDevice(
            );

        // Clear any condition associated with the specified DkmRuntimeInstructionBreakpoint.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryClearConditionOnTargetDevice(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmTryClearConditionOnTargetDeviceAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmRuntimeInstructionBreakpoint

}; // end namespace Breakpoints

// Contains the types used to implement setting in the debugger.
namespace Stepping {
    // Flags which describe how to proceed with a Step-Into action.
    enum DkmLanguageStepIntoFlags::e
    {
        // The function stepping should not deviate from default.
        None = 0x0,
        // The function should not be stepped into.
        NoStepInto = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmLanguageStepIntoFlags::e);

    // DkmNativeSteppingCallSite specifies a call instruction and it's target..
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("49b7610c-d229-e123-9f3a-b00df2ef4c24") DkmNativeSteppingCallSite : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNativeSteppingCallSite::Create to create this object
        private: DkmNativeSteppingCallSite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeSteppingCallSite();
        // This object cannot be copied
        private: DkmNativeSteppingCallSite& operator=(const DkmNativeSteppingCallSite&);
        private: DkmNativeSteppingCallSite(const DkmNativeSteppingCallSite&);

        private: Native::DkmNativeInstructionAddress* const m_pCallSite;
        private: OPTIONAL Native::DkmNativeInstructionAddress* const m_pCallTarget;
        private: OPTIONAL Native::DkmNativeInstructionAddress* const m_pCallTargetAddress;
        private: void* m__pExtendedData;

        // The address of the call instruction.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE CallSite(
            );

        // [Optional] The address of the instruction that would be called by the call
        // instruction.
        public: _Ret_opt_ DECLSPEC_NOTHROW Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE CallTarget(
            );

        // [Optional] For indirect calls only, the address being dereferenced by the call
        // instruction.
        public: _Ret_opt_ DECLSPEC_NOTHROW Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE CallTargetAddress(
            );

        // Create a new DkmNativeSteppingCallSite object instance.
        // pCallSite       : [In] The address of the call instruction.
        // pCallTarget     : [In,Optional] The address of the instruction that would be
        // called by the call instruction.
        // pCallTargetAddress: [In,Optional] For indirect calls only, the address being
        // dereferenced by the call instruction.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Native::DkmNativeInstructionAddress* pCallSite,
            _In_opt_ Native::DkmNativeInstructionAddress* pCallTarget,
            _In_opt_ Native::DkmNativeInstructionAddress* pCallTargetAddress,
            _Deref_out_ Stepping::DkmNativeSteppingCallSite** ppCreatedObject
            );
    }; // end of DkmNativeSteppingCallSite

    // DkmSingleStepRequest represents a request to single step a thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("15ec2b6b-561d-93d3-f7b4-50fba4cb8bb5") DkmSingleStepRequest : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSingleStepRequest::Create to create this object
        private: DkmSingleStepRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSingleStepRequest();
        // This object cannot be copied
        private: DkmSingleStepRequest& operator=(const DkmSingleStepRequest&);
        private: DkmSingleStepRequest(const DkmSingleStepRequest&);

        private: const GUID m_SourceId;
        private: DkmThread* const m_pThread;
        private: void* m__pExtendedData;

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Create a new DkmSingleStepRequest object instance.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ DkmThread* pThread,
            _Deref_out_ Stepping::DkmSingleStepRequest** ppCreatedObject
            );

        // Raise a GPUSingleStepComplete event. Components which implement the event sync
        // interface will receive the event notification. This method will enqueue the event
        // and control will immediately return to the caller.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnGPUSingleStepComplete(
            _In_ DkmThread* pThread
            );

        // Enable temporary breakpoint in stepping on a thread. This is similar to single
        // step except one or more instructions are advanced. When breakpoint is hit, step
        // complete event is sent.
        // TempBreakInstructions: [In] The instruction offset of temporary breakpoints to
        // set.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnableTempBreak(
            _In_ const DkmArray<UINT64>& TempBreakInstructions
            );

        // Clear temporary breakpoint in stepping on a thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearTempBreak(
            );

        // Enable single step on a thread. When then single step completes, the
        // SingleStepComplete event should be sent. The single step should reset after
        // completion.  Implementers should send one single step complete event per instance
        // of DkmSingleStepRequest they receive. Callers must make a new request to
        // single-step after this DkmSingleStepRequest is complete.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnableSingleStep(
            );

        // Disable single step on a thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearSingleStep(
            );

        // Raise a SingleStepComplete event. Components which implement the event sync
        // interface will receive the event notification. This method will enqueue the event
        // and control will immediately return to the caller.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSingleStepComplete(
            );
    }; // end of DkmSingleStepRequest

    // DkmStepArbitrationReason the reason step arbitration is occurring.
    enum DkmStepArbitrationReason::e
    {
        // The stepping manager is looking for a runtime to start a new step.
        NewStep = 0,
        // The instruction pointer has landed in a location not in a known DkmModuleInstance.
        UnknownModule = 1,
        // The instruction pointer has landed in a location in a known DkmModuleInstance with
        // no symbols.
        NoSymbols = 2,
        // The instruction pointer has landed in a location within a DkmModuleInstance marked
        // as a transition module.
        TransitionModule = 3,
        // The current runtime instance has just finished stepping through a known exit from
        // its runtime. The instruction pointer should be on the first instruction of the
        // next runtime's entry point.
        ExitRuntime = 4,
        // Another runtime instance has detected that the instruction pointer has hit an
        // entry point into its runtime. This is only used after a call to
        // StepControlRequested that return true.
        EnterRuntime = 5,
        // The instruction pointer has landed at a location in a known module but with no
        // source info.
        NoSource = 6,
        // An exception unwind was in flight and a handler was found. If a runtime's
        // exception model can be used by other runtimes, stepping arbitration should be
        // performed. For instance, CLR exceptions use native SEH exceptions. So, during a
        // managed step, if an exception is thrown and a handler is found, native will
        // receive its handler found notification. However, native should not take control of
        // that step. Managed should listen for stepping arbitration with
        // ExceptionHandlerFound as its reason and finish stepping to the managed catch
        // block.
        ExceptionHandlerFound = 7,
        // Used by the stepping manager to override a line or statement step with an
        // instruction level step. This is only passed to the native runtime instance if no
        // controlling runtime instance was found during initial stepping arbitration.
        InstructionLevelOverride = 8,
        // A runtime instance asked for stepping arbitration for an unknown reason.
        Unknown = 9,
        // A runtime instance that understands the async pattern has taken control of the
        // step. The step will complete asynchronously on another thread. Steppers should
        // clear all step state to allow for that.
        AsyncStep = 10
    };

    // DkmStepKind describes how to step the thread when the Step Method is called.
    enum DkmStepKind::e
    {
        // Step the thread into calls.
        Into = 0,
        // Step the thread over calls.
        Over = 1,
        // Step the thread out of the current frame.
        Out = 2,
        // Step into specific request.
        StepIntoSpecific = 3
    };

    // DkmStepUnit describes the granularity of the step when the Step method is called.
    enum DkmStepUnit::e
    {
        // Step the thread to the next statement.
        Statement = 0,
        // Step the thread to the next line.
        Line = 1,
        // Step the thread to the next instruction.
        Instruction = 2
    };

    // DkmStepper represents a request to step a thread. It facilitates shared object
    // lifetime between the various runtime debug monitors that participate in stepping.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2aae9764-33a3-8fc7-22ff-e27c9de91bda") DkmStepper : public DkmDataContainer
    {
        // Use DkmStepper::Create to create this object
        private: DkmStepper();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStepper();
        // This object cannot be copied
        private: DkmStepper& operator=(const DkmStepper&);
        private: DkmStepper(const DkmStepper&);

        // Contains additional fields of DkmStepper which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // In managed debugging, it indicates if the stepper wanted to capture return
            // value during stepping. Default it is false.
            const bool ShouldCaptureReturnValue;

            // [Optional] In managed debugging, it contains all code paths in current step
            // range. Otherwise it is NULL.
            OPTIONAL DkmReadOnlyCollection<Stepping::DkmSteppingCodePath*>* const pCurrentCodePaths;

            // [Optional] In managed debugging, it contains current method name. Otherwise it
            // is NULL.
            OPTIONAL DkmString* const pCurrentMethodName;
        };

        private: const GUID m_UniqueId;
        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmInstructionAddress* const m_pStartingAddress;
        private: const UINT64 m_FrameBase;
        private: const Stepping::DkmStepKind::e m_StepKind;
        private: const Stepping::DkmStepUnit::e m_StepUnit;
        private: const GUID m_SourceId;
        private: OPTIONAL Stepping::DkmSteppingCodePath* const m_pCodePath;
        private: OPTIONAL Stepping::DkmStepper* const m_pCrossThreadParent;
        private: ___ExtendedData* const m__pExtendedData;

        // Guid which uniquely identifies this DkmStepper.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The instruction address of the process at the time this step started.
        // This will be NULL if the step originated on a thread with no frames (Script &
        // Managed Only).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE StartingAddress(
            );

        // The frame base of the first frame at the beginning of the step. This value will be
        // MAXUINT64 if the StartingAddress was not specified.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameBase(
            );

        // DkmStepKind describes how to step the thread when the Step Method is called.
        public: DECLSPEC_NOTHROW Stepping::DkmStepKind::e STDMETHODCALLTYPE StepKind(
            );

        // DkmStepUnit describes the granularity of the step when the Step method is called.
        public: DECLSPEC_NOTHROW Stepping::DkmStepUnit::e STDMETHODCALLTYPE StepUnit(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // [Optional] If StepKind is StepIntoSpecific, specifies which call we are stepping
        // into. Otherwise it is NULL.
        public: _Ret_opt_ DECLSPEC_NOTHROW Stepping::DkmSteppingCodePath* STDMETHODCALLTYPE CodePath(
            );

        // [Optional] If a new stepper is created using OnCrossThreadStepArbitration, the
        // stepping manager will set this field to make is easy to get back to the original
        // stepper if the cross thread step fails or needs to fallback.
        public: _Ret_opt_ DECLSPEC_NOTHROW Stepping::DkmStepper* STDMETHODCALLTYPE CrossThreadParent(
            );

        // In managed debugging, it indicates if the stepper wanted to capture return value
        // during stepping. Default it is false.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ShouldCaptureReturnValue(
            );

        // [Optional] In managed debugging, it contains all code paths in current step range.
        // Otherwise it is NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Stepping::DkmSteppingCodePath*>* STDMETHODCALLTYPE CurrentCodePaths(
            );

        // [Optional] In managed debugging, it contains current method name. Otherwise it is
        // NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CurrentMethodName(
            );

        // Closes the stepper object. This should be closed by components when the stepper is
        // done, such as when a step complete event is suppressed, or if the stepper fails to
        // initialize. Steppers will be implicitly closed if their thread exits, or the
        // debugger is stopped. They will be closed by the stepping manager if a different
        // user-level execution request is issued.
        //
        // DkmStepper objects are automatically closed when their associated DkmThread object
        // is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // DkmStepper objects are created by components that wish to issue a step. User-level
        // steppers are created by the AD7-AL. To initialize a stepper object, Enable must be
        // called. Stepper objects will live until the step completes, or is aborted.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pStartingAddress: [In,Optional] The instruction address of the process at the time
        // this step started. This will be NULL if the step originated on a thread with no
        // frames (Script & Managed Only).
        // FrameBase       : [In] The frame base of the first frame at the beginning of the
        // step. This value will be MAXUINT64 if the StartingAddress was not specified.
        // StepKind        : [In] DkmStepKind describes how to step the thread when the Step
        // Method is called.
        // StepUnit        : [In] DkmStepUnit describes the granularity of the step when the
        // Step method is called.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pCodePath       : [In,Optional] If StepKind is StepIntoSpecific, specifies which
        // call we are stepping into. Otherwise it is NULL.
        // pCrossThreadParent: [In,Optional] If a new stepper is created using
        // OnCrossThreadStepArbitration, the stepping manager will set this field to make is
        // easy to get back to the original stepper if the cross thread step fails or needs
        // to fallback.
        // DataItem        : [In] Data object to add to the new DkmStepper instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pStartingAddress,
            _In_ UINT64 FrameBase,
            _In_ Stepping::DkmStepKind::e StepKind,
            _In_ Stepping::DkmStepUnit::e StepUnit,
            _In_ const GUID& SourceId,
            _In_opt_ Stepping::DkmSteppingCodePath* pCodePath,
            _In_opt_ Stepping::DkmStepper* pCrossThreadParent,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Stepping::DkmStepper** ppCreatedObject
            );

        // DkmStepper objects are created by components that wish to issue a step. User-level
        // steppers are created by the AD7-AL. To initialize a stepper object, Enable must be
        // called. Stepper objects will live until the step completes, or is aborted.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pStartingAddress: [In,Optional] The instruction address of the process at the time
        // this step started. This will be NULL if the step originated on a thread with no
        // frames (Script & Managed Only).
        // FrameBase       : [In] The frame base of the first frame at the beginning of the
        // step. This value will be MAXUINT64 if the StartingAddress was not specified.
        // StepKind        : [In] DkmStepKind describes how to step the thread when the Step
        // Method is called.
        // StepUnit        : [In] DkmStepUnit describes the granularity of the step when the
        // Step method is called.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pCodePath       : [In,Optional] If StepKind is StepIntoSpecific, specifies which
        // call we are stepping into. Otherwise it is NULL.
        // pCrossThreadParent: [In,Optional] If a new stepper is created using
        // OnCrossThreadStepArbitration, the stepping manager will set this field to make is
        // easy to get back to the original stepper if the cross thread step fails or needs
        // to fallback.
        // ShouldCaptureReturnValue: [In] In managed debugging, it indicates if the stepper
        // wanted to capture return value during stepping. Default it is false.
        // pCurrentCodePaths: [In,Optional] In managed debugging, it contains all code paths
        // in current step range. Otherwise it is NULL.
        // pCurrentMethodName: [In,Optional] In managed debugging, it contains current method
        // name. Otherwise it is NULL.
        // DataItem        : [In] Data object to add to the new DkmStepper instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pStartingAddress,
            _In_ UINT64 FrameBase,
            _In_ Stepping::DkmStepKind::e StepKind,
            _In_ Stepping::DkmStepUnit::e StepUnit,
            _In_ const GUID& SourceId,
            _In_opt_ Stepping::DkmSteppingCodePath* pCodePath,
            _In_opt_ Stepping::DkmStepper* pCrossThreadParent,
            _In_ bool ShouldCaptureReturnValue,
            _In_opt_ DkmReadOnlyCollection<Stepping::DkmSteppingCodePath*>* pCurrentCodePaths,
            _In_opt_ DkmString* pCurrentMethodName,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Stepping::DkmStepper** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by the stopping event manager before a step operation actually begins The
        // stopping event manager will notify all runtime instances so they can setup any
        // necessary state before the the stopping event manager starts blocking function
        // evaluations.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeforeEnable(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Used to initialize a stepper object so that the step will be performed when
        // execution is next resumed. This method is implemented by the stepping manager by
        // finding an appropriate runtime debug monitor, and asking this runtime debug
        // monitor to setup a step. This method should only be called once for a given
        // stepper object.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // RemoveOtherSteppers: [In] Set to true if other steppers are to be removed. This is
        // normally only set in response to user initiated step requests.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ bool RemoveOtherSteppers
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Allows a stepper to be cancelled after creation by the controlling runtime
        // instance. The calling runtime instance must match the current controlling runtime
        // instance. This is generally used in cross thread stepping scenarios where the
        // original stepper may be reactivated. The stepping manager will close the stepper
        // and not send step complete.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CancelStepper(
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Returns the runtime instance currently in-control of this DkmStepper.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppRuntimeInstance: [Out] The runtime instance currently in control of this
        // stepper.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetControllingRuntimeInstance(
            _Deref_out_ DkmRuntimeInstance** ppRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // StepControlRequested is called when a non-controlling runtime instance detects
        // that the thread has hit a transition into its runtime. The stepping manager will
        // forward the call to the current controlling runtime instance. If the current
        // controlling runtime instance can stop stepping, it should set Granted to true.
        // Actual control is not given until the requesting runtime calls
        // DkmStepper.TakeStepControl. This two part process allows callers to request
        // control of multiple steppers at the same time.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // pGranted        : [Out] The the controlling runtime can stop the step and give
        // control to the caller, then it should set this to true.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StepControlRequested(
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
            _Out_ bool* pGranted
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // TakeStepControl is called when a non-controlling runtime instance detects that the
        // thread has hit a transition into its runtime. The stepping manager will forward
        // the call to the current controlling runtime instance. The runtime instance
        // requesting control should first call StepControlRequested on all steppers it wants
        // control of. If they all set Granted to true, the runtime instance should then call
        // this method on each stepper it is taking control of.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // LeaveGuardsInPlace: [In] Set to true by the caller if it would like the current
        // controlling runtime instance to leave guards in place to stop the step if
        // necessary. For instance, this can be used to leave guard breakpoints after a call
        // instruction so another runtime can step back out if the target of the call doesn't
        // have source. However, any stepping state that affects the immediate step, such as
        // trap flags, should be removed by the controlling runtime instance.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TakeStepControl(
            _In_ bool LeaveGuardsInPlace,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by a runtime monitor when a step has left the confines of what the runtime
        // monitor understands or a potential transition into another runtime has been
        // encountered during a step. The stepping manager will initiate stepping arbitration
        // to give each runtime monitor a chance to inspect the process and determine which
        // runtime should complete the step. The runtimes are called in priority order. After
        // this process is complete, the stepping manager will call AfterSteppingArbitration
        // on the monitor that requested arbitration so it can respond to the new controlling
        // monitor if one was found, or finish the step if one was not found.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCurrentControllingRuntimeInstance: [In] The runtime instance requesting
        // arbitration.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStepArbitration(
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Called by a runtime monitor when a step is continuing on a different thread. The
        // stepping manager will create a new DkmStepper to be used on the new thread and
        // initiate stepping arbitration to determine which runtime should complete the step
        // just as OnStepArbitration does. The new stepper uses the same step kind and step
        // unit as the original stepper. A new starting instruction address must be given and
        // is set as the stepper's starting address. The original stepper remains alive and
        // when the new stepper completes the stepping manager will suppress the event and
        // notify the original stepper of the completion.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCurrentControllingRuntimeInstance: [In] The runtime instance requesting
        // arbitration.
        // pNewThread      : [In] The thread on which to create the new stepper.
        // pNewStartingInstructionAddress: [In] Starting address of the new stepper.
        // ppNewStepper    : [Out,Optional] The new stepper.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnCrossThreadStepArbitration(
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance,
            _In_ DkmThread* pNewThread,
            _In_ DkmInstructionAddress* pNewStartingInstructionAddress,
            _Deref_out_opt_ Stepping::DkmStepper** ppNewStepper
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // Raise a ReturnValues event. Components which implement the event sync interface
        // will receive the event notification. Control will return once all components have
        // been notified.
        // pReturnValues   : [In,Optional] DkmRawReturnValues recorded.
        // LastValueInCurrentContext: [In] If true, it is valid to use the current thread
        // context to evaluate the last return value.  This is true only in the case
        // immediately after processing the return instruction, and so should only be set if
        // raising this event immediately before, and on the same thread, as the StepComplete
        // event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnReturnValues(
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmRawReturnValue*>* pReturnValues,
            _In_ bool LastValueInCurrentContext
            );

        // Raise a StepComplete event. Components which implement the event sync interface
        // will receive the event notification. This method will enqueue the event and
        // control will immediately return to the caller.
        // pThread         : [In] The thread the step actually finished on. Normally, this is
        // the same as the thread in DkmStepper, but in some scenarios, it could be
        // different.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the stepping thread. Currently, only managed
        // runtime instances ever set this. This is used to quickly determine if exception
        // specific logic should apply without making another network round-trip.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStepComplete(
            _In_ DkmThread* pThread,
            _In_ bool HasException
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Runtime monitors call this to set or clear a flag on the DkmStepper that can be
        // used by cooperating runtimes to change the behavior of stepping if an exception is
        // current in flight. Called by runtime monitors when an exception is encountered
        // while stepping.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        // Enable          : [In] If true, the exception in flight flag is set. If false, it
        // is cleared.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetExceptionInFlight(
            _In_ bool Enable
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Gets the flag on the DkmStepper that states if a runtime monitor believes an
        // exception is currently in flight during this step. This can be used by runtime
        // monitors to change the behavior of stepping.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        // pEnabled        : [Out] If true, the exception in flight flag is set. If false, it
        // is cleared.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsExceptionInFlight(
            _Out_ bool* pEnabled
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmStepper

    // DkmSteppingCodePath represents a location that user can step to from current location.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("14c9f40d-f492-532e-ea75-f0d1ab0e9fff") DkmSteppingCodePath : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSteppingCodePath::Create to create this object
        private: DkmSteppingCodePath();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSteppingCodePath();
        // This object cannot be copied
        private: DkmSteppingCodePath& operator=(const DkmSteppingCodePath&);
        private: DkmSteppingCodePath(const DkmSteppingCodePath&);

        private: DkmString* const m_pName;
        private: const UINT32 m_CodePathOffset;
        private: const UINT32 m_EndOffset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // The string that represents a possible code path user can select.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // For managed this represents the IL offset to call instruction. For native it is
        // the RVA of the call instruction.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CodePathOffset(
            );

        // Represents end offset for current step unit.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE EndOffset(
            );

        // [Optional] Additional data about the code path. Meaning is implementation
        // specific.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Create a new DkmSteppingCodePath object instance.
        // pName           : [In] The string that represents a possible code path user can
        // select.
        // CodePathOffset  : [In] For managed this represents the IL offset to call
        // instruction. For native it is the RVA of the call instruction.
        // EndOffset       : [In] Represents end offset for current step unit.
        // pAdditionalData : [In,Optional] Additional data about the code path. Meaning is
        // implementation specific.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ UINT32 CodePathOffset,
            _In_ UINT32 EndOffset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Stepping::DkmSteppingCodePath** ppCreatedObject
            );
    }; // end of DkmSteppingCodePath

    // Object used for filtering for step into specific.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b4f7a81a-62b9-de29-106d-5f055114810a") DkmSteppingCodePathSource : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSteppingCodePathSource::Create to create this object
        private: DkmSteppingCodePathSource();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSteppingCodePathSource();
        // This object cannot be copied
        private: DkmSteppingCodePathSource& operator=(const DkmSteppingCodePathSource&);
        private: DkmSteppingCodePathSource(const DkmSteppingCodePathSource&);

        private: Symbols::DkmInstructionSymbol* const m_pInstructionSymbol;
        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: void* m__pExtendedData;

        // The instruction symbol at the location to begin looking for step into specific
        // code paths.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmInstructionSymbol* STDMETHODCALLTYPE InstructionSymbol(
            );

        // The instruction address at the location to begin looking for step into specific
        // code paths.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // The language of the location to begin looking for step into specific code paths.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Create a new DkmSteppingCodePathSource object instance.
        // pInstructionSymbol: [In] The instruction symbol at the location to begin looking
        // for step into specific code paths.
        // pInstructionAddress: [In] The instruction address at the location to begin looking
        // for step into specific code paths.
        // pLanguage       : [In] The language of the location to begin looking for step into
        // specific code paths.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmInstructionSymbol* pInstructionSymbol,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _Deref_out_ Stepping::DkmSteppingCodePathSource** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // GetCodePaths is called to get step into specific targets.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pStackFrame     : [In] Specifies the current frame.
        // StepUnit        : [In] Specifies if code paths are for current statement or line.
        // pCodePaths      : [Out] DkmSteppingCodePath[] represents a location that user can
        // step to from current location.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCodePaths(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Stepping::DkmStepUnit::e StepUnit,
            _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmSteppingCodePathSource

}; // end namespace Stepping

// Contains types for start debugging and launching processes.
namespace Start {
    // DkmLaunchedProcessInfo is returned from APIs that launch a process.
    struct DECLSPEC_UUID("df3c6c1f-676b-92dc-286b-b364a24342ae") DkmLaunchedProcessInfo
    {
        // Id of the launched process. Minidump implementations can set this to 0.
        UINT32 ProcessId;

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process. This can be set to 0 if this is unknown/invalid (ex:
        // minidumps).
        UINT64 StartTime;

        // Id of the first thread in the launched process. Minidump implementations can set
        // this to 0.
        UINT32 ThreadId;

        // Release all reference-counted fields within the DkmLaunchedProcessInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmLaunchedProcessInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Result of an asynchronous DkmTransportConnection.ActivateAppPackage call.
    struct DkmActivateAppPackageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Settings supplied during a start debugging operation from a project system or other
    // caller of LaunchDebugTargets (or various other start debugging APIs).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bbc4d5cc-e936-fc2a-64b7-ba716dda9020") DkmDebugLaunchSettings : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDebugLaunchSettings::Create to create this object
        private: DkmDebugLaunchSettings();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDebugLaunchSettings();
        // This object cannot be copied
        private: DkmDebugLaunchSettings& operator=(const DkmDebugLaunchSettings&);
        private: DkmDebugLaunchSettings(const DkmDebugLaunchSettings&);

        private: DkmString* const m_pOptionsString;
        private: OPTIONAL DkmReadOnlyCollection<GUID>* const m_pEngineFilter;
        private: void* m__pExtendedData;

        // Additional information provided by a project system when calling
        // LaunchDebugTargets through VsDebugTarget[2/3/etc].bstrOptions).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE OptionsString(
            );

        // [Optional] Guids for the set of debug engines being used to debug this process.
        // This will be null if the process was launched outside the debugger.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE EngineFilter(
            );

        // Create a new DkmDebugLaunchSettings object instance.
        // pOptionsString  : [In] Additional information provided by a project system when
        // calling LaunchDebugTargets through VsDebugTarget[2/3/etc].bstrOptions).
        // pEngineFilter   : [In,Optional] Guids for the set of debug engines being used to
        // debug this process. This will be null if the process was launched outside the
        // debugger.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pOptionsString,
            _In_opt_ DkmReadOnlyCollection<GUID>* pEngineFilter,
            _Deref_out_ Start::DkmDebugLaunchSettings** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Obtains any environment variables which the extension would like to add.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Scenario        : [In] Enumeration of the scenarios where
        // IDkmProcessLaunchEnvironmentFilter implementations are invoked.
        // ppAdditionalEnvironmentBlock: [Out,Optional] One or more environment variables
        // which should be passed to the target process. Multiple variables are separated
        // with an embedded null ('\0'). For example: "MyVariable1=1\0MyVariable2=12".
        //
        // Null or empty string are returned if the caller doesn't want to customize the
        // environment block for this launch.
        // Return value    : S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL,
        // S_FALSE is returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes
        // are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUAdditionalEnvironmentVariables(
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario::e Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmDebugLaunchSettings

    // DkmProcessAttachRequest is used to describe the process that debugger should attach
    // to.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7c0ada54-d17e-0067-cb5e-5a8169507663") DkmProcessAttachRequest : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmProcessAttachRequest::Create to create this object
        private: DkmProcessAttachRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessAttachRequest();
        // This object cannot be copied
        private: DkmProcessAttachRequest& operator=(const DkmProcessAttachRequest&);
        private: DkmProcessAttachRequest(const DkmProcessAttachRequest&);

        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: DkmString* const m_pPath;
        private: const UINT32 m_ProcessId;
        private: const GUID m_UniqueProcessId;
        private: const Start::DkmStartMethod::e m_StartMethod;
        private: const GUID m_HostingProcessLanguage;
        private: DkmEngineSettings* const m_pEngineSettings;
        private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
        private: void* m__pExtendedData;

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Full path to the starting executable of the process.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
            );

        // Id of the process which the debugger should attach to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProcessId(
            );

        // Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated by the
        // port, and is used to uniquely identifies the process object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueProcessId(
            );

        // DkmStartMethod describes how the debug engine started debugging this process.
        public: DECLSPEC_NOTHROW Start::DkmStartMethod::e STDMETHODCALLTYPE StartMethod(
            );

        // [Optional] Unique id for a programming language. These values must also be
        // registered under $(RegRoot)\AD7Metric\ExpressionEvaluator and returned from symbol
        // providers (through GetCompilerId) and language services (through
        // IVsLanguageDebugInfo.GetLanguageID).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE HostingProcessLanguage(
            );

        // Contains the session-wide debug settings. There is one instance of this object per
        // engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        // COMPlusNativeEng).
        public: _Ret_ DECLSPEC_NOTHROW DkmEngineSettings* STDMETHODCALLTYPE EngineSettings(
            );

        // Settings supplied during a start debugging operation from a project system or
        // other caller of LaunchDebugTargets (or various other start debugging APIs).
        public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
            );

        // Create a new DkmProcessAttachRequest object instance.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pPath           : [In] Full path to the starting executable of the process.
        // ProcessId       : [In] Id of the process which the debugger should attach to.
        // UniqueProcessId : [In] Value to assign to the 'DkmProcess.UniqueId' field. This
        // Guid is generated by the port, and is used to uniquely identifies the process
        // object.
        // StartMethod     : [In] DkmStartMethod describes how the debug engine started
        // debugging this process.
        // HostingProcessLanguage: [In,Optional] Unique id for a programming language. These
        // values must also be registered under $(RegRoot)\AD7Metric\ExpressionEvaluator and
        // returned from symbol providers (through GetCompilerId) and language services
        // (through IVsLanguageDebugInfo.GetLanguageID).
        // pEngineSettings : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
        // from a project system or other caller of LaunchDebugTargets (or various other
        // start debugging APIs).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pPath,
            _In_ UINT32 ProcessId,
            _In_ const GUID& UniqueProcessId,
            _In_ Start::DkmStartMethod::e StartMethod,
            _In_ const GUID& HostingProcessLanguage,
            _In_ DkmEngineSettings* pEngineSettings,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _Deref_out_ Start::DkmProcessAttachRequest** ppCreatedObject
            );

        // Causes the debug monitor to attach to the process. Before this method returns, the
        // debug monitor must start an event thread (or reuse an existing event thread) and
        // create the DkmProcess object on the event thread. Creating the DkmProcess object
        // will send a process create event.
        //
        // Note that this method may only be called in response to the Visual Studio debugger
        // package requesting an attach. Components that wish to attach to another process
        // should send a custom event to a visual studio package. From a package, an attach
        // can be requested through the IVsDebugger.LaunchDebugTargets API.
        // ppProcess       : [Out] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_ATTACH_USER_CANCELED indicates that the attach to process operation was
        // canceled. Returning this error will suppress most error messages. So it can be
        // used in combination with DkmUserMessage.Post or DkmCustomMessage.SendToVsService
        // as a way of providing custom failure messages to the user.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AttachToProcess(
            _Deref_out_ DkmProcess** ppProcess
            );
    }; // end of DkmProcessAttachRequest

    // Holds the list of implementations of the IDkmProcessLaunchEnvironmentFilter interface
    // which may be called by a component. This object is used to call these environment
    // filters.
    class DkmProcessLaunchEnvironmentFilterList : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: const DWORD m_count;

        // Use DkmProcessLaunchEnvironmentFilterList::Create to create this object
        private: DkmProcessLaunchEnvironmentFilterList();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessLaunchEnvironmentFilterList();
        // This object cannot be copied
        private: DkmProcessLaunchEnvironmentFilterList& operator=(const DkmProcessLaunchEnvironmentFilterList&);
        private: DkmProcessLaunchEnvironmentFilterList(const DkmProcessLaunchEnvironmentFilterList&);

        // Returns the number of implemantions of the IDkmProcessLaunchEnvironmentFilter interface which
        // may be called through this object.
        public: inline DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE Count(
            )
        {
            return m_count;
        }

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Obtains any environment variables which the extension would like to add.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ImplementationIndex: [In] Zero-based index into the collection of {0}
        // implementations that the caller wishes to be invoked. This should be less than the
        // 'Count' property.
        // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
        // from a project system or other caller of LaunchDebugTargets (or various other
        // start debugging APIs).
        // Scenario        : [In] Enumeration of the scenarios where
        // IDkmProcessLaunchEnvironmentFilter implementations are invoked.
        // ppAdditionalEnvironmentBlock: [Out,Optional] One or more environment variables
        // which should be passed to the target process. Multiple variables are separated
        // with an embedded null ('\0'). For example: "MyVariable1=1\0MyVariable2=12".
        //
        // Null or empty string are returned if the caller doesn't want to customize the
        // environment block for this launch.
        // Return value    : S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL,
        // S_FALSE is returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes
        // are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdditionalEnvironmentVariables(
            _In_ UINT32 ImplementationIndex,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario::e Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Create a new DkmProcessLaunchEnvironmentFilterList object instance.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Start::DkmProcessLaunchEnvironmentFilterList** ppCreatedObject
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    };

    // Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter implementations
    // are invoked.
    enum DkmProcessLaunchEnvironmentFilterScenario::e
    {
        // Application is about to be launched with CreateProcess.
        ClassicLaunch = 0,
        // Windows Store app package or Windows Phone app package is about to be started.
        AppPackageLaunch = 1
    };

    // Flag traits of a DkmProcessLaunchRequest.
    enum DkmProcessLaunchModeFlags::e
    {
        // No launch flags are set.
        None = 0x0,
        // Launch the process without debugging (Ctrl+F5).
        NoDebug = 0x1,
        // Launch the process with Edit and Continue enabled.
        EnableENC = 0x2,
        // Merge DkmProcessLaunchRequest.Environment with the environment block of the
        // monitor. If this flag is missing and DkmProcessLaunchRequest.Environment is
        // specified then the processed will be launched with only environment variables from
        // the input block.
        MergeEnvironment = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmProcessLaunchModeFlags::e);

    // DkmProcessLaunchRequest is used to describe the process that debugger should launch.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7107fc56-3477-2708-fc00-174f33c04b08") DkmProcessLaunchRequest : public DkmDataContainer
    {
        // Use DkmProcessLaunchRequest::Create to create this object
        private: DkmProcessLaunchRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessLaunchRequest();
        // This object cannot be copied
        private: DkmProcessLaunchRequest& operator=(const DkmProcessLaunchRequest&);
        private: DkmProcessLaunchRequest(const DkmProcessLaunchRequest&);

        private: DkmString* const m_pFileName;
        private: OPTIONAL DkmString* const m_pArguments;
        private: DkmString* const m_pWorkingDirectory;
        private: OPTIONAL DkmString* const m_pEnvironment;
        private: OPTIONAL Start::DkmProcessStartupInfo* const m_pStartupInfo;
        private: const Start::DkmProcessLaunchModeFlags::e m_ModeFlags;
        private: const UINT32 m_Win32Flags;
        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: const GUID m_UniqueId;
        private: OPTIONAL DkmEngineSettings* const m_pEngineSettings;
        private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
        private: void* m__pExtendedData;

        // Path to the executable file to launch.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FileName(
            );

        // [Optional] Arguments to pass to the executable file on the command line.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Arguments(
            );

        // The full path to the current directory for the process. The string can also
        // specify a UNC path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE WorkingDirectory(
            );

        // [Optional] A pointer to the environment block for the new process. If this
        // parameter is NULL, the new process uses the environment of the calling process.
        //
        // An environment block consists of a null-terminated block of null-terminated
        // strings. Each string is in the following form: 'name=value\0'. Because the equal
        // sign is used as a separator, it must not be used in the name of an environment
        // variable.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Environment(
            );

        // [Optional] Additional information used to launch a new process. This information
        // is contained within the 'STARTUPINFO' structure in Win32.
        public: _Ret_opt_ DECLSPEC_NOTHROW Start::DkmProcessStartupInfo* STDMETHODCALLTYPE StartupInfo(
            );

        // Flag traits of a DkmProcessLaunchRequest.
        public: DECLSPEC_NOTHROW Start::DkmProcessLaunchModeFlags::e STDMETHODCALLTYPE ModeFlags(
            );

        // Win32 process creation flags used when launching the process. For example,
        // CREATE_NO_WINDOW (0x08000000) could be passed to disable the creation of the
        // console window. The following flags should never be passed, and the behavior is
        // undefined if they are present: DEBUG_PROCESS, DEBUG_ONLY_THIS_PROCESS,
        // CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT, CREATE_SEPARATE_WOW_VDM,
        // CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Win32Flags(
            );

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // UniqueId uniquely identifies the launch request.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] Settings to use when launching this executable under the debugger. This
        // may be omitted if the process is not being launched under the debugger (ex:
        // Ctrl-F5).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmEngineSettings* STDMETHODCALLTYPE EngineSettings(
            );

        // Settings supplied during a start debugging operation from a project system or
        // other caller of LaunchDebugTargets (or various other start debugging APIs).
        public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
            );

        // Closes a DkmProcessLaunchRequest object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmProcessLaunchRequest objects are automatically closed when their associated
        // DkmTransportConnection object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmProcessLaunchRequest object instance. The caller is responsible
        // for closing the created object after they are done.
        // pFileName       : [In] Path to the executable file to launch.
        // pArguments      : [In,Optional] Arguments to pass to the executable file on the
        // command line.
        // pWorkingDirectory: [In] The full path to the current directory for the process.
        // The string can also specify a UNC path.
        // pEnvironment    : [In,Optional] A pointer to the environment block for the new
        // process. If this parameter is NULL, the new process uses the environment of the
        // calling process.
        //
        // An environment block consists of a null-terminated block of null-terminated
        // strings. Each string is in the following form: 'name=value\0'. Because the equal
        // sign is used as a separator, it must not be used in the name of an environment
        // variable.
        // pStartupInfo    : [In,Optional] Additional information used to launch a new
        // process. This information is contained within the 'STARTUPINFO' structure in
        // Win32.
        // ModeFlags       : [In] Flag traits of a DkmProcessLaunchRequest.
        // Win32Flags      : [In] Win32 process creation flags used when launching the
        // process. For example, CREATE_NO_WINDOW (0x08000000) could be passed to disable the
        // creation of the console window. The following flags should never be passed, and
        // the behavior is undefined if they are present: DEBUG_PROCESS,
        // DEBUG_ONLY_THIS_PROCESS, CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT,
        // CREATE_SEPARATE_WOW_VDM, CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pEngineSettings : [In,Optional] Settings to use when launching this executable
        // under the debugger. This may be omitted if the process is not being launched under
        // the debugger (ex: Ctrl-F5).
        // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
        // from a project system or other caller of LaunchDebugTargets (or various other
        // start debugging APIs).
        // DataItem        : [In] Data object to add to the new DkmProcessLaunchRequest
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pFileName,
            _In_opt_ DkmString* pArguments,
            _In_ DkmString* pWorkingDirectory,
            _In_opt_ DkmString* pEnvironment,
            _In_opt_ Start::DkmProcessStartupInfo* pStartupInfo,
            _In_ Start::DkmProcessLaunchModeFlags::e ModeFlags,
            _In_ UINT32 Win32Flags,
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_opt_ DkmEngineSettings* pEngineSettings,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Start::DkmProcessLaunchRequest** ppCreatedObject
            );

        // This API is remote-able version of the Win32 CreateProcess API. The implementation
        // will merge the environment block, process command line redirection and launch the
        // process. Unless the NoDebug flag is used, CreateProcess will use the DEBUG_PROCESS
        // flag when creating the Win32 process.
        // AdditionalWin32Flags: [In] Win32 process creation flags in addition to those found
        // in the DkmProcessLaunchRequest.Win32Flags. This is often used to pass
        // DEBUG_PROCESS (0x1), DEBUG_ONLY_THIS_PROCESS (0x2), or CREATE_SUSPENDED (0x4).
        // pLaunchedProcess: [Out] DkmLaunchedProcessInfo is returned from APIs that launch a
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LaunchProcess(
            _In_ UINT32 AdditionalWin32Flags,
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            );

        // This API is used to resume a process which was launched from CreateProcess with
        // the LaunchSuspended flag set to true.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResumeProcess(
            );

        // Causes the debug monitor to create a new process under the debugger. The process
        // should be left suspended until ResumeDebuggedProcess is called. The debug monitor
        // must wait for ResumeDebuggedProcess before creating the DkmProcess object since it
        // needs the UniqueProcessId value from the AD7 Layer.
        //
        // Note that this method may only be called in response to the Visual Studio debugger
        // package requesting a launch. Components that wish to launch another process under
        // the debugger should send a custom event to a visual studio package. From a
        // package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.
        // pLaunchedProcess: [Out] DkmLaunchedProcessInfo is returned from APIs that launch a
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LaunchDebuggedProcess(
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            );

        // Causes the debug monitor to resume a launched process and create the DkmProcess
        // object. The DkmProcess object will be created on the event thread and creating the
        // object will send a process create event.
        //
        // Note that this method may only be called in response to the Visual Studio debugger
        // package requesting a launch. Components that wish to launch another process under
        // the debugger should send a custom event to a visual studio package. From a
        // package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.
        // UniqueProcessId : [In] Value to assign to the 'DkmProcess.UniqueId' field. This
        // Guid is generated by the port, and is used to uniquely identifies the process
        // object.
        // ppProcess       : [Out] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResumeDebuggedProcess(
            _In_ const GUID& UniqueProcessId,
            _Deref_out_ DkmProcess** ppProcess
            );
    }; // end of DkmProcessLaunchRequest

    // Additional information used to launch a new process. This information is contained
    // within the 'STARTUPINFO' structure in Win32.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9e5881db-f4be-b1eb-2ba5-ed18f73a7979") DkmProcessStartupInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmProcessStartupInfo::Create to create this object
        private: DkmProcessStartupInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessStartupInfo();
        // This object cannot be copied
        private: DkmProcessStartupInfo& operator=(const DkmProcessStartupInfo&);
        private: DkmProcessStartupInfo(const DkmProcessStartupInfo&);

        private: OPTIONAL DkmString* const m_pDesktop;
        private: OPTIONAL DkmString* const m_pTitle;
        private: const UINT32 m_X;
        private: const UINT32 m_Y;
        private: const UINT32 m_XSize;
        private: const UINT32 m_YSize;
        private: const UINT32 m_XCountChars;
        private: const UINT32 m_YCountChars;
        private: const UINT32 m_FillAttribute;
        private: const UINT32 m_Flags;
        private: const UINT16 m_ShowWindow;
        private: const UINT64 m_StdInputHandle;
        private: const UINT64 m_StdOutputHandle;
        private: const UINT64 m_StdErrorHandle;
        private: void* m__pExtendedData;

        // [Optional] The name of the desktop, or the name of both the desktop and window
        // station for this process. A backslash in the string indicates that the string
        // includes both the desktop and window station names. For more information, see
        // Thread Connection to a Desktop.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Desktop(
            );

        // [Optional] For console processes, this is the title displayed in the title bar if
        // a new console window is created. If NULL, the name of the executable file is used
        // as the window title instead. This parameter must be NULL for GUI or console
        // processes that do not create a new console window.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Title(
            );

        // If 'Flags' specifies STARTF_USEPOSITION, this member is the x offset of the upper
        // left corner of a window if a new window is created, in pixels. Otherwise, this
        // member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE X(
            );

        // If 'Flags' specifies STARTF_USEPOSITION, this member is the y offset of the upper
        // left corner of a window if a new window is created, in pixels. Otherwise, this
        // member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Y(
            );

        // If 'Flags' specifies STARTF_USESIZE, this member is the width of the window if a
        // new window is created, in pixels. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE XSize(
            );

        // If 'Flags' specifies STARTF_USESIZE, this member is the height of the window if a
        // new window is created, in pixels. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE YSize(
            );

        // If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a
        // console process, this member specifies the screen buffer width, in character
        // columns. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE XCountChars(
            );

        // If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a
        // console process, this member specifies the screen buffer height, in character
        // rows. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE YCountChars(
            );

        // If 'Flags' specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and
        // background colors if a new console window is created in a console application.
        // Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FillAttribute(
            );

        // 'STARTF_*' flags for this request. More information can be found in Win32
        // documentation under 'STARTUPINFO.dwFlags'.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Flags(
            );

        // If 'Flags' specifies STARTF_USESHOWWINDOW, this member can be any of the values
        // that can be specified in the nCmdShow parameter for the ShowWindow function,
        // except for SW_SHOWDEFAULT. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE ShowWindow(
            );

        // If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard input
        // handle for the process. Otherwise, this value should be zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StdInputHandle(
            );

        // If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard output
        // handle for the process. Otherwise, this value should be zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StdOutputHandle(
            );

        // If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard error
        // handle for the process. Otherwise, this value should be zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StdErrorHandle(
            );

        // Create a new DkmProcessStartupInfo object instance.
        // pDesktop        : [In,Optional] The name of the desktop, or the name of both the
        // desktop and window station for this process. A backslash in the string indicates
        // that the string includes both the desktop and window station names. For more
        // information, see Thread Connection to a Desktop.
        // pTitle          : [In,Optional] For console processes, this is the title displayed
        // in the title bar if a new console window is created. If NULL, the name of the
        // executable file is used as the window title instead. This parameter must be NULL
        // for GUI or console processes that do not create a new console window.
        // X               : [In] If 'Flags' specifies STARTF_USEPOSITION, this member is the
        // x offset of the upper left corner of a window if a new window is created, in
        // pixels. Otherwise, this member is ignored.
        // Y               : [In] If 'Flags' specifies STARTF_USEPOSITION, this member is the
        // y offset of the upper left corner of a window if a new window is created, in
        // pixels. Otherwise, this member is ignored.
        // XSize           : [In] If 'Flags' specifies STARTF_USESIZE, this member is the
        // width of the window if a new window is created, in pixels. Otherwise, this member
        // is ignored.
        // YSize           : [In] If 'Flags' specifies STARTF_USESIZE, this member is the
        // height of the window if a new window is created, in pixels. Otherwise, this member
        // is ignored.
        // XCountChars     : [In] If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console
        // window is created in a console process, this member specifies the screen buffer
        // width, in character columns. Otherwise, this member is ignored.
        // YCountChars     : [In] If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console
        // window is created in a console process, this member specifies the screen buffer
        // height, in character rows. Otherwise, this member is ignored.
        // FillAttribute   : [In] If 'Flags' specifies STARTF_USEFILLATTRIBUTE, this member
        // is the initial text and background colors if a new console window is created in a
        // console application. Otherwise, this member is ignored.
        // Flags           : [In] 'STARTF_*' flags for this request. More information can be
        // found in Win32 documentation under 'STARTUPINFO.dwFlags'.
        // ShowWindow      : [In] If 'Flags' specifies STARTF_USESHOWWINDOW, this member can
        // be any of the values that can be specified in the nCmdShow parameter for the
        // ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is ignored.
        // StdInputHandle  : [In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is
        // the standard input handle for the process. Otherwise, this value should be zero.
        // StdOutputHandle : [In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is
        // the standard output handle for the process. Otherwise, this value should be zero.
        // StdErrorHandle  : [In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is
        // the standard error handle for the process. Otherwise, this value should be zero.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmString* pDesktop,
            _In_opt_ DkmString* pTitle,
            _In_ UINT32 X,
            _In_ UINT32 Y,
            _In_ UINT32 XSize,
            _In_ UINT32 YSize,
            _In_ UINT32 XCountChars,
            _In_ UINT32 YCountChars,
            _In_ UINT32 FillAttribute,
            _In_ UINT32 Flags,
            _In_ UINT16 ShowWindow,
            _In_ UINT64 StdInputHandle,
            _In_ UINT64 StdOutputHandle,
            _In_ UINT64 StdErrorHandle,
            _Deref_out_ Start::DkmProcessStartupInfo** ppCreatedObject
            );
    }; // end of DkmProcessStartupInfo

    // DkmStartMethod describes how the debug engine started debugging this process.
    enum DkmStartMethod::e
    {
        // Process was launched under the debugger.
        Launch = 0,
        // Process was launched outside the debugger and the debugger attached.
        Attach = 1,
        // Process was launched suspended by the project system or SDM. Then the engine was
        // asked to attach to the process while the process was still at the initial
        // suspension point. This is used for Low-rights IE (LoRIE).
        AttachForSuspendedLaunch = 2,
        // Hosting process was launched by the project system and then the project system
        // asked the debugger to attach to the process.
        AttachForHostingLaunch = 3
    };

}; // end namespace Start

// Contains types used to perform the basic, generally pre-debugging, tasks on the target
// computer such as listing processes, deploying files, etc.
namespace DefaultPort {
    // Result of an asynchronous DkmTransportConnection.ActivateBackgroundTask call.
    struct DkmActivateBackgroundTaskAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Identifies a Windows Store app package or Windows Phone app package.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("40f5e02e-bbc4-3b2a-5595-51d3208fb72f") DkmAppPackageId : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmAppPackageId::Create to create this object
        private: DkmAppPackageId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmAppPackageId();
        // This object cannot be copied
        private: DkmAppPackageId& operator=(const DkmAppPackageId&);
        private: DkmAppPackageId(const DkmAppPackageId&);

        private: const DefaultPort::DkmPackagedAppPlatform::e m_AppPlatform;
        private: DkmString* const m_pFullName;
        private: void* m__pExtendedData;

        // Indicates if the specified application package is a Windows Phone or Windows Store
        // app.
        public: DECLSPEC_NOTHROW DefaultPort::DkmPackagedAppPlatform::e STDMETHODCALLTYPE AppPlatform(
            );

        // The full name of the application. For DkmApplicationPlatform.WindowsAppx, this is
        // the package full name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Create a new DkmAppPackageId object instance.
        // AppPlatform     : [In] Indicates if the specified application package is a Windows
        // Phone or Windows Store app.
        // pFullName       : [In] The full name of the application. For
        // DkmApplicationPlatform.WindowsAppx, this is the package full name.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmPackagedAppPlatform::e AppPlatform,
            _In_ DkmString* pFullName,
            _Deref_out_ DefaultPort::DkmAppPackageId** ppCreatedObject
            );
    }; // end of DkmAppPackageId

    // Object representing an arbitrary executable which is executed on the target computer.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("301484b2-442b-a6f7-f258-48db3d9d121a") DkmDeploymentCommand : public DkmDataContainer
    {
        // Use DkmDeploymentCommand::Create to create this object
        private: DkmDeploymentCommand();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDeploymentCommand();
        // This object cannot be copied
        private: DkmDeploymentCommand& operator=(const DkmDeploymentCommand&);
        private: DkmDeploymentCommand(const DkmDeploymentCommand&);

        private: const GUID m_UniqueId;
        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: const GUID m_SourceId;
        private: DkmString* const m_pRemoteExecutable;
        private: OPTIONAL DkmString* const m_pArguments;
        private: OPTIONAL DkmString* const m_pCurrentDirectory;
        private: const DefaultPort::DkmDeploymentCommandFlags::e m_Flags;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Transport connection to the target where the command should execute.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Path to the remote executable. Environment variables will be expanded (ex:
        // %TMP%\mycommand.exe). If this is not a full path, the remote debugger will look
        // next to itself, and then search the PATH environment variable.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RemoteExecutable(
            );

        // [Optional] Arguments to pass to the remote command. This value may be null to pass
        // no arguments.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Arguments(
            );

        // [Optional] Initial current directory for the target process. This value may be
        // null to use the directory of the remote debugger.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CurrentDirectory(
            );

        // Flags effecting the processing of deployment commands.
        public: DECLSPEC_NOTHROW DefaultPort::DkmDeploymentCommandFlags::e STDMETHODCALLTYPE Flags(
            );

        // Closes the deployment command object. This should be called by the creator of the
        // DkmDeploymentCommand object after execution has completed
        // (IDkmDeploymentCommandCallback.OnProcessExit is called).
        //
        // DkmDeploymentCommand objects are automatically closed when their associated
        // DkmTransportConnection object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Creates a new DkmDeploymentCommand object. The command will not begin executing
        // until Start is called. The caller is responsible for closing the created object
        // after they are done.
        // pConnection     : [In] Transport connection to the target where the command should
        // execute.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pRemoteExecutable: [In] Path to the remote executable. Environment variables will
        // be expanded (ex: %TMP%\mycommand.exe). If this is not a full path, the remote
        // debugger will look next to itself, and then search the PATH environment variable.
        // pArguments      : [In,Optional] Arguments to pass to the remote command. This
        // value may be null to pass no arguments.
        // pCurrentDirectory: [In,Optional] Initial current directory for the target process.
        // This value may be null to use the directory of the remote debugger.
        // Flags           : [In] Flags effecting the processing of deployment commands.
        // DataItem        : [In] Data object to add to the new DkmDeploymentCommand
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ const GUID& SourceId,
            _In_ DkmString* pRemoteExecutable,
            _In_opt_ DkmString* pArguments,
            _In_opt_ DkmString* pCurrentDirectory,
            _In_ DefaultPort::DkmDeploymentCommandFlags::e Flags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ DefaultPort::DkmDeploymentCommand** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Indication that the launched command has completed. After this is received, no
        // further notifications will be sent.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ExitCode        : [In] 32-bit value which the processed returned on exit. This is
        // the same value that would be reported from the kernel32!GetExitCodeProcess.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnProcessExit(
            _In_ UINT32 ExitCode
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Indication that the target wrote to stdout. This is also used for StdErr if the
        // DkmDeploymentCommandFlags.CombineStdErr flag is used.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pText           : [In] Text written to stdout.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStdOut(
            _In_ DkmString* pText
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Indication that the target wrote to stderr. This will not be used if the
        // DkmDeploymentCommandFlags.CombineStdErr flag is used. Note that the output from
        // stderr and stdout is not synchronized, so if a program writes to stdout before
        // stderr, a listener may still get the stderr output first (or vice versa).
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pText           : [In] Text written to stderr.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStdErr(
            _In_ DkmString* pText
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // Begin execution of the deployment command. This method will return once the
        // deployed command has begun execution. Callers of this method would typically
        // implement IDkmDeploymentCommandCallback with a SourceId filter to receive
        // information about the command.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Start(
            );

        // Abort execution of the command by terminating the launched process. If successful,
        // this will cause IDkmDeploymentCommandCallback.OnProcessExit to be called.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Abort(
            );
    }; // end of DkmDeploymentCommand

    // Flags effecting the processing of deployment commands.
    enum DkmDeploymentCommandFlags::e
    {
        // No flags are set.
        Default = 0x0,
        // Launched program writes to StdOut/StdErr with the target computer's console code
        // page rather than Unicode (UTF-16).
        ConsoleCodePage = 0x1,
        // Combine StdErr with StdOut. When this flag is set,
        // IDkmDeploymentCommandCallback.OnStdErr will not be called. This is helpful to
        // synchronize StdErr/StdOut content.
        CombineStdErr = 0x2,
        // Show the UI for the executed command instead of running hidden.
        ShowUI = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmDeploymentCommandFlags::e);

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Result of an asynchronous DkmTransportConnection.DownloadFile call.
    struct DkmDownloadFileAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Result of an asynchronous DkmTransportConnection.EnumerateBackgroundTasks call.
    struct DkmEnumerateBackgroundTasksAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Background task ids (GUIDs).
        DkmArray<GUID> TaskIds;

        // Background task names.
        DkmArray<DkmString*> TaskNames;
    };

    // Contains basic information about a file which is returned from
    // DefaultPort.DkmTransportConnection.GetFileListing.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c255d11c-e40f-9be0-11ac-0f5da8427782") DkmFileInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmFileInfo::Create to create this object
        private: DkmFileInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFileInfo();
        // This object cannot be copied
        private: DkmFileInfo& operator=(const DkmFileInfo&);
        private: DkmFileInfo(const DkmFileInfo&);

        private: DkmString* const m_pFileName;
        private: DkmString* const m_pFilePath;
        private: const UINT32 m_Attributes;
        private: const UINT64 m_CreationTime;
        private: const UINT64 m_LastAccessTime;
        private: const UINT64 m_LastWriteTime;
        private: const UINT64 m_FileSize;
        private: void* m__pExtendedData;

        // Name of the file or sub directory. This name does not contain the directory (ex:
        // example.txt instead of c:\folder\example.txt).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FileName(
            );

        // Full path to the file or sub directory (ex: c:\folder\example.txt).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FilePath(
            );

        // Win32 File attribute values (ex: FILE_ATTRIBUTE_DIRECTORY (0x10)).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Attributes(
            );

        // Time the the file was created in FILETIME units (number of 100-nanosecond
        // intervals since January 1, 1601 (UTC)).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE CreationTime(
            );

        // Time the file was accessed in FILETIME units (number of 100-nanosecond intervals
        // since January 1, 1601 (UTC)).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE LastAccessTime(
            );

        // Time the file was written to in FILETIME units (number of 100-nanosecond intervals
        // since January 1, 1601 (UTC)).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE LastWriteTime(
            );

        // Size of the file in bytes.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FileSize(
            );

        // Create a new DkmFileInfo object instance.
        // pFileName       : [In] Name of the file or sub directory. This name does not
        // contain the directory (ex: example.txt instead of c:\folder\example.txt).
        // pFilePath       : [In] Full path to the file or sub directory (ex:
        // c:\folder\example.txt).
        // Attributes      : [In] Win32 File attribute values (ex: FILE_ATTRIBUTE_DIRECTORY
        // (0x10)).
        // CreationTime    : [In] Time the the file was created in FILETIME units (number of
        // 100-nanosecond intervals since January 1, 1601 (UTC)).
        // LastAccessTime  : [In] Time the file was accessed in FILETIME units (number of
        // 100-nanosecond intervals since January 1, 1601 (UTC)).
        // LastWriteTime   : [In] Time the file was written to in FILETIME units (number of
        // 100-nanosecond intervals since January 1, 1601 (UTC)).
        // FileSize        : [In] Size of the file in bytes.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pFileName,
            _In_ DkmString* pFilePath,
            _In_ UINT32 Attributes,
            _In_ UINT64 CreationTime,
            _In_ UINT64 LastAccessTime,
            _In_ UINT64 LastWriteTime,
            _In_ UINT64 FileSize,
            _Deref_out_ DefaultPort::DkmFileInfo** ppCreatedObject
            );
    }; // end of DkmFileInfo

    // Represents a file stream which can be used to transfer a large file over the remote
    // debugger connection.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("cfeabf40-7ab2-7d44-c16d-ef23d4579e8c") DkmFileTransferStream : public DkmDataContainer
    {
        // Use DkmFileTransferStream::Create to create this object
        private: DkmFileTransferStream();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFileTransferStream();
        // This object cannot be copied
        private: DkmFileTransferStream& operator=(const DkmFileTransferStream&);
        private: DkmFileTransferStream(const DkmFileTransferStream&);

        private: const GUID m_UniqueId;
        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: DkmString* const m_pRemoteFilePath;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Transport connection over which the file will be transferred.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Path to the file being transferred. Environment variables will be expanded (ex:
        // %TMP%\deploy.txt). The path must be a full path to the file.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RemoteFilePath(
            );

        // Closes the file transfer object. This will close the underlying file handle if it
        // is not already closed because all the bytes have been transferred. This method
        // must be called by the component which created the file file transfer object.
        //
        // DkmFileTransferStream objects are automatically closed when their associated
        // DkmTransportConnection object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Creates a new file transfer stream object which is used to represent a file which
        // is being streamed over the network. Note that the file is not immediately opened
        // when the object is created. The caller should close the file transfer object when
        // done. The caller is responsible for closing the created object after they are
        // done.
        // pConnection     : [In] Transport connection over which the file will be
        // transferred.
        // pRemoteFilePath : [In] Path to the file being transferred. Environment variables
        // will be expanded (ex: %TMP%\deploy.txt). The path must be a full path to the file.
        // DataItem        : [In] Data object to add to the new DkmFileTransferStream
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pRemoteFilePath,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ DefaultPort::DkmFileTransferStream** ppCreatedObject
            );

        // Begins a remote file write operation. The remote file will be opened and the bytes
        // from Content will be written to it. If additional bytes beyond what is in Content
        // should be transferred, then WriteNext should be called to transfer those. If the
        // directory of this file does not exist, the debugger will attempt to create it.
        // Content         : [In] The initial set of bytes to write to the file.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // TotalFileSize   : [In] Indicates the number of bytes which will be written to the
        // file. The file system handle will automatically be closed once this number of
        // bytes has been received. Attempts to write past this number of bytes will fail. If
        // the DkmFileTransferStream is closed before this number of bytes is transferred,
        // the file will be deleted.
        // LastWriteTime   : [In] The date/time to set for when this file was last modified.
        // The format of this is the same as a Win32 FILETIME structure, which is a 64-bit
        // value representing the number of 100-nanosecond intervals since January 1, 1601.
        // The value 0xffffffffffffffff may be used to specify that the current time should
        // be used.
        // OverwriteExisting: [In] true if the debugger should attempt to overwrite any
        // existing file. This will fail if the existing file is read-only.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteFirst(
            _In_ const DkmArray<BYTE>& Content,
            _In_ UINT64 TotalFileSize,
            _In_ UINT64 LastWriteTime,
            _In_ bool OverwriteExisting
            );

        // Writes the next set of bytes to the remote file. This API will fail if WriteFirst
        // has not already been called on the DkmFileTransferStream.
        // Content         : [In] The next set of bytes to write to the file.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteNext(
            _In_ const DkmArray<BYTE>& Content
            );

        // Begins a remote file read operation. The remote file will be opened and bytes up
        // to the size of the content buffer will be transferred. If the file is too large to
        // fit into the content buffer, than ReadNext can be called to read the remaining
        // bytes.
        // pContentBuffer  : [In,Out] Buffer which receives the starting bytes of the file.
        // BufferSize      : [In] Indicates the size of the content buffer.
        // pBytesRead      : [Out,Optional] Indicates the number of bytes read into the
        // content buffer. This will be the minimum of the file size and the buffer size.
        // pLastWriteTime  : [Out] The date/time to set for when this file was last modified.
        // The format of this is the same as a Win32 FILETIME structure, which is a 64-bit
        // value representing the number of 100-nanosecond intervals since January 1, 1601.
        // pTotalFileSize  : [Out] Indicates the size of the file on disk.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadFirst(
            _Out_capcount_(BufferSize) void* pContentBuffer,
            _In_ UINT32 BufferSize,
            _Out_ UINT32* pBytesRead,
            _Out_ UINT64* pLastWriteTime,
            _Out_ UINT64* pTotalFileSize
            );

        // Reads the next set of bytes from the remote file. This API will fail if ReadFirst
        // has not already been called on the DkmFileTransferStream.
        // pContentBuffer  : [In,Out] Buffer which receives the next bytes of the file.
        // BufferSize      : [In] Indicates the size of the content buffer.
        // pBytesRead      : [Out,Optional] Indicates the number of bytes read into the
        // content buffer. This value is the smaller of the number of bytes left in the file
        // (TotalFileSize returned from ReadFirst minus bytes already returned), and the size
        // of the input buffer. In pseudo-code: min(TotalFileSize-BytesAlreadyReturned,
        // BufferSize).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadNext(
            _Out_capcount_(BufferSize) void* pContentBuffer,
            _In_ UINT32 BufferSize,
            _Out_ UINT32* pBytesRead
            );
    }; // end of DkmFileTransferStream

    // Identifies an installed Windows Store App Package.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("686d56ce-05cf-f74b-c723-7b0b4e2cd09d") DkmInstalledAppPackageInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInstalledAppPackageInfo::Create to create this object
        private: DkmInstalledAppPackageInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInstalledAppPackageInfo();
        // This object cannot be copied
        private: DkmInstalledAppPackageInfo& operator=(const DkmInstalledAppPackageInfo&);
        private: DkmInstalledAppPackageInfo(const DkmInstalledAppPackageInfo&);

        private: DefaultPort::DkmAppPackageId* const m_pAppPackageId;
        private: DkmString* const m_pDisplayName;
        private: DkmString* const m_pVersion;
        private: OPTIONAL DkmString* const m_pLogoPath;
        private: OPTIONAL DkmReadOnlyCollection<DefaultPort::DkmInstalledApplicationInfo*>* const m_pApplications;
        private: void* m__pExtendedData;

        // Identifies a Windows Store app package or Windows Phone app package.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE AppPackageId(
            );

        // The App Package display name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DisplayName(
            );

        // The App Package version.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Version(
            );

        // [Optional] The App Package logo path. For remote this will be the path on the
        // remote system.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE LogoPath(
            );

        // [Optional] Array of applications found in the App Package.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DefaultPort::DkmInstalledApplicationInfo*>* STDMETHODCALLTYPE Applications(
            );

        // Create a new DkmInstalledAppPackageInfo object instance.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // pDisplayName    : [In] The App Package display name.
        // pVersion        : [In] The App Package version.
        // pLogoPath       : [In,Optional] The App Package logo path. For remote this will be
        // the path on the remote system.
        // pApplications   : [In,Optional] Array of applications found in the App Package.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ DkmString* pDisplayName,
            _In_ DkmString* pVersion,
            _In_opt_ DkmString* pLogoPath,
            _In_opt_ DkmReadOnlyCollection<DefaultPort::DkmInstalledApplicationInfo*>* pApplications,
            _Deref_out_ DefaultPort::DkmInstalledAppPackageInfo** ppCreatedObject
            );
    }; // end of DkmInstalledAppPackageInfo

    // Identifies an installed Windows Store App.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("220918fc-b335-72c8-16d2-4bfeaceee181") DkmInstalledApplicationInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInstalledApplicationInfo::Create to create this object
        private: DkmInstalledApplicationInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInstalledApplicationInfo();
        // This object cannot be copied
        private: DkmInstalledApplicationInfo& operator=(const DkmInstalledApplicationInfo&);
        private: DkmInstalledApplicationInfo(const DkmInstalledApplicationInfo&);

        private: DkmString* const m_pAppUserModelId;
        private: DkmString* const m_pDisplayName;
        private: OPTIONAL DkmString* const m_pExecutable;
        private: OPTIONAL DkmString* const m_pSmallLogoPath;
        private: OPTIONAL DkmString* const m_pBackgroundColor;
        private: DkmString* const m_pDescription;
        private: const GUID m_DefaultDebugEngine;
        private: void* m__pExtendedData;

        // The app user model id.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AppUserModelId(
            );

        // The application display name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DisplayName(
            );

        // [Optional] The executable name.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Executable(
            );

        // [Optional] The application small logo path. For remote this will be the path on
        // the remote system.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SmallLogoPath(
            );

        // [Optional] The application background color.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE BackgroundColor(
            );

        // The application description name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // The default debug engine to use for debugging this app.  If unable to determine,
        // the default is native.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE DefaultDebugEngine(
            );

        // Create a new DkmInstalledApplicationInfo object instance.
        // pAppUserModelId : [In] The app user model id.
        // pDisplayName    : [In] The application display name.
        // pExecutable     : [In,Optional] The executable name.
        // pSmallLogoPath  : [In,Optional] The application small logo path. For remote this
        // will be the path on the remote system.
        // pBackgroundColor: [In,Optional] The application background color.
        // pDescription    : [In] The application description name.
        // DefaultDebugEngine: [In] The default debug engine to use for debugging this app.
        // If unable to determine, the default is native.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pAppUserModelId,
            _In_ DkmString* pDisplayName,
            _In_opt_ DkmString* pExecutable,
            _In_opt_ DkmString* pSmallLogoPath,
            _In_opt_ DkmString* pBackgroundColor,
            _In_ DkmString* pDescription,
            _In_ const GUID& DefaultDebugEngine,
            _Deref_out_ DefaultPort::DkmInstalledApplicationInfo** ppCreatedObject
            );
    }; // end of DkmInstalledApplicationInfo

    // Describes the application package's current execution state. For Windows Store apps,
    // the values match the values in PACKAGE_EXECUTION_STATE.
    enum DkmPackageExecutionState::e
    {
        // The application's state is unknown.
        Unknown = 0,
        // The application is running.
        Running = 1,
        // The application is being suspended.
        Suspending = 2,
        // The application is suspended.
        Suspended = 3,
        // The application is terminated.
        Terminated = 4
    };

    // Indicates if the specified application package is a Windows Phone or Windows Store
    // app.
    enum DkmPackagedAppPlatform::e
    {
        // Used for Windows Store app.
        WindowsAppx = 0,
        // Used for Windows Phone XAP applications.
        WindowsPhoneXAP = 1
    };

    // Flags indicating features which are available in the processor on which this
    // system/process/thread is running. These generally deal with register set availability.
    enum DkmProcessorFeatures::e
    {
        // Processor does not support any additional features.
        None = 0x0,
        // On X86, used to indicate that the CPU supports MMX registers.
        MMX = 0x1,
        // On X86, used to indicate that the CPU supports SSE registers.
        SSE = 0x2,
        // On X86, used to indicate that the CPU supports SSE2 registers.
        SSE2 = 0x4,
        // On X86, used to indicate that the CPU supports 3DNow! registers.
        AMD3DNow = 0x8,
        // On X86/X64, used to indicate that the CPU supports AVX registers.
        AVX = 0x10,
        // On ARM, used to indicate that the CPU supports the full set of floating-point
        // registers (Q0-Q15, D0-D31, and S0-S63, ).  On arm, when this flag is cleared, the
        // only supported floating-point registers include Q0-Q3, D0-D7, and S0-S15.
        VFP32 = 0x20
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmProcessorFeatures::e);

    // Contains information about active script code running in the target process, or other
    // information published through CLSID_ProgramPublisher
    // (IDebugProgramPublisher2.PublishProgram/PublishProgramNode).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("eaeb3217-af01-dcda-7d08-2cabbddc2351") DkmPublishedProgramInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmPublishedProgramInfo::Create to create this object
        private: DkmPublishedProgramInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPublishedProgramInfo();
        // This object cannot be copied
        private: DkmPublishedProgramInfo& operator=(const DkmPublishedProgramInfo&);
        private: DkmPublishedProgramInfo(const DkmPublishedProgramInfo&);

        private: OPTIONAL DkmString* const m_pFriendlyName;
        private: DkmReadOnlyCollection<GUID>* const m_pEngineIds;
        private: void* m__pExtendedData;

        // [Optional] A friendly name for the program. This may be displayed in the attach to
        // processes window. This is exposed to the AD7 API via
        // IDebugProgramNode2.GetHostName(GHN_FRIENDLY_NAME).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FriendlyName(
            );

        // The collection of engines which are capable of debugging this code. Generally,
        // this collection only has one entry. For script, this value is DkmEngineId.Script.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE EngineIds(
            );

        // Create a new DkmPublishedProgramInfo object instance.
        // pFriendlyName   : [In,Optional] A friendly name for the program. This may be
        // displayed in the attach to processes window. This is exposed to the AD7 API via
        // IDebugProgramNode2.GetHostName(GHN_FRIENDLY_NAME).
        // pEngineIds      : [In] The collection of engines which are capable of debugging
        // this code. Generally, this collection only has one entry. For script, this value
        // is DkmEngineId.Script.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmString* pFriendlyName,
            _In_ DkmReadOnlyCollection<GUID>* pEngineIds,
            _Deref_out_ DefaultPort::DkmPublishedProgramInfo** ppCreatedObject
            );
    }; // end of DkmPublishedProgramInfo

    // Authentication mode to use when connecting over a standard remote connection.
    enum DkmRemoteAuthenticationMode::e
    {
        // Use built-in Windows authentication. Client and server will negotiate either
        // Kerberos or NTLM. This is the default value.
        WindowsNegotiate = 0,
        // Use built-in Windows Kerberos Authentication.
        Kerberos = 1,
        // Use built-in NTLM authentication. This option can be used when Kerberos is
        // malfunctioning.
        NTLM = 2,
        // Disable authentication. This value can only be used on trusted networks.
        None = 3,
        // Other form of authentication used by a custom transport.
        Custom = 4
    };

    // Flags containing Boolean properties of the running process.
    enum DkmRunningProcessFlags::e
    {
        // Default value for DkmRunningProcessFlags.
        None = 0x0,
        // Process is a 32-bit process running on a 64-bit computer. This is computed when
        // DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        Wow64 = 0x1,
        // There is a Win32 debugger attached to the process. This is computed when
        // DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        DebuggerAttached = 0x2,
        // Process is running under a different user account than the debug monitor.
        OtherUser = 0x4,
        // A security warning should be displayed before attaching to this process.
        SecurityWarningOnAttach = 0x8,
        // Process is running in AppContainer.
        AppContainer = 0x10,
        // Process should be hidden in the process listing unless the user wants all
        // processes to be shown. This is computed when
        // DkmRunningProcessInfoPropertyMask.FilterFlags is set.
        HideFromDefaultProcessList = 0x20,
        // The runtime used to execute native-compiled .NET Framework code is loaded in the
        // target process. This is computed when
        // DkmRunningProcessInfoPropertyMask.ClrVersions is specified.
        ClrNativeCompilationRuntimeLoaded = 0x40
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmRunningProcessFlags::e);

    // Snapshot of basic information about a running process. Unlike DkmProcess, this
    // information is for a process which is not necessarily being debugged. This can either
    // be returned as part of a task list, or information can be returned for a single
    // process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7b99a64-a129-3356-e276-1a7873905ceb") DkmRunningProcessInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmRunningProcessInfo::Create to create this object
        private: DkmRunningProcessInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRunningProcessInfo();
        // This object cannot be copied
        private: DkmRunningProcessInfo& operator=(const DkmRunningProcessInfo&);
        private: DkmRunningProcessInfo(const DkmRunningProcessInfo&);

        private: const UINT32 m_Id;
        private: const UINT64 m_StartTime;
        private: const UINT32 m_SessionId;
        private: OPTIONAL DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pTitle;
        private: OPTIONAL DkmString* const m_pUserName;
        private: OPTIONAL DkmReadOnlyCollection<DkmString*>* const m_pClrVersions;
        private: OPTIONAL DkmString* const m_pCommandLine;
        private: OPTIONAL DkmString* const m_pCurrentDirectory;
        private: OPTIONAL DkmString* const m_pEnvironmentBlock;
        private: const UINT32 m_IntegrityLevel;
        private: OPTIONAL DkmReadOnlyCollection<DefaultPort::DkmPublishedProgramInfo*>* const m_pPublishedPrograms;
        private: const DefaultPort::DkmRunningProcessFlags::e m_Flags;
        private: const UINT16 m_ProcessorArchitecture;
        private: OPTIONAL DefaultPort::DkmAppPackageId* const m_pAppPackageId;
        private: void* m__pExtendedData;

        // Process Id (PID) assigned by the operating system.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StartTime(
            );

        // Terminal server session id for the process (-1 if not obtained).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE SessionId(
            );

        // [Optional] Full path to the starting executable of the process. If the full path
        // cannot be obtained, this may only contain the base executable name.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Title of the process's main window (if any).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Title(
            );

        // [Optional] User name that the process is running under (ex: MyCompany\MyAlias).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE UserName(
            );

        // [Optional] Version number for all the CLR instances loaded into the debugged
        // process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE ClrVersions(
            );

        // [Optional] Command line used to start the process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CommandLine(
            );

        // [Optional] Current directory of the process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CurrentDirectory(
            );

        // [Optional] Environment block of the process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE EnvironmentBlock(
            );

        // SECURITY_MANDATORY_*_RID value used to indicate the integrity level of this
        // process. -1/MAXDWORD is used if the integrity level is unknown/invalid such as on
        // pre-Vista operating systems where integrity levels do not exist, or if the user
        // identity of process could not be obtained.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE IntegrityLevel(
            );

        // [Optional] The set of programs which have been published for this process through
        // pdm.dll. This primarily is used to determine script debugging information but may
        // also be used for other runtimes that notify the debugger of their existence
        // through CLSID_ProgramPublisher.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DefaultPort::DkmPublishedProgramInfo*>* STDMETHODCALLTYPE PublishedPrograms(
            );

        // Flags containing Boolean properties of the running process.
        public: DECLSPEC_NOTHROW DefaultPort::DkmRunningProcessFlags::e STDMETHODCALLTYPE Flags(
            );

        // Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or
        // PROCESSOR_ARCHITECTURE_AMD64 (9).  This is computed when
        // DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE ProcessorArchitecture(
            );

        // [Optional] The id of the application package for this process. Null if the process
        // is not part of a Windows Store app, or Windows Phone application. This is computed
        // when DkmRunningProcessInfoPropertyMask.AppPackageId is set.
        public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE AppPackageId(
            );

        // Create a new DkmRunningProcessInfo object instance.
        // Id              : [In] Process Id (PID) assigned by the operating system.
        // StartTime       : [In] 64-bit date time value indicating when the process was
        // started. The start time along with the id and the machine where the process was
        // started can uniquely identify a process.
        // SessionId       : [In] Terminal server session id for the process (-1 if not
        // obtained).
        // pName           : [In,Optional] Full path to the starting executable of the
        // process. If the full path cannot be obtained, this may only contain the base
        // executable name.
        // pTitle          : [In,Optional] Title of the process's main window (if any).
        // pUserName       : [In,Optional] User name that the process is running under (ex:
        // MyCompany\MyAlias).
        // pClrVersions    : [In,Optional] Version number for all the CLR instances loaded
        // into the debugged process.
        // pCommandLine    : [In,Optional] Command line used to start the process.
        // pCurrentDirectory: [In,Optional] Current directory of the process.
        // pEnvironmentBlock: [In,Optional] Environment block of the process.
        // IntegrityLevel  : [In] SECURITY_MANDATORY_*_RID value used to indicate the
        // integrity level of this process. -1/MAXDWORD is used if the integrity level is
        // unknown/invalid such as on pre-Vista operating systems where integrity levels do
        // not exist, or if the user identity of process could not be obtained.
        // pPublishedPrograms: [In,Optional] The set of programs which have been published
        // for this process through pdm.dll. This primarily is used to determine script
        // debugging information but may also be used for other runtimes that notify the
        // debugger of their existence through CLSID_ProgramPublisher.
        // Flags           : [In] Flags containing Boolean properties of the running process.
        // ProcessorArchitecture: [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0),
        // PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9).  This is
        // computed when DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        // pAppPackageId   : [In,Optional] The id of the application package for this
        // process. Null if the process is not part of a Windows Store app, or Windows Phone
        // application. This is computed when DkmRunningProcessInfoPropertyMask.AppPackageId
        // is set.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ UINT32 SessionId,
            _In_opt_ DkmString* pName,
            _In_opt_ DkmString* pTitle,
            _In_opt_ DkmString* pUserName,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pClrVersions,
            _In_opt_ DkmString* pCommandLine,
            _In_opt_ DkmString* pCurrentDirectory,
            _In_opt_ DkmString* pEnvironmentBlock,
            _In_ UINT32 IntegrityLevel,
            _In_opt_ DkmReadOnlyCollection<DefaultPort::DkmPublishedProgramInfo*>* pPublishedPrograms,
            _In_ DefaultPort::DkmRunningProcessFlags::e Flags,
            _In_ UINT16 ProcessorArchitecture,
            _In_opt_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppCreatedObject
            );
    }; // end of DkmRunningProcessInfo

    // Flags indicating which properties of DkmRunningProcessInfo should be computed.
    enum DkmRunningProcessInfoPropertyMask::e
    {
        // No information should be computed.
        Empty = 0x0,
        // 'StartTime' field should be computed.
        StartTime = 0x1,
        // 'SessionId' field should be computed.
        SessionId = 0x2,
        // 'Name' field should be computed.
        Name = 0x4,
        // 'Title' field should be computed.
        Title = 0x8,
        // 'UserName' field should be computed.
        UserName = 0x10,
        // Compute the 'ClrVersions' field and
        // 'DkmRunningProcessFlags.ClrNativeCompilationRuntimeLoaded'.
        ClrVersions = 0x20,
        // 'CommandLine' field should be computed.
        CommandLine = 0x40,
        // 'CurrentDirectory' field should be computed.
        CurrentDirectory = 0x80,
        // 'EnvironmentBlock' field should be computed.
        EnvironmentBlock = 0x100,
        // 'IntegrityLevel' field should be computed.
        IntegrityLevel = 0x200,
        // 'DkmRunningProcessFlags.Wow64' and 'DkmRunningProcessFlags.DebuggerAttached'
        // should be computed.
        BasicInfoFlags = 0x400,
        // 'DkmRunningProcessFlags.OtherUser' and
        // 'DkmRunningProcessFlags.SecurityWarningOnAttach' should be computed.
        UserIdentityFlags = 0x800,
        // 'DkmRunningProcessFlags.HideFromDefaultProcessList' should be computed.
        FilterFlags = 0x1000,
        // PublishedPrograms field should be computed.
        PublishedPrograms = 0x2000,
        // 'AppPackageId' field should be computed.
        AppPackageId = 0x4000
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmRunningProcessInfoPropertyMask::e);

    // Result of an asynchronous DkmTransportConnection.ShutDownAppPackage call.
    struct DkmShutDownAppPackageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmTransportConnection.SuspendAppPackage call.
    struct DkmSuspendAppPackageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Contains information about the computer system that a process or connection is using.
    // It can be obtained through the 'SystemInformation' property of a process, or from
    // DefaultPort.DkmTransportConnection.GetSystemInformation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0b539dba-077a-7055-b78c-44e3b1d35bba") DkmSystemInformation : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSystemInformation::Create to create this object
        private: DkmSystemInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSystemInformation();
        // This object cannot be copied
        private: DkmSystemInformation& operator=(const DkmSystemInformation&);
        private: DkmSystemInformation(const DkmSystemInformation&);

        // Contains additional fields of DkmSystemInformation which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // If dump debugging, specifies the MINIDUMP_TYPE flags of the mini dump being
            // debugged.  If live debugging, this value is always zero.
            const MINIDUMP_TYPE MinidumpFlags;

            // [Optional] The path of the system directory.  For both 32-bit and 64-bit
            // Windows, this value is typically C:\Windows\System32.
            OPTIONAL DkmString* const pSystemDirectory;

            // [Optional] The path of the WOW64 system directory.  This value is typically
            // C:\Windows\SysWOW64. On 32-bit Windows, this value will be NULL.
            OPTIONAL DkmString* const pSystemWow64Directory;
        };

        private: const UINT16 m_ProcessorArchitecture;
        private: const UINT32 m_PageSize;
        private: const UINT32 m_OperatingSystemVersion;
        private: const UINT16 m_SuiteMask;
        private: const DefaultPort::DkmSystemInformationFlags::e m_Flags;
        private: const DefaultPort::DkmProcessorFeatures::e m_ProcessorFeatures;
        private: ___ExtendedData* const m__pExtendedData;

        // Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or
        // PROCESSOR_ARCHITECTURE_AMD64 (9).
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE ProcessorArchitecture(
            );

        // Minimum size for a virtual memory page. This value may be zero in remote device
        // scenarios where the page size is unknown.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE PageSize(
            );

        // 4-byte value containing the operating system version packed as {platform id, major
        // version, minor version, service pack major version}. The platform id from the
        // OSVERSIONINFO structure and is currently always defined to VER_PLATFORM_WIN32_NT
        // (2).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE OperatingSystemVersion(
            );

        // VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE SuiteMask(
            );

        // Flags which provide information about the system that a computer system that a
        // process/thread/connection is using.
        public: DECLSPEC_NOTHROW DefaultPort::DkmSystemInformationFlags::e STDMETHODCALLTYPE Flags(
            );

        // Flags indicating features which are available in the processor on which this
        // system/process/thread is running. These generally deal with register set
        // availability.
        public: DECLSPEC_NOTHROW DefaultPort::DkmProcessorFeatures::e STDMETHODCALLTYPE ProcessorFeatures(
            );

        // If dump debugging, specifies the MINIDUMP_TYPE flags of the mini dump being
        // debugged.  If live debugging, this value is always zero.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW MINIDUMP_TYPE STDMETHODCALLTYPE MinidumpFlags(
            );

        // [Optional] The path of the system directory.  For both 32-bit and 64-bit Windows,
        // this value is typically C:\Windows\System32.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SystemDirectory(
            );

        // [Optional] The path of the WOW64 system directory.  This value is typically
        // C:\Windows\SysWOW64. On 32-bit Windows, this value will be NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SystemWow64Directory(
            );

        // Create a new DkmSystemInformation object instance.
        // ProcessorArchitecture: [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0),
        // PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9).
        // PageSize        : [In] Minimum size for a virtual memory page. This value may be
        // zero in remote device scenarios where the page size is unknown.
        // OperatingSystemVersion: [In] 4-byte value containing the operating system version
        // packed as {platform id, major version, minor version, service pack major version}.
        // The platform id from the OSVERSIONINFO structure and is currently always defined
        // to VER_PLATFORM_WIN32_NT (2).
        // SuiteMask       : [In] VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        // Flags           : [In] Flags which provide information about the system that a
        // computer system that a process/thread/connection is using.
        // ProcessorFeatures: [In] Flags indicating features which are available in the
        // processor on which this system/process/thread is running. These generally deal
        // with register set availability.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT16 ProcessorArchitecture,
            _In_ UINT32 PageSize,
            _In_ UINT32 OperatingSystemVersion,
            _In_ UINT16 SuiteMask,
            _In_ DefaultPort::DkmSystemInformationFlags::e Flags,
            _In_ DefaultPort::DkmProcessorFeatures::e ProcessorFeatures,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppCreatedObject
            );

        // Create a new DkmSystemInformation object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // ProcessorArchitecture: [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0),
        // PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9).
        // PageSize        : [In] Minimum size for a virtual memory page. This value may be
        // zero in remote device scenarios where the page size is unknown.
        // OperatingSystemVersion: [In] 4-byte value containing the operating system version
        // packed as {platform id, major version, minor version, service pack major version}.
        // The platform id from the OSVERSIONINFO structure and is currently always defined
        // to VER_PLATFORM_WIN32_NT (2).
        // SuiteMask       : [In] VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        // Flags           : [In] Flags which provide information about the system that a
        // computer system that a process/thread/connection is using.
        // ProcessorFeatures: [In] Flags indicating features which are available in the
        // processor on which this system/process/thread is running. These generally deal
        // with register set availability.
        // MinidumpFlags   : [In] If dump debugging, specifies the MINIDUMP_TYPE flags of the
        // mini dump being debugged.  If live debugging, this value is always zero.
        // pSystemDirectory: [In,Optional] The path of the system directory.  For both 32-bit
        // and 64-bit Windows, this value is typically C:\Windows\System32.
        // pSystemWow64Directory: [In,Optional] The path of the WOW64 system directory.  This
        // value is typically C:\Windows\SysWOW64. On 32-bit Windows, this value will be
        // NULL.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT16 ProcessorArchitecture,
            _In_ UINT32 PageSize,
            _In_ UINT32 OperatingSystemVersion,
            _In_ UINT16 SuiteMask,
            _In_ DefaultPort::DkmSystemInformationFlags::e Flags,
            _In_ DefaultPort::DkmProcessorFeatures::e ProcessorFeatures,
            _In_ MINIDUMP_TYPE MinidumpFlags,
            _In_opt_ DkmString* pSystemDirectory,
            _In_opt_ DkmString* pSystemWow64Directory,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppCreatedObject
            );
    }; // end of DkmSystemInformation

    // Flags which provide information about the system that a computer system that a
    // process/thread/connection is using.
    enum DkmSystemInformationFlags::e
    {
        // No flags are set.
        Default = 0x0,
        // The process/OS is 64-bit.
        Is64Bit = 0x1,
        // Indicates that the process/OS is from a .dmp file or other snapshot of a single
        // point in time.
        DumpFile = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmSystemInformationFlags::e);

    // This represents a connection between the monitor and the IDE. It can either be a local
    // connection if the monitor is running in the same process as the IDE, or it can be a
    // remote connection. In the monitor process, there is only one connection.
    //
    // Derived classes: DkmStandardRemoteTransportConnection
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("37f756b6-9ea0-4c02-3f0a-99fb3a0f7a77") DkmTransportConnection : public DkmDataContainer
    {
        // Use DkmTransportConnection::Create to create this object
        private: DkmTransportConnection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTransportConnection();
        // This object cannot be copied
        private: DkmTransportConnection& operator=(const DkmTransportConnection&);
        private: DkmTransportConnection(const DkmTransportConnection&);

        // Contains additional fields of DkmTransportConnection which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // The version of the protocol used between Visual Studio and the target
            // computer. This is the minimum of the protocol version that Visual Studio
            // understands, and the protocol version that the remote debugger understands.
            const DkmApiVersion::e ProtocolVersion;
        };

        private: const GUID m_UniqueId;
        private: OPTIONAL DkmString* const m_pQualifier;
        private: const GUID m_Kind;
        private: const DefaultPort::DkmTransportConnectionFlags::e m_Flags;
        private: ___ExtendedData* const m__pExtendedData;
        private: void* m_pCausalityConnectionCollection0;
        private: void* m_pDeploymentCommandCollection0;
        private: void* m_pDeploymentSessionCollection0;
        private: void* m_pFileTransferStreamCollection0;
        private: void* m_pLiveProcessCollection3;
        private: void* m_pProcessCollection0;
        private: void* m_pProcessLaunchNotifyListenerCollection0;
        private: void* m_pRequestCollection0;

        // Guid which uniquely identifies this connection. The local connection will use the
        // value 'DkmTransportKind.Local'. The value for other connections will be randomly
        // generated.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] String indicating the connection destination. This will be null for the
        // local connection. For default remote debugging, this is computer name and port
        // number that we are trying to connect to.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Qualifier(
            );

        // Indicates the type of transport being used to debug.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Kind(
            );

        // Flags indicating traits of the underlying connection.
        public: DECLSPEC_NOTHROW DefaultPort::DkmTransportConnectionFlags::e STDMETHODCALLTYPE Flags(
            );

        // The version of the protocol used between Visual Studio and the target computer.
        // This is the minimum of the protocol version that Visual Studio understands, and
        // the protocol version that the remote debugger understands.
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        public: DECLSPEC_NOTHROW DkmApiVersion::e STDMETHODCALLTYPE ProtocolVersion(
            );

        // Find a DkmTransportConnection object. If no object with the given input key is
        // present, FindConnection will fail.
        // UniqueId        : [In] Search key used to find the element.
        // ppConnection    : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindConnection(
            _In_ const GUID& UniqueId,
            _Deref_out_ DefaultPort::DkmTransportConnection** ppConnection
            );

        // GetConnections enumerates all the created DkmTransportConnection objects.
        // pConnections    : [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetConnections(
            _Out_ DkmArray<DefaultPort::DkmTransportConnection*>* pConnections
            );

        // Find a DkmProcess element within this DkmTransportConnection. If no element with
        // the given input key is present, FindProcess will fail.
        // UniqueId        : [In] Search key used to find the element.
        // ppProcess       : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindProcess(
            _In_ const GUID& UniqueId,
            _Deref_out_ DkmProcess** ppProcess
            );

        // GetProcesses enumerates the DkmProcess elements of this DkmTransportConnection
        // object.
        // pProcesses      : [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProcesses(
            _Out_ DkmArray<DkmProcess*>* pProcesses
            );

        // Find a DkmProcess element within this DkmTransportConnection. If no element with
        // the given input key is present, FindLiveProcess will fail. If an object is found,
        // it will always contain the 'Live' Part.
        // Id              : [In] Search key used to find the element.
        // ppProcess       : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindLiveProcess(
            _In_ UINT32 Id,
            _Deref_out_ DkmProcess** ppProcess
            );

        // GetLiveProcesses enumerates the DkmProcess elements of this
        // DkmTransportConnectionobject. All objects contain the 'Live' Part.
        // pProcesses      : [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLiveProcesses(
            _Out_ DkmArray<DkmProcess*>* pProcesses
            );

        // GetRequests enumerates the DkmProcessLaunchRequest elements of this
        // DkmTransportConnection object.
        // pRequests       : [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRequests(
            _Out_ DkmArray<Start::DkmProcessLaunchRequest*>* pRequests
            );

        // Activates the specified packaged application. This will cause the application to
        // start if it has not already started, and will bring it back as the active
        // application if it is already running. When launching under the debugger,
        // IDkmProcessLaunchNotifyListener.StartListener will be called before this API.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // AppPlatform     : [In] Indicates if the specified application package is a Windows
        // Phone or Windows Store app.
        // pActivationName : [In] Identifier for the application to launch.
        // LaunchForDebugging: [In] If true, the app is being debugged.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ActivateAppPackage(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmPackagedAppPlatform::e AppPlatform,
            _In_ DkmString* pActivationName,
            _In_ bool LaunchForDebugging,
            _In_ IDkmCompletionRoutine<Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine
            );

        // Performs a simulated process lifetime management-based suspend on the specified
        // application. This is used by developers to test their app's suspend handler.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // SessionId       : [In] The id of the session where the application is running.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SuspendAppPackage(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmSuspendAppPackageAsyncResult>* pCompletionRoutine
            );

        // Performs a simulated process lifetime management-based resume on the specified
        // application. This is used by developers to test their app's resume handler.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // SessionId       : [In] The id of the session where the application is running.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResumeAppPackage(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId
            );

        // Suspend and then shut down the specified application using the process lifetime
        // management services. Using this followed by a second app launch, developers can
        // test their app's ability to restart from suspended state.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // SessionId       : [In] The id of the session where the application is running.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ShutDownAppPackage(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmShutDownAppPackageAsyncResult>* pCompletionRoutine
            );

        // Obtain the full path to the isolated storage root directory for the specified
        // application.
        //
        // This API is not yet implemented for Windows Store apps, but is reserved for future
        // use.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // ppDirectoryFullPath: [Out,Optional] Full path to the directory on the target
        // system. Null if the application has no isolated storage directory.
        // Return value    : S_OK is returned if *ppDirectoryFullPath is non-NULL, S_FALSE is
        // returned when *ppDirectoryFullPath is NULL, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetIsolatedStorageRootForApplication(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _Deref_out_opt_ DkmString** ppDirectoryFullPath
            );

        // Get the execution state of the Windows Store app. The values in this field are
        // specified in PACKAGE_EXECUTION_STATE.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // SessionId       : [In] The id of the session where the application is running.
        // pAppPackageExecutionState: [Out] The execution state of the application.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAppPackageExecutionState(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _Out_ DefaultPort::DkmPackageExecutionState::e* pAppPackageExecutionState
            );

        // Enumerates the existing background tasks. This is used by developers to test their
        // app's enum handler.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // SessionId       : [In] The id of the session where the application is running.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumerateBackgroundTasks(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmEnumerateBackgroundTasksAsyncResult>* pCompletionRoutine
            );

        // Activate an background task. This is used by developers to test their app's
        // activate handler.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pAppPackageId   : [In] Identifies a Windows Store app package or Windows Phone app
        // package.
        // SessionId       : [In] The id of the session where the application is running.
        // TaskId          : [In] Activating task id (GUID).
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ActivateBackgroundTask(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ const GUID& TaskId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmActivateBackgroundTaskAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Enumerates installed and launchable (App Packages with applications) App Packages.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pPackages       : [Out] Array of App Packages found.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumPackages(
            _Out_ DkmArray<DefaultPort::DkmInstalledAppPackageInfo*>* pPackages
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Deploy a file to the target computer. Note that this will copy the file content
        // and last write time, but not attributes.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pLocalFilePath  : [In] Path to the local file which will be copied. The path must
        // be a full path.
        // pRemoteFilePath : [In] Path to the remote file that will be written. Environment
        // variables will be expanded (ex: %TMP%\deploy.txt). This must be a full path. If
        // the directory of this file does not exist, the debugger will attempt to create it.
        // OverwriteExisting: [In] true if the debugger should attempt to overwrite any
        // existing file. This will fail if the existing file is read-only.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DeployFile(
            _In_ DkmString* pLocalFilePath,
            _In_ DkmString* pRemoteFilePath,
            _In_ bool OverwriteExisting
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Download a file from the target computer. Note that this will copy the file
        // content and last write time, but not attributes.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pRemoteFilePath : [In] Path to the remote file that will be written. Environment
        // variables will be expanded (ex: %TMP%\deploy.txt).
        // pLocalFilePath  : [In] Local path where the download file will be placed. The path
        // must be a full path, and the directory must already exist.
        // OverwriteExisting: [In] true if the debugger should attempt to overwrite any
        // existing file. This will fail if the existing file is read-only.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DownloadFile(
            _In_ DkmString* pRemoteFilePath,
            _In_ DkmString* pLocalFilePath,
            _In_ bool OverwriteExisting
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Download a file from the target computer. Note that this will copy the file
        // content and last write time, but not attributes.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pRemoteFilePath : [In] Path to the remote file that will be written. Environment
        // variables will be expanded (ex: %TMP%\deploy.txt).
        // pLocalFilePath  : [In] Local path where the download file will be placed. The path
        // must be a full path, and the directory must already exist.
        // OverwriteExisting: [In] true if the debugger should attempt to overwrite any
        // existing file. This will fail if the existing file is read-only.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DownloadFile(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pRemoteFilePath,
            _In_ DkmString* pLocalFilePath,
            _In_ bool OverwriteExisting,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmDownloadFileAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Delete a file on the target computer.
        // pRemoteFilePath : [In] Path to the remote file that will be deleted. Environment
        // variables will be expanded (ex: %TMP%\deploy.txt).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DeleteFile(
            _In_ DkmString* pRemoteFilePath
            );

        // Provides the physical DNS host name that the target computer uses.
        // ppName          : [Out] Computer name. For more information, see
        // ComputerNamePhysicalDnsHostname in the Win32 documentation for GetComputerNameEx.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDNSName(
            _Deref_out_ DkmString** ppName
            );

        // Creates a directory on the target computer. Note that directories are implicitly
        // created when deploying files. So this API does not need to be used in that
        // scenario.
        // pRemoteDirectoryPath: [In] Path to the remote directory that will be created.
        // Environment variables will be expanded (ex: %TMP%\MyDirectory). The directory
        // cannot be a relative path.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDirectory(
            _In_ DkmString* pRemoteDirectoryPath
            );

        // Removes a directory on the target computer.
        // pRemoteDirectoryPath: [In] Path to the remote directory that will be removed.
        // Environment variables will be expanded (ex: %TMP%\MyDirectory). The directory
        // cannot be a relative path.
        // Recursive       : [In] True if all files and subdirectories under
        // 'RootDirectoryPath' should be removed. If false, this operation will fail unless
        // the directory is empty.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveDirectory(
            _In_ DkmString* pRemoteDirectoryPath,
            _In_ bool Recursive
            );

        // Obtains a listing of files and subdirectories that exist on the target computer.
        // pRootDirectoryPath: [In] Path to a remote directory under which the search will be
        // preformed. Environment variables will be expanded (ex: %TMP%\MyDirectory). The
        // directory cannot be a relative path.
        // pSearchWildcard : [In] Wildcard search string to use when matching files. For
        // example, '*' to obtain all files and directories, or 'example.txt' to obtain
        // information on just 'example.txt'.
        // Recursive       : [In] True if all subdirectories under 'RootDirectoryPath' should
        // be checked for files. This option excludes reparse points like mounted drives and
        // symbolic links.
        // pResults        : [Out] File information for all found files and subdirectories.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFileListing(
            _In_ DkmString* pRootDirectoryPath,
            _In_ DkmString* pSearchWildcard,
            _In_ bool Recursive,
            _Out_ DkmArray<DefaultPort::DkmFileInfo*>* pResults
            );

        // Provides a listing of all the processes running on the target computer (including
        // processes not being debugged).
        // IncludeFromAllUsers: [In] If true, processes from all users should be included.
        // RequestedPropertyMask: [In] Flags indicating which properties of
        // DkmRunningProcessInfo should be computed.
        // pProcesses      : [Out] Array of processes running on the target computer.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumRunningProcesses(
            _In_ bool IncludeFromAllUsers,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask,
            _Out_ DkmArray<DefaultPort::DkmRunningProcessInfo*>* pProcesses
            );

        // Obtain information about a process running on the target computer.
        // Id              : [In] Process Id (PID) assigned by the operating system.
        // StartTime       : [In] 64-bit date time value indicating when the process was
        // started. The start time along with the id and the machine where the process was
        // started can uniquely identify a process. '0' can be passed if the start time is
        // unknown.
        // IsDebuggee      : [In] When true, the request will fail if the debugger has
        // insufficient privileges to complete the request. If false, the implementation
        // should calculate what it can.
        // RequestedPropertyMask: [In] Flags indicating which properties of
        // DkmRunningProcessInfo should be computed.
        // ppProcessInfo   : [Out] Information about the requested process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRunningProcessInfo(
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ bool IsDebuggee,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppProcessInfo
            );

        // Terminates a process running on target computer which is not being debugged.
        // Id              : [In] Process Id (PID) assigned by the operating system.
        // StartTime       : [In] 64-bit date time value indicating when the process was
        // started. The start time along with the id and the machine where the process was
        // started can uniquely identify a process. '0' can be passed if the start time is
        // unknown.
        // ExitCode        : [In] The exit code to be used by the process and threads
        // terminated as a result of this call. Use the GetExitCodeProcess function to
        // retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a
        // thread's exit value.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TerminateRunningProcess(
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ UINT32 ExitCode
            );

        // Provides information about the computer where the debug monitor is running.
        // NativeSystemInfo: [In] If true and if the debug monitor is running under WOW64,
        // this function will return information about the native subsystem rather than WOW.
        // If the debug monitor is not running under WOW, this function is ignored.
        // ppSystemInfo    : [Out] Object describing the system where the debugger is
        // running.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSystemInformation(
            _In_ bool NativeSystemInfo,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppSystemInfo
            );

        // Provides the version string for the CLR that the debugger expects a given
        // executable to load. The return value is based on the content of the executable's
        // PE header (if the exe is managed), the executable's config file, CLR environment
        // variables, and loader policy in the registry. The return value may be incorrect,
        // especially in the case of a native executable.
        // pExePath        : [In] Path to the executable file.
        // ppClrVersionString: [Out] Version string of the CLR. Ex:'v4.0.30319'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrVersionOfExecutable(
            _In_ DkmString* pExePath,
            _Deref_out_ DkmString** ppClrVersionString
            );

        // Determines if the given executable file will execute within WOW64 (Windows On
        // Windows), which is used to execute 32-bit processes on a 64-bit OS.
        // pExePath        : [In] Path to the executable file.
        // pResult         : [Out] true if the specified executable file will execute under
        // WOW.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryIsWOW64Executable(
            _In_ DkmString* pExePath,
            _Out_ bool* pResult
            );

        // Returns the version of the CLR which is loaded in the monitor process.
        // ppClrVersionString: [Out] Version string of the CLR. Ex:'v4.0.30319'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDefaultClrVersion(
            _Deref_out_ DkmString** ppClrVersionString
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // This function is used to force all object close notifications to be immediately
        // exchanged with the monitor process. Like 'GC.Collect' in managed code, this
        // function is normally unnecessary, as the system automatically flushes the queue.
        // However, this method can be used if it is important that all updates are
        // immediately exchanged.
        //
        // An object close notification is created (and queued) when a component calls
        // 'Close' on a given object. Both the monitor process and the engine process
        // maintain a queue of closed objects. This method may only be called from the engine
        // process, but it is used to flush both queues.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FlushClosedObjectQueue(
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmTransportConnection

    // Flags indicating traits of the underlying connection.
    enum DkmTransportConnectionFlags::e
    {
        // Connection is to the local computer. This is used for both the 'pseudo-remote'
        // connection and the local connection.
        LocalComputer = 0x1,
        // Requests that cross from the higher level debugger components (ex: AD7 AL, symbol
        // handler, etc) to the low-level debugger components (ex: debug monitor) require
        // marshalling.
        MarshallingRequired = 0x2,
        // This connection is considered the default way to connect to the destination
        // computer. This flag will be used for the local connection, and for connections
        // running on the default port of remote computers.
        DefaultConnectionToTarget = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmTransportConnectionFlags::e);

    // Indicates the type of transport being used to debug.
    struct DkmTransportKind
    {
        // Local is used when the monitor and engine are in the same process. This is used to
        // debug local 32-bit processes.
        // Local is defined as {99a12aaf-a2fe-4a5f-90f8-39b805c6946b}.
        static const GUID Local;
        // PseudoRemote is used when the monitor and engine are in separate processes on the
        // same machine. This is used for debugging 64-bit processes.
        // PseudoRemote is defined as {2411b469-cf60-40af-aad5-8dbb3a2d5373}.
        static const GUID PseudoRemote;
        // StandardRemote is used for remote debugging over the standard remoting
        // infrastructure.
        // StandardRemote is defined as {e7a57bd9-a372-4ea8-9764-84b9bb3501b9}.
        static const GUID StandardRemote;
    };
    __declspec(selectany) const GUID DkmTransportKind::Local = { 0x99a12aaf, 0xa2fe, 0x4a5f, { 0x90, 0xf8, 0x39, 0xb8, 0x5, 0xc6, 0x94, 0x6b } };
    __declspec(selectany) const GUID DkmTransportKind::PseudoRemote = { 0x2411b469, 0xcf60, 0x40af, { 0xaa, 0xd5, 0x8d, 0xbb, 0x3a, 0x2d, 0x53, 0x73 } };
    __declspec(selectany) const GUID DkmTransportKind::StandardRemote = { 0xe7a57bd9, 0xa372, 0x4ea8, { 0x97, 0x64, 0x84, 0xb9, 0xbb, 0x35, 0x1, 0xb9 } };

    // This represents a remote connection between the monitor and the IDE over the standard
    // transport. This class derives from DkmTransportConnection, and defines options used to
    // connect to the target computer.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("97a0464d-a80e-ab40-233b-e55b49e3dfd9") DkmStandardRemoteTransportConnection : public DefaultPort::DkmTransportConnection
    {
        // Use DkmStandardRemoteTransportConnection::Create to create this object
        private: DkmStandardRemoteTransportConnection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStandardRemoteTransportConnection();
        // This object cannot be copied
        private: DkmStandardRemoteTransportConnection& operator=(const DkmStandardRemoteTransportConnection&);
        private: DkmStandardRemoteTransportConnection(const DkmStandardRemoteTransportConnection&);

        private: const DefaultPort::DkmRemoteAuthenticationMode::e m_AuthenticationMode;
        private: OPTIONAL DkmString* const m_pProxyServer;
        private: void* m__pExtendedData;

        // Authentication mode to use when connecting over a standard remote connection.
        public: DECLSPEC_NOTHROW DefaultPort::DkmRemoteAuthenticationMode::e STDMETHODCALLTYPE AuthenticationMode(
            );

        // [Optional] Proxy server used when connecting to this computer. This is null if the
        // debugger is directly connected to the computer.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ProxyServer(
            );

        // Silently aborts the transport connection in a similar way to what happens if the
        // Visual Studio or the Remote Debugger is terminated. The underlying connection will
        // be dropped, any in-flight operations will be aborted, and currently any debugged
        // processes will be terminated.
        //
        // This API was introduced in Visual Studio 11 Update 2 (DkmApiVersion.VS11Update2).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Abort(
            );
    }; // end of DkmStandardRemoteTransportConnection

}; // end namespace DefaultPort

// Contains types specific to debugging code running under the Common Language Runtime
// (CLR).
namespace Clr {
    // Contains the offsets for an await expression.
    struct DECLSPEC_UUID("f22942ed-2e95-dba6-04f2-d42f3439af36") DkmClrAwaitExpressionInfo
    {
        // The offset at which the expression yields.
        UINT32 YieldOffset;

        // The offset at which the expression resumes.
        UINT32 ResumeOffset;

        // The method in which the expression resumes.
        UINT32 ResumeMethodToken;

        // Release all reference-counted fields within the DkmClrAwaitExpressionInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrAwaitExpressionInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol
    // store's understanding of a particular CLR method within a module.
    struct DECLSPEC_UUID("023de36c-0bd8-a8ac-b6d4-b1870aae7471") DkmClrMethodId
    {
        // The method definition metadata token of the method that contains this symbol.
        UINT32 Token;

        // Version is a 1-based index. This will be '1' for methods that have not been edited
        // through Edit-and-continue. For edited methods, the version indicates the ENC apply
        // of this method. Thus if the user does 5 ENC applies and a particular method is
        // only edited in the 5th apply, then there are two method ids for this method, and
        // they have Version=1 and Version=5.
        //
        // The debugger needs to deal with old versions of the method because they will
        // continue to be on the call stack until control is unwound. The debugger can also
        // hit breakpoints or stop for exceptions within exception handling regions of old
        // methods. In other words, if the user sets a breakpoint within the catch block of a
        // non-leaf method, the debugger needs to set that breakpoint within the old version
        // of the method.
        //
        // In scenarios such as function breakpoint binding, the value '0' may used to
        // indicate the current version of the method.
        UINT32 Version;

        // Compare an instance of the DkmClrMethodId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmClrMethodId& other
            ) const;

        bool operator==(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmClrMethodId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmClrMethodId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmClrMethodId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrMethodId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Describes a range of IL instructions within a method.
    struct DECLSPEC_UUID("0dc8d999-b496-cd95-0469-06d11d4d8b23") DkmILRange
    {
        // Beginning IL offset the range.
        UINT32 StartOffset;

        // Ending IL offset of the range.
        UINT32 EndOffset;

        // Release all reference-counted fields within the DkmILRange structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmILRange* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmClrMethodScopeData describes a scope within a method. These are defined using
    // ISymUnmanagedWriter::OpenScope/CloseScope.
    struct DECLSPEC_UUID("97ed6d00-e7ea-5bd4-a627-de120e2e98ed") DkmClrMethodScopeData
    {
        // The IL range of this scope.
        Clr::DkmILRange ILRange;

        // The index of the parent scope in the array of scopes for the method.
        INT32 ParentScope;

        // Local variables defined in the PDB.
        DkmReadOnlyCollection<Clr::DkmClrLocalVariable*>* pLocalVariables;

        // Local constants defined in the PDB.
        DkmReadOnlyCollection<Clr::DkmClrLocalConstant*>* pLocalConstants;

        // Namespaces that are being 'used' within this scope.
        DkmReadOnlyCollection<DkmString*>* pNamespaces;

        // Release all reference-counted fields within the DkmClrMethodScopeData structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrMethodScopeData* pItem
            );
    };

    // Structure to define the IL instruction mapping for one or more native instructions.
    struct DECLSPEC_UUID("ff28f1ad-c2f5-1684-f358-eef67257c074") DkmClrNativeCodeMapEntry
    {
        // Starting address for this block of native code.
        UINT64 NativeAddress;

        // Number of bytes of native instruction memory described by this
        // DkmClrNativeCodeMapEntry.
        UINT32 NativeSize;

        // Offset of the native instruction.
        UINT32 NativeOffset;

        // Offset of the IL instruction. '-1' is used to indicate that the native
        // instructions cannot be mapped to an IL instruction. '-2' is used to indicate that
        // the native instructions are part of the prolog. '-3' is used to indicate that the
        // naive instructions are part of the epilog.
        UINT32 ILOffset;

        // Release all reference-counted fields within the DkmClrNativeCodeMapEntry structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrNativeCodeMapEntry* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents managed type id of an object. Corresponds to COR_TYPEID defined in
    // cordebug.h.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("e60e3116-d0f8-efb9-ef36-a373271ad669") DkmManagedTypeId
    {
        // The first token.
        UINT64 Token1;

        // The second token.
        UINT64 Token2;

        // Release all reference-counted fields within the DkmManagedTypeId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedTypeId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents managed heap object info. Corresponds to COR_HEAPOBJECT defined in
    // cordebug.h.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("606505d6-885d-610e-9c8f-20b721710dc8") DkmManagedHeapObjectInfo
    {
        // The address of the object in memory.
        UINT64 Address;

        // The total size of the object, in bytes.
        UINT64 Size;

        // A unique id that represents the type of the object.
        Clr::DkmManagedTypeId TypeId;

        // Release all reference-counted fields within the DkmManagedHeapObjectInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapObjectInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents info about a managed heap root.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("7ccd05ef-9127-6160-f766-ac0d5c7bb7ec") DkmManagedHeapRootInfo
    {
        // Address of the object.
        UINT64 Address;

        // Root type of the object.
        CorGCReferenceType RootType;

        // Name of the root object (if available).
        DkmString* pRootName;

        // ExtraData field of the CorGCReference structure that changes depending on the root
        // type. For instance for dependent handles this is the link to the secondary object.
        // For RefCount handles this is the reference count.
        UINT64 ExtraData;

        // Release all reference-counted fields within the DkmManagedHeapRootInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapRootInfo* pItem
            );
    };

    // Represents info about a managed heap segment.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("e97bab76-a083-6166-5d3a-d22bd6576782") DkmManagedHeapSegmentInfo
    {
        // Start address of the segment.
        UINT64 StartAddress;

        // End address of the segment.
        UINT64 EndAddress;

        // Generation of the segment.
        BYTE Generation;

        // Release all reference-counted fields within the DkmManagedHeapSegmentInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapSegmentInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents info about a type in managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("5c2790a6-65bd-568c-796b-7509eebb6ef1") DkmManagedHeapTypeInfo
    {
        // Name of the type.
        DkmString* pName;

        // Total number of objects for the type.
        UINT32 TotalCount;

        // Total size of the object for the type.
        UINT64 TotalSize;

        // Release all reference-counted fields within the DkmManagedHeapTypeInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapTypeInfo* pItem
            );
    };

    // Represents info about a managed object reference.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("11a79ceb-e6b7-e642-81d1-1e7be6a42a5b") DkmManagedObjectReferenceInfo
    {
        // Address of the source object.
        UINT64 From;

        // Address of the target object.
        UINT64 To;

        // Release all reference-counted fields within the DkmManagedObjectReferenceInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedObjectReferenceInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmClrAppDomain represents a CLR app domain inside a process which is being debugged.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("337360db-44af-e459-1323-f16ddacf8b79") DkmClrAppDomain : public DkmDataContainer
    {
        // Use DkmClrAppDomain::Create to create this object
        private: DkmClrAppDomain();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrAppDomain();
        // This object cannot be copied
        private: DkmClrAppDomain& operator=(const DkmClrAppDomain&);
        private: DkmClrAppDomain(const DkmClrAppDomain&);

        private: const GUID m_UniqueId;
        private: const UINT32 m_Id;
        private: Clr::DkmClrRuntimeInstance* const m_pRuntimeInstance;
        private: DkmString* m_pName;
        private: void* m__pExtendedData;
        private: void* m_pClrModuleInstanceCollection0;

        // Guid which uniquely identifies this app domain object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Id of the underlying CLR app domain. While running, this uniquely identifies the
        // app domain within a particular DkmRuntimeInstance.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // Represents a CLR instance running in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // AppDomain Name.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetName(
            _Deref_out_ DkmString** ppValue);

        // Closes a DkmClrAppDomain object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmClrAppDomain objects are automatically closed when their associated
        // DkmClrRuntimeInstance object is closed.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // This method is called by the managed debug monitor to create a DkmClrAppDomain
        // object. It is called on the event thread in response to the target process
        // creating an AppDomain. The caller is responsible for closing the created object
        // after they are done.
        // Id              : [In] Id of the underlying CLR app domain. While running, this
        // uniquely identifies the app domain within a particular DkmRuntimeInstance.
        // pRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pName           : [In] AppDomain Name.
        // DataItem        : [In] Data object to add to the new DkmClrAppDomain instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ DkmString* pName,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrAppDomain** ppCreatedObject
            );

        // Find a DkmClrModuleInstance element within this DkmClrAppDomain. If no element
        // with the given input key is present, FindClrModuleInstance will fail.
        // Mvid            : [In] Search key used to find the element.
        // ppClrModuleInstance: [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindClrModuleInstance(
            _In_ const GUID& Mvid,
            _Deref_out_ Clr::DkmClrModuleInstance** ppClrModuleInstance
            );

        // GetClrModuleInstances enumerates the DkmClrModuleInstance elements of this
        // DkmClrAppDomain object.
        // pClrModuleInstances: [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrModuleInstances(
            _Out_ DkmArray<Clr::DkmClrModuleInstance*>* pClrModuleInstances
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides direct access to the ICorDebugAppDomain object, which expression
        // evaluators or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppCorAppDomain  : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorObject(
            _Deref_out_ ICorDebugAppDomain** ppCorAppDomain
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Get the managed runtime module instance.(mscorlib.dll).
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // ppRuntimeModule : [Out] The CLR runtime module instance found.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedRuntimeModule(
            _Deref_out_ Clr::DkmClrModuleInstance** ppRuntimeModule
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrAppDomain

    // In an async method. all the possible locations the debugger could have stopped.
    enum DkmClrAsyncMethodLocation::e
    {
        // Not an async method.
        None = 0x0,
        // First statement of an async method. We step out synchronously here.
        FirstStatement = 0x1,
        // In an async method but not at an await expression.
        NonAwaitStatement = 0x2,
        // In an await statement and before an yield point.
        BeforeYield = 0x4,
        // At an yield point.
        AtYield = 0x8,
        // Last statement of the method - step into or step over should turn into step out.
        LastStatement = 0x10
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmClrAsyncMethodLocation::e);

    // Provides information about an exception which was caught in the target process. This
    // information includes details of the exception that was caught.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0550d914-26fe-bbe7-2d19-a432bbfea685") DkmClrCaughtExceptionInformation : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrCaughtExceptionInformation::Create to create this object
        private: DkmClrCaughtExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrCaughtExceptionInformation();
        // This object cannot be copied
        private: DkmClrCaughtExceptionInformation& operator=(const DkmClrCaughtExceptionInformation&);
        private: DkmClrCaughtExceptionInformation(const DkmClrCaughtExceptionInformation&);

        private: DkmThread* const m_pThread;
        private: const UINT64 m_FrameStart;
        private: const UINT64 m_FrameEnd;
        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: const UINT32 m_CatchHandlerILOffset;
        private: DkmString* const m_pName;
        private: void* m__pExtendedData;

        // DkmThread represents a thread running in the target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Start Address the current frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameStart(
            );

        // End Address the current frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameEnd(
            );

        // The Instruction address for this caught exception.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // The IL offset of the catch handler which is about to catch this exception.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CatchHandlerILOffset(
            );

        // Name of the Exception.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Create a new DkmClrCaughtExceptionInformation object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // FrameStart      : [In] Start Address the current frame.
        // FrameEnd        : [In] End Address the current frame.
        // pInstructionAddress: [In] The Instruction address for this caught exception.
        // CatchHandlerILOffset: [In] The IL offset of the catch handler which is about to
        // catch this exception.
        // pName           : [In] Name of the Exception.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ UINT64 FrameStart,
            _In_ UINT64 FrameEnd,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT32 CatchHandlerILOffset,
            _In_ DkmString* pName,
            _Deref_out_ Clr::DkmClrCaughtExceptionInformation** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Raise a ClrDebugMonitorExceptionCaught event. Components which implement the event
        // sync interface will receive the event notification. Control will return once all
        // components have been notified.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnClrDebugMonitorExceptionCaught(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrCaughtExceptionInformation

    // Indicates which version of the CLR debugging services (mscordbi.dll or other
    // implementation of the ICorDebug API) should be used when debugging this process.
    enum DkmClrDebuggingServicesId::e
    {
        // Debug an application using .NET Framework version 4 or later out-of-process CLR
        // execution pipeline.
        OutOfProcessPipeline = 0,
        // Debug an application running under .NET Framework version 4 or later. Note that
        // this value can use either the in-process (helper-thread based) or out-of-process
        // implementation of ICorDebug.
        DesktopClrV4 = 1,
        // Debug an application running under .NET Framework version 2.0 or earlier.
        DesktopClrV2 = 2,
        // Debug an application running using Silverlight on a Windows operating system.
        SilverlightWindows = 3,
        // Debug an application running on using Silverlight on a Mac operating system.
        SilverlightMac = 4,
        // Debug an application running under the .NET  Framework on a Windows CE device.
        DevicesClr = 5,
        // Debug an application running under the CoreCLR on a Windows Phone device.
        CoreSystemClr = 6
    };

    // Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the loaded
    // module. This indicates which type of binary was loaded.
    enum DkmClrHeaderStatus::e
    {
        // The binary contains no CLR code. This value is used for binaries without a
        // IMAGE_COR20_HEADER.
        NativeBinary = 0,
        // The binary contains both managed and native code. This value is used for binaries
        // with a IMAGE_COR20_HEADER and without the COMIMAGE_FLAGS_ILONLY flag.
        MixedModeBinary = 1,
        // The binary contains only managed code. This value is used for binaries with a
        // IMAGE_COR20_HEADER and with the COMIMAGE_FLAGS_ILONLY flag.
        ManagedOnlyBinary = 2,
        // The binary contains only pre-JITed managed code. This value is used for binaries
        // with a IMAGE_COR20_HEADER and with the COMIMAGE_FLAGS_IL_LIBRARY flag.
        NGenBinary = 3
    };

    // Represents a local constant defined within a method scope. These are defined with
    // ISymUnmanagedWriter::DefineConstant or ISymUnmanagedWriter2::DefineConstant2.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("be763bf4-5d54-ece8-8dcb-6f5ed4ae3506") DkmClrLocalConstant : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrLocalConstant::Create to create this object
        private: DkmClrLocalConstant();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrLocalConstant();
        // This object cannot be copied
        private: DkmClrLocalConstant& operator=(const DkmClrLocalConstant&);
        private: DkmClrLocalConstant(const DkmClrLocalConstant&);

        private: Symbols::DkmModule* const m_pModule;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmVariant* const m_pValue;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Module where this local constant is defined.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Name of the constant.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Value assigned to this constant. No value implies VT_EMPTY.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
            );

        // [Optional] Additional data used by the symbol provider to identify the constant.
        // Meaning is implementation specific.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Create a new DkmClrLocalConstant object instance.
        // pModule         : [In] Module where this local constant is defined.
        // pName           : [In] Name of the constant.
        // pValue          : [In,Optional] Value assigned to this constant. No value implies
        // VT_EMPTY.
        // pAdditionalData : [In,Optional] Additional data used by the symbol provider to
        // identify the constant. Meaning is implementation specific.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_opt_ DkmVariant* pValue,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Clr::DkmClrLocalConstant** ppCreatedObject
            );

        // Provides the COR_SIGNATURE for a local constant.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pSignature      : [Out] The COR_SIGNATURE for the constant, which defines the type
        // of this constant.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSignature(
            _Out_ DkmArray<BYTE>* pSignature
            );
    }; // end of DkmClrLocalConstant

    // Represents a local variable defined within a method scope. These are defined with
    // ISymUnmanagedWriter::DefineLocalVariable or
    // ISymUnmanagedWriter2::DefineLocalVariable2.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8ea1e31c-295d-3d63-f790-8f0eca9158c5") DkmClrLocalVariable : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrLocalVariable::Create to create this object
        private: DkmClrLocalVariable();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrLocalVariable();
        // This object cannot be copied
        private: DkmClrLocalVariable& operator=(const DkmClrLocalVariable&);
        private: DkmClrLocalVariable(const DkmClrLocalVariable&);

        private: Symbols::DkmModule* const m_pModule;
        private: DkmString* const m_pName;
        private: const UINT32 m_Attributes;
        private: const UINT32 m_Slot;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Module where this local variable is defined.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Name of the local variable.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Variable attributes defined in CorSymVarFlag. Currently, the only defined bit is
        // VAR_IS_COMP_GEN (0x1).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Attributes(
            );

        // The local slot used by the IL in stloc/ldloc instructions.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Slot(
            );

        // [Optional] Additional data used by the symbol provider to identify the local
        // variable. Meaning is implementation specific.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Create a new DkmClrLocalVariable object instance.
        // pModule         : [In] Module where this local variable is defined.
        // pName           : [In] Name of the local variable.
        // Attributes      : [In] Variable attributes defined in CorSymVarFlag. Currently,
        // the only defined bit is VAR_IS_COMP_GEN (0x1).
        // Slot            : [In] The local slot used by the IL in stloc/ldloc instructions.
        // pAdditionalData : [In,Optional] Additional data used by the symbol provider to
        // identify the local variable. Meaning is implementation specific.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_ UINT32 Attributes,
            _In_ UINT32 Slot,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Clr::DkmClrLocalVariable** ppCreatedObject
            );

        // Provides the COR_SIGNATURE for a local Variable.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pSignature      : [Out] The COR_SIGNATURE for the Variable, which defines the type
        // of this Variable.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSignature(
            _Out_ DkmArray<BYTE>* pSignature
            );
    }; // end of DkmClrLocalVariable

    // Flags which indicates traits of a DkmModuleInstance which has been loaded by the CLR.
    enum DkmClrModuleFlags::e
    {
        // No CLR module flags are set.
        None = 0x0,
        // Module is a dynamic module (types can be added to the module as it runs).
        Dynamic = 0x1,
        // Set if the module is the core module for the managed runtime (mscorlib.dll).
        RuntimeModule = 0x2,
        // Corresponds to the value returned by ICorDebugAssembly2::IsFullyTrusted. If the
        // CLR the process is running on does not implement ICorDebugAssembly2 or
        // ICorDebugAssembly2::IsFullyTrusted fails, this flag will not be set.
        FullyTrusted = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmClrModuleFlags::e);

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a managed type.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("837d21de-5f4c-e07c-0f1d-227f6422d67a") DkmClrType : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrType::Create to create this object
        private: DkmClrType();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrType();
        // This object cannot be copied
        private: DkmClrType& operator=(const DkmClrType&);
        private: DkmClrType(const DkmClrType&);

        private: Clr::DkmClrModuleInstance* const m_pModuleInstance;
        private: const UINT32 m_Token;
        private: OPTIONAL DkmReadOnlyCollection<Clr::DkmClrType*>* const m_pGenericArguments;
        private: void* m__pExtendedData;

        // The module the type resides in.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The type def token of the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Token(
            );

        // [Optional] If the type is generic, specifies the generic arguments for the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Clr::DkmClrType*>* STDMETHODCALLTYPE GenericArguments(
            );

        // The app domain of the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrAppDomain* STDMETHODCALLTYPE AppDomain(
            );

        // The process of the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Create a new DkmClrType object instance.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pModuleInstance : [In] The module the type resides in.
        // Token           : [In] The type def token of the type.
        // pGenericArguments: [In,Optional] If the type is generic, specifies the generic
        // arguments for the type.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericArguments,
            _Deref_out_ Clr::DkmClrType** ppCreatedObject
            );

        // Resolves a method name belonging to a given class into a DkmClrMethodId.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pMethodName     : [In] The name of the method.
        // pParameterTypes : [In,Optional] Optional array of parameter types.
        // pResult         : [Out] A DkmClrMethodId describing the method.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveMethodName(
            _In_ DkmString* pMethodName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pParameterTypes,
            _Out_ Clr::DkmClrMethodId* pResult
            );
    }; // end of DkmClrType
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous
    // DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement call.
    struct DkmGetAllAwaitExpressionInfoForStatementAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // An array of the yield and resume points for the statement.
        DkmArray<Clr::DkmClrAwaitExpressionInfo> AsyncExpressionInfo;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetAsyncKickoffMethod call.
    struct DkmGetAsyncKickoffMethodAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Kickoff method token.
        UINT32 KickoffMethodToken;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetAsyncMethodLocation call.
    struct DkmGetAsyncMethodLocationAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The location of the given instruction.
        Clr::DkmClrAsyncMethodLocation::e AsyncLocation;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetMethodLocalSymbols call.
    struct DkmGetMethodLocalSymbolsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmClrMethodScopeData[] describes a scope within a method. These are defined using
        // ISymUnmanagedWriter::OpenScope/CloseScope.
        DkmArray<Clr::DkmClrMethodScopeData> Scopes;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetMethodSymbolStoreAttribute call.
    struct DkmGetMethodSymbolStoreAttributeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The value of the requested symbol store attribute.
        DkmArray<BYTE> Data;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetNextAwaitExpressionInfo call.
    struct DkmGetNextAwaitExpressionInfoAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Next await expression info.
        Clr::DkmClrAwaitExpressionInfo AwaitExpressionInfo;
    };

    // Represents options for invoking the IL interpreter.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmILInterpreterOptions::e
    {
        // If true and we are interpreting a virtual function, indicates that the IL
        // interpreter should use virtual dispatch to figure out the most derived
        // implementation. If false, the specific method provided will be the one
        // interpreted.
        ResolveVirtual = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmILInterpreterOptions::e);

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A value that can be passed into and returned from a managed method being interpreted.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    //
    // Derived classes: DkmILInterpreterPrimitiveValue, DkmILInterpreterReferenceValue
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4851b2d6-89f2-46f5-1a56-f257135c3b4b") DkmILInterpreterValue : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILInterpreterValue::Create to create this object
        private: DkmILInterpreterValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInterpreterValue();
        // This object cannot be copied
        private: DkmILInterpreterValue& operator=(const DkmILInterpreterValue&);
        private: DkmILInterpreterValue(const DkmILInterpreterValue&);

        // DkmILInterpreterValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmILInterpreterPrimitiveValue'.
        PrimitiveValue = 0,
        // Object is an instance of 'DkmILInterpreterReferenceValue'.
        ReferenceValue = 1
        }; };

        private: const Tag::e m_TagValue;
        private: Clr::DkmClrRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // DkmILInterpreterValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // Represents a CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );
    }; // end of DkmILInterpreterValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // DkmManagedHeapSampler represents a sampler for objects in the managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("14537042-a674-0f63-20ba-a9fab411d46a") DkmManagedHeapSampler : public DkmDataContainer
    {
        // Use DkmManagedHeapSampler::Create to create this object
        private: DkmManagedHeapSampler();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedHeapSampler();
        // This object cannot be copied
        private: DkmManagedHeapSampler& operator=(const DkmManagedHeapSampler&);
        private: DkmManagedHeapSampler(const DkmManagedHeapSampler&);

        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this DkmManagedHeapSampler.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes a DkmManagedHeapSampler object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmManagedHeapSampler objects are automatically closed when their associated
        // DkmRuntimeInstance object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmManagedHeapSampler object instance. The caller is responsible for
        // closing the created object after they are done.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // DataItem        : [In] Data object to add to the new DkmManagedHeapSampler
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmManagedHeapSampler** ppCreatedObject
            );

        // Initializes heap sampler.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // TargetObjectCount: [In] The number of sampled objects to return.
        // LiveObjectStatsOnly: [In] Whether the sampler should calculate stats for only the
        // live objects on the heap.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            _In_ UINT32 TargetObjectCount,
            _In_ bool LiveObjectStatsOnly
            );

        // Walks the given number of objects on the heap.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pFetchedCount   : [Out] Count of items fetched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            );

        // Walks the given number of references on the heap.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pFetchedCount   : [Out] Count of items fetched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            );

        // Walks the given number of GC roots on the heap.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pFetchedCount   : [Out] Count of items fetched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            );

        // Returns the next requested portion of serialized object graph data.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Sampled heap data.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSampledHeapData(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<BYTE>* pItems
            );

        // Returns the heap type stats.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pItems          : [Out] Sampled heap type stats.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSampledHeapTypeStats(
            _Out_ DkmArray<Clr::DkmManagedHeapTypeInfo>* pItems
            );

        // Returns roots from the sampled heap.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pItems          : [Out] Sampled heap roots.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRoots(
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            );
    }; // end of DkmManagedHeapSampler

    // DkmManagedHeapWalker represents an enumerator for managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dca8e5e0-6bfc-1a87-5ae8-4c165856c3cb") DkmManagedHeapWalker : public DkmDataContainer
    {
        // Use DkmManagedHeapWalker::Create to create this object
        private: DkmManagedHeapWalker();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedHeapWalker();
        // This object cannot be copied
        private: DkmManagedHeapWalker& operator=(const DkmManagedHeapWalker&);
        private: DkmManagedHeapWalker(const DkmManagedHeapWalker&);

        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this DkmManagedHeapWalker.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Closes a DkmManagedHeapWalker object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmManagedHeapWalker objects are automatically closed when their associated
        // DkmRuntimeInstance object is closed.
        //
        // This method may only be called by the component which created the object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmManagedHeapWalker object instance. The caller is responsible for
        // closing the created object after they are done.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // DataItem        : [In] Data object to add to the new DkmManagedHeapWalker
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmManagedHeapWalker** ppCreatedObject
            );

        // Prepares enumerator for walking the objects in the heap, returns error if heap
        // cannot be enumerated.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            );

        // Prepares enumeration for reporting references between objects in the heap, returns
        // error if heap cannot be enumerated.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapReferenceWalk(
            );

        // Prepares enumeration for reporting roots in the heap, returns error if heap cannot
        // be enumerated.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapRootsWalk(
            );

        // Returns the next set of objects from the enumeration.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Array containing the managed heap object infos.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapObjectInfo>* pItems
            );

        // Returns the next set of elements from the enumeration.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Array containing the managed heap reference infos.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedObjectReferenceInfo>* pItems
            );

        // Returns the next set of roots from the enumeration.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Array containing the managed heap root infos.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            );

        // Gets the type names for the given type ids.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // TypeIds         : [In] The list of managed type ids.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pTypeNames      : [Out] The list of type names.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTypeNames(
            _In_ const DkmArray<Clr::DkmManagedTypeId>& TypeIds,
            _Out_ DkmArray<DkmString*>* pTypeNames
            );

        // Gets the list of segments in the heap.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pSegments       : [Out] The list of heap segments.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSegments(
            _Out_ DkmArray<Clr::DkmManagedHeapSegmentInfo>* pSegments
            );
    }; // end of DkmManagedHeapWalker

    // Contains information needed to construct a managed DkmStackWalkFrame.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b4660c09-eaf1-87dd-bbdf-8210478281a6") DkmManagedReturnStackFrame : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmManagedReturnStackFrame::Create to create this object
        private: DkmManagedReturnStackFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnStackFrame();
        // This object cannot be copied
        private: DkmManagedReturnStackFrame& operator=(const DkmManagedReturnStackFrame&);
        private: DkmManagedReturnStackFrame(const DkmManagedReturnStackFrame&);

        private: DkmThread* const m_pThread;
        private: const CallStack::DkmStackWalkFrameFlags::e m_Flags;
        private: const Clr::DkmClrMethodId m_Method;
        private: Clr::DkmClrModuleInstance* const m_pModuleInstance;
        private: const UINT32 m_AwaitIndex;
        private: CallStack::DkmAsyncStackWalkContext* const m_pAsyncStackWalkContext;
        private: CallStack::DkmStackWalkFrameData* const m_pData;
        private: void* m__pExtendedData;

        // The thread that this frame belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Flags associated with this frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameFlags::e STDMETHODCALLTYPE Flags(
            );

        // The managed method that this frame belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const Clr::DkmClrMethodId& STDMETHODCALLTYPE Method(
            );

        // The module that this method belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The index of the await statement where code will transfer to when this frame later
        // executes.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE AwaitIndex(
            );

        // Context to use for continuing to walk the async return stack beyond this frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE AsyncStackWalkContext(
            );

        // Optional data object to associate with this frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Data(
            );

        // Create a new DkmManagedReturnStackFrame object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pThread         : [In] The thread that this frame belongs to.
        // Flags           : [In] Flags associated with this frame.
        // Method          : [In] The managed method that this frame belongs to.
        // pModuleInstance : [In] The module that this method belongs to.
        // AwaitIndex      : [In] The index of the await statement where code will transfer
        // to when this frame later executes.
        // pAsyncStackWalkContext: [In] Context to use for continuing to walk the async
        // return stack beyond this frame.
        // pData           : [In] Optional data object to associate with this frame.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmStackWalkFrameFlags::e Flags,
            _In_ const Clr::DkmClrMethodId& Method,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 AwaitIndex,
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ CallStack::DkmStackWalkFrameData* pData,
            _Deref_out_ Clr::DkmManagedReturnStackFrame** ppCreatedObject
            );
    }; // end of DkmManagedReturnStackFrame

    // Provides a context for managed return value.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5550ca27-ac65-0a34-f6fb-5a0688bb83aa") DkmManagedReturnValueContext : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmManagedReturnValueContext::Create to create this object
        private: DkmManagedReturnValueContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueContext();
        // This object cannot be copied
        private: DkmManagedReturnValueContext& operator=(const DkmManagedReturnValueContext&);
        private: DkmManagedReturnValueContext(const DkmManagedReturnValueContext&);

        private: DkmThread* const m_pThread;
        private: DkmRuntimeInstance* const m_pRuntime;
        private: Clr::DkmClrInstructionAddress* const m_pAddress;
        private: DkmString* const m_pName;
        private: DkmString* const m_pFullName;
        private: void* m__pExtendedData;

        // The thread to retrieve the return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // The runtime of the Expression Evaluator that should evaluate this return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE Runtime(
            );

        // Return value hitting guard breakpoint address.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE Address(
            );

        // Name of the finished method call.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // The full name of the return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Create a new DkmManagedReturnValueContext object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pThread         : [In] The thread to retrieve the return value.
        // pRuntime        : [In] The runtime of the Expression Evaluator that should
        // evaluate this return value.
        // pAddress        : [In] Return value hitting guard breakpoint address.
        // pName           : [In] Name of the finished method call.
        // pFullName       : [In] The full name of the return value.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ DkmRuntimeInstance* pRuntime,
            _In_ Clr::DkmClrInstructionAddress* pAddress,
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _Deref_out_ Clr::DkmManagedReturnValueContext** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // ppValueInfo     : [Out] Return value from CLR.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetReturnValueInfo(
            _Deref_out_ Clr::DkmManagedReturnValueInfo** ppValueInfo
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmManagedReturnValueContext

    // Provides information for managed return value.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    //
    // Derived classes: DkmManagedReturnValueCopy, DkmManagedReturnValueReference
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d72b0393-ff2a-9a20-531c-68d2bdbaaeb9") DkmManagedReturnValueInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmManagedReturnValueInfo::Create to create this object
        private: DkmManagedReturnValueInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueInfo();
        // This object cannot be copied
        private: DkmManagedReturnValueInfo& operator=(const DkmManagedReturnValueInfo&);
        private: DkmManagedReturnValueInfo(const DkmManagedReturnValueInfo&);

        // DkmManagedReturnValueInfo is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: struct Tag { enum e {
        // Object is an instance of 'DkmManagedReturnValueReference'.
        ManagedReturnValueReference = 0,
        // Object is an instance of 'DkmManagedReturnValueCopy'.
        ManagedReturnValueCopy = 1
        }; };

        private: const Tag::e m_TagValue;
        private: ICorDebugType* const m_pCorType;
        private: void* m__pExtendedData;

        // DkmManagedReturnValueInfo is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag::e STDMETHODCALLTYPE TagValue(
            );

        // ICorDebugType of the return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW ICorDebugType* STDMETHODCALLTYPE CorType(
            );
    }; // end of DkmManagedReturnValueInfo

    // Describes whether or not metadata is available for a given module instance.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmMetadataStatus::e
    {
        // Not determined.
        NotDetermined = 0,
        // Metadata is present.
        Present = 1,
        // Metadata is not present.  This case can happen only in minidumps without heap when
        // we haven't loaded the binary.
        NotPresent = 2
    };

    // Indicates whether non user code is due to DebuggerHidden, DebuggerStepThrough, or
    // DebuggerNonUserCode attribute marked on method or class or marked hidden due 0xfeefee
    // sequence point.
    enum DkmNonUserCodeFlags::e
    {
        // Method or class is not marked with non user code related attributes.
        None = 0x0,
        // Method or class is marked with the DebuggerHidden attribute or marked hidden due
        // to 0xfeefee sequence point.
        HiddenAttribute = 0x1,
        // Method or class is marked with the DebuggerStepThrough attribute.
        StepThroughAttribute = 0x2,
        // Method or class is marked with the DebuggerNonUserCode attribute.
        NonUserCodeAttribute = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmNonUserCodeFlags::e);

    // Provides information about a CLR exception which was raised in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("42d9ccf0-bf7f-1064-377a-4aa80ac85812") DkmClrExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmClrExceptionInformation::Create to create this object
        private: DkmClrExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrExceptionInformation();
        // This object cannot be copied
        private: DkmClrExceptionInformation& operator=(const DkmClrExceptionInformation&);
        private: DkmClrExceptionInformation(const DkmClrExceptionInformation&);

        private: void* m__pExtendedData;

        // Type name of the exception. Example: 'System.NullReferenceException'.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Address where the exception occurred. This will be null if the CLR
        // exception occurred inside the runtime when no managed code was on the stack.
        public: _Ret_opt_ DECLSPEC_NOTHROW Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmClrExceptionInformation'. Return
        // NULL if the path object is not a 'DkmClrExceptionInformation'.
        // pClrException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::ClrException)
                return NULL;

            return static_cast<DkmClrExceptionInformation*>(pException);
        }

        // Create a new DkmClrExceptionInformation object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration indicates the stage(s) for a notification.
        // pName           : [In] Type name of the exception. Example:
        // 'System.NullReferenceException'.
        // pInstructionAddress: [In,Optional] Address where the exception occurred. This will
        // be null if the CLR exception occurred inside the runtime when no managed code was
        // on the stack.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_ DkmString* pName,
            _In_opt_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _Deref_out_ Clr::DkmClrExceptionInformation** ppCreatedObject
            );
    }; // end of DkmClrExceptionInformation

    // DkmClrInstructionAddress is used for addresses in managed code.
    //
    // Derived classes: DkmClrNcInstructionAddress
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ef7a9773-03a1-0aab-55bb-ee6b870e6246") DkmClrInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmClrInstructionAddress::Create to create this object
        private: DkmClrInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrInstructionAddress();
        // This object cannot be copied
        private: DkmClrInstructionAddress& operator=(const DkmClrInstructionAddress&);
        private: DkmClrInstructionAddress(const DkmClrInstructionAddress&);

        private: const Clr::DkmClrMethodId m_MethodId;
        private: const UINT32 m_NativeOffset;
        private: const UINT32 m_ILOffset;
        private: void* m__pExtendedData;

        // Represents a CLR instance running in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The module containing the InstructionPointer.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The version/token pair for this method.
        public: DECLSPEC_NOTHROW const Clr::DkmClrMethodId& STDMETHODCALLTYPE MethodId(
            );

        // For the standard .NET Framework, NativeOffset is a byte offset relative to start
        // of the method where the CPU instruction can be found. For the purpose of this
        // value, the method should be treated as a contiguous block of bytes. If the method
        // has not been Just-in-time compiled or if this address is being used to refer
        // purely to the IL address, NativeOffset will be set to UInt32.MaxValue.
        //
        // For native-compiled .NET Framework modules,  this value is the RVA of the native
        // instruction in the module.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NativeOffset(
            );

        // ILOffset is the index of the IL instruction that this address represents. This
        // value may be set to UInt32.MaxValue for an instruction that is within the given
        // method, but not tied to a particular IL instruction. This is used for CLR native
        // instructions that don't map to an IL instruction. (ICorDebugILFrame::GetIP
        // indicates MAPPING_UNMAPPED_ADDRESS).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ILOffset(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmClrInstructionAddress'. Return
        // NULL if the path object is not a 'DkmClrInstructionAddress'.
        // pClrAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::ClrAddress)
                return NULL;

            return static_cast<DkmClrInstructionAddress*>(pInstructionAddress);
        }

        // Create a new DkmClrInstructionAddress object instance.
        // pRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pModuleInstance : [In] The module containing the InstructionPointer.
        // MethodId        : [In] The version/token pair for this method.
        // NativeOffset    : [In] For the standard .NET Framework, NativeOffset is a byte
        // offset relative to start of the method where the CPU instruction can be found. For
        // the purpose of this value, the method should be treated as a contiguous block of
        // bytes. If the method has not been Just-in-time compiled or if this address is
        // being used to refer purely to the IL address, NativeOffset will be set to
        // UInt32.MaxValue.
        //
        // For native-compiled .NET Framework modules,  this value is the RVA of the native
        // instruction in the module.
        // ILOffset        : [In] ILOffset is the index of the IL instruction that this
        // address represents. This value may be set to UInt32.MaxValue for an instruction
        // that is within the given method, but not tied to a particular IL instruction. This
        // is used for CLR native instructions that don't map to an IL instruction.
        // (ICorDebugILFrame::GetIP indicates MAPPING_UNMAPPED_ADDRESS).
        // pCPUInstruction : [In,Optional] CPUInstruction provides the address that the CPU
        // will execute. This is always provided for native instructions. It may be provided
        // for CLR or custom addresses depending on how the address object was created.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 NativeOffset,
            _In_ UINT32 ILOffset,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Clr::DkmClrInstructionAddress** ppCreatedObject
            );

        // Obtains non user code status for this instruction address.
        // pNonUserCodeFlags: [Out] The non user code status for this instruction address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNonUserCodeMetadataFlags(
            _Out_ Clr::DkmNonUserCodeFlags::e* pNonUserCodeFlags
            );

        // Provides the map of how this method was compiled to native code.
        // pStackFrame     : [In,Optional] Stack frame where this address is from. This is
        // necessary for CLR v2 support. This argument will be ignored for CLR v4.
        // pMap            : [Out] Structure to define the IL instruction mapping for one or
        // more native instructions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeCodeMap(
            _In_opt_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ DkmArray<Clr::DkmClrNativeCodeMapEntry>* pMap
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides direct access to the ICorDebugFunction object, which expression
        // evaluators or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppCorFunction   : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorFunction(
            _Deref_out_ ICorDebugFunction** ppCorFunction
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Helper method implemented by the managed DM and used by the shim EE to determine
        // if a method is user code while we're walking async return stacks. We won't want to
        // use the regular IsUserCode() method because that method makes a round trip to the
        // symbol provider to see if there's line info.  To avoid this, we use this method to
        // have the managed DM do its other checks. Then, when the shim EE returns to the
        // symbol provider, the symbol provider will then check for line info.  Doing it this
        // way allows the entire managed return stack to be calculated in one round trip to
        // the remote side, without the need for extra chatting back and forth just to
        // determine if return stack frames are user code or not.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pUserCode       : [Out] True if the provided instruction address is user code.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsUserCodeWithoutCheckingLineInfo(
            _Out_ bool* pUserCode
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrInstructionAddress

    // DkmClrInstructionSymbol represents an IL instruction that runs under the Common
    // Language Runtime (CLR) in the target process. This object contains the method version
    // number. So in Edit-and-Continue scenarios, the instruction symbol would be different
    // for different versions of the method. This object does not contain information about
    // generic binding parameters. So different generic instantiations of a method (ex:
    // MyMethod<string> and MyMethod<int>) are represented by the same instruction symbol
    // since the CLR represents them with a single method token.
    //
    // Derived classes: DkmClrNcInstructionSymbol
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8e7388ae-e3e2-122c-5560-09f77dfaed9d") DkmClrInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmClrInstructionSymbol::Create to create this object
        private: DkmClrInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrInstructionSymbol();
        // This object cannot be copied
        private: DkmClrInstructionSymbol& operator=(const DkmClrInstructionSymbol&);
        private: DkmClrInstructionSymbol(const DkmClrInstructionSymbol&);

        private: const Clr::DkmClrMethodId m_MethodId;
        private: const UINT32 m_ILOffset;
        private: void* m__pExtendedData;

        // The version/token pair for this method.
        public: DECLSPEC_NOTHROW const Clr::DkmClrMethodId& STDMETHODCALLTYPE MethodId(
            );

        // ILOffset is the index of the IL instruction that this symbol represents. This
        // value may be set to UInt32.MaxValue for an instruction that is within the given
        // method, but not tied to a particular instruction. This is used for CLR native
        // instructions that don't map to an IL instruction.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ILOffset(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmClrInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmClrInstructionSymbol'.
        // pClrInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::ClrInstruction)
                return NULL;

            return static_cast<DkmClrInstructionSymbol*>(pInstruction);
        }

        // Create a new DkmClrInstructionSymbol object instance.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // MethodId        : [In] The version/token pair for this method.
        // ILOffset        : [In] ILOffset is the index of the IL instruction that this
        // symbol represents. This value may be set to UInt32.MaxValue for an instruction
        // that is within the given method, but not tied to a particular instruction. This is
        // used for CLR native instructions that don't map to an IL instruction.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 ILOffset,
            _Deref_out_ Clr::DkmClrInstructionSymbol** ppCreatedObject
            );

        // Gets the location of the instruction symbol in it's method.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pAsyncLocation  : [Out] The location of the given instruction.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncMethodLocation(
            _Out_ Clr::DkmClrAsyncMethodLocation::e* pAsyncLocation
            );

        // Gets the location of the instruction symbol in it's method.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncMethodLocation(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetAsyncMethodLocationAsyncResult>* pCompletionRoutine
            );

        // Gets the yield and resume points contained within the statement surrounding the
        // given instruction symbol.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pAsyncExpressionInfo: [Out] An array of the yield and resume points for the
        // statement.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAllAwaitExpressionInfoForStatement(
            _Out_ DkmArray<Clr::DkmClrAwaitExpressionInfo>* pAsyncExpressionInfo
            );

        // Gets the yield and resume points contained within the statement surrounding the
        // given instruction symbol.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAllAwaitExpressionInfoForStatement(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetAllAwaitExpressionInfoForStatementAsyncResult>* pCompletionRoutine
            );

        // Gets the optional starting IL offset of an async method's generated catch handler.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pHasCatchHandlerILOffset: [Out] True if async method has a catch handler IL offset
        // in the PDB.
        // pCatchHandlerILOffset: [Out] The catch handler's starting IL offset.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncMethodCatchHandlerILOffset(
            _Out_ bool* pHasCatchHandlerILOffset,
            _Out_ UINT32* pCatchHandlerILOffset
            );

        // Get the yield and resume information of the next await expression.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pAwaitExpressionInfo: [Out] Next await expression info.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextAwaitExpressionInfo(
            _Out_ Clr::DkmClrAwaitExpressionInfo* pAwaitExpressionInfo
            );

        // Get the yield and resume information of the next await expression.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextAwaitExpressionInfo(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetNextAwaitExpressionInfoAsyncResult>* pCompletionRoutine
            );

        // If the current method is an async method then return the kickoff method for this
        // async method.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pKickoffMethodToken: [Out] Kickoff method token.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncKickoffMethod(
            _Out_ UINT32* pKickoffMethodToken
            );

        // If the current method is an async method then return the kickoff method for this
        // async method.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncKickoffMethod(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetAsyncKickoffMethodAsyncResult>* pCompletionRoutine
            );

        // Returns the scopes within a method. There will always be at least one scope.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pScopes         : [Out] DkmClrMethodScopeData[] describes a scope within a method.
        // These are defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodLocalSymbols(
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            );

        // Returns the scopes within a method. There will always be at least one scope.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodLocalSymbols(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetMethodLocalSymbolsAsyncResult>* pCompletionRoutine
            );

        // Gets a custom attribute based upon its name. Not to be confused with Metadata
        // custom attributes, these attributes are held in the symbol store.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pAttributeName  : [In] The name of the attribute to find.
        // pData           : [Out] The value of the requested symbol store attribute.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreAttribute(
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            );

        // Gets a custom attribute based upon its name. Not to be confused with Metadata
        // custom attributes, these attributes are held in the symbol store.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: This API will fail when called from an IDE component to query
        // information for server-side compiled ASP.NET code, or dynamically compiled code.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pWorkList       : WorkList to append the new work item to.
        // pAttributeName  : [In] The name of the attribute to find.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreAttribute(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pAttributeName,
            _In_ IDkmCompletionRoutine<Clr::DkmGetMethodSymbolStoreAttributeAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmClrInstructionSymbol

    // 'DkmClrModuleInstance' is used for modules which are loaded into the Common Language
    // Runtime.
    //
    // Derived classes: DkmClrNcModuleInstance
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("29da4ffa-6063-6232-46dd-64d14cf56ddf") DkmClrModuleInstance : public DkmModuleInstance
    {
        // Use DkmClrModuleInstance::Create to create this object
        private: DkmClrModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrModuleInstance();
        // This object cannot be copied
        private: DkmClrModuleInstance& operator=(const DkmClrModuleInstance&);
        private: DkmClrModuleInstance(const DkmClrModuleInstance&);

        // Contains additional fields of DkmClrModuleInstance which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Specifies the size of the IL image of this module.
            const UINT32 ILImageSize;
        };

        private: const GUID m_Mvid;
        private: const Clr::DkmClrModuleFlags::e m_ClrFlags;
        private: Clr::DkmClrAppDomain* const m_pAppDomain;
        private: ___ExtendedData* const m__pExtendedData;

        // Represents a CLR instance running in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Module Version Identifier from the loaded module. This is a unique value which is
        // embedded in an exe/dll by linkers/compilers when the dll/exe is built. A new value
        // is generated each time that the dll/exe is compiled.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Mvid(
            );

        // Flags which indicates traits of a DkmModuleInstance which has been loaded by the
        // CLR.
        public: DECLSPEC_NOTHROW Clr::DkmClrModuleFlags::e STDMETHODCALLTYPE ClrFlags(
            );

        // DkmClrAppDomain represents a CLR app domain inside a process which is being
        // debugged.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrAppDomain* STDMETHODCALLTYPE AppDomain(
            );

        // Specifies the size of the IL image of this module.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ILImageSize(
            );

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmClrModuleInstance'. Return
        // NULL if the path object is not a 'DkmClrModuleInstance'.
        // pClrModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::ClrModuleInstance)
                return NULL;

            return static_cast<DkmClrModuleInstance*>(pModuleInstance);
        }

        // Create a new DkmClrModuleInstance object instance.
        //
        // This method will send a ModuleInstanceLoad event.
        // pName           : [In] Short representation of the module name. For file-based
        // modules, this  is the file name and extension (ex: kernel32.dll).
        // pFullName       : [In] Fully qualified module name. For file-based modules, this
        // is the full path to the module (ex: c:\windows\system32\kernel32.dll.
        // TimeDateStamp   : [In] Date/Time of when the loaded module was built. This value
        // is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of
        // measurement is a  FILETIME value, which is a 64-bit value representing the number
        // of 100-nanosecond intervals since January 1, 1601 (UTC).
        // pVersion        : [In,Optional] File version information.
        // pSymbolFileId   : [In,Optional] Contains information needed to locate symbols for
        // this module. On Win32, this information is contained within the
        // IMAGE_DEBUG_DIRECTORY.
        // Flags           : [In] Flags which indicate traits of a DkmModuleInstance.
        // MemoryLayout    : [In] Enumeration that indicates how a module is laid out in
        // memory.
        // BaseAddress     : [In,Optional] The starting memory address of where the module
        // loaded. This value will be zero if the module did not load in a contiguous block
        // of memory.
        // LoadOrder       : [In] The integer count of the number of module instances that
        // have loaded up to and including this module. Each runtime instance keeps track of
        // its own load order count.
        // Size            : [In,Optional] The number of bytes in the module's memory region.
        // This value will be zero if the module did not load in a contiguous block of
        // memory.
        // pLoadContext    : [In] String description of the context under which this module
        // has been loaded. ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        // pRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // Mvid            : [In] Module Version Identifier from the loaded module. This is a
        // unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe
        // is built. A new value is generated each time that the dll/exe is compiled.
        // ClrFlags        : [In] Flags which indicates traits of a DkmModuleInstance which
        // has been loaded by the CLR.
        // pAppDomain      : [In] DkmClrAppDomain represents a CLR app domain inside a
        // process which is being debugged.
        // IsDisabled      : [In] Indicates if this module instance has been disabled.
        // Disabled modules are largely ignored by the debugger. For native modules, the
        // address range of the disabled module is treated as if it is unmapped. For CLR
        // modules, any frames from these modules is hidden from the call stack.
        // pModule         : [In,Optional] The symbol handler's representation of a module
        // (DkmModule) which is associated with this module instance. This value is initially
        // null, and is assigned if and when symbols are associated with this module
        // instance.
        // pMinidumpInfo   : [In,Optional] 'MinidumpInfo' is used to convey additional
        // information about modules in a DkmProcess for a minidump.
        // DataItem        : [In] Data object to add to the new DkmClrModuleInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags::e Flags,
            _In_ DkmModuleMemoryLayout::e MemoryLayout,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 LoadOrder,
            _In_ UINT32 Size,
            _In_ DkmString* pLoadContext,
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& Mvid,
            _In_ Clr::DkmClrModuleFlags::e ClrFlags,
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrModuleInstance** ppCreatedObject
            );

        // Create a new DkmClrModuleInstance object instance.
        //
        // This method will send a ModuleInstanceLoad event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pName           : [In] Short representation of the module name. For file-based
        // modules, this  is the file name and extension (ex: kernel32.dll).
        // pFullName       : [In] Fully qualified module name. For file-based modules, this
        // is the full path to the module (ex: c:\windows\system32\kernel32.dll.
        // TimeDateStamp   : [In] Date/Time of when the loaded module was built. This value
        // is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of
        // measurement is a  FILETIME value, which is a 64-bit value representing the number
        // of 100-nanosecond intervals since January 1, 1601 (UTC).
        // pVersion        : [In,Optional] File version information.
        // pSymbolFileId   : [In,Optional] Contains information needed to locate symbols for
        // this module. On Win32, this information is contained within the
        // IMAGE_DEBUG_DIRECTORY.
        // Flags           : [In] Flags which indicate traits of a DkmModuleInstance.
        // MemoryLayout    : [In] Enumeration that indicates how a module is laid out in
        // memory.
        // BaseAddress     : [In,Optional] The starting memory address of where the module
        // loaded. This value will be zero if the module did not load in a contiguous block
        // of memory.
        // LoadOrder       : [In] The integer count of the number of module instances that
        // have loaded up to and including this module. Each runtime instance keeps track of
        // its own load order count.
        // Size            : [In,Optional] The number of bytes in the module's memory region.
        // This value will be zero if the module did not load in a contiguous block of
        // memory.
        // pLoadContext    : [In] String description of the context under which this module
        // has been loaded. ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        // pRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // Mvid            : [In] Module Version Identifier from the loaded module. This is a
        // unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe
        // is built. A new value is generated each time that the dll/exe is compiled.
        // ClrFlags        : [In] Flags which indicates traits of a DkmModuleInstance which
        // has been loaded by the CLR.
        // pAppDomain      : [In] DkmClrAppDomain represents a CLR app domain inside a
        // process which is being debugged.
        // ILImageSize     : [In] Specifies the size of the IL image of this module.
        // IsDisabled      : [In] Indicates if this module instance has been disabled.
        // Disabled modules are largely ignored by the debugger. For native modules, the
        // address range of the disabled module is treated as if it is unmapped. For CLR
        // modules, any frames from these modules is hidden from the call stack.
        // pModule         : [In,Optional] The symbol handler's representation of a module
        // (DkmModule) which is associated with this module instance. This value is initially
        // null, and is assigned if and when symbols are associated with this module
        // instance.
        // pMinidumpInfo   : [In,Optional] 'MinidumpInfo' is used to convey additional
        // information about modules in a DkmProcess for a minidump.
        // DataItem        : [In] Data object to add to the new DkmClrModuleInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags::e Flags,
            _In_ DkmModuleMemoryLayout::e MemoryLayout,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 LoadOrder,
            _In_ UINT32 Size,
            _In_ DkmString* pLoadContext,
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& Mvid,
            _In_ Clr::DkmClrModuleFlags::e ClrFlags,
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ UINT32 ILImageSize,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrModuleInstance** ppCreatedObject
            );

        // Obtains the CLR metadata from a given module. See IMetaDataImport documentation in
        // MSDN for more information on metadata.
        // ppMetaData      : [Out] The IMetaDataImport interface for this managed module
        // instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataImport(
            _Deref_out_ IUnknown** ppMetaData
            );

        // Obtains the bytes of the CLR metadata from a given module. These bytes can then be
        // passed to IMetaDataDispenser::OpenScope to decode the metadata.
        // pMetaData       : [Out] The raw metadata for this module.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataBytes(
            _Out_ DkmArray<BYTE>* pMetaData
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides direct access to the ICorDebugModule object, which expression evaluators
        // or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppCorModule     : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorObject(
            _Deref_out_ ICorDebugModule** ppCorModule
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Resolves a type name into a type.  If the type is generic, the generic parameters
        // will not be instantiated.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pTypeName       : [In] The name of the type.
        // pGenericParameters: [In,Optional] If the type is generic, specifies the generic
        // parameters for the type.
        // ppResult        : [Out] A DkmClrType describing the type.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveTypeName(
            _In_ DkmString* pTypeName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericParameters,
            _Deref_out_ Clr::DkmClrType** ppResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Simulates the execution of a method on an object by interpreting the method's MSIL
        // code. The result of the method will be returned back to the caller.  However,
        // unlike a function evaluation, in which the method is actually running in the
        // target, interpreting a method does not actually execute the method, but instead,
        // merely simulates the behavior of the method.  Because the method never actually
        // executes, any side effects resulting from the method's execution are discarded
        // after the interpretation of the method is complete, leaving the target process in
        // an identical state to that from before the call.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Method          : [In] The method to be interpreted.  This function does not
        // support interpreting certain types of methods, including, but not limited to: -
        // Methods that consume ref or out parameters - Methods whose implementation calls
        // into native code via P/Invoke, COM interop, or some other means.
        // pGenericTypeParameters: [In,Optional] If the method belongs to a generic class,
        // specifies the instantiations of the type's generic parameters.
        // pGenericMethodParameters: [In,Optional] If the method is generic, specifies the
        // instantiations of the method's generic parameters.
        // pThisParameter  : [In,Optional] If the method to be interpreted is non-static,
        // specifies the non-null object instance that the method should be called on. If the
        // method to be interpreted is a class constructor, this can be either null or
        // non-null.  A null this parameter on a class constructor will cause us to virtually
        // create a new object and interpret the constructor. A non-null this parameter to a
        // constructor will cause us to interpret the call to the constructor on the existing
        // object.
        // pParameters     : [In,Optional] Parameters to be passed into the function,
        // excluding the 'this' parameter.  This may be null if the function to be
        // interpreted takes no parameters. If the function takes parameters, the length of
        // this array must be equal to the number of parameters specified in the method
        // signature.
        // MaxInstructionCount: [In] The maximum number of total IL instructions that we are
        // allowed to interpret.  The IL interpretation will be aborted with an error code of
        // E_ABORT if the actual number of instructions exceeds this limit.  This limit
        // prevents Visual Studio from hanging if the code being interpreted enters an
        // infinite loop.
        // Options         : [In] Additional options for the IL interpreter.
        // ppReturnValue   : [Out,Optional] The return value of the method.  This will be
        // null if the method returns void or throws an exception.
        // ppExceptionType : [Out,Optional] If the method throws an unhandled exception, the
        // type of the exception that got thrown.
        // Return value    : S_OK is returned if *ppReturnValue is non-NULL, S_FALSE is
        // returned when *ppReturnValue is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InterpretManagedMethod(
            _In_ const Clr::DkmClrMethodId& Method,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericTypeParameters,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericMethodParameters,
            _In_opt_ Clr::DkmILInterpreterValue* pThisParameter,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmILInterpreterValue*>* pParameters,
            _In_ UINT32 MaxInstructionCount,
            _In_ Clr::DkmILInterpreterOptions::e Options,
            _Deref_out_opt_ Clr::DkmILInterpreterValue** ppReturnValue,
            _Deref_out_opt_ DkmString** ppExceptionType
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Get metadata status.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pMetadataStatus : [Out] Metadata status.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetadataStatus(
            _Out_ Clr::DkmMetadataStatus::e* pMetadataStatus
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrModuleInstance

    // Represents a CLR instance running in a target process.
    //
    // Derived classes: DkmClrNcRuntimeInstance
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ea234770-c86f-1706-8842-c6fb5311ba79") DkmClrRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmClrRuntimeInstance::Create to create this object
        private: DkmClrRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrRuntimeInstance();
        // This object cannot be copied
        private: DkmClrRuntimeInstance& operator=(const DkmClrRuntimeInstance&);
        private: DkmClrRuntimeInstance(const DkmClrRuntimeInstance&);

        private: OPTIONAL DkmString* const m_pCORSystemDirectory;
        private: OPTIONAL DkmString* const m_pRuntimeVersion;
        private: void* m__pExtendedData;
        private: void* m_pAppDomainCollection0;
        private: void* m_pAppDomainCollection1;

        // [Optional] The installation directory of the common language runtime (CLR)
        // instance. For example 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is
        // the same path returned from the GetCORSystemDirectory API, and it always includes
        // the trailing slash.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CORSystemDirectory(
            );

        // [Optional] The version string for the CLR instance (ex: 'v2.0.50727').
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RuntimeVersion(
            );

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmClrRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmClrRuntimeInstance'.
        // pClrRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::ClrRuntimeInstance)
                return NULL;

            return static_cast<DkmClrRuntimeInstance*>(pRuntimeInstance);
        }

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // pCORSystemDirectory: [In,Optional] The installation directory of the common
        // language runtime (CLR) instance. For example
        // 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is the same path returned
        // from the GetCORSystemDirectory API, and it always includes the trailing slash.
        // pRuntimeVersion : [In,Optional] The version string for the CLR instance (ex:
        // 'v2.0.50727').
        // DataItem        : [In] Data object to add to the new DkmClrRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_opt_ DkmString* pCORSystemDirectory,
            _In_opt_ DkmString* pRuntimeVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrRuntimeInstance** ppCreatedObject
            );

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // Capabilities    : [In] Enumeration of runtime capabilities.
        // pParentRuntime  : [In,Optional] For runtimes that are implemented on top of
        // another runtime, this can optionally be used to indicant the logical parent. This
        // can then be used to request services from the parent when the child runtime
        // doesn't implement the service. This is currently used only for obtaining the top
        // stack frame to evaluate a conditional breakpoint when the child runtime doesn't
        // walk stacks itself.
        // pCORSystemDirectory: [In,Optional] The installation directory of the common
        // language runtime (CLR) instance. For example
        // 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is the same path returned
        // from the GetCORSystemDirectory API, and it always includes the trailing slash.
        // pRuntimeVersion : [In,Optional] The version string for the CLR instance (ex:
        // 'v2.0.50727').
        // DataItem        : [In] Data object to add to the new DkmClrRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities::e Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_opt_ DkmString* pCORSystemDirectory,
            _In_opt_ DkmString* pRuntimeVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrRuntimeInstance** ppCreatedObject
            );

        // Find a DkmClrAppDomain element within this DkmClrRuntimeInstance. If no element
        // with the given input key is present, FindAppDomain will fail.
        // Id              : [In] Search key used to find the element.
        // ppAppDomain     : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindAppDomain(
            _In_ UINT32 Id,
            _Deref_out_ Clr::DkmClrAppDomain** ppAppDomain
            );

        // GetAppDomains enumerates the DkmClrAppDomain elements of this
        // DkmClrRuntimeInstance object.
        // pAppDomains     : [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAppDomains(
            _Out_ DkmArray<Clr::DkmClrAppDomain*>* pAppDomains
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Obtains the DkmClrModuleInstance from an ICorDebugModule.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pCorModule      : [In] The CLR module to get the module instance for.
        // ppResult        : [Out] The DkmClrModuleInstance that matches the provided
        // ICorDebugModule.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindClrModuleInstance(
            _In_ ICorDebugModule* pCorModule,
            _Deref_out_ Clr::DkmClrModuleInstance** ppResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides direct access to the ICorDebugThread object, which expression evaluators
        // or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pThread         : [In] DkmThread object that should be mapped to the CorDebug
        // thread.
        // ppCorThread     : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorThread(
            _In_ DkmThread* pThread,
            _Deref_out_ ICorDebugThread** ppCorThread
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides direct access to the ICorDebugProcess object, which expression evaluators
        // or other components can use for inspection.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppCorProcess    : [Out] ICorDebug interface representing a process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorProcess(
            _Deref_out_ ICorDebugProcess** ppCorProcess
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Checks to see if we should load the FEQA DLL.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pSkipLoad       : [Out] Specifies if the FEQA DLL should be loaded. The hosting
        // process could have loaded it already.
        // pMemoryAddress  : [Out] Specifies the address in debuggee process. Valid only if
        // AlreadyLoaded is false.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE PrepareForFuncEvalQuickAbort(
            _In_ DkmThread* pThread,
            _Out_ bool* pSkipLoad,
            _Out_ UINT64* pMemoryAddress
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Notifies the result of the attempt to load the FEQA DLL.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Result          : [In] Specifies if the FEQA DLL was successfully loaded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnFuncEvalQuickAbortDllLoaded(
            _In_ DkmThread* pThread,
            _In_ bool Result
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Continue the process and wait for a func-eval to complete.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pThread         : [In] The thread for which to do the func-eval.
        // pCorEval        : [In] The object.
        // FuncEvalFlags   : [In] Function evaluation flags.
        // Timeout         : [In] The timeout.
        // pEvaluationString: [In] The text being evaluated. Displayed in the call stack
        // window if the function evaluation re-enters break mode.
        // pResult         : [Out] The result of doing the function evaluation. S_OK if all
        // went well. Other possible values include S_EVAL_TIMEDOUT, S_EVAL_ABORTED, or
        // E_PROCESS_DESTROYED.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ContinueForFuncEval(
            _In_ DkmThread* pThread,
            _In_ ICorDebugEval* pCorEval,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _In_ UINT32 Timeout,
            _In_ DkmString* pEvaluationString,
            _Out_ HRESULT* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Checks if the given thread is in a state in which the CLR supports managed
        // func-evals.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pResult         : [Out] The result of doing the function evaluation. S_OK if all
        // went well. Other possible values include E_EVAL_FUNCEVAL_IN_MINIDUMP or
        // S_EVAL_BAD_THREAD_STATE.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CanDoFuncEval(
            _In_ DkmThread* pThread,
            _Out_ HRESULT* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrRuntimeInstance

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A primitive value or string.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dd09d102-60f5-a71f-6a91-6d9770d907ca") DkmILInterpreterPrimitiveValue : public Clr::DkmILInterpreterValue
    {
        // Use DkmILInterpreterPrimitiveValue::Create to create this object
        private: DkmILInterpreterPrimitiveValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInterpreterPrimitiveValue();
        // This object cannot be copied
        private: DkmILInterpreterPrimitiveValue& operator=(const DkmILInterpreterPrimitiveValue&);
        private: DkmILInterpreterPrimitiveValue(const DkmILInterpreterPrimitiveValue&);

        private: DkmVariant* const m_pValue;
        private: void* m__pExtendedData;

        // The value to be passed into or returned from the interpreted method.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmILInterpreterValue' to a 'DkmILInterpreterPrimitiveValue'. Return
        // NULL if the path object is not a 'DkmILInterpreterPrimitiveValue'.
        // pPrimitiveValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILInterpreterPrimitiveValue* TryCast(
            DkmILInterpreterValue* pValue
            )
        {
            if (pValue == NULL || pValue->TagValue() != Tag::PrimitiveValue)
                return NULL;

            return static_cast<DkmILInterpreterPrimitiveValue*>(pValue);
        }

        // Create a new DkmILInterpreterPrimitiveValue object instance.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pValue          : [In] The value to be passed into or returned from the
        // interpreted method.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ DkmVariant* pValue,
            _Deref_out_ Clr::DkmILInterpreterPrimitiveValue** ppCreatedObject
            );
    }; // end of DkmILInterpreterPrimitiveValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A reference to an object in the debuggee's managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("cd724a8f-abd6-8297-c2f2-4e539e1512fd") DkmILInterpreterReferenceValue : public Clr::DkmILInterpreterValue
    {
        // Use DkmILInterpreterReferenceValue::Create to create this object
        private: DkmILInterpreterReferenceValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInterpreterReferenceValue();
        // This object cannot be copied
        private: DkmILInterpreterReferenceValue& operator=(const DkmILInterpreterReferenceValue&);
        private: DkmILInterpreterReferenceValue(const DkmILInterpreterReferenceValue&);

        private: OPTIONAL ICorDebugHandleValue* const m_pValue;
        private: void* m__pExtendedData;

        // [Optional] A reference to the object in the debuggee to be passed into or returned
        // from the interpreted method.  If the value refers to a null object reference,
        // ReferenceValue will be null.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW ICorDebugHandleValue* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmILInterpreterValue' to a 'DkmILInterpreterReferenceValue'. Return
        // NULL if the path object is not a 'DkmILInterpreterReferenceValue'.
        // pReferenceValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILInterpreterReferenceValue* TryCast(
            DkmILInterpreterValue* pValue
            )
        {
            if (pValue == NULL || pValue->TagValue() != Tag::ReferenceValue)
                return NULL;

            return static_cast<DkmILInterpreterReferenceValue*>(pValue);
        }

        // Create a new DkmILInterpreterReferenceValue object instance.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pValue          : [In,Optional] A reference to the object in the debuggee to be
        // passed into or returned from the interpreted method.  If the value refers to a
        // null object reference, ReferenceValue will be null.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_opt_ ICorDebugHandleValue* pValue,
            _Deref_out_ Clr::DkmILInterpreterReferenceValue** ppCreatedObject
            );
    }; // end of DkmILInterpreterReferenceValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Managed return value of value type copy.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("78986f0d-1eec-5d34-51fd-88e48e04b5b2") DkmManagedReturnValueCopy : public Clr::DkmManagedReturnValueInfo
    {
        // Use DkmManagedReturnValueCopy::Create to create this object
        private: DkmManagedReturnValueCopy();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueCopy();
        // This object cannot be copied
        private: DkmManagedReturnValueCopy& operator=(const DkmManagedReturnValueCopy&);
        private: DkmManagedReturnValueCopy(const DkmManagedReturnValueCopy&);

        private: const UINT32 m_CorElementType;
        private: const UINT32 m_Size;
        private: const UINT64 m_Address;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pValueBuffer;
        private: void* m__pExtendedData;

        // [Optional] The CorElementType of the value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CorElementType(
            );

        // [Optional] The size of the value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // [Optional] The address of the value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // [Optional] The captured value type buffer.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ValueBuffer(
            );

        // Attempt to cast a 'DkmManagedReturnValueInfo' to a 'DkmManagedReturnValueCopy'. Return
        // NULL if the path object is not a 'DkmManagedReturnValueCopy'.
        // pManagedReturnValueCopy : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmManagedReturnValueCopy* TryCast(
            DkmManagedReturnValueInfo* pManagedReturnValueInfo
            )
        {
            if (pManagedReturnValueInfo == NULL || pManagedReturnValueInfo->TagValue() != Tag::ManagedReturnValueCopy)
                return NULL;

            return static_cast<DkmManagedReturnValueCopy*>(pManagedReturnValueInfo);
        }

        // Create a new DkmManagedReturnValueCopy object instance.
        //
        // Location constraint: The caller is required to be in the same process (IDE process
        // or Monitor process) as the implementation component.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pCorType        : [In] ICorDebugType of the return value.
        // CorElementType  : [In,Optional] The CorElementType of the value type.
        // Size            : [In,Optional] The size of the value type.
        // Address         : [In,Optional] The address of the value type.
        // pValueBuffer    : [In,Optional] The captured value type buffer.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ICorDebugType* pCorType,
            _In_ UINT32 CorElementType,
            _In_ UINT32 Size,
            _In_ UINT64 Address,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pValueBuffer,
            _Deref_out_ Clr::DkmManagedReturnValueCopy** ppCreatedObject
            );
    }; // end of DkmManagedReturnValueCopy

    // Managed return value of reference type.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("59b45a07-6a5f-6938-4039-e4e382aaa05e") DkmManagedReturnValueReference : public Clr::DkmManagedReturnValueInfo
    {
        // Use DkmManagedReturnValueReference::Create to create this object
        private: DkmManagedReturnValueReference();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueReference();
        // This object cannot be copied
        private: DkmManagedReturnValueReference& operator=(const DkmManagedReturnValueReference&);
        private: DkmManagedReturnValueReference(const DkmManagedReturnValueReference&);

        private: OPTIONAL ICorDebugValue* const m_pCorValue;
        private: void* m__pExtendedData;

        // [Optional] ICorDebugValue from CLR. It is null for value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW ICorDebugValue* STDMETHODCALLTYPE CorValue(
            );

        // Attempt to cast a 'DkmManagedReturnValueInfo' to a 'DkmManagedReturnValueReference'. Return
        // NULL if the path object is not a 'DkmManagedReturnValueReference'.
        // pManagedReturnValueReference : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmManagedReturnValueReference* TryCast(
            DkmManagedReturnValueInfo* pManagedReturnValueInfo
            )
        {
            if (pManagedReturnValueInfo == NULL || pManagedReturnValueInfo->TagValue() != Tag::ManagedReturnValueReference)
                return NULL;

            return static_cast<DkmManagedReturnValueReference*>(pManagedReturnValueInfo);
        }

        // Create a new DkmManagedReturnValueReference object instance.
        //
        // Location constraint: The caller is required to be in the same process (IDE process
        // or Monitor process) as the implementation component.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pCorType        : [In] ICorDebugType of the return value.
        // pCorValue       : [In,Optional] ICorDebugValue from CLR. It is null for value
        // type.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ICorDebugType* pCorType,
            _In_opt_ ICorDebugValue* pCorValue,
            _Deref_out_ Clr::DkmManagedReturnValueReference** ppCreatedObject
            );
    }; // end of DkmManagedReturnValueReference

}; // end namespace Clr

// Contains types specific to debugging code running under the native-compiled CLR.
namespace Clr { namespace NativeCompilation {
    // Information about an instance field for a managed class that is compiled into native
    // code.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bb9283d5-b8d9-c1fc-fcdc-c798561b248e") DkmClrNcInstanceFieldSymbol : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrNcInstanceFieldSymbol::Create to create this object
        private: DkmClrNcInstanceFieldSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcInstanceFieldSymbol();
        // This object cannot be copied
        private: DkmClrNcInstanceFieldSymbol& operator=(const DkmClrNcInstanceFieldSymbol&);
        private: DkmClrNcInstanceFieldSymbol(const DkmClrNcInstanceFieldSymbol&);

        private: DkmString* const m_pName;
        private: const UINT32 m_Size;
        private: const UINT32 m_Offset;
        private: void* m__pExtendedData;

        // Field name.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Size in bytes.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Byte offset in class.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Offset(
            );

        // Create a new DkmClrNcInstanceFieldSymbol object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pName           : [In] Field name.
        // Size            : [In] Size in bytes.
        // Offset          : [In] Byte offset in class.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ UINT32 Size,
            _In_ UINT32 Offset,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol** ppCreatedObject
            );
    }; // end of DkmClrNcInstanceFieldSymbol

    // 'DkmClrNcContainerModuleInstance' is used to represent a module instance which is 1:1
    // with a physical native dll loaded by the target app. This native dll functions as a
    // logical container for one or more logical managed modules (DkmClrNcModuleInstance)
    // which are embedded inside it.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a79c8888-83eb-5fa2-143f-7e9b42f77bed") DkmClrNcContainerModuleInstance : public DkmModuleInstance
    {
        // Use DkmClrNcContainerModuleInstance::Create to create this object
        private: DkmClrNcContainerModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcContainerModuleInstance();
        // This object cannot be copied
        private: DkmClrNcContainerModuleInstance& operator=(const DkmClrNcContainerModuleInstance&);
        private: DkmClrNcContainerModuleInstance(const DkmClrNcContainerModuleInstance&);

        private: void* m__pExtendedData;
        private: void* m_pEmbeddedModuleCollection0;

        // Represents a native-compiled CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmClrNcContainerModuleInstance'. Return
        // NULL if the path object is not a 'DkmClrNcContainerModuleInstance'.
        // pClrNcContainerModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrNcContainerModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::ClrNcContainerModuleInstance)
                return NULL;

            return static_cast<DkmClrNcContainerModuleInstance*>(pModuleInstance);
        }

        // Find a DkmClrNcModuleInstance element within this DkmClrNcContainerModuleInstance.
        // If no element with the given input key is present, FindEmbeddedModule will fail.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // Index           : [In] Search key used to find the element.
        // ppEmbeddedModule: [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindEmbeddedModule(
            _In_ UINT32 Index,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcModuleInstance** ppEmbeddedModule
            );

        // GetEmbeddedModules enumerates the DkmClrNcModuleInstance elements of this
        // DkmClrNcContainerModuleInstance object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pEmbeddedModules: [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEmbeddedModules(
            _Out_ DkmArray<Clr::NativeCompilation::DkmClrNcModuleInstance*>* pEmbeddedModules
            );

        // Returns the image bytes starting at a specified RVA. Implemented by symbol
        // provider for managed DM.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // RVA             : [In] Starting RVA from where bytes are requested.
        // BytesRequested  : [In] Number of bytes requested.
        // pImageBytes     : [Out] Image bytes.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAssemblyImageBytes(
            _In_ UINT32 RVA,
            _In_ UINT32 BytesRequested,
            _Out_ DkmArray<BYTE>* pImageBytes
            );

        // Retrieves the layout of the class.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pClassSignature : [In] Signature of class.
        // pInstanceFields : [Out] Array of instance fields.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pSize           : [Out] Size of the struct/class in bytes.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClassInfo(
            _In_ DkmReadOnlyCollection<BYTE>* pClassSignature,
            _Out_ DkmArray<Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol*>* pInstanceFields,
            _Out_ UINT32* pSize
            );
    }; // end of DkmClrNcContainerModuleInstance

    // DkmClrNcInstructionAddress is used to represent an addresses in native-compiled CLR
    // code. It contains the information about where the instruction is using both managed
    // concepts (DkmClrNcModuleInstance, method token, IL offset) and native concepts (
    // DkmClrNcContainerModuleInstance, RVA).
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("377ece5a-e9ff-bb6a-1612-b5d9cc54755f") DkmClrNcInstructionAddress : public Clr::DkmClrInstructionAddress
    {
        // Use DkmClrNcInstructionAddress::Create to create this object
        private: DkmClrNcInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcInstructionAddress();
        // This object cannot be copied
        private: DkmClrNcInstructionAddress& operator=(const DkmClrNcInstructionAddress&);
        private: DkmClrNcInstructionAddress(const DkmClrNcInstructionAddress&);

        private: Clr::NativeCompilation::DkmClrNcContainerModuleInstance* const m_pContainerModule;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pGenericParameters;
        private: void* m__pExtendedData;

        // Represents a native-compiled CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The managed module containing the InstructionPointer.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The underlying container module (on-disk module) where this address is loaded.
        // Symbols (DkmModule) are accessed through this module instead of 'ModuleInstance'.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE ContainerModule(
            );

        // [Optional] For generic methods, this provides the ECMA formatted TypeSpec
        // signature for each generic parameter. For non-generic methods, this will be null.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE GenericParameters(
            );

        // Create a new DkmClrNcInstructionAddress object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // MethodId        : [In] The version/token pair for this method.
        // NativeOffset    : [In] For the standard .NET Framework, NativeOffset is a byte
        // offset relative to start of the method where the CPU instruction can be found. For
        // the purpose of this value, the method should be treated as a contiguous block of
        // bytes. If the method has not been Just-in-time compiled or if this address is
        // being used to refer purely to the IL address, NativeOffset will be set to
        // UInt32.MaxValue.
        //
        // For native-compiled .NET Framework modules,  this value is the RVA of the native
        // instruction in the module.
        // ILOffset        : [In] ILOffset is the index of the IL instruction that this
        // address represents. This value may be set to UInt32.MaxValue for an instruction
        // that is within the given method, but not tied to a particular IL instruction. This
        // is used for CLR native instructions that don't map to an IL instruction.
        // (ICorDebugILFrame::GetIP indicates MAPPING_UNMAPPED_ADDRESS).
        // pRuntimeInstance: [In] Represents a native-compiled CLR instance running in a
        // target process.
        // pModuleInstance : [In] The managed module containing the InstructionPointer.
        // pContainerModule: [In] The underlying container module (on-disk module) where this
        // address is loaded. Symbols (DkmModule) are accessed through this module instead of
        // 'ModuleInstance'.
        // pGenericParameters: [In,Optional] For generic methods, this provides the ECMA
        // formatted TypeSpec signature for each generic parameter. For non-generic methods,
        // this will be null.
        // pCPUInstruction : [In,Optional] CPUInstruction provides the address that the CPU
        // will execute. This is always provided for native instructions. It may be provided
        // for CLR or custom addresses depending on how the address object was created.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 NativeOffset,
            _In_ UINT32 ILOffset,
            _In_ Clr::NativeCompilation::DkmClrNcRuntimeInstance* pRuntimeInstance,
            _In_ Clr::NativeCompilation::DkmClrNcModuleInstance* pModuleInstance,
            _In_ Clr::NativeCompilation::DkmClrNcContainerModuleInstance* pContainerModule,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pGenericParameters,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcInstructionAddress** ppCreatedObject
            );
    }; // end of DkmClrNcInstructionAddress

    // DkmClrNcInstructionSymbol represents an IL instruction that has been compiled to
    // native code and is running under the native-compiled CLR. DkmClrNcInstructionSymbol is
    // in a hybrid of a native and CLR instruction symbols - like a CLR instruction symbol,
    // it contains enough information to bind the symbol to the managed IL instruction
    // address concepts. Like a native symbol, it contains enough information to bind it to a
    // native CPU address.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("19d8a807-38c8-4b6d-a89a-4e4b00a604d7") DkmClrNcInstructionSymbol : public Clr::DkmClrInstructionSymbol
    {
        // Use DkmClrNcInstructionSymbol::Create to create this object
        private: DkmClrNcInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcInstructionSymbol();
        // This object cannot be copied
        private: DkmClrNcInstructionSymbol& operator=(const DkmClrNcInstructionSymbol&);
        private: DkmClrNcInstructionSymbol(const DkmClrNcInstructionSymbol&);

        private: const UINT32 m_EmbeddedModuleIndex;
        private: const UINT32 m_NativeOffset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pGenericParameters;
        private: void* m__pExtendedData;

        // Identifier of the embedded module within the container where this function
        // resides.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE EmbeddedModuleIndex(
            );

        // This value is the RVA of the native instruction from the beginning of the native
        // module that contains this instruction.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NativeOffset(
            );

        // [Optional] For generic methods, this provides the ECMA formatted TypeSpec
        // signature for each generic parameter. For non-generic methods, this will be null.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE GenericParameters(
            );

        // Create a new DkmClrNcInstructionSymbol object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // MethodId        : [In] The version/token pair for this method.
        // ILOffset        : [In] ILOffset is the index of the IL instruction that this
        // symbol represents. This value may be set to UInt32.MaxValue for an instruction
        // that is within the given method, but not tied to a particular instruction. This is
        // used for CLR native instructions that don't map to an IL instruction.
        // EmbeddedModuleIndex: [In] Identifier of the embedded module within the container
        // where this function resides.
        // NativeOffset    : [In] This value is the RVA of the native instruction from the
        // beginning of the native module that contains this instruction.
        // pGenericParameters: [In,Optional] For generic methods, this provides the ECMA
        // formatted TypeSpec signature for each generic parameter. For non-generic methods,
        // this will be null.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 ILOffset,
            _In_ UINT32 EmbeddedModuleIndex,
            _In_ UINT32 NativeOffset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pGenericParameters,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcInstructionSymbol** ppCreatedObject
            );
    }; // end of DkmClrNcInstructionSymbol

    // 'DkmClrNcModuleInstance' is used for managed modules which are compiled to native code
    // and embedded inside of a native module. Like DkmClrModuleInstance, these are 1:1 with
    // an ICorDebugModule.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("f85a173b-616b-91d3-319d-24cf9030c023") DkmClrNcModuleInstance : public Clr::DkmClrModuleInstance
    {
        // Use DkmClrNcModuleInstance::Create to create this object
        private: DkmClrNcModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcModuleInstance();
        // This object cannot be copied
        private: DkmClrNcModuleInstance& operator=(const DkmClrNcModuleInstance&);
        private: DkmClrNcModuleInstance(const DkmClrNcModuleInstance&);

        private: Clr::NativeCompilation::DkmClrNcContainerModuleInstance* const m_pContainerModule;
        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // Represents a native-compiled CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The container (physical) module instance that this embedded (virtual) module is
        // built into.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE ContainerModule(
            );

        // The identifier for this embedded module within the container. This is used as a
        // prefix on type names in the container module to indicate which embedded module a
        // type belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );
    }; // end of DkmClrNcModuleInstance

    // Represents a native-compiled CLR instance running in a target process.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a1a355e8-c42b-c18f-c5e6-42f06d6aa8c5") DkmClrNcRuntimeInstance : public Clr::DkmClrRuntimeInstance
    {
        // Use DkmClrNcRuntimeInstance::Create to create this object
        private: DkmClrNcRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcRuntimeInstance();
        // This object cannot be copied
        private: DkmClrNcRuntimeInstance& operator=(const DkmClrNcRuntimeInstance&);
        private: DkmClrNcRuntimeInstance(const DkmClrNcRuntimeInstance&);

        private: void* m__pExtendedData;

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // Capabilities    : [In] Enumeration of runtime capabilities.
        // pParentRuntime  : [In,Optional] For runtimes that are implemented on top of
        // another runtime, this can optionally be used to indicant the logical parent. This
        // can then be used to request services from the parent when the child runtime
        // doesn't implement the service. This is currently used only for obtaining the top
        // stack frame to evaluate a conditional breakpoint when the child runtime doesn't
        // walk stacks itself.
        // pRuntimeVersion : [In,Optional] The version string for the CLR instance (ex:
        // 'v2.0.50727').
        // DataItem        : [In] Data object to add to the new DkmClrNcRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities::e Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_opt_ DkmString* pRuntimeVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcRuntimeInstance** ppCreatedObject
            );
    }; // end of DkmClrNcRuntimeInstance

};}; // end namespace Clr::NativeCompilation

// Contains types specific to debugging native code.
namespace Native {
    // Extended information about a CPP exception thrown while debugging a windows runtime
    // application.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dcee9b3e-138b-d26c-42fd-4bfd99a3955b") DkmCppWinRTExceptionInformation : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmCppWinRTExceptionInformation::Create to create this object
        private: DkmCppWinRTExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCppWinRTExceptionInformation();
        // This object cannot be copied
        private: DkmCppWinRTExceptionInformation& operator=(const DkmCppWinRTExceptionInformation&);
        private: DkmCppWinRTExceptionInformation(const DkmCppWinRTExceptionInformation&);

        // Contains additional fields of DkmCppWinRTExceptionInformation which were added
        // after the class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // The address of the IErrorInfo object associated with the exception.  This is
            // used to retrieve captured stack.
            const UINT64 ErrorInfoAddress;

            // [Optional] If the exception contains a captured stack trace, specifies the
            // addresses of the captured frames.
            OPTIONAL DkmReadOnlyCollection<DkmInstructionAddress*>* const pCapturedStack;
        };

        private: DkmString* const m_pDescription;
        private: DkmString* const m_pRestrictedDescription;
        private: DkmString* const m_pRestrictedReference;
        private: DkmString* const m_pRestrictedCapabilitySid;
        private: const HRESULT m_ExceptionHR;
        private: ___ExtendedData* const m__pExtendedData;

        // Basic non-restricted description of the exception.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // Restricted description of the exception.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedDescription(
            );

        // Reference string used as a key to find restricted information when
        // RestrictedReference is missing.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedReference(
            );

        // Security identifier of a missing capability if this exception was thrown for that
        // reason.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedCapabilitySid(
            );

        // The failed HRESULT value that caused this exception to be thrown.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ExceptionHR(
            );

        // The address of the IErrorInfo object associated with the exception.  This is used
        // to retrieve captured stack.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ErrorInfoAddress(
            );

        // [Optional] If the exception contains a captured stack trace, specifies the
        // addresses of the captured frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmInstructionAddress*>* STDMETHODCALLTYPE CapturedStack(
            );

        // Create a new DkmCppWinRTExceptionInformation object instance.
        // pDescription    : [In] Basic non-restricted description of the exception.
        // pRestrictedDescription: [In] Restricted description of the exception.
        // pRestrictedReference: [In] Reference string used as a key to find restricted
        // information when RestrictedReference is missing.
        // pRestrictedCapabilitySid: [In] Security identifier of a missing capability if this
        // exception was thrown for that reason.
        // ExceptionHR     : [In] The failed HRESULT value that caused this exception to be
        // thrown.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDescription,
            _In_ DkmString* pRestrictedDescription,
            _In_ DkmString* pRestrictedReference,
            _In_ DkmString* pRestrictedCapabilitySid,
            _In_ HRESULT ExceptionHR,
            _Deref_out_ Native::DkmCppWinRTExceptionInformation** ppCreatedObject
            );

        // Create a new DkmCppWinRTExceptionInformation object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pDescription    : [In] Basic non-restricted description of the exception.
        // pRestrictedDescription: [In] Restricted description of the exception.
        // pRestrictedReference: [In] Reference string used as a key to find restricted
        // information when RestrictedReference is missing.
        // pRestrictedCapabilitySid: [In] Security identifier of a missing capability if this
        // exception was thrown for that reason.
        // ExceptionHR     : [In] The failed HRESULT value that caused this exception to be
        // thrown.
        // ErrorInfoAddress: [In] The address of the IErrorInfo object associated with the
        // exception.  This is used to retrieve captured stack.
        // pCapturedStack  : [In,Optional] If the exception contains a captured stack trace,
        // specifies the addresses of the captured frames.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDescription,
            _In_ DkmString* pRestrictedDescription,
            _In_ DkmString* pRestrictedReference,
            _In_ DkmString* pRestrictedCapabilitySid,
            _In_ HRESULT ExceptionHR,
            _In_ UINT64 ErrorInfoAddress,
            _In_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>* pCapturedStack,
            _Deref_out_ Native::DkmCppWinRTExceptionInformation** ppCreatedObject
            );
    }; // end of DkmCppWinRTExceptionInformation

    // Result of an asynchronous DkmNativeModuleInstance.FindExportName call.
    struct DkmFindExportNameAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] If the export was found in the specified module, this will contain the
        // target address. Note that this instruction address object may be in a different
        // module than the searched module. This can happen if the export was forwarded and
        // the destination module is already loaded. If the destination module is not loaded,
        // the export will be ignored.
        OPTIONAL Native::DkmNativeInstructionAddress* pAddress;
    };

    // Result of an asynchronous DkmNativeInstructionAddress.FindNearestExport call.
    struct DkmFindNearestExportAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Name of the export.
        OPTIONAL DkmString* pExportName;

        // Byte offset from the start of the export.
        INT32 ByteOffset;
    };

    // DkmNativeAddressMetadata represents symbol based metadata about addresses. This
    // includes if the address is a thunk, a prolog, or a trampoline.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4d17e81c-cff2-58f7-7973-87f40be51fc0") DkmNativeAddressMetadata : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNativeAddressMetadata::Create to create this object
        private: DkmNativeAddressMetadata();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeAddressMetadata();
        // This object cannot be copied
        private: DkmNativeAddressMetadata& operator=(const DkmNativeAddressMetadata&);
        private: DkmNativeAddressMetadata(const DkmNativeAddressMetadata&);

        private: const Native::DkmNativeAddressType::e m_AddressType;
        private: const Native::DkmNativeAddressStepType::e m_StepType;
        private: const UINT32 m_AddressTypeLength;
        private: void* m__pExtendedData;

        // A value from the DkmNativeAddressType enumeration describing what this address is
        // in the debuggee.
        public: DECLSPEC_NOTHROW Native::DkmNativeAddressType::e STDMETHODCALLTYPE AddressType(
            );

        // A value from the DkmNativeAddressStepType enumeration describing how the native
        // steppers should tread this address when a step encounters it.
        public: DECLSPEC_NOTHROW Native::DkmNativeAddressStepType::e STDMETHODCALLTYPE StepType(
            );

        // The length of the current address type.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE AddressTypeLength(
            );

        // Create a new DkmNativeAddressMetadata object instance.
        // AddressType     : [In] A value from the DkmNativeAddressType enumeration
        // describing what this address is in the debuggee.
        // StepType        : [In] A value from the DkmNativeAddressStepType enumeration
        // describing how the native steppers should tread this address when a step
        // encounters it.
        // AddressTypeLength: [In] The length of the current address type.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Native::DkmNativeAddressType::e AddressType,
            _In_ Native::DkmNativeAddressStepType::e StepType,
            _In_ UINT32 AddressTypeLength,
            _Deref_out_ Native::DkmNativeAddressMetadata** ppCreatedObject
            );
    }; // end of DkmNativeAddressMetadata

    // DkmNativeAddressStepType describes how the native range steppers should treat this
    // location. Used during step-in and step-out.
    enum DkmNativeAddressStepType::e
    {
        // No special treatment for this location.
        None = 0,
        // Stopping at this address does not make sense. Continue stepping past it.
        ContinueStep = 1
    };

    // DkmNativeAddressType describes if an address represents a special location in the
    // debuggee instruction stream.
    enum DkmNativeAddressType::e
    {
        // The address has native symbols and is at a normal location.
        Native = 0,
        // The address has native symbols but has no source information.
        NativeNoSource = 1,
        // The address represents a thunk in the target process.
        Thunk = 2,
        // The address represents a prolog to a function in the target process.
        Prolog = 3,
        // The address represents a epilog to a function in the target process.
        Epilog = 4,
        // The address represents a trampoline in the target process.
        Trampoline = 5,
        // The address represents code telling debugger do not stop and step into for any
        // call.
        NonStopStepIntoCode = 6,
        // The address is at the label _NLG_Return or _NLG_Return2.
        NlgReturn = 7,
        // The address represents a custom location in the debuggee.
        Custom = 8,
        // The address does not have native symbols.
        NoNativeSymbols = 9,
        // The address has native symbols but should not be stepped into.
        NativeNoStepInto = 10,
        // The address represents compiler generated WinRT glue code.
        CompilerGeneratedGlueCode = 11
    };

    // Provides information about a C++ exception which was raised in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8d9e3c4f-e264-47d5-0e02-7d5bf93c4659") DkmCppExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmCppExceptionInformation::Create to create this object
        private: DkmCppExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCppExceptionInformation();
        // This object cannot be copied
        private: DkmCppExceptionInformation& operator=(const DkmCppExceptionInformation&);
        private: DkmCppExceptionInformation(const DkmCppExceptionInformation&);

        private: const UINT64 m_ExceptionObjectPointer;
        private: const UINT64 m_Address;
        private: OPTIONAL Native::DkmCppWinRTExceptionInformation* const m_pWinRTExceptionInfo;
        private: void* m__pExtendedData;

        // Type name of the exception. Example: 'std::exception'.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Address within the target process of the thrown object.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ExceptionObjectPointer(
            );

        // The address where the exception occurred.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // [Optional] Extended information about a WinRT exception if it exists.
        public: _Ret_opt_ DECLSPEC_NOTHROW Native::DkmCppWinRTExceptionInformation* STDMETHODCALLTYPE WinRTExceptionInfo(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmCppExceptionInformation'. Return
        // NULL if the path object is not a 'DkmCppExceptionInformation'.
        // pCppException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCppExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::CppException)
                return NULL;

            return static_cast<DkmCppExceptionInformation*>(pException);
        }

        // Create a new DkmCppExceptionInformation object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pInstructionAddress: [In,Optional] Address where the exception occurred. This will
        // always be present for C++ and Win32 exceptions. It may be missing from CLR
        // exceptions or MDAs as these may originate from inside the runtime.
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration indicates the stage(s) for a notification.
        // pImplementationException: [In,Optional] Information about the underlying exception
        // used to implement a higher level exception. For example, CLR and C++ exceptions
        // may be implemented on top of Win32 exceptions. So this may store the
        // DkmWin32ExceptionInformation for CLR or C++ exceptions.
        // pName           : [In] Type name of the exception. Example: 'std::exception'.
        // ExceptionObjectPointer: [In] Address within the target process of the thrown
        // object.
        // Address         : [In] The address where the exception occurred.
        // pWinRTExceptionInfo: [In,Optional] Extended information about a WinRT exception if
        // it exists.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_opt_ Exceptions::DkmExceptionInformation* pImplementationException,
            _In_ DkmString* pName,
            _In_ UINT64 ExceptionObjectPointer,
            _In_ UINT64 Address,
            _In_opt_ Native::DkmCppWinRTExceptionInformation* pWinRTExceptionInfo,
            _Deref_out_ Native::DkmCppExceptionInformation** ppCreatedObject
            );
    }; // end of DkmCppExceptionInformation

    // DkmNativeInstructionAddress is used for addresses that resolve to within a native
    // module. This is used regardless as to if there are symbols for the module.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a1e2e4ab-463a-e8a1-3e68-1f49e6945d9e") DkmNativeInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmNativeInstructionAddress::Create to create this object
        private: DkmNativeInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeInstructionAddress();
        // This object cannot be copied
        private: DkmNativeInstructionAddress& operator=(const DkmNativeInstructionAddress&);
        private: DkmNativeInstructionAddress(const DkmNativeInstructionAddress&);

        private: const UINT32 m_RVA;
        private: void* m__pExtendedData;

        // Represents the native code executing in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The module containing the InstructionPointer.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The RVA of InstructionPointer within Module.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RVA(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmNativeInstructionAddress'. Return
        // NULL if the path object is not a 'DkmNativeInstructionAddress'.
        // pNativeAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::NativeAddress)
                return NULL;

            return static_cast<DkmNativeInstructionAddress*>(pInstructionAddress);
        }

        // Create a new DkmNativeInstructionAddress object instance.
        // pRuntimeInstance: [In] Represents the native code executing in a target process.
        // pModuleInstance : [In] The module containing the InstructionPointer.
        // RVA             : [In] The RVA of InstructionPointer within Module.
        // pCPUInstruction : [In,Optional] CPUInstruction provides the address that the CPU
        // will execute. This is always provided for native instructions. It may be provided
        // for CLR or custom addresses depending on how the address object was created.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Native::DkmNativeRuntimeInstance* pRuntimeInstance,
            _In_ Native::DkmNativeModuleInstance* pModuleInstance,
            _In_ UINT32 RVA,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Native::DkmNativeInstructionAddress** ppCreatedObject
            );

        // Finds the nearest module export from the specified instruction address. The export
        // could either be a function or data export, though function exports are far more
        // common. Because exports do not have address ranges, the specified address may not
        // actually be associated with the returned export.
        // ppExportName    : [Out,Optional] Name of the export.
        // pByteOffset     : [Out] Byte offset from the start of the export.
        // Return value    : S_OK is returned if *ppExportName is non-NULL, S_FALSE is
        // returned when *ppExportName is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNearestExport(
            _Deref_out_opt_ DkmString** ppExportName,
            _Out_ INT32* pByteOffset
            );

        // Finds the nearest module export from the specified instruction address. The export
        // could either be a function or data export, though function exports are far more
        // common. Because exports do not have address ranges, the specified address may not
        // actually be associated with the returned export.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNearestExport(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Native::DkmFindNearestExportAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // GetSteppingCallSites is called to get call sites reachable from an instruction.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // SteppingRanges  : [In] The stepping ranges to evaluate for call sites.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pCallSites      : [Out] DkmNativeSteppingCallSite[] specifies a call instruction
        // and it's target..
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppingCallSites(
            _In_ const DkmArray<Symbols::DkmSteppingRange>& SteppingRanges,
            _Out_ DkmArray<Stepping::DkmNativeSteppingCallSite*>* pCallSites
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmNativeInstructionAddress

    // DkmNativeInstructionSymbol represents a native instruction within a module of the
    // target process. DkmNativeInstructionSymbol are 1:1 with the underlying native
    // instructions. So if there are two template instantiations of a method (ex:
    // MyMethod<CString> and MyMethod<int>) if the linker merges the two instantiations into
    // a single function through COMDAT folding then the methods will be identical. If the
    // linker isn't able to merge the two instantiations then both user-level functions will
    // appear as one DkmNativeInstructionSymbol.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0eb834ca-c591-449c-66ad-e016093977d2") DkmNativeInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmNativeInstructionSymbol::Create to create this object
        private: DkmNativeInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeInstructionSymbol();
        // This object cannot be copied
        private: DkmNativeInstructionSymbol& operator=(const DkmNativeInstructionSymbol&);
        private: DkmNativeInstructionSymbol(const DkmNativeInstructionSymbol&);

        private: const UINT32 m_RVA;
        private: void* m__pExtendedData;

        // The RVA of InstructionPointer within Module.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RVA(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmNativeInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmNativeInstructionSymbol'.
        // pNativeInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::NativeInstruction)
                return NULL;

            return static_cast<DkmNativeInstructionSymbol*>(pInstruction);
        }

        // Create a new DkmNativeInstructionSymbol object instance.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // RVA             : [In] The RVA of InstructionPointer within Module.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 RVA,
            _Deref_out_ Native::DkmNativeInstructionSymbol** ppCreatedObject
            );

        // Returns address information to the native debug monitor.
        // pInstructionAddress: [In,Optional] Abstract representation of an executable code
        // location (ex: EIP value). If resolved, an Instruction Address will be within a
        // particular module instance. An Instruction Address is always within a particular
        // Runtime Instance.
        // ppMetadata      : [Out,Optional] DkmNativeAddressMetadata represents symbol based
        // metadata about addresses. This includes if the address is a thunk, a prolog, or a
        // trampoline.
        // Return value    : S_OK is returned if *ppMetadata is non-NULL, S_FALSE is returned
        // when *ppMetadata is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeInstructionMetadataCallback(
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _Deref_out_opt_ Native::DkmNativeAddressMetadata** ppMetadata
            );
    }; // end of DkmNativeInstructionSymbol

    // 'DkmNativeModuleInstance' is used for modules which contain CPU code and/or are loaded
    // by the Win32 loader.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7de7beb-acab-76c4-bd78-fbba698e4b65") DkmNativeModuleInstance : public DkmModuleInstance
    {
        // Use DkmNativeModuleInstance::Create to create this object
        private: DkmNativeModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeModuleInstance();
        // This object cannot be copied
        private: DkmNativeModuleInstance& operator=(const DkmNativeModuleInstance&);
        private: DkmNativeModuleInstance(const DkmNativeModuleInstance&);

        private: const Clr::DkmClrHeaderStatus::e m_ClrHeaderStatus;
        private: void* m__pExtendedData;

        // Represents the native code executing in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The starting memory address of where the module is loaded. This value should
        // always be valid.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE BaseAddress(
            );

        // The number of bytes in the module's memory region.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the
        // loaded module. This indicates which type of binary was loaded.
        public: DECLSPEC_NOTHROW Clr::DkmClrHeaderStatus::e STDMETHODCALLTYPE ClrHeaderStatus(
            );

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmNativeModuleInstance'. Return
        // NULL if the path object is not a 'DkmNativeModuleInstance'.
        // pNativeModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::NativeModuleInstance)
                return NULL;

            return static_cast<DkmNativeModuleInstance*>(pModuleInstance);
        }

        // Create a new DkmNativeModuleInstance object instance.
        //
        // This method will send a ModuleInstanceLoad event.
        // pName           : [In] Short representation of the module name. For file-based
        // modules, this  is the file name and extension (ex: kernel32.dll).
        // pFullName       : [In] Fully qualified module name. For file-based modules, this
        // is the full path to the module (ex: c:\windows\system32\kernel32.dll.
        // TimeDateStamp   : [In] Date/Time of when the loaded module was built. This value
        // is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of
        // measurement is a  FILETIME value, which is a 64-bit value representing the number
        // of 100-nanosecond intervals since January 1, 1601 (UTC).
        // pVersion        : [In,Optional] File version information.
        // pSymbolFileId   : [In,Optional] Contains information needed to locate symbols for
        // this module. On Win32, this information is contained within the
        // IMAGE_DEBUG_DIRECTORY.
        // Flags           : [In] Flags which indicate traits of a DkmModuleInstance.
        // MemoryLayout    : [In] Enumeration that indicates how a module is laid out in
        // memory.
        // LoadOrder       : [In] The integer count of the number of module instances that
        // have loaded up to and including this module. Each runtime instance keeps track of
        // its own load order count.
        // pLoadContext    : [In] String description of the context under which this module
        // has been loaded. ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        // pRuntimeInstance: [In] Represents the native code executing in a target process.
        // BaseAddress     : [In] The starting memory address of where the module is loaded.
        // This value should always be valid.
        // Size            : [In] The number of bytes in the module's memory region.
        // ClrHeaderStatus : [In] Contains information from the 'Flags' field of the
        // IMAGE_COR20_HEADER of the loaded module. This indicates which type of binary was
        // loaded.
        // IsDisabled      : [In] Indicates if this module instance has been disabled.
        // Disabled modules are largely ignored by the debugger. For native modules, the
        // address range of the disabled module is treated as if it is unmapped. For CLR
        // modules, any frames from these modules is hidden from the call stack.
        // pModule         : [In,Optional] The symbol handler's representation of a module
        // (DkmModule) which is associated with this module instance. This value is initially
        // null, and is assigned if and when symbols are associated with this module
        // instance.
        // pMinidumpInfo   : [In,Optional] 'MinidumpInfo' is used to convey additional
        // information about modules in a DkmProcess for a minidump.
        // DataItem        : [In] Data object to add to the new DkmNativeModuleInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags::e Flags,
            _In_ DkmModuleMemoryLayout::e MemoryLayout,
            _In_ UINT32 LoadOrder,
            _In_ DkmString* pLoadContext,
            _In_ Native::DkmNativeRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 Size,
            _In_ Clr::DkmClrHeaderStatus::e ClrHeaderStatus,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Native::DkmNativeModuleInstance** ppCreatedObject
            );

        // Obtain the function table entry for the passed address. The format of the engine
        // is dependent on the debuggee architecture.
        // Address         : [In] The address to search the function table for. Normally,
        // each entry contains a start and an end address. Implementations should return the
        // entry whose address range contains the requested address.
        // ppEntry         : [Out] The contents of the function table entry.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunctionTableEntry(
            _In_ UINT64 Address,
            _Deref_out_ DkmReadOnlyCollection<BYTE>** ppEntry
            );

        // Finds the address of the specified named exported function (or data export).
        // pName           : [In] The export name to search for in the module's export table.
        // IgnoreDataExports: [In] If true, the implementation will ignore any export which
        // is in non-executable memory.
        // ppAddress       : [Out,Optional] If the export was found in the specified module,
        // this will contain the target address. Note that this instruction address object
        // may be in a different module than the searched module. This can happen if the
        // export was forwarded and the destination module is already loaded. If the
        // destination module is not loaded, the export will be ignored.
        // Return value    : S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned
        // when *ppAddress is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindExportName(
            _In_ DkmString* pName,
            _In_ bool IgnoreDataExports,
            _Deref_out_opt_ Native::DkmNativeInstructionAddress** ppAddress
            );

        // Finds the address of the specified named exported function (or data export).
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // pName           : [In] The export name to search for in the module's export table.
        // IgnoreDataExports: [In] If true, the implementation will ignore any export which
        // is in non-executable memory.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindExportName(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pName,
            _In_ bool IgnoreDataExports,
            _In_ IDkmCompletionRoutine<Native::DkmFindExportNameAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmNativeModuleInstance

    // Represents the native code executing in a target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d7d75a72-5477-dcc3-e306-8e31a8e7fd7e") DkmNativeRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmNativeRuntimeInstance::Create to create this object
        private: DkmNativeRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeRuntimeInstance();
        // This object cannot be copied
        private: DkmNativeRuntimeInstance& operator=(const DkmNativeRuntimeInstance&);
        private: DkmNativeRuntimeInstance(const DkmNativeRuntimeInstance&);

        private: void* m__pExtendedData;
        private: void* m_pNativeModuleInstanceCollection0;

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmNativeRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmNativeRuntimeInstance'.
        // pNativeRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::NativeRuntimeInstance)
                return NULL;

            return static_cast<DkmNativeRuntimeInstance*>(pRuntimeInstance);
        }

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // DataItem        : [In] Data object to add to the new DkmNativeRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Native::DkmNativeRuntimeInstance** ppCreatedObject
            );

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // Capabilities    : [In] Enumeration of runtime capabilities.
        // pParentRuntime  : [In,Optional] For runtimes that are implemented on top of
        // another runtime, this can optionally be used to indicant the logical parent. This
        // can then be used to request services from the parent when the child runtime
        // doesn't implement the service. This is currently used only for obtaining the top
        // stack frame to evaluate a conditional breakpoint when the child runtime doesn't
        // walk stacks itself.
        // DataItem        : [In] Data object to add to the new DkmNativeRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities::e Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Native::DkmNativeRuntimeInstance** ppCreatedObject
            );

        // Find a DkmNativeModuleInstance element within this DkmNativeRuntimeInstance. If no
        // element with the given input key is present, FindNativeModuleInstance will fail.
        // BaseAddress     : [In] Search key used to find the element.
        // ppNativeModuleInstance: [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNativeModuleInstance(
            _In_ UINT64 BaseAddress,
            _Deref_out_ Native::DkmNativeModuleInstance** ppNativeModuleInstance
            );

        // GetNativeModuleInstances enumerates the DkmNativeModuleInstance elements of this
        // DkmNativeRuntimeInstance object.
        // pNativeModuleInstances: [Out] Array containing the enumerated elements.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeModuleInstances(
            _Out_ DkmArray<Native::DkmNativeModuleInstance*>* pNativeModuleInstances
            );
    }; // end of DkmNativeRuntimeInstance

    // Provides information about a Win32 exception which was raised in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8ca1a5b5-5cbb-f33f-6476-ae67ac9417fa") DkmWin32ExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmWin32ExceptionInformation::Create to create this object
        private: DkmWin32ExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmWin32ExceptionInformation();
        // This object cannot be copied
        private: DkmWin32ExceptionInformation& operator=(const DkmWin32ExceptionInformation&);
        private: DkmWin32ExceptionInformation(const DkmWin32ExceptionInformation&);

        private: const UINT32 m_ExceptionFlags;
        private: const UINT64 m_ParentExceptionRecordAddress;
        private: const UINT64 m_Address;
        private: DkmReadOnlyCollection<UINT64>* const m_pExceptionParameters;
        private: void* m__pExtendedData;

        // The exception flags. This can be either zero to indicate a continuable exception,
        // or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable exception.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ExceptionFlags(
            );

        // Address within the target process where the parent EXCEPTION_RECORD pointer can be
        // found. This is commonly zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ParentExceptionRecordAddress(
            );

        // The address where the exception occurred.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Parameters passed when the exception was raised. These parameters may be passed
        // from the Kernel as part of handling a hardware fault (ex: access violation), or
        // they may be passed from kernel32!RaiseException for software exceptions.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE ExceptionParameters(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmWin32ExceptionInformation'. Return
        // NULL if the path object is not a 'DkmWin32ExceptionInformation'.
        // pWin32Exception : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmWin32ExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::Win32Exception)
                return NULL;

            return static_cast<DkmWin32ExceptionInformation*>(pException);
        }

        // Create a new DkmWin32ExceptionInformation object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pInstructionAddress: [In,Optional] Address where the exception occurred. This will
        // always be present for C++ and Win32 exceptions. It may be missing from CLR
        // exceptions or MDAs as these may originate from inside the runtime.
        // Code            : [In] 32-bit integer code for the exception. For Win32
        // exceptions, this is the code passed to RaiseException
        // (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that
        // identify exceptions by string (ex: CLR).
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration indicates the stage(s) for a notification.
        // ExceptionFlags  : [In] The exception flags. This can be either zero to indicate a
        // continuable exception, or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable
        // exception.
        // ParentExceptionRecordAddress: [In] Address within the target process where the
        // parent EXCEPTION_RECORD pointer can be found. This is commonly zero.
        // Address         : [In] The address where the exception occurred.
        // pExceptionParameters: [In] Parameters passed when the exception was raised. These
        // parameters may be passed from the Kernel as part of handling a hardware fault (ex:
        // access violation), or they may be passed from kernel32!RaiseException for software
        // exceptions.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT32 Code,
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_ UINT32 ExceptionFlags,
            _In_ UINT64 ParentExceptionRecordAddress,
            _In_ UINT64 Address,
            _In_ DkmReadOnlyCollection<UINT64>* pExceptionParameters,
            _Deref_out_ Native::DkmWin32ExceptionInformation** ppCreatedObject
            );
    }; // end of DkmWin32ExceptionInformation

}; // end namespace Native

// Contains types specific to debugging script code.
namespace Script {
    // Result of an asynchronous DkmScriptRuntimeInstance.OnScriptCriticalError call.
    struct DkmOnScriptCriticalErrorAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Provides the content and position of a block of code in a mixed-content document (ex:
    // .aspx file). This can be used to map the block from source to generated document.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("95e15cff-d9eb-8030-0b43-da52cd1b977b") DkmScriptBlockMappingInfo : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmScriptBlockMappingInfo::Create to create this object
        private: DkmScriptBlockMappingInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptBlockMappingInfo();
        // This object cannot be copied
        private: DkmScriptBlockMappingInfo& operator=(const DkmScriptBlockMappingInfo&);
        private: DkmScriptBlockMappingInfo(const DkmScriptBlockMappingInfo&);

        private: DkmString* const m_pCodeText;
        private: const Symbols::DkmTextSpan m_TextSpan;
        private: void* m__pExtendedData;

        // Text of the code in the script block.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CodeText(
            );

        // The text span of this script block.
        public: DECLSPEC_NOTHROW const Symbols::DkmTextSpan& STDMETHODCALLTYPE TextSpan(
            );

        // Create a new DkmScriptBlockMappingInfo object instance.
        // pCodeText       : [In] Text of the code in the script block.
        // TextSpan        : [In] The text span of this script block.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pCodeText,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _Deref_out_ Script::DkmScriptBlockMappingInfo** ppCreatedObject
            );
    }; // end of DkmScriptBlockMappingInfo

    // Indicates the content type of the underlying script document.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmScriptDocumentContentType::e
    {
        // Document kind could not be determined.
        Unknown = 0,
        // Document is JavaScript.
        Script = 1,
        // Document is HTML.
        Html = 2
    };

    // Flag properties of a script document.
    enum DkmScriptDocumentFlags::e
    {
        // No flags are set.
        None = 0x0,
        // Document represents a container which aggregated together many sub-documents. For
        // JavaScript, this is use for 'eval code' and 'Function code' documents.
        AggregateDocument = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmScriptDocumentFlags::e);

    // The Just-My-Code state of the document exposed via the DkmScriptDocument.JmcState
    // variable. The JMC state of the document is ignored if JMC is not enabled and all
    // documents are treated as user code.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmScriptDocumentJmcState::e
    {
        // The project system and/or runtime engine does not know whether the script document
        // is user code.  Unsure means the engine will continuing querying the rest of the
        // project systems until one of them returns something other than Unsure. If all
        // project systems return Unsure, the script will be treated by the engine as though
        // it is user code (see MyCode state).
        Unsure = 0,
        // The script document is user code and should not be hidden from the user in any
        // way.  All script documents behave as MyCode when JMC is not enabled.
        MyCode = 1,
        // The script document is library code.  Unhandled exceptions and first chance
        // exceptions where the call stack contains user code are exposed to the user. Step
        // operations bypass the non-user code unless the step originates in non-user code.
        // Stack frames in library code are collapsed to [External Code].
        LibraryCode = 2,
        // The script document is unrelated to any user code.  Unhandled exceptions and first
        // chance exceptions are not visible to the user.  Embedded script breakpoints are
        // also not visible to the user.
        UnrelatedCode = 3
    };

    // Represents a node in the 'Script Documents' virtual tree within solution explorer.
    // Nodes may either be a virtual container, or they can be a document. In the latter
    // case, they will be a DkmScriptDocument.
    //
    // Derived classes: DkmScriptDocument
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("df65fb73-d375-49e7-06f9-0e5613dba3f3") DkmScriptDocumentTreeNode : public DkmDataContainer
    {
        // Use DkmScriptDocumentTreeNode::Create to create this object
        private: DkmScriptDocumentTreeNode();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptDocumentTreeNode();
        // This object cannot be copied
        private: DkmScriptDocumentTreeNode& operator=(const DkmScriptDocumentTreeNode&);
        private: DkmScriptDocumentTreeNode(const DkmScriptDocumentTreeNode&);

        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: OPTIONAL Script::DkmScriptDocumentTreeNode* const m_pParent;
        private: const GUID m_UniqueId;
        private: DkmString* const m_pTitle;
        private: void* m__pExtendedData;

        // The runtime which produced this container.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // [Optional] Parent in the script document tree. This will be null for the root
        // application container.
        public: _Ret_opt_ DECLSPEC_NOTHROW Script::DkmScriptDocumentTreeNode* STDMETHODCALLTYPE Parent(
            );

        // Guid which uniquely identifies this script document folder object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Title of the node.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Title(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Create a new DkmScriptDocumentTreeNode object instance.
        //
        // This method will send a ScriptDocumentTreeNodeCreate event.
        // pRuntimeInstance: [In] The runtime which produced this container.
        // pParent         : [In,Optional] Parent in the script document tree. This will be
        // null for the root application container.
        // pTitle          : [In] Title of the node.
        // DataItem        : [In] Data object to add to the new DkmScriptDocumentTreeNode
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Script::DkmScriptDocumentTreeNode* pParent,
            _In_ DkmString* pTitle,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptDocumentTreeNode** ppCreatedObject
            );

        // Invoked by a script document provide to fire a ScriptDocumentTreeNodeUnload event.
        //
        // This method may only be called by the component which created the object.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
            );
    }; // end of DkmScriptDocumentTreeNode

    // Indicates the kind of embedded document (or none if not an embedded document). The
    // type can be eval code, function code, or script block.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmScriptEmbeddedDocumentKind::e
    {
        // This is not an embedded script document.
        None = 0,
        // Document is eval code.
        EvalCode = 1,
        // Document is function code.
        FunctionCode = 2,
        // Document is a script block.
        ScriptBlock = 3
    };

    // The source project system item for a script document.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("554a3b31-dbb1-1b82-b0a4-8854519691c7") DkmScriptSourceProjectItem : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmScriptSourceProjectItem::Create to create this object
        private: DkmScriptSourceProjectItem();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptSourceProjectItem();
        // This object cannot be copied
        private: DkmScriptSourceProjectItem& operator=(const DkmScriptSourceProjectItem&);
        private: DkmScriptSourceProjectItem(const DkmScriptSourceProjectItem&);

        private: DkmString* const m_pPath;
        private: const bool m_IsGenerated;
        private: void* m__pExtendedData;

        // Moniker of the project item returned from MapDeployedURLToProjectItem. Project
        // systems can plug into this through IsDocumentInProject.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
            );

        // True if the script document is expected to be a generated client-side document, so
        // the project item cannot be directly mapped.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsGenerated(
            );

        // Create a new DkmScriptSourceProjectItem object instance.
        // pPath           : [In] Moniker of the project item returned from
        // MapDeployedURLToProjectItem. Project systems can plug into this through
        // IsDocumentInProject.
        // IsGenerated     : [In] True if the script document is expected to be a generated
        // client-side document, so the project item cannot be directly mapped.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pPath,
            _In_ bool IsGenerated,
            _Deref_out_ Script::DkmScriptSourceProjectItem** ppCreatedObject
            );
    }; // end of DkmScriptSourceProjectItem

    // Value returned from IDkmScriptSymbolCallback.GetNextSteppingAction which indicates the
    // next action that the script DM should take.
    enum DkmScriptSymbolNextSteppingAction::e
    {
        // Step has landed at non-hidden code which maps to the same statement/line
        // (depending on the IsSteppingByLine value) as where the step was originated.
        CompleteStep = 0,
        // Step completed at a hidden statement, or at a statement which is still part of the
        // same statement/line (depending on the IsSteppingByLine value) as the
        // StartingInstruction. The debug monitor should step again. If it is a performing a
        // step into, the debug monitor should resume with a step into. Otherwise a step over
        // should be performed.
        SkipStatement = 1,
        // Step completed at a hidden statement, or at a statement which is still part of the
        // same statement/line (depending on the IsSteppingByLine value) as the
        // StartingInstruction. The debug monitor should step again with a step over (even if
        // the original operation was a step into).
        SkipMethodCall = 2,
        // Step completed in a hidden method, or the remainder of the method is hidden code.
        // The debug monitor should step out of the method.
        SkipCurrentMethod = 3
    };

    // Result of an asynchronous DkmScriptDocument.SetRaiseSymbolEvents call.
    struct DkmSetRaiseSymbolEventsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Represents a document which is executing in a script runtime environment. For example,
    // the Microsoft JavaScript engine.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5df7092d-153e-3a9e-6a9c-01d70ae57148") DkmScriptDocument : public Script::DkmScriptDocumentTreeNode
    {
        // Use DkmScriptDocument::Create to create this object
        private: DkmScriptDocument();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptDocument();
        // This object cannot be copied
        private: DkmScriptDocument& operator=(const DkmScriptDocument&);
        private: DkmScriptDocument(const DkmScriptDocument&);

        // Contains additional fields of DkmScriptDocument which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Indicates the content type of the underlying script document.
            const Script::DkmScriptDocumentContentType::e ContentType;

            // Indicates the kind of embedded document (or none if not an embedded document).
            // The type can be eval code, function code, or script block.
            const Script::DkmScriptEmbeddedDocumentKind::e EmbeddedDocumentKind;

            // The Just-My-Code state of the document. To update the value of this variable,
            // call DkmScriptDocument.SetJmcState.
            Script::DkmScriptDocumentJmcState::e JmcState;
        };

        private: Symbols::DkmModule* const m_pModule;
        private: OPTIONAL DkmString* const m_pUrl;
        private: OPTIONAL DkmString* const m_pFilePath;
        private: const Script::DkmScriptDocumentFlags::e m_Flags;
        private: OPTIONAL Script::DkmScriptSourceProjectItem* m_pSourceProjectItem;
        private: ___ExtendedData* const m__pExtendedData;

        // Guid which uniquely identifies this script document folder object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The symbol container which owns this document.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // [Optional] URL of the script document. This may be null if the document has no
        // URL.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Url(
            );

        // [Optional] File path (ex: c:\myfolder\file.js) of the script document. This will
        // be null if the document has no URL, or has a non-'file://' URL.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FilePath(
            );

        // Flag properties of a script document.
        public: DECLSPEC_NOTHROW Script::DkmScriptDocumentFlags::e STDMETHODCALLTYPE Flags(
            );

        // Indicates the content type of the underlying script document.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Script::DkmScriptDocumentContentType::e STDMETHODCALLTYPE ContentType(
            );

        // Indicates the kind of embedded document (or none if not an embedded document). The
        // type can be eval code, function code, or script block.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Script::DkmScriptEmbeddedDocumentKind::e STDMETHODCALLTYPE EmbeddedDocumentKind(
            );

        // [Optional] The project item which matches this document.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourceProjectItem(
            _Deref_out_opt_ Script::DkmScriptSourceProjectItem** ppValue);

        // The Just-My-Code state of the document. To update the value of this variable, call
        // DkmScriptDocument.SetJmcState.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Script::DkmScriptDocumentJmcState::e STDMETHODCALLTYPE JmcState(
            );

        // Create a new DkmScriptDocument object instance.
        //
        // This method will send a ScriptDocumentTreeNodeCreate event.
        // pRuntimeInstance: [In] The runtime which produced this container.
        // pParent         : [In,Optional] Parent in the script document tree. This will be
        // null for the root application container.
        // pTitle          : [In] Title of the node.
        // pModule         : [In] The symbol container which owns this document.
        // pUrl            : [In,Optional] URL of the script document. This may be null if
        // the document has no URL.
        // pFilePath       : [In,Optional] File path (ex: c:\myfolder\file.js) of the script
        // document. This will be null if the document has no URL, or has a non-'file://'
        // URL.
        // Flags           : [In] Flag properties of a script document.
        // pSourceProjectItem: [In,Optional] The project item which matches this document.
        // DataItem        : [In] Data object to add to the new DkmScriptDocument instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Script::DkmScriptDocumentTreeNode* pParent,
            _In_ DkmString* pTitle,
            _In_ Symbols::DkmModule* pModule,
            _In_opt_ DkmString* pUrl,
            _In_opt_ DkmString* pFilePath,
            _In_ Script::DkmScriptDocumentFlags::e Flags,
            _In_opt_ Script::DkmScriptSourceProjectItem* pSourceProjectItem,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptDocument** ppCreatedObject
            );

        // Create a new DkmScriptDocument object instance.
        //
        // This method will send a ScriptDocumentTreeNodeCreate event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pRuntimeInstance: [In] The runtime which produced this container.
        // pParent         : [In,Optional] Parent in the script document tree. This will be
        // null for the root application container.
        // pTitle          : [In] Title of the node.
        // pModule         : [In] The symbol container which owns this document.
        // pUrl            : [In,Optional] URL of the script document. This may be null if
        // the document has no URL.
        // pFilePath       : [In,Optional] File path (ex: c:\myfolder\file.js) of the script
        // document. This will be null if the document has no URL, or has a non-'file://'
        // URL.
        // Flags           : [In] Flag properties of a script document.
        // ContentType     : [In] Indicates the content type of the underlying script
        // document.
        // EmbeddedDocumentKind: [In] Indicates the kind of embedded document (or none if not
        // an embedded document). The type can be eval code, function code, or script block.
        // pSourceProjectItem: [In,Optional] The project item which matches this document.
        // JmcState        : [In] The Just-My-Code state of the document. To update the value
        // of this variable, call DkmScriptDocument.SetJmcState.
        // DataItem        : [In] Data object to add to the new DkmScriptDocument instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Script::DkmScriptDocumentTreeNode* pParent,
            _In_ DkmString* pTitle,
            _In_ Symbols::DkmModule* pModule,
            _In_opt_ DkmString* pUrl,
            _In_opt_ DkmString* pFilePath,
            _In_ Script::DkmScriptDocumentFlags::e Flags,
            _In_ Script::DkmScriptDocumentContentType::e ContentType,
            _In_ Script::DkmScriptEmbeddedDocumentKind::e EmbeddedDocumentKind,
            _In_opt_ Script::DkmScriptSourceProjectItem* pSourceProjectItem,
            _In_ Script::DkmScriptDocumentJmcState::e JmcState,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptDocument** ppCreatedObject
            );

        // Provides the current content of the specified document object.
        // EnableContentEvents: [In] If true, the script document provider should raise
        // events when the content of this document changes. Passing true is equivalent to
        // calling SetRaiseContentEvents(true). If false, the RaiseContentEvent state remains
        // the same.
        // ppContent       : [Out] The current content of this document.
        // pSectionDividers: [Out] For aggregate documents
        // (DkmScriptDocumentFlags.AggregateDocument is set), this is the 1-based line
        // numbers for where the section dividers should be drawn. For standard documents, an
        // empty array is returned.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetContent(
            _In_ bool EnableContentEvents,
            _Deref_out_ DkmString** ppContent,
            _Out_ DkmArray<UINT32>* pSectionDividers
            );

        // Enables or disables raising events when the content of the document is changed. By
        // default, documents do not generate content events. So this method should be called
        // by any component that wishes to receive content events. The script document
        // manager maintains a count of the number of calls to enable content events, and
        // will raise events whenever this count is greater than 0. Callers should take care
        // to ensure that SetRaiseContentEvents(false) is called ONLY after a successful call
        // to SetRaiseContentEvents(true). Content events are automatically disabled when the
        // document is unloaded.
        // Enable          : [In] If true, content events should be enabled for this
        // document. If false, the count of content event listeners is decremented. When the
        // count reaches zero, no further events will be sent.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRaiseContentEvents(
            _In_ bool Enable
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // This method is called when a script document is created or when the project item
        // path is set to try and bind breakpoints against the given script document.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pSourceFileId   : [In] Identifies a source file and provides the information which
        // a symbol handler could use to search a symbol file (PDB) for information on this
        // source file.
        // ppResolvedDocument: [Out,Optional] If the given script document matches the given
        // source file id, this returns a DkmResolvedDocument for the match. Otherwise, null
        // is returned.
        // Return value    : S_OK is returned if *ppResolvedDocument is non-NULL, S_FALSE is
        // returned when *ppResolvedDocument is NULL, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryResolve(
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Deref_out_opt_ Symbols::DkmResolvedDocument** ppResolvedDocument
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Enables or disables raising ScriptSymbolsUpdated when symbols in the document are
        // changed. By default, documents do not generate symbol events. So this method
        // should be called by any component that wishes to receive symbol events. The script
        // document manager maintains a count of the number of calls to enable symbol events,
        // and will raise events whenever this count is greater than 0. Callers should take
        // care to ensure that SetRaiseSymbolEvents(false) is called ONLY after a successful
        // call to SetRaiseSymbolEvents(true). Symbol events are automatically disabled when
        // the document is unloaded.
        // Enable          : [In] If true, symbol events should be enabled for this document.
        // If false, the count of symbol event listeners is decremented. When the count
        // reaches zero, no further events will be sent.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRaiseSymbolEvents(
            _In_ bool Enable
            );

        // Enables or disables raising ScriptSymbolsUpdated when symbols in the document are
        // changed. By default, documents do not generate symbol events. So this method
        // should be called by any component that wishes to receive symbol events. The script
        // document manager maintains a count of the number of calls to enable symbol events,
        // and will raise events whenever this count is greater than 0. Callers should take
        // care to ensure that SetRaiseSymbolEvents(false) is called ONLY after a successful
        // call to SetRaiseSymbolEvents(true). Symbol events are automatically disabled when
        // the document is unloaded.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        // pWorkList       : WorkList to append the new work item to.
        // Enable          : [In] If true, symbol events should be enabled for this document.
        // If false, the count of symbol event listeners is decremented. When the count
        // reaches zero, no further events will be sent.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRaiseSymbolEvents(
            _In_ DkmWorkList* pWorkList,
            _In_ bool Enable,
            _In_ IDkmCompletionRoutine<Script::DkmSetRaiseSymbolEventsAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Queries the language service (IVsLanguageDebugInfoScript) to obtain script block
        // information from the associated project item of the specified script document.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppScriptBlocks  : [Out] Set of script blocks returned from the language service.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProjectItemScriptBlocks(
            _Deref_out_ DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>** ppScriptBlocks
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        // Raises a ScriptDocumentContentInsert event. The script document provider will only
        // raise this event if events have been enabled for this document.
        //
        // This method may only be called by the component which created the object.
        // Span            : [In] The text span of the inserted text. For aggregate documents
        // (DkmScriptDocumentFlags.AggregateDocument is set), this must start on a new line,
        // and at at the end of a line immediately before a new section would begin.
        // pNewText        : [In] The new text content which is inserted into the document.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContentInsert(
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ DkmString* pNewText
            );

        // Raises a ScriptDocumentContentRemove event. The script document provider will only
        // raise this event if events have been enabled for this document.
        //
        // This method may only be called by the component which created the object.
        // Span            : [In] The text span of the removed text. For aggregate documents
        // (DkmScriptDocumentFlags.AggregateDocument is set), this must start at the begging
        // of a line, and correspond to a previously added section.
        // CharsToRemove   : [In] Number of characters within the section to remove.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContentRemove(
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ UINT32 CharsToRemove
            );

        // Sets the JMC state for the  script document.  If the value is "Unsure", the script
        // debug monitor can make its own determination of the JMC state or ask a project
        // system for the JMC state.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // NewValue        : [In] The Just-My-Code state of the document exposed via the
        // DkmScriptDocument.JmcState variable. The JMC state of the document is ignored if
        // JMC is not enabled and all documents are treated as user code.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetJmcState(
            _In_ Script::DkmScriptDocumentJmcState::e NewValue
            );
    }; // end of DkmScriptDocument

    // DkmScriptInstructionAddress is used to represent an executable statement in a
    // script-based runtime environment such the Microsoft JavaScript engine.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6b4814ba-827e-19cf-d178-ecab171f2d30") DkmScriptInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmScriptInstructionAddress::Create to create this object
        private: DkmScriptInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptInstructionAddress();
        // This object cannot be copied
        private: DkmScriptInstructionAddress& operator=(const DkmScriptInstructionAddress&);
        private: DkmScriptInstructionAddress(const DkmScriptInstructionAddress&);

        private: Script::DkmScriptDocument* const m_pDocument;
        private: const UINT32 m_Revision;
        private: const UINT32 m_StartIndex;
        private: const UINT32 m_StatementLength;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Represents a script-based execution environment executing in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Script::DkmScriptRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Document containing this instruction.
        public: _Ret_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE Document(
            );

        // Indicates the revision number which inserted the statement represented by this
        // object. Typically, this will be zero for non-dynamic documents.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Revision(
            );

        // Indicates the starting character index of this statement, relative  to the start
        // of revision which inserted this statement.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StartIndex(
            );

        // Length of the statement (in characters).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StatementLength(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmScriptInstructionAddress'. Return
        // NULL if the path object is not a 'DkmScriptInstructionAddress'.
        // pScriptAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmScriptInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::ScriptAddress)
                return NULL;

            return static_cast<DkmScriptInstructionAddress*>(pInstructionAddress);
        }

        // Create a new DkmScriptInstructionAddress object instance.
        // pModuleInstance : [In,Optional] The module containing this address. Addresses
        // without a module cannot have symbols (even for custom addresses). CLR addresses
        // will always have a module. Native addresses will not have a module if either the
        // CPU jumped to an invalid address (ex: NULL), or if the CPU is executing
        // dynamically-emitted code.
        // pRuntimeInstance: [In] Represents a script-based execution environment executing
        // in a target process.
        // pDocument       : [In] Document containing this instruction.
        // Revision        : [In] Indicates the revision number which inserted the statement
        // represented by this object. Typically, this will be zero for non-dynamic
        // documents.
        // StartIndex      : [In] Indicates the starting character index of this statement,
        // relative  to the start of revision which inserted this statement.
        // StatementLength : [In] Length of the statement (in characters).
        // pAdditionalData : [In,Optional] Additional runtime-specific data associated with
        // an address. This data will not be used when comparing addresses.
        // pCPUInstruction : [In,Optional] CPUInstruction provides the address that the CPU
        // will execute. This is always provided for native instructions. It may be provided
        // for CLR or custom addresses depending on how the address object was created.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmModuleInstance* pModuleInstance,
            _In_ Script::DkmScriptRuntimeInstance* pRuntimeInstance,
            _In_ Script::DkmScriptDocument* pDocument,
            _In_ UINT32 Revision,
            _In_ UINT32 StartIndex,
            _In_ UINT32 StatementLength,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Script::DkmScriptInstructionAddress** ppCreatedObject
            );
    }; // end of DkmScriptInstructionAddress

    // DkmScriptInstructionSymbol is used to represent an executable statement in a
    // script-based runtime environment such the Microsoft JavaScript engine.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("aebaa0af-6437-2ecf-aaf1-86c58eba9447") DkmScriptInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmScriptInstructionSymbol::Create to create this object
        private: DkmScriptInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptInstructionSymbol();
        // This object cannot be copied
        private: DkmScriptInstructionSymbol& operator=(const DkmScriptInstructionSymbol&);
        private: DkmScriptInstructionSymbol(const DkmScriptInstructionSymbol&);

        private: Script::DkmScriptDocument* const m_pDocument;
        private: const UINT32 m_Revision;
        private: const UINT32 m_StartIndex;
        private: const UINT32 m_StatementLength;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Document containing this instruction.
        public: _Ret_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE Document(
            );

        // Indicates the revision number which inserted the statement represented by this
        // object. Typically, this will be zero for non-dynamic documents.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Revision(
            );

        // Indicates the starting character index of this statement, relative  to the start
        // of revision which inserted this statement.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StartIndex(
            );

        // Length of the statement (in characters).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StatementLength(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmScriptInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmScriptInstructionSymbol'.
        // pScriptInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmScriptInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::ScriptInstruction)
                return NULL;

            return static_cast<DkmScriptInstructionSymbol*>(pInstruction);
        }

        // Create a new DkmScriptInstructionSymbol object instance.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // RuntimeType     : [In] The Runtime Id identifies the execution environment for a
        // particular piece of code. Runtime Ids are used by the dispatcher to decide which
        // monitor to dispatch to. Note that the ordering of the runtime ID Guids is somewhat
        // significant as this dictates which runtime gets the first shot during arbitration.
        // Thus, if one wants to declare a new runtime instance which is built on the CLR,
        // the runtime id should be less than DkmRuntimeId.Clr.
        // pDocument       : [In] Document containing this instruction.
        // Revision        : [In] Indicates the revision number which inserted the statement
        // represented by this object. Typically, this will be zero for non-dynamic
        // documents.
        // StartIndex      : [In] Indicates the starting character index of this statement,
        // relative  to the start of revision which inserted this statement.
        // StatementLength : [In] Length of the statement (in characters).
        // pAdditionalData : [In,Optional] Additional runtime-specific data associated with
        // an address. This data will not be used when comparing addresses.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const GUID& RuntimeType,
            _In_ Script::DkmScriptDocument* pDocument,
            _In_ UINT32 Revision,
            _In_ UINT32 StartIndex,
            _In_ UINT32 StatementLength,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Script::DkmScriptInstructionSymbol** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Call back implemented by the script symbol provider to tell the script debug
        // monitor what to do next when stepping.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pStartingInstruction: [In,Optional] The instruction symbol of the process at the
        // time this step started. This will be NULL if the step originated on a thread with
        // no frames.
        // IsSteppingByLine: [In] true if the step is by line (instead of by statement).
        // pResult         : [Out] Enum value indicating the next action that the script dm
        // should perform.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. NotImplementedException/E_NOTIMPL indicates that no symbol provider is
        // available for the script symbol.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextSteppingAction(
            _In_opt_ Script::DkmScriptInstructionSymbol* pStartingInstruction,
            _In_ bool IsSteppingByLine,
            _Out_ Script::DkmScriptSymbolNextSteppingAction::e* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmScriptInstructionSymbol

    // Represents a script-based execution environment executing in a target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("f6cb156c-9ad9-c01d-29e0-cb77e45fa254") DkmScriptRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmScriptRuntimeInstance::Create to create this object
        private: DkmScriptRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptRuntimeInstance();
        // This object cannot be copied
        private: DkmScriptRuntimeInstance& operator=(const DkmScriptRuntimeInstance&);
        private: DkmScriptRuntimeInstance(const DkmScriptRuntimeInstance&);

        private: const UINT32 m_LoadOrderIndex;
        private: void* m__pExtendedData;

        // Index indicating the relative load order of this script runtime instance to other
        // script runtime instances within the target process. The first runtime instance to
        // load will be given an index of zero.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LoadOrderIndex(
            );

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmScriptRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmScriptRuntimeInstance'.
        // pScriptRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmScriptRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::ScriptRuntimeInstance)
                return NULL;

            return static_cast<DkmScriptRuntimeInstance*>(pRuntimeInstance);
        }

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // LoadOrderIndex  : [In] Index indicating the relative load order of this script
        // runtime instance to other script runtime instances within the target process. The
        // first runtime instance to load will be given an index of zero.
        // DataItem        : [In] Data object to add to the new DkmScriptRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ UINT32 LoadOrderIndex,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptRuntimeInstance** ppCreatedObject
            );

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // Capabilities    : [In] Enumeration of runtime capabilities.
        // pParentRuntime  : [In,Optional] For runtimes that are implemented on top of
        // another runtime, this can optionally be used to indicant the logical parent. This
        // can then be used to request services from the parent when the child runtime
        // doesn't implement the service. This is currently used only for obtaining the top
        // stack frame to evaluate a conditional breakpoint when the child runtime doesn't
        // walk stacks itself.
        // LoadOrderIndex  : [In] Index indicating the relative load order of this script
        // runtime instance to other script runtime instances within the target process. The
        // first runtime instance to load will be given an index of zero.
        // DataItem        : [In] Data object to add to the new DkmScriptRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities::e Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ UINT32 LoadOrderIndex,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptRuntimeInstance** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Allows a caller to obtain a direct access to the IRemoteDebugApplication interface
        // from the target process. This can be used to load dlls into the target
        // application, or inspect the target application. Note that this should never be
        // used for execution control, breakpoints, or evaluation.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ppApplication   : [Out] Debug application interface from the debugged process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRemoteDebugApplication(
            _Deref_out_ IRemoteDebugApplication** ppApplication
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // API which is called from break mode which tells the script runtime that execution
        // should be aborted when resuming (BREAKRESUMEACTION_ABORT). This API requires an
        // MSHTML v10+ target execution environment.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AbortExecutionOnResume(
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Provides notification to the user that a critical error has happened in the target
        // process. This method will complete once the critical error UI has been dismissed.
        //
        // This method will append a new work item to the specified work list, and return
        // once the work item has been appended. The actual processing of the work item is
        // asynchronous. The caller will be notified that the request is complete through the
        // completion routine.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pWorkList       : WorkList to append the new work item to.
        // pSource         : [In] Specifies to the web developer what aspect of their page
        // the issue pertains to. Ex: "HTML", "DOM", "SCRIPT", etc.
        // MessageId       : [In] Indicates an error code. Source + MessageId should uniquely
        // identify the message so that information about the error can be found in help.
        // pMessage        : [In] Message to display to users.
        // pInstructionAddress: [In,Optional] When known, the script instruction address
        // where the error occurred.
        // pSourcePosition : [In,Optional] When InstructionAddress is non-null, this contains
        // the current source position of this instruction.
        // pCompletionRoutine: Routine to fire when the request is complete. If the request
        // is successfully appended to the work list, this will always fire (including when
        // the operation is canceled). This will never fire if appending the work item fails.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnScriptCriticalError(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pSource,
            _In_ UINT32 MessageId,
            _In_ DkmString* pMessage,
            _In_opt_ Script::DkmScriptInstructionAddress* pInstructionAddress,
            _In_opt_ Symbols::DkmSourcePosition* pSourcePosition,
            _In_ IDkmCompletionRoutine<Script::DkmOnScriptCriticalErrorAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        // Raises the notification that one or more script documents have been updated.
        // Documents       : [In] Set of documents which have been updated.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnScriptSymbolsUpdated(
            _In_ const DkmArray<Script::DkmScriptDocument*>& Documents
            );
    }; // end of DkmScriptRuntimeInstance

}; // end namespace Script

// Contains types specific to GPU debugging.
namespace GPU {
    // Collection of properties of GPU compute kernel.
    struct DECLSPEC_UUID("a6792ede-1d69-7729-4e5b-f6de0e3afb3b") DkmComputeProperty
    {
        // Property Name.
        DkmString* pName;

        // Property value.
        DkmString* pValue;

        // Release all reference-counted fields within the DkmComputeProperty structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmComputeProperty* pItem
            );
    };

    // Collection of properties of GPU compute threads.
    struct DECLSPEC_UUID("30645692-f6be-eb65-a2b8-719fb033e020") DkmComputeThreadInfo
    {
        // The number of threads represented by this object, could be greater than one if
        // returned in a group by call.
        UINT32 ThreadCount;

        // Vector index.
        UINT32 VectorId;

        // Thread group ID, unique to kernel.
        UINT64 ThreadGroupId;

        // Thread ID, unique to kernel.
        UINT64 ThreadId;

        // The IP of the compute thread.
        UINT64 InstructionPointer;

        // State of the compute thread.
        GPU::DkmComputeThreadState::e ThreadState;

        // Flagged state of the compute thread.
        bool FlaggedState;

        // Frozen state of the compute thread.
        bool FrozenState;

        // Release all reference-counted fields within the DkmComputeThreadInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmComputeThreadInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // The description of GPU registers for a GPU compute thread.
    struct DECLSPEC_UUID("5b4f9bea-1b43-64a4-e441-8b61f377d417") DkmGPURegisterDescription
    {
        // The GPU register type.
        UINT32 RegisterType;

        // The index of a GPU register.
        UINT32 RegisterIndex;

        // The size of a GPU register in bytes.
        UINT64 RegisterSize;

        // The value bytes of a GPU register. This is normally 16 bytes.
        DkmReadOnlyCollection<BYTE>* pRegisterValue;

        // Release all reference-counted fields within the DkmGPURegisterDescription structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmGPURegisterDescription* pItem
            );
    };

    // A structure used as a where clause when querying compute thread info.
    struct DECLSPEC_UUID("0365513d-4d3c-8674-f02e-af9db38d12f5") DkmWhereClause
    {
        // Flags specifying columns in a where clause.
        GPU::DkmQueryComputeThreadInfoFlags::e ColumnFlags;

        // Values of the columns specified in ColumnFlags.
        GPU::DkmComputeThreadInfo Values;

        // Release all reference-counted fields within the DkmWhereClause structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmWhereClause* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // The model type that a compute kernel uses.
    enum DkmComputeKernelModel::e
    {
        // Compute kernel uses flat model.
        Flat = 0,
        // Compute kernel uses tile model.
        Tile = 1,
        // Compute kernel uses three-dimensional HLSL model.
        HLSL = 2
    };

    // Compute thread state flags.
    enum DkmComputeThreadState::e
    {
        // Not a valid compute thread state.
        Unknown = 0x0,
        // Compute thread is active.
        Active = 0x1,
        // Compute thread is divergent.
        Divergent = 0x2,
        // Compute thread is blocked.
        Blocked = 0x4,
        // Compute thread is unused.
        Unused = 0x8,
        // Compute thread is not started.
        NotStarted = 0x10,
        // Compute thread is completed.
        Completed = 0x20
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmComputeThreadState::e);

    // DkmGPUAddressType describes if an address represents a special location in the GPU
    // debuggee's byte code.
    enum DkmGPUAddressType::e
    {
        // No type flat is set.
        None = 0x1,
        // The address is at the inline function call site, that is, the instruction just
        // before inline function.
        FunctionCall = 0x2,
        // The address has symbols but should not be stepped into.
        NoStepInto = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmGPUAddressType::e);

    // Flags for describing GPU breakpoint behavior.
    enum DkmGPUBreakpointBehaviorFlags::e
    {
        // No specific behavior.
        None = 0,
        // Break once per warp.
        BreakOncePerWarp = 1,
        // Break for every thread.
        BreakForEveryThread = 2,
        // Break on first or default warp.
        BreakOnFirstDefaultWarp = 3
    };

    // DkmGPUComputeKernel represents a GPU compute kernel running in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("944cc867-86e7-9c78-724c-d929d98ce82d") DkmGPUComputeKernel : public DkmDataContainer
    {
        // Use DkmGPUComputeKernel::Create to create this object
        private: DkmGPUComputeKernel();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUComputeKernel();
        // This object cannot be copied
        private: DkmGPUComputeKernel& operator=(const DkmGPUComputeKernel&);
        private: DkmGPUComputeKernel(const DkmGPUComputeKernel&);

        private: const UINT32 m_DispatchId;
        private: const UINT64 m_GPUDevice;
        private: const UINT64 m_GPUShader;
        private: const UINT64 m_GPUShaderDispatch;
        private: DkmReadOnlyCollection<UINT32>* const m_pGroupDimensions;
        private: const UINT64 m_NumberOfGroups;
        private: DkmReadOnlyCollection<UINT32>* const m_pThreadDimensions;
        private: const UINT32 m_NumberOfThreads;
        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: void* m__pExtendedData;
        private: void* m_pComputeThreadCollection0;

        // The GPU dispatch id for this kernel object.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE DispatchId(
            );

        // The GPU device this compute kernel runs on.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GPUDevice(
            );

        // A compute kernel is a running instance of this GPU shader.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GPUShader(
            );

        // The handle of the executing GPU shader corresponding to this compute kernel.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GPUShaderDispatch(
            );

        // Thread group dimensions in a compute kernel.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE GroupDimensions(
            );

        // Number of thread groups in a compute kernel.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE NumberOfGroups(
            );

        // Thread dimensions in a compute kernel.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE ThreadDimensions(
            );

        // Number of compute threads in a thread group of compute kernel.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumberOfThreads(
            );

        // Guid which uniquely identifies this compute kernel object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // DkmGPUComputeKernel is called by a debug monitor to create a new
        // DkmGPUComputeKernel instance. DkmGPUComputeKernel objects for GPU compute kernels
        // are created by the base debug monitor.
        // DispatchId      : [In] The GPU dispatch id for this kernel object.
        // GPUDevice       : [In] The GPU device this compute kernel runs on.
        // GPUShader       : [In] A compute kernel is a running instance of this GPU shader.
        // GPUShaderDispatch: [In] The handle of the executing GPU shader corresponding to
        // this compute kernel.
        // pGroupDimensions: [In] Thread group dimensions in a compute kernel.
        // NumberOfGroups  : [In] Number of thread groups in a compute kernel.
        // pThreadDimensions: [In] Thread dimensions in a compute kernel.
        // NumberOfThreads : [In] Number of compute threads in a thread group of compute
        // kernel.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // DataItem        : [In] Data object to add to the new DkmGPUComputeKernel instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 DispatchId,
            _In_ UINT64 GPUDevice,
            _In_ UINT64 GPUShader,
            _In_ UINT64 GPUShaderDispatch,
            _In_ DkmReadOnlyCollection<UINT32>* pGroupDimensions,
            _In_ UINT64 NumberOfGroups,
            _In_ DkmReadOnlyCollection<UINT32>* pThreadDimensions,
            _In_ UINT32 NumberOfThreads,
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ GPU::DkmGPUComputeKernel** ppCreatedObject
            );

        // ComputeKernelExit is sent by the dispatcher when DkmGPUComputeKernel::Unload is
        // invoked by the monitor.
        //
        // This method may only be called by the component which created the object.
        // ExitCode        : [In] 32-bit value that the compute kernel returned on exit.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
            _In_ UINT32 ExitCode
            );

        // Find a DkmGPUComputeThread element within this DkmGPUComputeKernel. If no element
        // with the given input key is present, FindComputeThread will fail.
        // GlobalThreadIndex: [In] Search key used to find the element.
        // ppComputeThread : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindComputeThread(
            _In_ UINT64 GlobalThreadIndex,
            _Deref_out_ GPU::DkmGPUComputeThread** ppComputeThread
            );

        // Obtain the warp size of the hardware or emulator.
        // pWidth          : [Out] Width of the hardware.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeVectorWidth(
            _Out_ UINT32* pWidth
            );

        // Obtain the active thread groups from the compute kernel.
        // pActiveThreadGroups: [Out] List of global Thread group id of all active thread
        // groups.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfGroups : [Out] Number of active thread groups in the compute kernel.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetActiveThreadGroups(
            _Out_ DkmArray<UINT64>* pActiveThreadGroups,
            _Out_ UINT32* pNumberOfGroups
            );

        // Get the dimension of the thread block.
        // pThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentThreadDimensions(
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        // Get the dimension of the thread block.
        // pGroupDimensions: [Out] Grid Dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Grid dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentGroupDimensions(
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        // Get the name of compute kernel.
        // ppComputeKernelName: [Out] Name of the ComputeKernel that is launched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeKernelName(
            _Deref_out_ DkmString** ppComputeKernelName
            );

        // Get properties of the compute kernel.
        // pComputeProperties: [Out] List of Compute kernel properties.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfProperties: [Out] Number of properties in the compute kernel.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeKernelProperties(
            _Out_ DkmArray<GPU::DkmComputeProperty>* pComputeProperties,
            _Out_ UINT32* pNumberOfProperties
            );

        // Runs the select query on thread info objects.
        // pFrom           : [In] From clause specification for selection (can be empty to
        // select from all available threads).
        // Where           : [In] Where clause specification for selection.
        // pThreadInfoArray: [Out] The result set of compute thread info objects.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Select(
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            );

        // Runs the group by query on thread info objects.
        // GroupByFlags    : [In] Flags specifying on which columns the group by is run.
        // pFrom           : [In] From clause specification for selection (can be empty to
        // select from all available threads).
        // Where           : [In] Where clause specification for group by.
        // pThreadInfoArray: [Out] The result set of compute thread info objects.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GroupBy(
            _In_ GPU::DkmQueryComputeThreadInfoFlags::e GroupByFlags,
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            );

        // Get all threads that hit breakpoint.
        // pThreadIdArray  : [Out] The result set of compute thread ids that hit breakpoint.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStoppedThreads(
            _Out_ DkmArray<UINT64>* pThreadIdArray
            );

        // Gets the DkmGPUComputeThread object for a given thread ID.
        // ThreadId        : [In] ID of the thread to return.
        // ppThread        : [Out] Thread object that matches the given thread ID.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadFromId(
            _In_ UINT64 ThreadId,
            _Deref_out_ GPU::DkmGPUComputeThread** ppThread
            );

        // Update flagged state of compute threads.
        // Where           : [In] Where clause specification for update.
        // Flagged         : [In] The value to update with.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateFlaggedState(
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Flagged
            );

        // Update frozen state of compute threads.
        // Where           : [In] Where clause specification for update.
        // Frozen          : [In] The value to update with.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateFrozenState(
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Frozen
            );

        // Get the dimension of the thread block.
        // pFlatThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pFlatIndexBase  : [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // pModel          : [Out] Model Type.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFlatComputeKernelDimensions(
            _Out_ DkmArray<UINT32>* pFlatThreadDimensions,
            _Out_ DkmArray<INT32>* pFlatIndexBase,
            _Out_ UINT32* pNumberOfDimensions,
            _Out_ GPU::DkmComputeKernelModel::e* pModel
            );
    }; // end of DkmGPUComputeKernel

    // Indicates which parts of a thread or group ID should be used.
    enum DkmHlslThreadIdComponents::e
    {
        // The X portion of the id vector.
        X = 0x1,
        // The Y portion of the id vector.
        Y = 0x2,
        // The Z portion of the id vector.
        Z = 0x4
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmHlslThreadIdComponents::e);

    // Options for how to query compute thread info.
    enum DkmQueryComputeThreadInfoFlags::e
    {
        // No query option flags are set.
        None = 0x0,
        // Do the query by ThreadGroupId.
        ThreadGroupId = 0x1,
        // Do the query by VectorId.
        VectorId = 0x2,
        // Do the query by ThreadId.
        ThreadId = 0x4,
        // Do the query by ThreadState.
        ThreadState = 0x8,
        // Do the query by FlagState.
        FlaggedState = 0x10,
        // Do the query by InstructionPointer.
        InstructionPointer = 0x20,
        // Do the query by FrozenState.
        FrozenState = 0x40
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmQueryComputeThreadInfoFlags::e);

    // DkmGPUComputeThread represents a compute thread running in the GPU target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("40cbb26d-05f5-dc30-49f9-797b17f2ab9e") DkmGPUComputeThread : public DkmThread
    {
        // Use DkmGPUComputeThread::Create to create this object
        private: DkmGPUComputeThread();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUComputeThread();
        // This object cannot be copied
        private: DkmGPUComputeThread& operator=(const DkmGPUComputeThread&);
        private: DkmGPUComputeThread(const DkmGPUComputeThread&);

        // Contains additional fields of DkmGPUComputeThread which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The native thread on which an exception is raised to notify the
            // debugger that a GPU debug event is available.
            OPTIONAL DkmThread* const pNativeThread;
        };

        private: const UINT64 m_GlobalThreadIndex;
        private: GPU::DkmGPUComputeKernel* const m_pComputeKernel;
        private: ___ExtendedData* const m__pExtendedData;

        // Unique to kernel compute thread index.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GlobalThreadIndex(
            );

        // DkmGPUComputeKernel represents a GPU compute kernel running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW GPU::DkmGPUComputeKernel* STDMETHODCALLTYPE ComputeKernel(
            );

        // [Optional] The native thread on which an exception is raised to notify the
        // debugger that a GPU debug event is available.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE NativeThread(
            );

        // Create a new DkmGPUComputeThread object instance.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // NativeStartAddress: [In] If available, this is the Win32 start address of this
        // thread (value passed to the CreateThread API). The value will not always be
        // available, for example, it is generally not available in scenarios where the
        // thread was started after the debugger attached, or in minidumps.
        // IsMainThread    : [In] True if this is the main thread of this process. The main
        // thread is the first thread to start.
        // GlobalThreadIndex: [In] Unique to kernel compute thread index.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pSystem         : [In,Optional] Describes traits of the thread which are relevant
        // to a full Win32 thread. Currently, this value is required, and all threads will
        // have a 'System' block. In the future, this value may be NULL if the DkmThread
        // represents something other than a full Win32 thread.
        // DataItem        : [In] Data object to add to the new DkmGPUComputeThread instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 NativeStartAddress,
            _In_ bool IsMainThread,
            _In_ UINT64 GlobalThreadIndex,
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_opt_ const DkmThread::System* pSystem,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ GPU::DkmGPUComputeThread** ppCreatedObject
            );

        // Create a new DkmGPUComputeThread object instance.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // NativeStartAddress: [In] If available, this is the Win32 start address of this
        // thread (value passed to the CreateThread API). The value will not always be
        // available, for example, it is generally not available in scenarios where the
        // thread was started after the debugger attached, or in minidumps.
        // IsMainThread    : [In] True if this is the main thread of this process. The main
        // thread is the first thread to start.
        // GlobalThreadIndex: [In] Unique to kernel compute thread index.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pNativeThread   : [In,Optional] The native thread on which an exception is raised
        // to notify the debugger that a GPU debug event is available.
        // pSystem         : [In,Optional] Describes traits of the thread which are relevant
        // to a full Win32 thread. Currently, this value is required, and all threads will
        // have a 'System' block. In the future, this value may be NULL if the DkmThread
        // represents something other than a full Win32 thread.
        // DataItem        : [In] Data object to add to the new DkmGPUComputeThread instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 NativeStartAddress,
            _In_ bool IsMainThread,
            _In_ UINT64 GlobalThreadIndex,
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_opt_ DkmThread* pNativeThread,
            _In_opt_ const DkmThread::System* pSystem,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ GPU::DkmGPUComputeThread** ppCreatedObject
            );

        // Get the dimension of the thread block.
        // pThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThisThreadDimension(
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        // Get the dimension of the thread block.
        // pGroupDimensions: [Out] Grid dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Grid dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThisGroupDimension(
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        // Get the dimension of the thread block.
        // pThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadId(
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        // Get the dimension of the thread block.
        // pGroupDimensions: [Out] Grid dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Grid dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGroupId(
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        // Read the memory of the target GPU process. The method is on DkmGPUComputeThread
        // because it may read thread local memory, group shared memory or global memory.
        // Address         : [In] The address from which to read the target GPU process's
        // memory.
        // InstructionPointer: [In] The instruction pointer where to resolve address to
        // register location.
        // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        // pBuffer         : [In,Out] A buffer that receives the contents from the address
        // space of the target process. On failure, the content of this buffer is
        // unspecified.
        // Size            : [In] The number of bytes to be read from the process.
        // pBytesRead      : [Out,Optional] Indicates the number of bytes read from the
        // target GPU process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success
        // this value will always be exactly equal to the input size. If
        // DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be
        // greater than zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadMemory(
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ DkmReadMemoryFlags::e Flags,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            );

        // Writes memory to the target GPU process. The method is on DkmGPUComputeThread
        // because it may write thread local memory, group shared memory or global memory.
        // Address         : [In] The base address from which to write the target GPU
        // process's memory.
        // InstructionPointer: [In] The instruction pointer where to resolve address to
        // register location.
        // Data            : [In] Data to be written in the address space of the specified
        // GPU process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteMemory(
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ const DkmArray<BYTE>& Data
            );

        // Checks if a tag for a buffer has been forwarded for this kernel execution.
        // InputTag        : [In] The C++ AMP pointer tag.
        // pForwardedTag   : [Out] The forwarded tag value.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateBufferTag(
            _In_ UINT32 InputTag,
            _Out_ UINT32* pForwardedTag
            );

        // Validate the specified GPU memory address.
        // Address         : [In] The address to validate.
        // pIsValidGpuMemoryAddress: [Out] True if the specified address is a valid GPU
        // memory address, false otherwise.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ValidateAddress(
            _In_ UINT64 Address,
            _Out_ bool* pIsValidGpuMemoryAddress
            );

        // Obtain the list of all register descriptions from the GPU compute thread.
        // pRegisterDescriptions: [Out] The list of all register descriptions from the GPU
        // compute thread.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pRegisterDescriptions contains any elements,
        // S_FALSE is indicates the array is empty, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRegisterDescriptions(
            _Out_ DkmArray<GPU::DkmGPURegisterDescription>* pRegisterDescriptions
            );

        // Set the value of a register in the GPU compute thread.
        // RegisterDescription: [In] The description of a register from the GPU compute
        // thread.
        // pRegisterValue  : [In] The value bytes of a register to be written in the GPU
        // compute thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRegisterValue(
            _In_ const GPU::DkmGPURegisterDescription& RegisterDescription,
            _In_ DkmReadOnlyCollection<BYTE>* pRegisterValue
            );
    }; // end of DkmGPUComputeThread

    // Represents an address in GPU data. The high 32-bit in Value is tag and the low 32-bit
    // in Value is offset.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5d7ae46a-0766-92b7-31f0-466dabc07582") DkmGPUDataAddress : public Evaluation::DkmDataAddress
    {
        // Use DkmGPUDataAddress::Create to create this object
        private: DkmGPUDataAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUDataAddress();
        // This object cannot be copied
        private: DkmGPUDataAddress& operator=(const DkmGPUDataAddress&);
        private: DkmGPUDataAddress(const DkmGPUDataAddress&);

        private: GPU::DkmGPUComputeThread* const m_pComputeThread;
        private: const UINT64 m_InstructionPointer;
        private: void* m__pExtendedData;

        // DkmGPUComputeThread represents a compute thread running in the GPU target process.
        public: _Ret_ DECLSPEC_NOTHROW GPU::DkmGPUComputeThread* STDMETHODCALLTYPE ComputeThread(
            );

        // GPU data address may correspond to different register location at different
        // instruction pointer.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE InstructionPointer(
            );

        // Create a new DkmGPUDataAddress object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // Value           : [In] Data address.
        // pInstructionAddress: [In,Optional] Set when the data address is an instruction
        // address.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // InstructionPointer: [In] GPU data address may correspond to different register
        // location at different instruction pointer.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 Value,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 InstructionPointer,
            _Deref_out_ GPU::DkmGPUDataAddress** ppCreatedObject
            );
    }; // end of DkmGPUDataAddress

    // Provides information about a GPU memory access exception which was raised in the
    // target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1930c922-5906-c29d-d51b-a59e5c8d4227") DkmGPUMemoryAccessExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmGPUMemoryAccessExceptionInformation::Create to create this object
        private: DkmGPUMemoryAccessExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUMemoryAccessExceptionInformation();
        // This object cannot be copied
        private: DkmGPUMemoryAccessExceptionInformation& operator=(const DkmGPUMemoryAccessExceptionInformation&);
        private: DkmGPUMemoryAccessExceptionInformation(const DkmGPUMemoryAccessExceptionInformation&);

        private: const UINT64 m_ConflictingInstructionAddress;
        private: const UINT64 m_ConflictingThreadGlobalIndex;
        private: void* m__pExtendedData;

        // The address of the conflicting instruction.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ConflictingInstructionAddress(
            );

        // The global id of the conflicting thread.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ConflictingThreadGlobalIndex(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmGPUMemoryAccessExceptionInformation'. Return
        // NULL if the path object is not a 'DkmGPUMemoryAccessExceptionInformation'.
        // pGPUMemoryAccessException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmGPUMemoryAccessExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::GPUMemoryAccessException)
                return NULL;

            return static_cast<DkmGPUMemoryAccessExceptionInformation*>(pException);
        }

        // Create a new DkmGPUMemoryAccessExceptionInformation object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pInstructionAddress: [In,Optional] Address where the exception occurred. This will
        // always be present for C++ and Win32 exceptions. It may be missing from CLR
        // exceptions or MDAs as these may originate from inside the runtime.
        // pName           : [In,Optional] Name of the exception. For C++ or CLR exceptions,
        // this is the type name. This value will be null for exception categories that
        // identify exceptions by code (ex: Win32).
        // Code            : [In] 32-bit integer code for the exception. For Win32
        // exceptions, this is the code passed to RaiseException
        // (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that
        // identify exceptions by string (ex: CLR).
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration indicates the stage(s) for a notification.
        // ConflictingInstructionAddress: [In] The address of the conflicting instruction.
        // ConflictingThreadGlobalIndex: [In] The global id of the conflicting thread.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_opt_ DkmString* pName,
            _In_ UINT32 Code,
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_ UINT64 ConflictingInstructionAddress,
            _In_ UINT64 ConflictingThreadGlobalIndex,
            _Deref_out_ GPU::DkmGPUMemoryAccessExceptionInformation** ppCreatedObject
            );
    }; // end of DkmGPUMemoryAccessExceptionInformation

}; // end namespace GPU

// Contains types specific to extending the debugger to support a custom execution
// environment.
namespace CustomRuntimes {
    // Provides information about an exception which was raised in the target process. Custom
    // exceptions are used for C++ Runtime checks, Managed Debugging Assistant failures, and
    // exceptions from 3rd party runtimes.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7572c08d-ef31-438a-9324-21d72ad99c65") DkmCustomExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmCustomExceptionInformation::Create to create this object
        private: DkmCustomExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomExceptionInformation();
        // This object cannot be copied
        private: DkmCustomExceptionInformation& operator=(const DkmCustomExceptionInformation&);
        private: DkmCustomExceptionInformation(const DkmCustomExceptionInformation&);

        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalInformation;
        private: void* m__pExtendedData;

        // [Optional] Additional data about this custom exception. Format is defined by the
        // custom exception type.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalInformation(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmCustomExceptionInformation'. Return
        // NULL if the path object is not a 'DkmCustomExceptionInformation'.
        // pCustomException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::CustomException)
                return NULL;

            return static_cast<DkmCustomExceptionInformation*>(pException);
        }

        // Create a new DkmCustomExceptionInformation object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // ExceptionCategory: [In] Indicates the type of exception.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pInstructionAddress: [In,Optional] Address where the exception occurred. This will
        // always be present for C++ and Win32 exceptions. It may be missing from CLR
        // exceptions or MDAs as these may originate from inside the runtime.
        // pName           : [In,Optional] Name of the exception. For C++ or CLR exceptions,
        // this is the type name. This value will be null for exception categories that
        // identify exceptions by code (ex: Win32).
        // Code            : [In] 32-bit integer code for the exception. For Win32
        // exceptions, this is the code passed to RaiseException
        // (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that
        // identify exceptions by string (ex: CLR).
        // ProcessingStage : [In] The debugger receives notifications from the target process
        // at various stages within exception processing (ex: exception thrown, exception
        // unhandled). This enumeration indicates the stage(s) for a notification.
        // pImplementationException: [In,Optional] Information about the underlying exception
        // used to implement a higher level exception. For example, CLR and C++ exceptions
        // may be implemented on top of Win32 exceptions. So this may store the
        // DkmWin32ExceptionInformation for CLR or C++ exceptions.
        // pAdditionalInformation: [In,Optional] Additional data about this custom exception.
        // Format is defined by the custom exception type.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& ExceptionCategory,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_opt_ DkmString* pName,
            _In_ UINT32 Code,
            _In_ Exceptions::DkmExceptionProcessingStage::e ProcessingStage,
            _In_opt_ Exceptions::DkmExceptionInformation* pImplementationException,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalInformation,
            _Deref_out_ CustomRuntimes::DkmCustomExceptionInformation** ppCreatedObject
            );
    }; // end of DkmCustomExceptionInformation

    // DkmCustomInstructionAddress is used for addresses from a custom runtime environment
    // (not native or CLR-based). For example, this could be used in a custom interpreter or
    // Just-In-Time compiler.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9205f0c6-3471-83dc-bd08-54c4c7d5dbc8") DkmCustomInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmCustomInstructionAddress::Create to create this object
        private: DkmCustomInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomInstructionAddress();
        // This object cannot be copied
        private: DkmCustomInstructionAddress& operator=(const DkmCustomInstructionAddress&);
        private: DkmCustomInstructionAddress(const DkmCustomInstructionAddress&);

        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pEntityId;
        private: const UINT64 m_Offset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // The module containing the InstructionPointer.
        public: _Ret_ DECLSPEC_NOTHROW CustomRuntimes::DkmCustomModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // [Optional] This is a runtime-specific data structure which custom runtimes may use
        // to store the location of this instruction. Along with 'offset', this field will
        // used to compare two instructions from the same module.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE EntityId(
            );

        // Along with 'EntityId' the 'Offset' field is used to uniquely identity an
        // instruction. This could hold a pointer value (such as a pointer to the
        // instruction) or an offset from the start of the function/module.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Offset(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmCustomInstructionAddress'. Return
        // NULL if the path object is not a 'DkmCustomInstructionAddress'.
        // pCustomAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::CustomAddress)
                return NULL;

            return static_cast<DkmCustomInstructionAddress*>(pInstructionAddress);
        }

        // Create a new DkmCustomInstructionAddress object instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pModuleInstance : [In] The module containing the InstructionPointer.
        // pEntityId       : [In,Optional] This is a runtime-specific data structure which
        // custom runtimes may use to store the location of this instruction. Along with
        // 'offset', this field will used to compare two instructions from the same module.
        // Offset          : [In] Along with 'EntityId' the 'Offset' field is used to
        // uniquely identity an instruction. This could hold a pointer value (such as a
        // pointer to the instruction) or an offset from the start of the function/module.
        // pAdditionalData : [In,Optional] Additional runtime-specific data associated with
        // an address. This data will not be used when comparing addresses.
        // pCPUInstruction : [In,Optional] CPUInstruction provides the address that the CPU
        // will execute. This is always provided for native instructions. It may be provided
        // for CLR or custom addresses depending on how the address object was created.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ CustomRuntimes::DkmCustomModuleInstance* pModuleInstance,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pEntityId,
            _In_ UINT64 Offset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ CustomRuntimes::DkmCustomInstructionAddress** ppCreatedObject
            );
    }; // end of DkmCustomInstructionAddress

    // DkmCustomInstructionSymbol is used to represent an executable statement in any type of
    // custom runtime environment.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c154cde9-82a7-6e6f-f4f4-8dbb776da068") DkmCustomInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmCustomInstructionSymbol::Create to create this object
        private: DkmCustomInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomInstructionSymbol();
        // This object cannot be copied
        private: DkmCustomInstructionSymbol& operator=(const DkmCustomInstructionSymbol&);
        private: DkmCustomInstructionSymbol(const DkmCustomInstructionSymbol&);

        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pEntityId;
        private: const UINT64 m_Offset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // [Optional] This is a runtime-specific data structure which custom runtimes may use
        // to store the location of this instruction. Along with 'offset', this field will
        // used to compare two instructions from the same module.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE EntityId(
            );

        // Along with 'EntityId' the 'Offset' field is used to uniquely identity an
        // instruction. This could hold a pointer value (such as a pointer to the
        // instruction) or an offset from the start of the function/module.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Offset(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmCustomInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmCustomInstructionSymbol'.
        // pCustomInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::CustomInstruction)
                return NULL;

            return static_cast<DkmCustomInstructionSymbol*>(pInstruction);
        }

        // Create a new DkmCustomInstructionSymbol object instance.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // RuntimeType     : [In] The Runtime Id identifies the execution environment for a
        // particular piece of code. Runtime Ids are used by the dispatcher to decide which
        // monitor to dispatch to. Note that the ordering of the runtime ID Guids is somewhat
        // significant as this dictates which runtime gets the first shot during arbitration.
        // Thus, if one wants to declare a new runtime instance which is built on the CLR,
        // the runtime id should be less than DkmRuntimeId.Clr.
        // pEntityId       : [In,Optional] This is a runtime-specific data structure which
        // custom runtimes may use to store the location of this instruction. Along with
        // 'offset', this field will used to compare two instructions from the same module.
        // Offset          : [In] Along with 'EntityId' the 'Offset' field is used to
        // uniquely identity an instruction. This could hold a pointer value (such as a
        // pointer to the instruction) or an offset from the start of the function/module.
        // pAdditionalData : [In,Optional] Additional runtime-specific data associated with
        // an address. This data will not be used when comparing addresses.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const GUID& RuntimeType,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pEntityId,
            _In_ UINT64 Offset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ CustomRuntimes::DkmCustomInstructionSymbol** ppCreatedObject
            );
    }; // end of DkmCustomInstructionSymbol

    // 'DkmCustomModuleInstance' is used for modules from a custom runtime environment (not
    // native or CLR-based). For example, this could be used in a custom interpreter or
    // Just-In-Time compiler.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("28a2ee07-bdcf-31f8-66e9-09b958e66fe8") DkmCustomModuleInstance : public DkmModuleInstance
    {
        // Use DkmCustomModuleInstance::Create to create this object
        private: DkmCustomModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomModuleInstance();
        // This object cannot be copied
        private: DkmCustomModuleInstance& operator=(const DkmCustomModuleInstance&);
        private: DkmCustomModuleInstance(const DkmCustomModuleInstance&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmCustomModuleInstance'. Return
        // NULL if the path object is not a 'DkmCustomModuleInstance'.
        // pCustomModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::CustomModuleInstance)
                return NULL;

            return static_cast<DkmCustomModuleInstance*>(pModuleInstance);
        }

        // Create a new DkmCustomModuleInstance object instance.
        //
        // This method will send a ModuleInstanceLoad event.
        // pName           : [In] Short representation of the module name. For file-based
        // modules, this  is the file name and extension (ex: kernel32.dll).
        // pFullName       : [In] Fully qualified module name. For file-based modules, this
        // is the full path to the module (ex: c:\windows\system32\kernel32.dll.
        // TimeDateStamp   : [In] Date/Time of when the loaded module was built. This value
        // is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of
        // measurement is a  FILETIME value, which is a 64-bit value representing the number
        // of 100-nanosecond intervals since January 1, 1601 (UTC).
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pVersion        : [In,Optional] File version information.
        // pSymbolFileId   : [In,Optional] Contains information needed to locate symbols for
        // this module. On Win32, this information is contained within the
        // IMAGE_DEBUG_DIRECTORY.
        // Flags           : [In] Flags which indicate traits of a DkmModuleInstance.
        // MemoryLayout    : [In] Enumeration that indicates how a module is laid out in
        // memory.
        // BaseAddress     : [In,Optional] The starting memory address of where the module
        // loaded. This value will be zero if the module did not load in a contiguous block
        // of memory.
        // LoadOrder       : [In] The integer count of the number of module instances that
        // have loaded up to and including this module. Each runtime instance keeps track of
        // its own load order count.
        // Size            : [In,Optional] The number of bytes in the module's memory region.
        // This value will be zero if the module did not load in a contiguous block of
        // memory.
        // pLoadContext    : [In] String description of the context under which this module
        // has been loaded. ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        // IsDisabled      : [In] Indicates if this module instance has been disabled.
        // Disabled modules are largely ignored by the debugger. For native modules, the
        // address range of the disabled module is treated as if it is unmapped. For CLR
        // modules, any frames from these modules is hidden from the call stack.
        // pModule         : [In,Optional] The symbol handler's representation of a module
        // (DkmModule) which is associated with this module instance. This value is initially
        // null, and is assigned if and when symbols are associated with this module
        // instance.
        // pMinidumpInfo   : [In,Optional] 'MinidumpInfo' is used to convey additional
        // information about modules in a DkmProcess for a minidump.
        // DataItem        : [In] Data object to add to the new DkmCustomModuleInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags::e Flags,
            _In_ DkmModuleMemoryLayout::e MemoryLayout,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 LoadOrder,
            _In_ UINT32 Size,
            _In_ DkmString* pLoadContext,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CustomRuntimes::DkmCustomModuleInstance** ppCreatedObject
            );
    }; // end of DkmCustomModuleInstance

    // Represents the custom execution environment executing in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("83e44dea-5cac-3e7d-c980-118728716623") DkmCustomRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmCustomRuntimeInstance::Create to create this object
        private: DkmCustomRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomRuntimeInstance();
        // This object cannot be copied
        private: DkmCustomRuntimeInstance& operator=(const DkmCustomRuntimeInstance&);
        private: DkmCustomRuntimeInstance(const DkmCustomRuntimeInstance&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmCustomRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmCustomRuntimeInstance'.
        // pCustomRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::CustomRuntimeInstance)
                return NULL;

            return static_cast<DkmCustomRuntimeInstance*>(pRuntimeInstance);
        }

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // DataItem        : [In] Data object to add to the new DkmCustomRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject
            );

        // Creates a new runtime instance object from a debug monitor. This method must be
        // called from the event thread when a debug monitor detects that a new runtime
        // instance has loaded (for example, when the corresponding runtime dll loads in the
        // target process).
        //
        // This method will send a RuntimeInstanceLoad event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Id              : [In] Identifies a DkmRuntimeInstance object within a process.
        // Capabilities    : [In] Enumeration of runtime capabilities.
        // pParentRuntime  : [In,Optional] For runtimes that are implemented on top of
        // another runtime, this can optionally be used to indicant the logical parent. This
        // can then be used to request services from the parent when the child runtime
        // doesn't implement the service. This is currently used only for obtaining the top
        // stack frame to evaluate a conditional breakpoint when the child runtime doesn't
        // walk stacks itself.
        // DataItem        : [In] Data object to add to the new DkmCustomRuntimeInstance
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities::e Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject
            );
    }; // end of DkmCustomRuntimeInstance

}; // end namespace CustomRuntimes

// Contains types specific to runtime environment agnostic disassembly.
namespace Disassembly {
    // An effective address for an instruction. The effective address is the calculated
    // address that an instruction operand represents. For instance, on x86, an instruction
    // may be of the form dwordptr [esp-12]. The effective address of this operand will be
    // the result of subtracting 12 from esp. The number of operands and effective addresses
    // are architecture specific.
    struct DECLSPEC_UUID("143e24fc-8dcd-826c-1008-a3578f617a79") DkmEffectiveAddress
    {
        // The effective address for the operand.
        UINT64 EffectiveAddress;

        // The size of the operand this address applies to.
        UINT32 OperandSize;

        // Set if the the segment register is FS. Only used on x86.
        Disassembly::DkmEffectiveAddressFlags::e Flags;

        // Release all reference-counted fields within the DkmEffectiveAddress structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmEffectiveAddress* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Contains information about a disassembled instruction in the debuggee. Objects are
    // returned from DkmProcess.Disassemble.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0d808671-5c47-a9c5-fffb-5aecb558b2b4") DkmDisassembledInstruction : public IUnknown
    {
        private: DWORD m_ReferenceCount;
        private: DkmDispatcherObjectFlags::e m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDisassembledInstruction::Create to create this object
        private: DkmDisassembledInstruction();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDisassembledInstruction();
        // This object cannot be copied
        private: DkmDisassembledInstruction& operator=(const DkmDisassembledInstruction&);
        private: DkmDisassembledInstruction(const DkmDisassembledInstruction&);

        private: DkmProcess* const m_pProcess;
        private: const UINT64 m_InstructionPointer;
        private: const UINT32 m_InstructionLength;
        private: DkmString* const m_pAddress;
        private: DkmString* const m_pAddressOffset;
        private: DkmString* const m_pCodeBytes;
        private: DkmString* const m_pRawOpcode;
        private: DkmString* const m_pRawOperands;
        private: DkmString* const m_pFormattedOpcode;
        private: DkmString* const m_pFormattedOperands;
        private: OPTIONAL DkmString* const m_pSymbol;
        private: OPTIONAL Symbols::DkmSourcePosition* const m_pDocumentPosition;
        private: const UINT32 m_ByteOffset;
        private: DkmReadOnlyCollection<CV_HREG_e>* const m_pRegisterOperands;
        private: const bool m_ValidInstruction;
        private: void* m__pExtendedData;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // The address of this instruction in the debuggee address space.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE InstructionPointer(
            );

        // The length of the instruction in bytes.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE InstructionLength(
            );

        // The formatted address of this instruction in the debuggee address space.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Address(
            );

        // The address as an offset from some starting point, usually the beginning of the
        // associated function.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AddressOffset(
            );

        // The code bytes for this instruction.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CodeBytes(
            );

        // The raw opcode for this instruction with no symbolic lookups.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RawOpcode(
            );

        // The raw operands for this instruction with no symbolic lookups.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RawOperands(
            );

        // The opcode for this instruction including resolved symbol names. If nothing is
        // resolved, this is the same as RawOpcode.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FormattedOpcode(
            );

        // The operands for this instruction including resolved symbol names. If nothing is
        // resolved, this is the same as RawOperands.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FormattedOperands(
            );

        // [Optional] The symbol name, if any, associated with the address (public symbol,
        // label, and so on).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Symbol(
            );

        // [Optional] An optional reference to the document and text position this
        // instruction belongs to in the source document.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSourcePosition* STDMETHODCALLTYPE DocumentPosition(
            );

        // The number of bytes from the beginning of the corresponding source statement.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // A read only collection of CV constants representing any register arguments in the
        // disassembled instruction.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<CV_HREG_e>* STDMETHODCALLTYPE RegisterOperands(
            );

        // True if this instruction was successfully disassembled. False if it is a filler
        // instruction used by heuristic unwinders when an invalid op code is encountered.
        // Most disassembly providers will fill the op code with question marks when this is
        // set to true to indicate a bogus instruction.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ValidInstruction(
            );

        // Create a new DkmDisassembledInstruction object instance.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // InstructionPointer: [In] The address of this instruction in the debuggee address
        // space.
        // InstructionLength: [In] The length of the instruction in bytes.
        // pAddress        : [In] The formatted address of this instruction in the debuggee
        // address space.
        // pAddressOffset  : [In] The address as an offset from some starting point, usually
        // the beginning of the associated function.
        // pCodeBytes      : [In] The code bytes for this instruction.
        // pRawOpcode      : [In] The raw opcode for this instruction with no symbolic
        // lookups.
        // pRawOperands    : [In] The raw operands for this instruction with no symbolic
        // lookups.
        // pFormattedOpcode: [In] The opcode for this instruction including resolved symbol
        // names. If nothing is resolved, this is the same as RawOpcode.
        // pFormattedOperands: [In] The operands for this instruction including resolved
        // symbol names. If nothing is resolved, this is the same as RawOperands.
        // pSymbol         : [In,Optional] The symbol name, if any, associated with the
        // address (public symbol, label, and so on).
        // pDocumentPosition: [In,Optional] An optional reference to the document and text
        // position this instruction belongs to in the source document.
        // ByteOffset      : [In] The number of bytes from the beginning of the corresponding
        // source statement.
        // pRegisterOperands: [In] A read only collection of CV constants representing any
        // register arguments in the disassembled instruction.
        // ValidInstruction: [In] True if this instruction was successfully disassembled.
        // False if it is a filler instruction used by heuristic unwinders when an invalid op
        // code is encountered. Most disassembly providers will fill the op code with
        // question marks when this is set to true to indicate a bogus instruction.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 InstructionPointer,
            _In_ UINT32 InstructionLength,
            _In_ DkmString* pAddress,
            _In_ DkmString* pAddressOffset,
            _In_ DkmString* pCodeBytes,
            _In_ DkmString* pRawOpcode,
            _In_ DkmString* pRawOperands,
            _In_ DkmString* pFormattedOpcode,
            _In_ DkmString* pFormattedOperands,
            _In_opt_ DkmString* pSymbol,
            _In_opt_ Symbols::DkmSourcePosition* pDocumentPosition,
            _In_ UINT32 ByteOffset,
            _In_ DkmReadOnlyCollection<CV_HREG_e>* pRegisterOperands,
            _In_ bool ValidInstruction,
            _Deref_out_ Disassembly::DkmDisassembledInstruction** ppCreatedObject
            );
    }; // end of DkmDisassembledInstruction
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Flags that impact the effective address.
    enum DkmEffectiveAddressFlags::e
    {
        // No flags applied.
        None = 0x0,
        // Indicates that the segment register is FS. Used only on x86.
        SegmentIsFS = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmEffectiveAddressFlags::e);

}; // end namespace Disassembly

// Contains types used to describe properties of threads running in the target process.
namespace ThreadProperties {
    // Result of an asynchronous DkmThread.GetManagedThreadProperties call.
    struct DkmGetManagedThreadPropertiesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The managed thread id of the thread.
        INT32 ManagedThreadId;
    };

    // Result of an asynchronous DkmRuntimeInstance.GetThreadDisplayProperties call.
    struct DkmGetThreadDisplayPropertiesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] The Thread Display Name.
        OPTIONAL DkmString* pDisplayName;

        // [Optional] The Thread Name Priority: Values are from DISPLAY_NAME_PRI as defined
        // in MSDBG100.
        UINT32 DisplayNamePriority;

        // [Optional] Values are from THREADCATEGORY as defined in EnvDTE90.dll/.tlb.
        UINT32 ThreadCategory;
    };

    // Result of an asynchronous DkmRuntimeInstance.GetThreadName call.
    struct DkmGetThreadNameAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] The Thread Name.
        OPTIONAL DkmString* pName;
    };

    // Result of an asynchronous DkmThread.GetVolatileFlags call.
    struct DkmGetVolatileFlagsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Volatile flags that apply to a thread. These values are expected to change over
        // time and should not be cached by callers.
        ThreadProperties::DkmVolatileThreadFlags::e Flags;
    };

    // Result of an asynchronous DkmThread.GetVolatileProperties call.
    struct DkmGetVolatilePropertiesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The priority of the thread. The values returned correspond directly to the values
        // defined for kernel32!GetThreadPriority.
        INT32 Priority;

        // The affinity mask of the thread. The values returned correspond directly to the
        // values defined for kernel32!SetThreadAffinityMask.
        UINT64 AffinityMask;
    };

    // Volatile flags that apply to a thread. These values are expected to change over time
    // and should not be cached by callers.
    enum DkmVolatileThreadFlags::e
    {
        // No flags are set.
        None = 0x0,
        // The thread is a user-mode scheduled helper or scheduler thread.
        UserModeScheduled = 0x1
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmVolatileThreadFlags::e);

}; // end namespace ThreadProperties

// Contains types used to provide data to the 'Parallel Tasks' and 'Parallel Stacks'
// debugger windows. Types in this namespace are subject to change in future versions of
// Visual Studio.
namespace ParallelTasks {
    // Represents stack segment that task applies to. AddressOriginalMin <= AddressMin <=
    // AddressMax <= AddressOriginalMax.
    struct DECLSPEC_UUID("9fdf4025-864e-58e3-84c9-5f0e5a82e49f") DkmTaskStackSegment
    {
        // Trimmed  minimum address on stack.
        UINT64 AddressMin;

        // Trimmed  maximum address on stack.
        UINT64 AddressMax;

        // original minimum address on stack.
        UINT64 AddressOriginalMin;

        // original maximum address on stack.
        UINT64 AddressOriginalMax;

        // OS thread id.
        UINT32 ThreadId;

        // Release all reference-counted fields within the DkmTaskStackSegment structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmTaskStackSegment* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Properties of the task.
    struct DECLSPEC_UUID("d0fc2053-8661-2602-078e-13207a8b6727") DkmTaskProperties
    {
        // [Optional] Name of task.
        OPTIONAL DkmString* pName;

        // [Optional] TODO.
        OPTIONAL DkmString* pLocation;

        // [Optional] TODO.
        OPTIONAL DkmString* pProperty1;

        // [Optional] TODO.
        OPTIONAL DkmString* pProperty2;

        // [Optional] TODO.
        OPTIONAL DkmString* pProperty3;

        // TODO.
        enum_TASKSTATE_TYPE State;

        // TODO.
        enum_TASKLOAD_FLAGS Flags;

        // TODO.
        UINT32 Fields;

        // Release all reference-counted fields within the DkmTaskProperties structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmTaskProperties* pItem
            );
    };

    // Information about a managed task that is obtained via inspection.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("00083cf7-83a6-88c5-bf6e-c4fc451fa49c") DkmManagedTaskInfo
    {
        // The task ID.
        UINT32 Id;

        // The ID of this tasks parent.
        UINT32 ParentId;

        // [Optional] String representing the AsyncState property of the task.
        OPTIONAL DkmString* pAsyncState;

        // The state flags stored in the task object.
        UINT32 StateFlags;

        // Release all reference-counted fields within the DkmManagedTaskInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedTaskInfo* pItem
            );
    };

    // Represents either a managed TPL task or a native Concurrency Runtime task.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("91470324-c843-bec3-2050-7c9e644c28d7") DkmTask : public DkmDataContainer
    {
        // Use DkmTask::Create to create this object
        private: DkmTask();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTask();
        // This object cannot be copied
        private: DkmTask& operator=(const DkmTask&);
        private: DkmTask(const DkmTask&);

        // Contains additional fields of DkmTask which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // The return status of the task or unknown if the task has not completed.
            const ParallelTasks::DkmTaskReturnStatus::e ReturnStatus;

            // The time since debugging started that this task started.  The time is in
            // seconds.
            const double StartTime;

            // The time since debugging started that this task completed.  The time is in
            // seconds.
            const double CompletedTime;

            // The current task duration in seconds.
            const double Duration;
        };

        private: ParallelTasks::DkmTaskProvider* const m_pTaskProvider;
        private: OPTIONAL DkmThread* const m_pThread;
        private: const UINT64 m_TaskId;
        private: const UINT64 m_ParentTaskId;
        private: const ParallelTasks::DkmTaskStackSegment m_StackSegment;
        private: ___ExtendedData* const m__pExtendedData;
        private: void* m_pTaskSyncObjectCollection0;

        // Represents a task provider which is loaded into the target process.
        public: _Ret_ DECLSPEC_NOTHROW ParallelTasks::DkmTaskProvider* STDMETHODCALLTYPE TaskProvider(
            );

        // [Optional] DkmThread represents a thread running in the target process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Identifier for this particular instance.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TaskId(
            );

        // ID of parent task, 0 if there is no parent task.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ParentTaskId(
            );

        // Represents stack segment that task applies to. AddressOriginalMin <= AddressMin <=
        // AddressMax <= AddressOriginalMax.
        public: DECLSPEC_NOTHROW const ParallelTasks::DkmTaskStackSegment& STDMETHODCALLTYPE StackSegment(
            );

        // The return status of the task or unknown if the task has not completed.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW ParallelTasks::DkmTaskReturnStatus::e STDMETHODCALLTYPE ReturnStatus(
            );

        // The time since debugging started that this task started.  The time is in seconds.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW double STDMETHODCALLTYPE StartTime(
            );

        // The time since debugging started that this task completed.  The time is in
        // seconds.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW double STDMETHODCALLTYPE CompletedTime(
            );

        // The current task duration in seconds.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW double STDMETHODCALLTYPE Duration(
            );

        // Closes a DkmTask object instance. This will release any resources associated with
        // this object across all components. This includes resources across computer or
        // managed/native marshalling boundaries.
        //
        // DkmTask objects are automatically closed when their associated DkmTaskProvider
        // object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // This method is called to represent a task on a specific thread.
        // pTaskProvider   : [In] Represents a task provider which is loaded into the target
        // process.
        // pThread         : [In,Optional] DkmThread represents a thread running in the
        // target process.
        // TaskId          : [In] Identifier for this particular instance.
        // ParentTaskId    : [In] ID of parent task, 0 if there is no parent task.
        // StackSegment    : [In] Represents stack segment that task applies to.
        // AddressOriginalMin <= AddressMin <= AddressMax <= AddressOriginalMax.
        // DataItem        : [In] Data object to add to the new DkmTask instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_opt_ DkmThread* pThread,
            _In_ UINT64 TaskId,
            _In_ UINT64 ParentTaskId,
            _In_ const ParallelTasks::DkmTaskStackSegment& StackSegment,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTask** ppCreatedObject
            );

        // This method is called to represent a task on a specific thread.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // pTaskProvider   : [In] Represents a task provider which is loaded into the target
        // process.
        // pThread         : [In,Optional] DkmThread represents a thread running in the
        // target process.
        // TaskId          : [In] Identifier for this particular instance.
        // ParentTaskId    : [In] ID of parent task, 0 if there is no parent task.
        // StackSegment    : [In] Represents stack segment that task applies to.
        // AddressOriginalMin <= AddressMin <= AddressMax <= AddressOriginalMax.
        // ReturnStatus    : [In] The return status of the task or unknown if the task has
        // not completed.
        // StartTime       : [In] The time since debugging started that this task started.
        // The time is in seconds.
        // CompletedTime   : [In] The time since debugging started that this task completed.
        // The time is in seconds.
        // Duration        : [In] The current task duration in seconds.
        // DataItem        : [In] Data object to add to the new DkmTask instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_opt_ DkmThread* pThread,
            _In_ UINT64 TaskId,
            _In_ UINT64 ParentTaskId,
            _In_ const ParallelTasks::DkmTaskStackSegment& StackSegment,
            _In_ ParallelTasks::DkmTaskReturnStatus::e ReturnStatus,
            _In_ double StartTime,
            _In_ double CompletedTime,
            _In_ double Duration,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTask** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns children tasks.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pItems          : [Out] TODO.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildTasks(
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Returns task properties.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // Radix           : [In] TODO.
        // Fields          : [In] TODO.
        // pProperties     : [Out] TODO.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskProperties(
            _In_ UINT32 Radix,
            _In_ UINT32 Fields,
            _Out_ ParallelTasks::DkmTaskProperties* pProperties
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // TODO.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pItems          : [Out] TODO.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSynchronizationObjects(
            _Out_ DkmArray<ParallelTasks::DkmTaskSynchronizationObject*>* pItems
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmTask

    // Represents a task provider which is loaded into the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9df33d71-fb30-91b6-43fd-15c2bdda7236") DkmTaskProvider : public DkmDataContainer
    {
        // Use DkmTaskProvider::Create to create this object
        private: DkmTaskProvider();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTaskProvider();
        // This object cannot be copied
        private: DkmTaskProvider& operator=(const DkmTaskProvider&);
        private: DkmTaskProvider(const DkmTaskProvider&);

        // Contains additional fields of DkmTaskProvider which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Flags describing additional information that this Task Provider can supply,
            // such as timestamps.
            const ParallelTasks::DkmTaskProviderCapabilityFlags::e AdditionalCapabilities;
        };

        private: const GUID m_TaskProviderId;
        private: DkmString* const m_pName;
        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: ___ExtendedData* const m__pExtendedData;
        private: void* m_pTaskCollection0;

        // Extensible GUID indicating the task provider which a task is from.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE TaskProviderId(
            );

        // Task name e.g. Chore or Task.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Identifier for this particular instance.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Flags describing additional information that this Task Provider can supply, such
        // as timestamps.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW ParallelTasks::DkmTaskProviderCapabilityFlags::e STDMETHODCALLTYPE AdditionalCapabilities(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Closes a DkmTaskProvider object instance. This will release any resources
        // associated with this object across all components. This includes resources across
        // computer or managed/native marshalling boundaries.
        //
        // DkmTaskProvider objects are automatically closed when their associated
        // DkmRuntimeInstance object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // This method is called a task provider component to create a DkmTaskProvider
        // object. It may be called in response to a call to InitializeTaskProviders call, or
        // to a module/app domain load event.
        //
        // This method will send a TaskProviderCreate event.
        // TaskProviderId  : [In] Extensible GUID indicating the task provider which a task
        // is from.
        // pName           : [In] Task name e.g. Chore or Task.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // DataItem        : [In] Data object to add to the new DkmTaskProvider instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& TaskProviderId,
            _In_ DkmString* pName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTaskProvider** ppCreatedObject
            );

        // This method is called a task provider component to create a DkmTaskProvider
        // object. It may be called in response to a call to InitializeTaskProviders call, or
        // to a module/app domain load event.
        //
        // This method will send a TaskProviderCreate event.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // TaskProviderId  : [In] Extensible GUID indicating the task provider which a task
        // is from.
        // pName           : [In] Task name e.g. Chore or Task.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // AdditionalCapabilities: [In] Flags describing additional information that this
        // Task Provider can supply, such as timestamps.
        // DataItem        : [In] Data object to add to the new DkmTaskProvider instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& TaskProviderId,
            _In_ DkmString* pName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ ParallelTasks::DkmTaskProviderCapabilityFlags::e AdditionalCapabilities,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTaskProvider** ppCreatedObject
            );

        // Find a DkmTask element within this DkmTaskProvider. If no element with the given
        // input key is present, FindTask will fail.
        // TaskId          : [In] Search key used to find the element.
        // ppTask          : [Out] Result of the search.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindTask(
            _In_ UINT64 TaskId,
            _Deref_out_ ParallelTasks::DkmTask** ppTask
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Enumerates the current set of tasks running in the target process.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // IsRoot          : [In] TODO.
        // RequestCount    : [In] Count of tasks requested.
        // pScheduledTaskCount: [Out] Number of scheduled tasks.
        // pItems          : [Out] Array contained the found tasks.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pTaskEnumFlags  : [Out] TODO.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTasks(
            _In_ bool IsRoot,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pScheduledTaskCount,
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems,
            _Out_ UINT32* pTaskEnumFlags
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // TODO.
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pNames          : [Out] TODO.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPropertyNames(
            _Out_ DkmArray<DkmString*>* pNames
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmTaskProvider

    // Flags indicating additional capabilities a Task Provider can have.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmTaskProviderCapabilityFlags::e
    {
        // No additional capabilities.
        None = 0x0,
        // Can provide timestamps for Tasks, i.e. Creation Time.
        Timestamps = 0x1,
        // Can provide the return value of completed tasks.
        ReturnStatus = 0x2
    };
    DEFINE_ENUM_FLAG_OPERATORS(DkmTaskProviderCapabilityFlags::e);

    // Extensible GUID indicating the task provider which a task is from.
    struct DkmTaskProviderId
    {
        // Task provider for Microsoft Task Parallel Library (TPL) for managed.
        // TPL is defined as {319f6cb1-11fa-407c-bd93-eddc1f5e3af0}.
        static const GUID TPL;
        // Task provider for Microsoft Concurrency Runtime programming framework for C++.
        // ConcurrencyRuntime is defined as {f02925c6-752c-48f6-bfc0-3bf2118e2c9e}.
        static const GUID ConcurrencyRuntime;
        // Task provider for JavaScript runtime.
        // JavaScript is defined as {d1d9b74c-1396-4610-b28c-9e56d96cea58}.
        static const GUID JavaScript;
        // Task provider for Managed TPL tasks based on ETW.
        // ManagedEtw is defined as {0b39b84c-597e-421c-b04c-7561735bcf8c}.
        static const GUID ManagedEtw;
        // Task provider for Native PPL tasks based on ETW.
        // NativeEtw is defined as {80b5df72-4b63-4e24-980a-67b4b4689f09}.
        static const GUID NativeEtw;
    };
    __declspec(selectany) const GUID DkmTaskProviderId::TPL = { 0x319f6cb1, 0x11fa, 0x407c, { 0xbd, 0x93, 0xed, 0xdc, 0x1f, 0x5e, 0x3a, 0xf0 } };
    __declspec(selectany) const GUID DkmTaskProviderId::ConcurrencyRuntime = { 0xf02925c6, 0x752c, 0x48f6, { 0xbf, 0xc0, 0x3b, 0xf2, 0x11, 0x8e, 0x2c, 0x9e } };
    __declspec(selectany) const GUID DkmTaskProviderId::JavaScript = { 0xd1d9b74c, 0x1396, 0x4610, { 0xb2, 0x8c, 0x9e, 0x56, 0xd9, 0x6c, 0xea, 0x58 } };
    __declspec(selectany) const GUID DkmTaskProviderId::ManagedEtw = { 0xb39b84c, 0x597e, 0x421c, { 0xb0, 0x4c, 0x75, 0x61, 0x73, 0x5b, 0xcf, 0x8c } };
    __declspec(selectany) const GUID DkmTaskProviderId::NativeEtw = { 0x80b5df72, 0x4b63, 0x4e24, { 0x98, 0xa, 0x67, 0xb4, 0xb4, 0x68, 0x9f, 0x9 } };

    // The return status for the task.  If the task hasn't completed yet, the status is
    // unknown.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    enum DkmTaskReturnStatus::e
    {
        // The return status is unknown because the task has not completed.
        Unknown = 0,
        // The task succeeded.
        Success = 1,
        // There was an error executing the task.
        Error = 2,
        // The task has been cancelled.
        Cancelled = 3
    };

    // Represents a synchronization object.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ceeeb968-317e-47e7-f0e7-42d12f5bb406") DkmTaskSynchronizationObject : public DkmDataContainer
    {
        // Use DkmTaskSynchronizationObject::Create to create this object
        private: DkmTaskSynchronizationObject();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTaskSynchronizationObject();
        // This object cannot be copied
        private: DkmTaskSynchronizationObject& operator=(const DkmTaskSynchronizationObject&);
        private: DkmTaskSynchronizationObject(const DkmTaskSynchronizationObject&);

        private: ParallelTasks::DkmTask* const m_pTask;
        private: OPTIONAL DkmThread* const m_pOwningThread;
        private: const GUID m_UniqueId;
        private: OPTIONAL DkmString* const m_pDecimalName;
        private: OPTIONAL DkmString* const m_pHexidecimalName;
        private: OPTIONAL DkmString* const m_pType;
        private: const UINT32 m_WaitTime;
        private: const UINT32 m_Timeout;
        private: void* m__pExtendedData;

        // Represents either a managed TPL task or a native Concurrency Runtime task.
        public: _Ret_ DECLSPEC_NOTHROW ParallelTasks::DkmTask* STDMETHODCALLTYPE Task(
            );

        // [Optional] The owning thread.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE OwningThread(
            );

        // Identifier for this particular instance.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] Name of the object, in base 10.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DecimalName(
            );

        // [Optional] Name of the object, in base 16.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE HexidecimalName(
            );

        // [Optional] TODO.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // TODO.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE WaitTime(
            );

        // TODO.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Timeout(
            );

        // Closes a DkmTaskSynchronizationObject object instance. This will release any
        // resources associated with this object across all components. This includes
        // resources across computer or managed/native marshalling boundaries.
        //
        // DkmTaskSynchronizationObject objects are automatically closed when their
        // associated DkmTask object is closed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        // Create a new DkmTaskSynchronizationObject object instance.
        // pTask           : [In] Represents either a managed TPL task or a native
        // Concurrency Runtime task.
        // pOwningThread   : [In,Optional] The owning thread.
        // pDecimalName    : [In,Optional] Name of the object, in base 10.
        // pHexidecimalName: [In,Optional] Name of the object, in base 16.
        // pType           : [In,Optional] TODO.
        // WaitTime        : [In] TODO.
        // Timeout         : [In] TODO.
        // DataItem        : [In] Data object to add to the new DkmTaskSynchronizationObject
        // instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        // data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ParallelTasks::DkmTask* pTask,
            _In_opt_ DkmThread* pOwningThread,
            _In_opt_ DkmString* pDecimalName,
            _In_opt_ DkmString* pHexidecimalName,
            _In_opt_ DkmString* pType,
            _In_ UINT32 WaitTime,
            _In_ UINT32 Timeout,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTaskSynchronizationObject** ppCreatedObject
            );
    }; // end of DkmTaskSynchronizationObject

}; // end namespace ParallelTasks

// Contains types which are Microsoft-internal and subject to change.
namespace Internal {
    // Internal object for accessing visualizer information from the target computer.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("81492227-e68b-4398-eea2-12c86fd2be52") DkmEELocalObject : public DkmDataContainer
    {
        // Use DkmEELocalObject::Create to create this object
        private: DkmEELocalObject();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEELocalObject();
        // This object cannot be copied
        private: DkmEELocalObject& operator=(const DkmEELocalObject&);
        private: DkmEELocalObject(const DkmEELocalObject&);

        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this DkmEELocalObject.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Create a new DkmEELocalObject object instance.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // DataItem        : [In] Data object to add to the new DkmEELocalObject instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Internal::DkmEELocalObject** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Initializes the visualizer cache on the IDE computer.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitCache(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // Returns visualizer information for a class.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pName           : [In] Name of the class.
        // AssemblyCookie  : [In] Assembly cookie.
        // pCookie         : [Out] Class cookie.
        // pValueAttributeCount: [Out] ValueAttributeCount.
        // pViewerAttributeCount: [Out] ViewerAttributeCount.
        // pVisualizerAttributeCount: [Out] VisualizerAttributeCount.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTargetClass(
            _In_ DkmString* pName,
            _In_ UINT32 AssemblyCookie,
            _Out_ UINT32* pCookie,
            _Out_ UINT32* pValueAttributeCount,
            _Out_ UINT32* pViewerAttributeCount,
            _Out_ UINT32* pVisualizerAttributeCount
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetTargetAssembly.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // pName           : [In] Name.
        // pCookie         : [Out] Cookie.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTargetAssembly(
            _In_ DkmString* pName,
            _Out_ UINT32* pCookie
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetAssembly.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // AssemblyCookie  : [In] Assembly cookie.
        // Flags           : [In] GETASSEMBLY flags.
        // pFlagsOut       : [Out,Optional] ASSEMBLYFLAGS flags.
        // ppName          : [Out,Optional] name.
        // pAssemblyBytes  : [Out] Bytes of the visualizer assembly.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pPdbBytes       : [Out] Bytes of the visualizer assembly's PDB.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAssembly(
            _In_ UINT32 AssemblyCookie,
            _In_ UINT32 Flags,
            _Out_ UINT32* pFlagsOut,
            _Deref_out_opt_ DkmString** ppName,
            _Out_ DkmArray<BYTE>* pAssemblyBytes,
            _Out_ DkmArray<BYTE>* pPdbBytes
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetHostAssembly.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // Flags           : [In] Flags.
        // pAssemblyBytes  : [Out] Assembly bytes.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pPdbBytes       : [Out] Bytes of the visualizer assembly's PDB.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHostAssembly(
            _In_ UINT32 Flags,
            _Out_ DkmArray<BYTE>* pAssemblyBytes,
            _Out_ DkmArray<BYTE>* pPdbBytes
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetValueAttributeProps.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ClassCookie     : [In] Class cookie.
        // Ordinal         : [In] Ordinal.
        // ppTargetedAssembly: [Out,Optional] Target assembly.
        // pAssemblyLocation: [Out,Optional] Assembly location.
        // ppName          : [Out,Optional] Name.
        // ppValue         : [Out,Optional] Value.
        // ppType          : [Out,Optional] Type.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetValueAttributeProps(
            _In_ UINT32 ClassCookie,
            _In_ UINT32 Ordinal,
            _Deref_out_opt_ DkmString** ppTargetedAssembly,
            _Out_ UINT32* pAssemblyLocation,
            _Deref_out_opt_ DkmString** ppName,
            _Deref_out_opt_ DkmString** ppValue,
            _Deref_out_opt_ DkmString** ppType
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetViewerAttributeProps.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ClassCookie     : [In] Class cookie.
        // Ordinal         : [In] Ordinal.
        // ppTargetedAssembly: [Out,Optional] Target assembly.
        // pAssemblyLocation: [Out,Optional] Assembly location.
        // ppClassName     : [Out,Optional] Class name.
        // pClassAssemblyLocation: [Out,Optional] ClassAssemblyLocation.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetViewerAttributeProps(
            _In_ UINT32 ClassCookie,
            _In_ UINT32 Ordinal,
            _Deref_out_opt_ DkmString** ppTargetedAssembly,
            _Out_ UINT32* pAssemblyLocation,
            _Deref_out_opt_ DkmString** ppClassName,
            _Out_ UINT32* pClassAssemblyLocation
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        // GetVisualizerAttributeProps.
        //
        // Location constraint: API must be called from a Monitor component (component level
        // < 100,000).
        // ClassCookie     : [In] Class cookie.
        // Ordinal         : [In] Ordinal.
        // ppTargetedAssembly: [Out,Optional] Target assembly.
        // pAssemblyLocation: [Out,Optional] Assembly location.
        // ppDisplayClassName: [Out,Optional] Display class name.
        // pDisplayClassAssemblyLocation: [Out,Optional] DisplayClassAssemblyLocation.
        // ppProxyClassName: [Out,Optional] Proxy class name.
        // pProxyClassAssemblyLocation: [Out,Optional] ProxyClassAssemblyLocation.
        // ppDescription   : [Out,Optional] Description.
        // pType           : [Out,Optional] Type.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVisualizerAttributeProps(
            _In_ UINT32 ClassCookie,
            _In_ UINT32 Ordinal,
            _Deref_out_opt_ DkmString** ppTargetedAssembly,
            _Out_ UINT32* pAssemblyLocation,
            _Deref_out_opt_ DkmString** ppDisplayClassName,
            _Out_ UINT32* pDisplayClassAssemblyLocation,
            _Deref_out_opt_ DkmString** ppProxyClassName,
            _Out_ UINT32* pProxyClassAssemblyLocation,
            _Deref_out_opt_ DkmString** ppDescription,
            _Out_ UINT32* pType
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmEELocalObject

    // Concord wrapper around IPropertyProxyEESide.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("26a761e2-09ad-2a3e-6c9f-cc799df30828") DkmPropertyProxy : public DkmDataContainer
    {
        // Use DkmPropertyProxy::Create to create this object
        private: DkmPropertyProxy();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPropertyProxy();
        // This object cannot be copied
        private: DkmPropertyProxy& operator=(const DkmPropertyProxy&);
        private: DkmPropertyProxy(const DkmPropertyProxy&);

        private: const UINT32 m_Id;
        private: Evaluation::DkmSuccessEvaluationResult* const m_pEvaluationResult;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Not described (internal API).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The evaluation result this proxy is based on.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE EvaluationResult(
            );

        // Guid which uniquely identifies this DkmPropertyProxy.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Create a new DkmPropertyProxy object instance.
        // Id              : [In] Not described (internal API).
        // pEvaluationResult: [In] The evaluation result this proxy is based on.
        // DataItem        : [In] Data object to add to the new DkmPropertyProxy instance.
        // DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        // ppCreatedObject : [Out] Result of this method call.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ Evaluation::DkmSuccessEvaluationResult* pEvaluationResult,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Internal::DkmPropertyProxy** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Not described (internal API).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppDataOut       : [Out,Optional] the result bytes.
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitSourceDataProvider(
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Not described (internal API).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // ppAssemblyName  : [Out,Optional] Not described (internal API).
        // ppAssemblyBytes : [Out,Optional] Not described (internal API).
        // ppAssemblyPdb   : [Out,Optional] Not described (internal API).
        // ppClassName     : [Out,Optional] class name.
        // pAssemblyResolution: [Out] enum_ASSEMBLYLOCRESOLUTION enumeration.
        // pReplacementOk  : [Out] replacement ok.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedViewerCreationData(
            _Deref_out_opt_ DkmString** ppAssemblyName,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppClassName,
            _Out_ UINT32* pAssemblyResolution,
            _Out_ bool* pReplacementOk
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Not described (internal API).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // DataIn          : [In] Not described (internal API).
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // ppDataOut       : [Out,Optional] Not described (internal API).
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InPlaceUpdateObject(
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Implements IPropertyProxyEESide::ResolveAssemblyReference().
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        // pAssemblyName   : [In] Not described (internal API).
        // Flags           : [In] GETASSEMBLY flags.
        // ppAssemblyBytes : [Out,Optional] Not described (internal API).
        // ppAssemblyPdb   : [Out,Optional] Not described (internal API).
        // ppAssemblyLocation: [Out,Optional] Not described (internal API).
        // pAssemblyResolution: [Out] ASSEMBLYLOCRESOLUTION enum.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveAssemblyReference(
            _In_ DkmString* pAssemblyName,
            _In_ UINT32 Flags,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppAssemblyLocation,
            _Out_ UINT32* pAssemblyResolution
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Not described (internal API).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // ppDataOut       : [Out,Optional] Not described (internal API).
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInitialData(
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        // Not described (internal API).
        //
        // Location constraint: API must be called from an IDE component (component level >
        // 100,000).
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        // DataIn          : [In] Not described (internal API).
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // ppDataOut       : [Out,Optional] Not described (internal API).
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateReplacementObject(
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmPropertyProxy

}; // end namespace Internal



// Expression evaluators interfaces
// Expression Evaluators are components which are typically implemented by compiler
// vendors. They allow users to debug in the same language as the code was written. They
// do this by flavoring various debugger windows, such as the Watch, Call stack, and
// Function breakpoints to the language of the code.
//
// Expression evaluators may be loaded on either the Visual Studio computer or the target
// (remote) computer.
//
// The challenge with implementing expression evaluators on the Visual Studio computer is
// that in target debugging scenarios, it can be slow to access the memory of the target
// computer. To resolve this issue, expression evaluators should be implemented by
// sending a query to the target machine which can examine the state of the target
// process and return data. For debugging native code, this is implemented though
// DkmCompiledInspectionQuery.Execute. Expression evaluators loaded on the Visual Studio
// computer should have a component level of 9992000.
//
// The challenge with implementing expression evaluators on the target computer is that
// accesses to the symbol store may need to be remoted, and can therefore be expensive.
// This approach can be used in languages/runtimes where a large amount of the symbolic
// information is available on the target computer. For example, in most managed
// languages, metadata can be used to describe much of the program, so it's possible to
// implement expression evaluators for managed languages on the target computer.
// Expression evaluators that load on the target computer should have a component level
// of 65000.
namespace ComponentInterfaces
{
    // This interface is implemented the expression evaluator to allow an EE addin to
    // callback to the expression evaluator.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId, SourceId, VisualizerId.
    #define IID_IDkmCustomVisualizerCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomVisualizerCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c36da556-bab7-7ca1-50e4-6372543a80fe") IDkmCustomVisualizerCallback : public IUnknown
    {
        // Allows custom expression evaluator addins to obtain the symbol interface for the
        // type being visualized. This is not stored in the DkmVisualizedExpression directly
        // to enable addins that live on the remote machine and do not depend on symbols.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // TypeSymbolInterfaceId: [In] The GUID of the TypeSymbolInterface interface
        // requested from the caller. For the Microsoft native C++ expression evaluator, this
        // should be IID_IDiaSymbol.
        // ppTypeSymbolInterface: [Out] The symbol interface of the type that was used to
        // evaluate the expression.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ const GUID& TypeSymbolInterfaceId,
            _Deref_out_ IUnknown** ppTypeSymbolInterface
            ) = 0;

        // This method allows a visualizer addin use the expression evaluator to compile and
        // evaluate the default value for an expression. The addin can use this result as-is
        // or override fields by creating a new result. The addin can also choose to use the
        // expression evaluator for expansion using the the get children callbacks.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pInspectionContext: [In] The inspection context to use for this evaluation.
        // pExpression     : [In] The expression the visualizer addin to would like the
        // expression evaluator to evaluate.
        // pStackFrame     : [In] Stack frame to evaluate the expression in.
        // ppResultObject  : [Out] Object containing the result of the evaluation.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_PROCESS_DESTROYED indicates that the process exited while attempting to
        // evaluate.
        virtual HRESULT STDMETHODCALLTYPE EvaluateExpressionCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            ) = 0;

        // This method will construct a default full name for a custom visualized child
        // expression. This name will be the root expression's full name and an expand format
        // string that will cause the expression evaluator to callback to the visualizer to
        // obtain children. The DkmVisualizedExpression instance this is called on should be
        // the parent visualized expression for a child and the root visualized expression
        // for a root.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // Index           : [In] The index of child for which this full name is created.
        // Ignored in the case of a root item.
        // ppFullName      : [Out] The returned full name string.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CreateDefaultChildFullName(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ INT32 Index,
            _Deref_out_ DkmString** ppFullName
            ) = 0;

        // This method allows a visualizer addin use the expression evaluator for expansion.
        // The evaluation result contained within the visualized expression must have come
        // from the expression evaluator via EvaluateExpressionCallback.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pDefaultEvaluationResult: [In] The evaluation result returned from the expression
        // evaluator for this expression. The expression evaluator can only control the
        // expansion of evaluations it understands.
        // InitialRequestSize: [In] The initial number of children that the caller would like
        // returned. This value can be zero if no children will be initially returned. This
        // value may be larger than the number of children that this expression has, in which
        // case all children should be returned. Very large or negative values should not be
        // used as arrays can have extremely large sizes which would cause out-of-memory if
        // all elements were requested.
        // pInspectionContext: [In] The inspection context to use for computing the children.
        // This may differ from the original inspection context with respect to settings,
        // such as radix, evaluation flags, or timeout.
        // pInitialChildren: [Out] The initial children to return. Each child must be closed
        // by the caller when the caller is done.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppEnumContext   : [Out] Context object used to enumerate the children. This object
        // must be closed by the caller of this API when enumeration is complete.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetChildrenCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            ) = 0;

        // This method allows a visualizer addin use the expression evaluator for expansion
        // using the passed enumeration context. This is used to obtain local variables of a
        // stack frame or child members from an evaluation result.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pEnumContext    : [In] Context object used to enumerate the children.
        // StartIndex      : [In] The zero-based index of the first item to obtain.
        // Count           : [In] The number of items to try and return. This value may be
        // larger than the total number of remaining items, in which case all remaining items
        // should be returned. Very large or negative values should not be used as arrays can
        // have extremely large sizes which would cause out-of-memory if all elements were
        // requested.
        // pItems          : [Out] The DkmEvaluationResult items to return. Each item must be
        // closed by the caller when the caller is done.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetItemsCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pItems
            ) = 0;

        // Modifies the value of the given evaluation result (assumed to be non-read-only) to
        // match the given string. This is used after the user edits a value in any of the
        // evaluation windows.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pDefaultEvaluationResult: [In] The evaluation result returned from the expression
        // evaluator for this expression. The expression evaluator can only control
        // evaluations it understands.
        // pValue          : [In] Textual representation of value to assign to the evaluation
        // result.
        // Timeout         : [In] If a function evaluation is needed to assign the value,
        // specifies the timeout to use.
        // ppErrorText     : [Out,Optional] If the operation failed, this indicates the
        // reason why. This value should be null if the operation succeeded. In native code,
        // an S_OK return value is used when returning error text.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetValueAsStringCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        // This method is used for evaluation results that include
        // DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        // enclosing quotes or escape sequences. This is method is invoked to display one of
        // the various string visualizers in an expression evaluation window (click the
        // magnifying glass icon).
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pDefaultEvaluationResult: [In] The evaluation result returned from the expression
        // evaluator for this expression. The expression evaluator can only control
        // evaluations it understands.
        // ppStringValue   : [Out,Optional] The underlying string value.
        // Return value    : S_OK is returned if *ppStringValue is non-NULL, S_FALSE is
        // returned when *ppStringValue is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingStringCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

    // This interface allows a language extension to provide the ability to evaluate
    // expressions on a group of threads. It should generally be implemented by all language
    // extensions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmGroupLanguageExpressionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGroupLanguageExpressionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c3ae386f-e1b7-32a4-9d9e-3f8c317c2162") IDkmGroupLanguageExpressionEvaluator : public IUnknown
    {
        // Bind the input expression and evaluate it. Then format the resulting value for
        // display in the debugger. This is used for data tips, the watch windows, the
        // immediate window, etc.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThreads        : [In] The compute threads to use when executing the query.
        // pStackFrame     : [In] Stack frame to match on compute threads.
        // pExpression     : [In] Expression to evaluate.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EvaluateExpressionOnThreads(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ IDkmCompletionRoutine<Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // This interface allows an expression evaluator to specify intrinsic operations to be
    // invoked through IL, which the EE is responsible for implementing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // LanguageId, SourceId.
    #define IID_IDkmIntrinsicFunctionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIntrinsicFunctionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("54090b06-0fa6-dba2-b7c7-b598f98f4b16") IDkmIntrinsicFunctionEvaluator : public IUnknown
    {
        // Executes an intrinsic function.
        // pExecuteIntrinsic: [In] Pops the arguments off the IL stack in reverse order
        // (prior to the DkmILExecuteIntrinsic instruction, arguments should be pushed on the
        // stack in order). Then, executes an EE-defined operation that makes use of these
        // values.  Then, pushes the result back onto the IL stack.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // Arguments       : [In] The arguments supplied to the intrinsic function.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pSubroutines    : [In,Optional] Optional array of IL-based subroutines that the
        // intrinsic function may choose to invoke during its operation.
        // pResults        : [Out] The results of the evaluation to be pushed onto the IL
        // stack (in order).
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pFailureReason  : [Out] If an error occurs, specifies the reason for the error.
        // To indicate an error code whose meaning is specific to the particular intrinsic
        // function being executed, return a value less than zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::IL::DkmILExecuteIntrinsic* pExecuteIntrinsic,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ const DkmArray<Evaluation::IL::DkmILEvaluationResult*>& Arguments,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason::e* pFailureReason
            ) = 0;
    };

    // This interface is implemented by languages to enable stepping behavior for async
    // methods.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageAsyncStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageAsyncStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c2770199-bdf6-b971-47a9-e5d86ec4daf7") IDkmLanguageAsyncStepper : public IUnknown
    {
        // This method returns the identity of an async method. This is used to set
        // conditional breakpoints for stepping over an await expression.
        // pLanguageInstructionAddress: [In] Pairing between an instruction address and the
        // language that should be used to decode it.
        // pThread         : [In] Stack frame that provides the context of in which to
        // evaluate the expression.
        // ppIdentity      : [Out] The identity of the async method.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMethodIdentity(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ DkmThread* pThread,
            _Deref_out_ ICorDebugHandleValue** ppIdentity
            ) = 0;

        // This method asks the language to set or clear a flag on the Task backing the async
        // method. This flag enables stopping during step out of an async method.
        // pLanguageInstructionAddress: [In] Pairing between an instruction address and the
        // language that should be used to decode it.
        // pThread         : [In] Stack frame that provides the context of in which to
        // evaluate the expression.
        // Value           : [In] If true set the flag, else clear the flag.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetStepOutFlag(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ DkmThread* pThread,
            _In_ bool Value
            ) = 0;
    };

    // This interface is implemented by expression evaluators which live or the target
    // computer and wish to support conditional breakpoints.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageConditionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageConditionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c64e6bd6-39ac-04fb-ecd3-e2e41ed6d59a") IDkmLanguageConditionEvaluator : public IUnknown
    {
        // Parses an input breakpoint condition so that it can later be evaluated. If the
        // breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the
        // expression evaluator should require that the specified condition evaluates to a
        // Boolean value. The created query must return only a single result. For
        // BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any
        // non-zero value is considered true.
        // pEvaluationCondition: [In] Represents a condition which is evaluated on the target
        // computer. These objects are used for languages where the expression evaluator is
        // implemented on the target.
        // ppErrorText     : [Out,Optional] If the condition could not be parsed, this
        // indicates the reason why. This value should be null if the compile succeeded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ParseCondition(
            _In_ Breakpoints::DkmEvaluationBreakpointCondition* pEvaluationCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        // Evaluates a condition to decide if the debugger should stop.
        // pEvaluationCondition: [In] Represents a condition which is evaluated on the target
        // computer. These objects are used for languages where the expression evaluator is
        // implemented on the target.
        // pStackFrame     : [In] The stack frame to use when evaluating the condition.
        // pStop           : [Out] True if the breakpoint condition indicated that the IDE
        // should stop.
        // ppErrorText     : [Out,Optional] If the condition could not be evaluated, this
        // indicates the reason why. This value should be null if the compile succeeded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EvaluateCondition(
            _In_ Breakpoints::DkmEvaluationBreakpointCondition* pEvaluationCondition,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ bool* pStop,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;
    };

    // This interface allows a language extension to pre-compile an expression so that the
    // same expression may be quickly evaluated in multiple contexts.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageExpressionCompiler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageExpressionCompiler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b8a50138-6bf6-e554-871c-186db6678991") IDkmLanguageExpressionCompiler : public IUnknown
    {
        // Compile the input expression so that it is ready for evaluation. A typical
        // expression evaluator may lex the input string, parse the tokens, bind the tokens
        // to symbols and possibly transform the expression into an intermediate
        // representation for evaluation. However, since this method returns no result on
        // success, all of this processing is optional and an expression evaluator may delay
        // all of this work to the 'EvaluateExpression' method. The advantage of performing
        // this work during 'Compile' is to issue any expression errors back to this user as
        // soon as possible, and to improve the performance of repeated evaluations.
        // Currently, these advantages show up in the user scenario of breakpoint conditions
        // -- 'Compile' errors can be shown to the user before the dialog closes, and as
        // breakpoints may be hit frequently, there may be noticeable performance advantages
        // of moving work from 'Evaluate' to 'Compile'. 'Compile' may also be used in HPC
        // scenarios where an expression is compiled against one input address and then
        // evaluated against the same method in various other processes.
        // pLanguageInstructionAddress: [In] Pairing between an instruction address and the
        // language that should be used to decode it.
        // pExpression     : [In] Expression to compile.
        // ppError         : [Out,Optional] Indicates any error compiling the expression. On
        // successful compilation, this value should be null. In error cases, this value is
        // used to indicate the reason for the compilation failure, and the caller should
        // return S_OK.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Compile(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _Deref_out_opt_ Evaluation::DkmFailedEvaluationResult** ppError
            ) = 0;

        // Compiles an input breakpoint condition into an inspection query which can be
        // evaluated on the target computer. If the breakpoint condition uses
        // DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should
        // require that the specified condition evaluates to a Boolean value. The created
        // query must return only a single result. For BreakWhenTrue conditions, this must be
        // either a 4-byte or 1-byte value, and any non-zero value is considered true.
        // pLanguageInstructionAddress: [In] Pairing between an instruction address and the
        // language that should be used to decode it.
        // pCondition      : [In] Breakpoint condition to compile.
        // ppCompiledCondition: [Out,Optional] The result of the compilation. This is null in
        // the case that the compilation failed. In this case, ErrorText should indicate the
        // reason for the failure.
        // ppErrorText     : [Out,Optional] If the compilation failed, this indicates the
        // reason why. This value should be null if the compile succeeded. If the compile
        // does fail, S_FALSE is returned (native code only).
        // Return value    : S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is
        // returned when *ppCompiledCondition is NULL, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CompileCondition(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;
    };

    // This interface allows a language extension to provide the ability to evaluate
    // expressions in the various data inspection windows of the debugger (watch, autos,
    // immediate, memory, disassembly, etc). It should generally be implemented by all
    // language extensions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageExpressionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageExpressionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("85b024d7-e6e5-1943-ac3c-9815e754cf8b") IDkmLanguageExpressionEvaluator : public IUnknown
    {
        // Bind the input expression and evaluate it. Then format the resulting value for
        // display in the debugger. This is used for data tips, the watch windows, the
        // immediate window, etc.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pExpression     : [In] DkmLanguageExpression represents an expression to be parsed
        // and evaluated by an expression evaluator.
        // pStackFrame     : [In] Stack frame to evaluate the expression in.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EvaluateExpression(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateExpressionAsyncResult>* pCompletionRoutine
            ) = 0;

        // Gets an enumeration context used to obtain the children of this evaluation result.
        // This is used in all expression evaluation windows.
        // pResult         : [In] The formatted result of an evaluation, ready to be
        // displayed in an expression evaluation window.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // InitialRequestSize: [In] The initial number of children that the caller would like
        // returned. This value can be zero if no children will be initially returned. This
        // value may be larger than the number of children that this expression has, in which
        // case all children should be returned. Very large or negative values should not be
        // used as arrays can have extremely large sizes which would cause out-of-memory if
        // all elements were requested.
        // pInspectionContext: [In] The inspection context to use for computing the children.
        // This may differ from the original inspection context with respect to settings,
        // such as radix, evaluation flags, or timeout.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine
            ) = 0;

        // Gets an enumeration context used to obtain the local variables of this stack
        // frame. This is used in computing the locals window.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pStackFrame     : [In] Stack frame to evaluate the expression in.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFrameLocals(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameLocalsAsyncResult>* pCompletionRoutine
            ) = 0;

        // Provides information on the arguments of a stack frame. This is currently only
        // exposed through the VS automation model (EnvDTE.StackFrame.Arguments).
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pFrame          : [In] Walked frames which the evaluator is requested to describe.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFrameArguments(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameArgumentsAsyncResult>* pCompletionRoutine
            ) = 0;

        // Obtain DkmEvaluationResult items from this enumeration context. This is used to
        // obtain local variables of a stack frame or child members from an evaluation
        // result.
        // pEnumContext    : [In] Context object used to enumerate child members of an
        // evaluation result, or to enumerate local variables from a stack frame. This is
        // logically similar to an enumerator, except that access to elements is index-based
        // rather than sequential.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // StartIndex      : [In] The zero-based index of the first item to obtain.
        // Count           : [In] The number of items to try and return. This value may be
        // larger than the total number of remaining items, in which case all remaining items
        // should be returned. Very large or negative values should not be used as arrays can
        // have extremely large sizes which would cause out-of-memory if all elements were
        // requested.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine
            ) = 0;

        // Modifies the value of the given evaluation result (assumed to be non-read-only) to
        // match the given string. This is used after the user edits a value in any of the
        // evaluation windows.
        // pResult         : [In] The formatted result of an evaluation, ready to be
        // displayed in an expression evaluation window.
        // pValue          : [In] Textual representation of value to assign to the evaluation
        // result.
        // Timeout         : [In] If a function evaluation is needed to assign the value,
        // specifies the timeout to use.
        // ppErrorText     : [Out,Optional] If the operation failed, this indicates the
        // reason why. This value should be null if the operation succeeded. In native code,
        // an S_OK return value is used when returning error text.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        // This method is used for evaluation results that include
        // DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        // enclosing quotes or escape sequences. This is method is invoked to display one of
        // the various string visualizers in an expression evaluation window (click the
        // magnifying glass icon).
        // pResult         : [In] The formatted result of an evaluation, ready to be
        // displayed in an expression evaluation window.
        // ppStringValue   : [Out,Optional] The underlying string value.
        // Return value    : S_OK is returned if *ppStringValue is non-NULL, S_FALSE is
        // returned when *ppStringValue is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

    // This interface allows a language extension to format the display of function names in
    // the call stack window.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageFrameDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageFrameDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9db8c089-484a-a5bb-8677-bacaaf15af1c") IDkmLanguageFrameDecoder : public IUnknown
    {
        // Provides a text representation for a stack frame. This is used when building the
        // formatted call stack.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pFrame          : [In] Walked frames which the evaluator is requested to describe.
        // ArgumentFlags   : [In] Flags to indicate what information about the arguments
        // should be included in the frame name.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFrameName(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmVariableInfoFlags::e ArgumentFlags,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameNameAsyncResult>* pCompletionRoutine
            ) = 0;

        // Provides a text representation of the return type for one or more stack frame.
        // This is currently only exposed through the VS automation model
        // (EnvDTE.StackFrame.ReturnType).
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pFrame          : [In] Walked frames which the evaluator is requested to describe.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFrameReturnType(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameReturnTypeAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // This interface allows a language extension to format the display of the 'Function'
    // column in the breakpoints window, and other places that attempt to format an
    // instruction address.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageInstructionDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageInstructionDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("77e415d7-28b1-a27d-02ec-3b312ead337a") IDkmLanguageInstructionDecoder : public IUnknown
    {
        // Provides a text representation for a method symbol. This is used when describing
        // an address in the UI, for example the 'Function' column in the breakpoints window.
        // pLanguageInstructionAddress: [In] Pairing between an instruction address and the
        // language that should be used to decode it.
        // ArgumentFlags   : [In] Flags to indicate what information about the arguments
        // should be included in the method name.  As parameter values cannot be obtained
        // without a stack frame and a stack frame is not available here, the "Values" flag
        // will never be present.
        // ppMethodName    : [Out] Language's representation of the name of this method.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMethodName(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ Evaluation::DkmVariableInfoFlags::e ArgumentFlags,
            _Deref_out_ DkmString** ppMethodName
            ) = 0;
    };

    // This is an optional interface implemented by expression evaluators. It should be
    // implemented by expression evaluators which return evaluation results with the
    // 'CanHaveObjectId' flag.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageObjectIdProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageObjectIdProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7a0d8562-b453-d19f-45f3-01dfa2f4e77e") IDkmLanguageObjectIdProvider : public IUnknown
    {
        // Creates an object id for this particular expression.
        // pResult         : [In] The formatted result of an evaluation, ready to be
        // displayed in an expression evaluation window.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CreateObjectId(
            _In_ Evaluation::DkmEvaluationResult* pResult
            ) = 0;

        // Destroys an object id for this particular expression.
        // pResult         : [In] The formatted result of an evaluation, ready to be
        // displayed in an expression evaluation window.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DestroyObjectId(
            _In_ Evaluation::DkmEvaluationResult* pResult
            ) = 0;
    };

    // This interface allows a language extension to evaluate return values as collected by a
    // runtime during stepping.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageReturnValueEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageReturnValueEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dfec0557-0e74-2698-da4f-81678ea4834d") IDkmLanguageReturnValueEvaluator : public IUnknown
    {
        // Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        // pInspectionContext: [In] Options and target context to use while performing the
        // inspection operation.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pStackFrame     : [In] Stack frame that provides the context of in which to
        // evaluate the expression.
        // pRawReturnValue : [In] Return value target and cached context.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EvaluateReturnValue(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmRawReturnValue* pRawReturnValue,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateReturnValueAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // This interface allows a language extension to affect the Step-Into behavior of the
    // native runtime.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageStepIntoFilterCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageStepIntoFilterCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a70278a3-f362-06f0-2bf6-a4a57860cfd3") IDkmLanguageStepIntoFilterCallback : public IUnknown
    {
        // Called during a Step-Into to determine special behavior for a particular function.
        // pLanguageInstructionAddress: [In] Pairing between an instruction address and the
        // language that should be used to decode it.
        // pStepIntoFlags  : [Out] Flags which describe how to proceed with a Step-Into
        // action.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetStepIntoFlags(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _Out_ Stepping::DkmLanguageStepIntoFlags::e* pStepIntoFlags
            ) = 0;
    };

    // This interface is implemented by expression evaluators which are loaded on the target
    // computer to map between a function/address expression and the instructions which are
    // represented by it. This is used to bind function breakpoints. In addition to
    // expression evaluators, this interface may also be implemented by other components
    // which may want to bind function breakpoints using data from the target process (ex:
    // native export function breakpoints).
    //
    // Components filtering based on LanguageId and/or VendorId should ensure that Guid.Empty
    // is one of the accepted values in their filter. See
    // DkmRuntimeFunctionResolutionRequest.CompilerId for more information.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId.
    #define IID_IDkmRuntimeFunctionResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeFunctionResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e0ecb64b-afec-5dea-f1c0-9d9d8cc83215") IDkmRuntimeFunctionResolver : public IUnknown
    {
        // Called by the breakpoint manager to add a pending resolve request. Expression
        // evaluators, or other components will immediately try to bind the breakpoint
        // against current modules, and will bind the breakpoint to additional locations as
        // modules load. The caller of this interface should implement
        // IDkmRuntimeFunctionResolverClient to obtain the results of the resolution.
        //
        // Implementations of this interface should stop attempting to bind the breakpoint
        // when the DkmRuntimeFunctionResolutionRequest object is closed.
        // pRuntimeFunctionResolutionRequest: [In] DkmRuntimeFunctionResolutionRequest
        // represents an expression to be parsed and evaluated by a runtime based expression
        // evaluator and is bound to a particular process. Resolutions will send
        // DkmModuleInstance::FunctionResolved events.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnableResolution(
            _In_ FunctionResolution::DkmRuntimeFunctionResolutionRequest* pRuntimeFunctionResolutionRequest,
            _In_ DkmWorkList* pWorkList
            ) = 0;
    };

    // This interface is implemented by symbol based expression evaluators to map between a
    // function/address expression and the instructions which are represented by it. This is
    // used to bind function breakpoints.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SymbolProviderId.
    #define IID_IDkmSymbolFunctionResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolFunctionResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("61ec2e73-6713-54c4-bb59-e20f04313e6d") IDkmSymbolFunctionResolver : public IUnknown
    {
        // Resolve an address string to zero or more address symbols. This is used to bind
        // function breakpoints.
        // pSymbolFunctionResolutionRequest: [In] DkmSymbolFunctionResolutionRequest
        // represents an expression to be parsed and evaluated by a symbol based expression
        // evaluator and is not bound to a particular process. Used to perform function
        // breakpoint binds.
        // pAddresses      : [Out] DkmInstructionSymbol[] represents a method in the target
        // process.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Resolve(
            _In_ FunctionResolution::DkmSymbolFunctionResolutionRequest* pSymbolFunctionResolutionRequest,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pAddresses
            ) = 0;
    };

    // Optional interface to compiles an object visualization data from a human-readable form
    // into a DkmCompiledVisualizationData object.  Currently, this interface is implemented
    // only by C++.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmVisualizationDataCompiler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVisualizationDataCompiler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c1ec72fb-6d26-fcd8-f4bb-8cd516c16110") IDkmVisualizationDataCompiler : public IUnknown
    {
        // Compiles object visualization data from a human-readable form into a
        // DkmCompiledVisualizationData object.
        // pVisualizationDataObject: [In] Represents the results of parsing one or more
        // visualization files.
        // VisualizationFiles: [In] List of full paths, on to the Visual Studio computer,
        // that describe information to be used for object visualization. For C++, each item
        // in the array should be the full path to a .natvis file you wish to use when
        // formatting the results of the expression.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE InitializeVisualizationData(
            _In_ Evaluation::DkmCompiledVisualizationData* pVisualizationDataObject,
            _In_ const DkmArray<DkmString*>& VisualizationFiles
            ) = 0;
    };

}; // end of Expression evaluators interfaces


// Expression evaluator addins interfaces
// Expression evaluator addins are customizations that affect the view of objects in the
// various debugger expression windows. They can affect the value of the object as well
// as expansion scenarios. They must be below the standard expression evaluator component
// level.
namespace ComponentInterfaces
{
    // This interface is implemented by custom expression evaluator visualizers in order to
    // customize the view of an expression programmatically. This is normally done to support
    // visualizations that are not possible using the native visualizer syntax or to enable
    // visualization without full symbolic information. The visualizer can take complete
    // control of the expression including expansion of children, or it can obtain the
    // default expression from the expression evaluator, modify it slightly but defer other
    // operations such as expansion back to the EE.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId, SourceId, VisualizerId.
    #define IID_IDkmCustomVisualizer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomVisualizer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f00e7f6d-fc66-d9a9-e3e5-83b32a0a9755") IDkmCustomVisualizer : public IUnknown
    {
        // Evaluate a visualized expression returning a DkmEvaluationResult for it.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // ppResultObject  : [Out] Object containing the result of the evaluation. This
        // object must be closed by the caller when the caller is done with the object. The
        // expression evaluator reserves the right to override this instance so do not rely
        // on storing data items in the DkmEvaluationResult instance. Use the
        // DkmVisualizedExpression instance as a data container instead.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EvaluateVisualizedExpression(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            ) = 0;

        // Called by the expression evaluator when a visualized expression's children are
        // being expanded, the the value is being set, or the underlying string is being
        // obtained. If the visualizer addin wants complete control of the expression it
        // should return false. It will then receive calls to GetChildren, GetItems,
        // SetValueAsString, and GetUnderlyingString. If the visualizer addin wants to
        // completely defer these operations to the expression evaluator, it should return
        // true. It must also give the expression evaluator back the instance of
        // DkmEvaluationResult that came from the EE via one of the
        // IDkmCustomVisualizerCallback methods. Note that the addin MUST have obtained the
        // default DkmEvaluationResult from the EE if it wants the EE to control the object.
        // Returning true from this method is primarily used by visualizer addins that just
        // tweak something small like the view of a value but don't want to modify expansion
        // or setting values.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pUseDefaultEvaluationBehavior: [Out] Return true to use default expansion, false
        // otherwise.
        // ppDefaultEvaluationResult: [Out,Optional] The instance of DkmEvaluationResult
        // returned from a call to one of the methods of IDkmCustomVisualizerCallback. The
        // expression evaluator can only control DkmEvaluationResults it understands.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UseDefaultEvaluationBehavior(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _Out_ bool* pUseDefaultEvaluationBehavior,
            _Deref_out_opt_ Evaluation::DkmEvaluationResult** ppDefaultEvaluationResult
            ) = 0;

        // Gets an enumeration context used to obtain the children of this evaluation result.
        // This is used in all expression evaluation windows.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // InitialRequestSize: [In] The initial number of children that the caller would like
        // returned. This value can be zero if no children will be initially returned. This
        // value may be larger than the number of children that this expression has, in which
        // case all children should be returned. Very large or negative values should not be
        // used as arrays can have extremely large sizes which would cause out-of-memory if
        // all elements were requested.
        // pInspectionContext: [In] The inspection context to use for computing the children.
        // This may differ from the original inspection context with respect to settings,
        // such as radix, evaluation flags, or timeout.
        // pInitialChildren: [Out] The initial children to return.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppEnumContext   : [Out] Context object used to enumerate the children. This object
        // must be closed by the caller of this API when enumeration is complete.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            ) = 0;

        // Called to obtain items from a instance of DkmEvaluationResultEnumContext created
        // by an earlier call to GetChildren.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pEnumContext    : [In] The enum context to use for this call. This instance will
        // have been returned from a previous call to DkmVisualizedExpression.
        // StartIndex      : [In] The zero-based index of the first item to obtain.
        // Count           : [In] The number of items to try and return. This value may be
        // larger than the total number of remaining items, in which case all remaining items
        // should be returned. Very large or negative values should not be used as arrays can
        // have extremely large sizes which would cause out-of-memory if all elements were
        // requested.
        // pItems          : [Out] The DkmChildVisualizedExpression items to return.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pItems
            ) = 0;

        // Modifies the value of the given evaluation result (assumed to be non-read-only) to
        // match the given string. This is used after the user edits a value in any of the
        // evaluation windows.
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // pValue          : [In] Textual representation of value to assign to the evaluation
        // result.
        // Timeout         : [In] If a function evaluation is needed to assign the value,
        // specifies the timeout to use.
        // ppErrorText     : [Out,Optional] If the operation failed, this indicates the
        // reason why. This value should be null if the operation succeeded. In native code,
        // an S_OK return value is used when returning error text.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        // This method is used for evaluation results that include
        // DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        // enclosing quotes or escape sequences. This is method is invoked to display one of
        // the various string visualizers in an expression evaluation window (click the
        // magnifying glass icon).
        // pVisualizedExpression: [In] Dispatcher object used for custom visualization
        // through a concord EE addin.
        // ppStringValue   : [Out,Optional] The underlying string value.
        // Return value    : S_OK is returned if *ppStringValue is non-NULL, S_FALSE is
        // returned when *ppStringValue is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

}; // end of Expression evaluator addins interfaces


// Debug monitors (general) interfaces
// Debug monitors provide the basic inspection and execution control services that the
// rest of the debugger stack relies on. These run on the same computer as the target
// process. There are two types of debug monitors - 'Base debug monitors' and 'Runtime
// debug monitors'.
namespace ComponentInterfaces
{
    // This interface contains the API for performing an async-break on the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmAsyncBreak __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncBreak)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d8c04b5c-9fe9-0cc7-1978-09a3b2a95d10") IDkmAsyncBreak : public IUnknown
    {
        // This method will tell the debug monitors to asynchronously break execution of the
        // debuggee process. An AsyncBreakComplete event is sent after the operation is
        // complete.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // StopImmediately : [In] If this is set to true, implementers should immediately
        // enter break rather than trying to find a thread inside the process that is
        // executing code.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE AsyncBreak(
            _In_ DkmProcess* pProcess,
            _In_ bool StopImmediately
            ) = 0;
    };

    // This interface contains the API for writing out a dump file of the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmDumpWriter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDumpWriter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6d079f19-89d7-6468-ca62-de227a3cbc6f") IDkmDumpWriter : public IUnknown
    {
        // This method will write out a memory dump of the process to the path specified.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // DumpType        : [In] The type of dump to write. Either minidump or full-memory
        // minidump.
        // pPath           : [In] The full path to where the minidump should be saved. In
        // remote scenarios, this path is relative to the remote machine.
        // pTargetThread   : [In,Optional] The thread to use for the minidump if there is no
        // current exception.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE WriteDump(
            _In_ DkmProcess* pProcess,
            _In_ DkmDumpType::e DumpType,
            _In_ DkmString* pPath,
            _In_opt_ DkmThread* pTargetThread
            ) = 0;
    };

    // IDkmExceptionController is implemented by runtime debug monitors which fire exception
    // events (DkmExceptionInformation.OnDebugMonitorException()).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionController __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionController)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d90b5b6e-0eb7-e6c3-517d-3c019667f21d") IDkmExceptionController : public IUnknown
    {
        // Determines if processing for this exception may be modified by the debugger. For
        // example, if this user has performed an action (such as set next statement) that
        // required the exception to be implicitly squashed, this may return false. This
        // method may also return false if the runtime does not permit the exception from
        // being squashed.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // pResult         : [Out] True if the debug monitor is able to modify the processing
        // of this exceptions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CanModifyProcessing(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Out_ bool* pResult
            ) = 0;

        // Updates the state of the target process so that when execution is resumed, the
        // target process will not continue standard exception processing (ex: handler
        // search, stack unwinding). This method needs to be called before resuming
        // execution.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SquashProcessing(
            _In_ Exceptions::DkmExceptionInformation* pException
            ) = 0;
    };

    // IDkmExceptionFormatter is implemented by runtime debug monitors which fire exception
    // events. Unlike IDkmExceptionController, there is generally a single implementation of
    // IDkmExceptionFormatter for each exception category. For example, while multiple base
    // debug monitor implementations are able to detect Win32 exceptions, there only needs to
    // be one formatter implementation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionFormatter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionFormatter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b7863c9a-4fa5-5317-abd2-03fcbe66b47e") IDkmExceptionFormatter : public IUnknown
    {
        // Provides a string description for an exception. This is used when tracing the
        // exception to the output window.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // ppValue         : [Out] String description of the exception.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetDescription(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_ DkmString** ppValue
            ) = 0;

        // Provides additional information about an exception which will appear when Visual
        // Studio stops on the exception. For CLR exceptions, this contains the 'Message'
        // property from the System.Exception which was thrown.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // ppValue         : [Out,Optional] String description of the exception. If no other
        // information is available, null is returned.
        // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
        // when *ppValue is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalInformation(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_opt_ DkmString** ppValue
            ) = 0;
    };

    // IDkmExceptionWinRTErrorExtractor is called by the exception manager to extract WinRT
    // enhanced error info from a JavaScript/CLR/C++/etc exception.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionWinRTErrorExtractor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionWinRTErrorExtractor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("42247de7-53e4-d930-c996-5bf208e8148a") IDkmExceptionWinRTErrorExtractor : public IUnknown
    {
        // Provides developer-oriented additional information about the exception.  This info
        // should be displayed along with GetDescription and GetAdditionalInformation to
        // clarify the cause of the error.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // ppRestrictedDescription: [Out,Optional] RestrictedErrorInfo description of the
        // exception. Due to security restrictions, this may not be available even if
        // RestrictedErrorInfo is available for the exception.
        // ppRestrictedErrorReference: [Out,Optional] If present, used to retrieve
        // IRestrictedErrorInfo via the RoResolvedRestrictedErrorInfoReference API.
        // ppRestrictedCapabilitySid: [Out,Optional] If present specifies the missing
        // capability.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetWinRTErrorInfo(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_opt_ DkmString** ppRestrictedDescription,
            _Deref_out_opt_ DkmString** ppRestrictedErrorReference,
            _Deref_out_opt_ DkmString** ppRestrictedCapabilitySid
            ) = 0;
    };

    // Interface to provide access to the runtime function table of a process. A default
    // implementation is provided by Microsoft's Native Debug Monitor which is able to find
    // function tables in loaded Win32 modules and dynamic PData in live processes. This
    // interface may be implemented by base debug monitors to provide runtime function table
    // access for non-live processes (ex: minidumps).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmFunctionTableProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFunctionTableProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f9fcac25-fcbe-18d6-2700-22dddf8a67d3") IDkmFunctionTableProvider : public IUnknown
    {
        // Obtain the function table entry for the passed address. The format of the engine
        // is dependent on the debuggee architecture.
        // pNativeModuleInstance: [In] 'DkmNativeModuleInstance' is used for modules which
        // contain CPU code and/or are loaded by the Win32 loader.
        // Address         : [In] The address to search the function table for. Normally,
        // each entry contains a start and an end address. Implementations should return the
        // entry whose address range contains the requested address.
        // ppEntry         : [Out] The contents of the function table entry.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFunctionTableEntry(
            _In_ Native::DkmNativeModuleInstance* pNativeModuleInstance,
            _In_ UINT64 Address,
            _Deref_out_ DkmReadOnlyCollection<BYTE>** ppEntry
            ) = 0;

        // The method will return the contents of the IMAGE_RUNTIME_FUNCTION_ENTRY for an
        // address if possible. For searching static entries, callers should call the
        // equivalent method on DkmNativeModuleInstance.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The virtual address for which to find a function table
        // entry for.
        // pBaseAddress    : [Out] The base address for the runtime function table entry.
        // ppFunctionTableEntry: [Out,Optional] The runtime function table entry for this
        // address if found.
        // Return value    : S_OK is returned if *ppFunctionTableEntry is non-NULL, S_FALSE
        // is returned when *ppFunctionTableEntry is NULL, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SearchRuntimeFunctionTable(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _Out_ UINT64* pBaseAddress,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppFunctionTableEntry
            ) = 0;
    };

    // Interface implemented by debug monitors to perform any updates when the 'Disabled'
    // property of a module changed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleInstanceDisabledNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleInstanceDisabledNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("62cde81a-01db-8f1e-f96f-fff01a95bbad") IDkmModuleInstanceDisabledNotification : public IUnknown
    {
        // Performs any updates needed when the 'Disabled' state changes.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnDisabledChanged(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;
    };

    // Interface implemented by debug monitors that support debugging dumps to allow the UI
    // to search for binaries that were not found when the dump originally loaded. The symbol
    // path is updated by the UI if the user chooses a path when searching for the binary.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleLocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleLocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ab521d60-90eb-b345-211e-9dc45c22c601") IDkmModuleLocator : public IUnknown
    {
        // Attempt to load a binary that previously failed to load using updated symbol
        // paths.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TryLoadBinary(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;
    };

    // Provides services to set and remove breakpoints. This interface is implemented by the
    // Debug Monitor for most runtimes. The implementation must use a data item to track the
    // lifetime of each enabled DkmRuntimeBreakpoint so that it can implicitly disable the
    // breakpoint when the DkmRuntimeBreakpoint is closed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmRuntimeMonitorBreakpointHandler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeMonitorBreakpointHandler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("595931ad-c79f-4bd4-06a5-5ca93b3c16f2") IDkmRuntimeMonitorBreakpointHandler : public IUnknown
    {
        // Enables a breakpoint. Breakpoints start off initially disabled, so this method
        // must be called before the breakpoint can be set. Enabling a breakpoint is
        // typically implemented in the debug monitor by modifying the state of the target
        // process. For example inserting an 'int3' instruction into the code stream. If the
        // breakpoint is already enabled, this operation has no effect.
        //
        // Once a breakpoint has been enabled, the debug monitor will raise a
        // RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger
        // condition (ex: target instruction is executed) is met. Multiple
        // DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug
        // monitor will raise a different RuntimeBreakpoint event for each breakpoint object.
        // Similarly, if a step complete and a breakpoint both complete on the same
        // instruction, the debug monitor will raise both events.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        // breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        // not currently loaded in the specified script document.
        virtual HRESULT STDMETHODCALLTYPE EnableRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        // Determines if the given DkmRuntimeBreakpoint could be enabled. This is used from
        // within the breakpoints dialog to validate breakpoints before the dialog is closed.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        // breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        // not currently loaded in the specified script document.
        virtual HRESULT STDMETHODCALLTYPE TestRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        // Disables a breakpoint. Disabling a breakpoint is typically implemented by
        // modifying the state of the target process so the breakpoint will no longer fire.
        // For example, removing a previously inserted 'int3' from the instruction stream. If
        // the breakpoint is already disabled, this operation has no effect. In addition to
        // this method, a breakpoint is implicitly disabled when it is closed.
        //
        // If multiple breakpoints are set on the same instruction, disabling one breakpoint
        // does not affect the other breakpoints set on this instruction.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DisableRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;
    };

}; // end of Debug monitors (general) interfaces


// Base debug monitors interfaces
// There is a single base debug monitor for every debugged process. The base debug
// monitor is responsible for providing the lowest-level inspection and execution control
// primitives such as native-instruction breakpoints, memory and register reads and
// writes, etc.
namespace ComponentInterfaces
{
    // Interface implemented by base debug monitors to allow resuming the process for a
    // function evaluation. This interface contains the basic services utilized by
    // 'ExecuteFuncEval'. Setup, cleanup, timeout handling, exception handling and completion
    // detection are all handled by the higher-level debug monitors.
    //
    // This interface is not provided for CLR v2 debugging.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmBaseFuncEvalService __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBaseFuncEvalService)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e7884271-5fb5-5eef-8dfc-948d12bd0c6f") IDkmBaseFuncEvalService : public IUnknown
    {
        // This method is used to resume the target process so that a function evaluation may
        // occur. This function is called by a runtime debug monitor after it has setup a
        // function evaluation in order to make the target process run. The runtime monitor
        // will first update the thread context, update any necessary memory in the target
        // process, and setup any detection that the function evaluation is completed.
        //
        // Callers of this method MUST always call EndFuncEvalExecution before returning from
        // the operation that triggered the function evaluation. The behavior is undefined if
        // a caller fails to do so.
        //
        // This method is implemented in the base debug monitor by first updating the target
        // process to be in function evaluation mode (DkmThread.OnBeginFuncEvalExecution),
        // then suspending and/or resuming threads as specified by the function evaluation
        // flags and finally continuing the target process.
        //
        // This method may be called from any thread, however OnBeginFuncEvalExecution must
        // be called from the stopping event thread, so the base debug monitor may need to
        // perform as thread switch as part of the implementation of this method. The base
        // debug monitor should not return from BeginFuncEvalExecution until after the target
        // has been resumed.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Flags           : [In] Flags impacting how function evaluation requests are
        // performed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE BeginFuncEvalExecution(
            _In_ DkmThread* pThread,
            _In_ Evaluation::DkmFuncEvalFlags::e Flags
            ) = 0;
    };

    // IDkmBaseNativeExecutionController is implemented by base debug monitors which support
    // setting native breakpoints or single stepping over native instructions. It provides
    // the advanced execution control primitives needed for CLR debugging.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmBaseNativeExecutionController __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBaseNativeExecutionController)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6eb3c780-c70d-1e67-98cf-9baf7b524b65") IDkmBaseNativeExecutionController : public IUnknown
    {
        // API which may be called from a IDkmSingleStepCompleteReceived or
        // IDkmRuntimeBreakpointReceived implementation to force the base DM to fire the
        // EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP exception in the target process when
        // execution is resumed. Normally, the breakpoint or single step exception is
        // implicitly suppressed. This allows the EXCEPTION_BREAKPOINT/EXCEPTION_SINGLE_STEP
        // to be handled by exception handlers within the target process. This API will fail
        // if the thread is not currently sitting at a step complete or breakpoint event.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ExceptionCode   : [In] Win32 exception code to raise. Currently, this must be
        // EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE RaiseExecutionControlException(
            _In_ DkmThread* pThread,
            _In_ UINT32 ExceptionCode
            ) = 0;
    };

    // This interface contains the API for resuming execution after the engine has sent a
    // stopping event to the Visual Studio debugger package. This interface should only be
    // implemented by Base Debug Monitor components. Unlike nearly all other interfaces, one
    // implementation of this interface may not chain to another implementation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmContinueExecution __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmContinueExecution)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0f1ef515-340e-e38b-8db8-46ea677d90ec") IDkmContinueExecution : public IUnknown
    {
        // This method is provided by base debug monitors to resume execution of the target
        // process. This interface is always triggered by a request to resume the process by
        // the Visual Studio Debugger UI/SDM. Concord components cannot resume the target
        // process once a stopping event has been sent to the UI/SDM.
        //
        // Base debug monitors implement this by calling from the request thread onto the
        // stopping event thread. On the stopping event thread, the base debug monitor calls
        // DkmThread.OnContinueExecution and then modifies the target process so that it will
        // resume. After the target is running, the base debug monitor signals the request
        // thread so that ContinueExecution will return.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ContinueExecution(
            _In_ DkmThread* pThread
            ) = 0;
    };

    // Gets the extended registers from the thread context.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmExtendedRegisters __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExtendedRegisters)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ce482f7d-9401-eaa9-3ad8-f6fd122a04f1") IDkmExtendedRegisters : public IUnknown
    {
        // Gets the extended registers from the thread context.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pExtendedRegisters: [Out] An array of extended registers.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetExtendedRegisters(
            _In_ DkmThread* pThread,
            _Out_ DkmArray<CallStack::DkmUnwoundRegister*>* pExtendedRegisters
            ) = 0;

        // Sets the value of the extended register in the thread's context.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // RegisterIndex   : [In] The CV constant of the register to set. For AVX, this can
        // be any of the YMM register enumeration codes. The caller is expected to set the
        // full YMM register (including the portions which are aliased on XMM registers).
        // pValue          : [In] The value to set the register to. The size of the byte
        // array must match the width of the register being set.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetExtendedRegisterValue(
            _In_ DkmThread* pThread,
            _In_ CV_HREG_e RegisterIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValue
            ) = 0;
    };

    // Interface implemented by base debug monitors to provide instruction-level stepping
    // primitives. This interface is consumed by runtime debug monitors to implement
    // user-level execution control.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmInstructionStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5c9a47d2-e4b8-b620-0fa0-d18f0b973e2b") IDkmInstructionStepper : public IUnknown
    {
        // Enable single step on a thread. When then single step completes, the
        // SingleStepComplete event should be sent. The single step should reset after
        // completion.  Implementers should send one single step complete event per instance
        // of DkmSingleStepRequest they receive. Callers must make a new request to
        // single-step after this DkmSingleStepRequest is complete.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnableSingleStep(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest
            ) = 0;

        // Disable single step on a thread.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearSingleStep(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest
            ) = 0;
    };

    // Interface to support managed func-eval quick abort.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmManagedFuncEvalQuickAbortServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedFuncEvalQuickAbortServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d83ff0da-6a34-8517-3a57-1bc6c0d38435") IDkmManagedFuncEvalQuickAbortServices : public IUnknown
    {
        // Checks to see if we should load the FEQA DLL.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pSkipLoad       : [Out] Specifies if the FEQA DLL should be loaded. The hosting
        // process could have loaded it already.
        // pMemoryAddress  : [Out] Specifies the address in debuggee process. Valid only if
        // AlreadyLoaded is false.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE PrepareForFuncEvalQuickAbort(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _Out_ bool* pSkipLoad,
            _Out_ UINT64* pMemoryAddress
            ) = 0;

        // Notifies the result of the attempt to load the FEQA DLL.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Result          : [In] Specifies if the FEQA DLL was successfully loaded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnFuncEvalQuickAbortDllLoaded(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ bool Result
            ) = 0;
    };

    // Implemented by base debug monitors to provide access to the memory of the target
    // process. This interface is also implemented by higher level components to provide
    // memory caching. Base debug monitors are responsible for performing the memory I/O,
    // maintaining a table of invisible writes, and providing events when the invisible write
    // table is updated (via DkmProcess.OnInstructionPatchInserted/Removed).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmMemoryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMemoryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7ad9578e-2685-b96c-8f49-0d6147e9a8f8") IDkmMemoryOperation : public IUnknown
    {
        // Read the memory of the target process.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to read the target process's
        // memory.
        // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        // pBuffer         : [In,Out] A buffer that receives the contents from the address
        // space of the target process. On failure, the content of this buffer is
        // unspecified.
        // Size            : [In] The number of bytes to be read from the process.
        // pBytesRead      : [Out] Indicates the number of bytes read from the target
        // process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this value
        // will always be exactly equal to the input size. If
        // DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be
        // greater than zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
        // 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
        virtual HRESULT STDMETHODCALLTYPE ReadMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ DkmReadMemoryFlags::e Flags,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            ) = 0;

        // Reads a null-terminated string from the target process process's memory. This can
        // be used to read an ANSI or Unicode (UTF-8, UTF-16 or UTF-32) strings.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to read the target process's
        // memory.
        // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        // CharacterSize   : [In] Number of bytes in each character. This should be set to 1
        // (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).
        // MaxCharacters   : [In] The maximum number of characters to read from the target
        // process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail
        // if a null terminator isn't found within this range. This value should be
        // reasonable. The Microsoft implementation will fail any request for more than
        // 128MBs of string memory.
        // pStringMemory   : [Out] The value of the string which was read from the target
        // process. If DkmReadMemoryFlags.AllowPartialRead is clear, this memory will always
        // include the null termination character. If DkmReadMemoryFlags.AllowPartialRead is
        // specified, this buffer will not contain the null termination character if the read
        // was truncated.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
        // 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
        // E_STRING_TOO_LONG indicates that the string could not be read within the specified
        // maximum number of characters.
        virtual HRESULT STDMETHODCALLTYPE ReadMemoryString(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ DkmReadMemoryFlags::e Flags,
            _In_ UINT16 CharacterSize,
            _In_ UINT32 MaxCharacters,
            _Out_ DkmArray<BYTE>* pStringMemory
            ) = 0;

        // Writes memory to the target process. Before data transfer occurs, the system
        // verifies that all data in the base address and memory of the specified size is
        // accessible for write access, and if it is not accessible, the function raises an
        // E_INVALID_MEMORY_ADDRESS error.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to write the target process's
        // memory.
        // Data            : [In] Data to be written in the address space of the specified
        // process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE WriteMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;

        // Write memory to the target process, but hide the write from calls to ReadMemory.
        // This API may be used to patch instructions or data within the target process to
        // implement debugger features. Before data transfer occurs, the system verifies that
        // all data in the base address and memory of the specified size is accessible for
        // write access, and if it is not accessible, the function raises an
        // E_INVALID_MEMORY_ADDRESS error.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to write the target process's
        // memory.
        // Data            : [In] Data to be written in the address space of the specified
        // process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE InvisibleWriteMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;
    };

    // Interface implemented by base debug monitors to fire a symbols loaded event.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleSymbolsLoaded __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleSymbolsLoaded)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("298f27bb-9a80-c3fe-1582-406a362ac38d") IDkmModuleSymbolsLoaded : public IUnknown
    {
        // After a symbol provided has loaded symbols, this method will be invoked by the
        // dispatcher to cause a ModuleSymbolsLoaded event to be raised. Base debug monitors
        // should implement the interface by transitioning to their event thread and calling
        // DkmModuleInstance.OnSymbolsLoaded.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pModule         : [In] The DkmModule that is associated with the
        // DkmModuleInstance.
        // IsReload        : [In] True if symbols are being reloaded for an existing module,
        // False if this is happening as part of module load processing.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE RaiseSymbolsLoadedEvent(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ Symbols::DkmModule* pModule,
            _In_ bool IsReload
            ) = 0;
    };

    // Optional interface implemented by base debug debug monitors which use the same event
    // thread for multiple processes.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmProcessDebuggerInitializeWaiter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessDebuggerInitializeWaiter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5e2bc414-5920-aa35-8f3e-300d0395cddf") IDkmProcessDebuggerInitializeWaiter : public IUnknown
    {
        // Wait until process debugger becomes initialized.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE WaitForDebuggerInitialize(
            _In_ DkmProcess* pProcess
            ) = 0;

        // Process debugging became initialized.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetDebuggerInitialized(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Queries state about the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessQueryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessQueryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("495f1aa0-59b9-a149-e5ba-c12e29af53f6") IDkmProcessQueryOperation : public IUnknown
    {
        // Obtains the number of active handles in the process.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pHandleCount    : [Out] The number of handles in the debuggee process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetHandleCount(
            _In_ DkmProcess* pProcess,
            _Out_ UINT32* pHandleCount
            ) = 0;

        // Obtains the number of clock cycles that the debuggee has been running since
        // ResetRunningTime() was last called.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pRunningTime    : [Out] The time the debuggee has been running.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetRunningTime(
            _In_ DkmProcess* pProcess,
            _Out_ UINT64* pRunningTime
            ) = 0;

        // Sets the running time counter to the specified value.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // RunningTime     : [In] The value to set the clock to.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetRunningTime(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 RunningTime
            ) = 0;
    };

    // This interface contains the API for launching a new process under the debugger or
    // attaching the debugger to an existing process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmStartDebuggingOperations __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStartDebuggingOperations)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f0114593-949f-0b85-0693-33feed681031") IDkmStartDebuggingOperations : public IUnknown
    {
        // Causes the debug monitor to attach to the process. Before this method returns, the
        // debug monitor must start an event thread (or reuse an existing event thread) and
        // create the DkmProcess object on the event thread. Creating the DkmProcess object
        // will send a process create event.
        //
        // Note that this method may only be called in response to the Visual Studio debugger
        // package requesting an attach. Components that wish to attach to another process
        // should send a custom event to a visual studio package. From a package, an attach
        // can be requested through the IVsDebugger.LaunchDebugTargets API.
        // pRequest        : [In] DkmProcessAttachRequest is used to describe the process
        // that debugger should attach to.
        // ppProcess       : [Out] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_ATTACH_USER_CANCELED indicates that the attach to process operation was
        // canceled. Returning this error will suppress most error messages. So it can be
        // used in combination with DkmUserMessage.Post or DkmCustomMessage.SendToVsService
        // as a way of providing custom failure messages to the user.
        virtual HRESULT STDMETHODCALLTYPE AttachToProcess(
            _In_ Start::DkmProcessAttachRequest* pRequest,
            _Deref_out_ DkmProcess** ppProcess
            ) = 0;

        // Causes the debug monitor to create a new process under the debugger. The process
        // should be left suspended until ResumeDebuggedProcess is called. The debug monitor
        // must wait for ResumeDebuggedProcess before creating the DkmProcess object since it
        // needs the UniqueProcessId value from the AD7 Layer.
        //
        // Note that this method may only be called in response to the Visual Studio debugger
        // package requesting a launch. Components that wish to launch another process under
        // the debugger should send a custom event to a visual studio package. From a
        // package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.
        // pRequest        : [In] DkmProcessLaunchRequest is used to describe the process
        // that debugger should launch.
        // pLaunchedProcess: [Out] DkmLaunchedProcessInfo is returned from APIs that launch a
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE LaunchDebuggedProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest,
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            ) = 0;

        // Causes the debug monitor to resume a launched process and create the DkmProcess
        // object. The DkmProcess object will be created on the event thread and creating the
        // object will send a process create event.
        //
        // Note that this method may only be called in response to the Visual Studio debugger
        // package requesting a launch. Components that wish to launch another process under
        // the debugger should send a custom event to a visual studio package. From a
        // package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.
        // pRequest        : [In] DkmProcessLaunchRequest is used to describe the process
        // that debugger should launch.
        // UniqueProcessId : [In] Value to assign to the 'DkmProcess.UniqueId' field. This
        // Guid is generated by the port, and is used to uniquely identifies the process
        // object.
        // ppProcess       : [Out] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ResumeDebuggedProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest,
            _In_ const GUID& UniqueProcessId,
            _Deref_out_ DkmProcess** ppProcess
            ) = 0;
    };

    // This interface contains the API for stop debugging. These interface must be
    // implemented by base debug monitors. It is also possible to implement this interface in
    // order to customize the stop debugging experience for a particular application. For
    // example, a component could re-implement Terminate so that the debugger would
    // gracefully shutdown the application instead of using the TerminateProcess Win32 API.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmStopDebuggingOperations __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStopDebuggingOperations)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2e628601-1628-28fe-8b2e-524974efd213") IDkmStopDebuggingOperations : public IUnknown
    {
        // This method is called to tell the monitor to detach from the target process. This
        // will trigger a ProcessExit event to be sent on the event thread.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Detach(
            _In_ DkmProcess* pProcess
            ) = 0;

        // This method is called to tell the monitor to terminate the target process. This
        // will trigger a ProcessExit event to be sent on the event thread.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // ExitCode        : [In] The exit code to be used by the process and threads
        // terminated as a result of this call. Use the GetExitCodeProcess function to
        // retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a
        // thread's exit value.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Terminate(
            _In_ DkmProcess* pProcess,
            _In_ UINT32 ExitCode
            ) = 0;
    };

    // Operations provided by a base debug monitor to obtain and update a thread's context
    // (register values).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadContextOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadContextOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0b3dd722-7b1c-4a40-e96a-22dbdcd870e2") IDkmThreadContextOperation : public IUnknown
    {
        // Update the context (register values) of a thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Context         : [In] A CONTEXT structure that contains the context to be set in
        // the specified thread. The value of the ContextFlags member of this structure
        // specifies which portions of a thread's context to set. Some values in the CONTEXT
        // structure that cannot be specified are silently set to the correct value. This
        // includes bits in the CPU status register that specify the privileged processor
        // mode, global enabling bits in the debugging register, and other states that must
        // be controlled by the operating system.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetContext(
            _In_ DkmThread* pThread,
            _In_ const DkmArray<BYTE>& Context
            ) = 0;

        // Obtain the current context (register values) of a thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ContextFlags    : [In] Win32 flags indicating which portion of the CONTEXT object
        // to obtain (ex: CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).
        // pContext        : [In,Out] A Win32 CONTEXT structure that contains the context of
        // the specified thread. The value of the ContextFlags member of this structure
        // specifies which portions of a thread's context to obtained.
        // ContextSize     : [In] Size of the context structure to read in bytes. This must
        // exactly match the size required to read the context.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetContext(
            _In_ DkmThread* pThread,
            _In_ UINT32 ContextFlags,
            _Out_capcount_(ContextSize) void* pContext,
            _In_ UINT32 ContextSize
            ) = 0;
    };

    // Called to suspend or resume a thread and to obtain the current thread suspension
    // count.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadSuspension __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadSuspension)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("015aaf9b-9342-09b8-7873-980d89ff2ecc") IDkmThreadSuspension : public IUnknown
    {
        // Suspend this thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // InternalSuspension: [In] Pass true if this suspension should be hidden in calls to
        // GetSuspensionCount. This is useful for internal suspensions that should not be
        // reported to the user such as thread slippage suspensions.
        // pExternalSuspensionCount: [Out,Optional] The previous number of suspensions for
        // this thread minus the ones internal to the debugger.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Suspend(
            _In_ DkmThread* pThread,
            _In_ bool InternalSuspension,
            _Out_ UINT32* pExternalSuspensionCount
            ) = 0;

        // Resume this thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // InternalSuspension: [In] Pass true if this suspension should be hidden in calls to
        // GetSuspensionCount. This is useful for internal suspensions that should not be
        // reported to the user such as thread slippage suspensions.
        // pExternalSuspensionCount: [Out,Optional] The previous number of suspensions for
        // this thread minus the ones internal to the debugger before this resume is applied.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Resume(
            _In_ DkmThread* pThread,
            _In_ bool InternalSuspension,
            _Out_ UINT32* pExternalSuspensionCount
            ) = 0;

        // Return the current suspension count of this thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ShowInternal    : [In] Pass true to return the true suspension count for the
        // thread. Return false to only see the suspensions that occurred in the debuggee
        // process or the one's that passed true for InternalSuspension to Suspend.
        // pSuspensionCount: [Out] The suspension count of thread. The internal thread
        // suspension count is subtracted from this value if ShowInternal is false.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSuspensionCount(
            _In_ DkmThread* pThread,
            _In_ bool ShowInternal,
            _Out_ UINT32* pSuspensionCount
            ) = 0;

        // Return the total number of suspensions caused by the debugger (i.e. calls to
        // DkmThread::Suspend without a call to DkmThread::Resume). This excludes any
        // suspensions external to the debugger.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pSuspensionCount: [Out] The total number of suspensions caused by the debugger
        // (i.e. calls to DkmThread::Suspend without a call to DkmThread::Resume). This
        // excludes any suspensions external to the debugger.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetDebuggerSuspensionCount(
            _In_ DkmThread* pThread,
            _Out_ UINT32* pSuspensionCount
            ) = 0;
    };

    // Implemented by base debug monitors to allow allocation/free of virtual memory in the
    // target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmVirtualMemoryAllocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVirtualMemoryAllocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5668629d-1253-d9a2-0cb1-7b77009092d8") IDkmVirtualMemoryAllocator : public IUnknown
    {
        // Reserves and/or commits a region of memory within the virtual address space of the
        // target process. The function initializes the memory it allocates to zero, unless
        // MEM_RESET is used. For additional information, see the VirtualAlloc Win32 API in
        // MSDN.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] Address within the target process where the memory should
        // be committed or reserved. This value is typically zero, in which case the system
        // chooses an address.
        // Size            : [In] The size of the region of memory to allocate, in bytes. The
        // system will automatically round up to the next page boundary.
        // AllocationType  : [In] Indicates the type of allocation to perform. This is
        // typically MEM_COMMIT | MEM_RESERVE (0x3000) which reserves and commits an
        // allocation in one step.
        // PageProtection  : [In] The memory protection for the region of pages to be
        // allocated. If the pages are being committed, you can specify any one of the memory
        // protection constants (ex: PAGE_READWRITE, PAGE_EXECUTE).
        // pAllocatedAddress: [Out] Base address of the allocated region of pages.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE AllocateVirtualMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ UINT32 Size,
            _In_ UINT32 AllocationType,
            _In_ UINT32 PageProtection,
            _Out_ UINT64* pAllocatedAddress
            ) = 0;

        // Releases and/or decommits a region of memory within the virtual address space of
        // the target process. For additional information, see the VirtualFree Win32 API in
        // MSDN.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] Address within the target process where the memory should
        // be freed.
        // Size            : [In] Number of bytes to decommit. To release a region of memory,
        // this value must be zero.
        // FreeType        : [In] Indicates the type of free operation to perform. This is
        // typically MEM_RELEASE (0x8000), which releases the specified region of pages.
        // After the operation, the pages are in the free state. MEM_DECOMMIT (0x4000) can be
        // used instead to decommit the pages without releasing them.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE FreeVirtualMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ UINT32 Size,
            _In_ UINT32 FreeType
            ) = 0;
    };

    // Provides support for reading and writing memory. Unlike IDkmMemoryOperation, this
    // Interface can be used when the process is running, and it will never cache results, so
    // it should be used with care.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmVolatileMemoryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVolatileMemoryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d91f2e1d-6f19-6bf5-f7bd-dc29585d6601") IDkmVolatileMemoryOperation : public IUnknown
    {
        // Read memory from the target process. This method differs from 'ReadMemory' in that
        // this method can be called at any time (not just when the target is stopped) and
        // the debugger will not try to cache the result of this operation.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to read the target process's
        // memory.
        // pBuffer         : [In,Out] A buffer that receives the contents from the address
        // space of the target process. On failure, the content of this buffer is
        // unspecified.
        // Size            : [In] The number of bytes to be read from the process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request
        // could not be read.
        virtual HRESULT STDMETHODCALLTYPE VolatileReadMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size
            ) = 0;

        // Write to the memory of the target process. This method differs from 'WriteMemory'
        // in that this method can be called at any time (not just when the target is
        // stopped) and the debugger will not try to cache the result of this operation. If
        // any memory cannot be written to, an E_INVALID_MEMORY_ADDRESS error will be raised.
        // Because the memory write may occur from run mode, this failure may happen after
        // the copy operation has already begun, and thus may lead to memory corruption in
        // the target process. For this reason, this function must be used with care, and
        // failures may be fatal.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to write the target process's
        // memory.
        // Data            : [In] Data to be written in the address space of the specified
        // process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE VolatileWriteMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;
    };

    // Exposes volatile properties of a thread such as priority and affinity mask. These
    // values are expected to change over time and should not be cached by callers.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmVolatileThreadProperties __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVolatileThreadProperties)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7af2ed97-ad57-169d-9694-9acf19c5018b") IDkmVolatileThreadProperties : public IUnknown
    {
        // Get a thread's dynamic properties.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pPriority       : [Out] The priority of the thread. The values returned correspond
        // directly to the values defined for kernel32!GetThreadPriority.
        // pAffinityMask   : [Out] The affinity mask of the thread. The values returned
        // correspond directly to the values defined for kernel32!SetThreadAffinityMask.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetVolatileProperties(
            _In_ DkmThread* pThread,
            _Out_ INT32* pPriority,
            _Out_ UINT64* pAffinityMask
            ) = 0;

        // Get volatile flags about a thread. For instance, return if a thread is a user-mode
        // scheduled thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pFlags          : [Out] Volatile flags that apply to a thread. These values are
        // expected to change over time and should not be cached by callers.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetVolatileFlags(
            _In_ DkmThread* pThread,
            _Out_ ThreadProperties::DkmVolatileThreadFlags::e* pFlags
            ) = 0;
    };

}; // end of Base debug monitors interfaces


// Runtime debug monitors interfaces
// A runtime debug monitor is capable of inspecting and modifying a runtime environment
// in the target process in order to assist in execution control or data inspection. For
// example, Microsoft provides the Managed Debug Monitor component to interact with the
// .NET Framework Virtual Machine (VM), and it provides the Native Debug Monitor to
// interact with the Visual C++ Runtime (CRT) and to interact with code compiled with the
// Visual C++ compiler (or similar compilers and/or CRTs). There may be more than one
// Runtime debug monitor inspecting the target process.
//
// See also: IDkmRuntimeBreakpointNotification, IDkmRuntimeBreakpointReceived,
// IDkmThreadExitNotification
namespace ComponentInterfaces
{
    // IDkmBinaryLoadedNotification is implemented by components that want to listen for the
    // BinaryLoaded event. When this notification fires, the target process will be suspended
    // and can be examined. Indicates that we have successfully loaded the binary of a module
    // in the minidump we are debugging.
    //
    // BinaryLoaded events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmBinaryLoadedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryLoadedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ce3cbe07-9bc9-1a7a-7ee9-f2a975521222") IDkmBinaryLoadedNotification : public IUnknown
    {
        // OnBinaryLoaded is invoked as part of event processing. See interface definition
        // for more information.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pPath           : [In] The full path, relative to the computer running Visual
        // Studio to open the minidump, of the matching binary we were able to find.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBinaryLoaded(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmString* pPath,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmClrDebugMonitorExceptionCaughtNotification is implemented by components that want
    // to listen for the ClrDebugMonitorExceptionCaught event. When this notification fires,
    // the target process will be suspended and can be examined. The
    // 'ClrDebugMonitorExceptionCaught' event provides notification from the Managed Debug
    // Monitor about a caught exception which occurred within the target process.  This event
    // is consumed by Diagnostic tools like IntelliTrace to be logged in their
    // TraceDebugger.\n.
    //
    // ClrDebugMonitorExceptionCaught events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrDebugMonitorExceptionCaughtNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrDebugMonitorExceptionCaughtNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6623b5f1-9b1b-1c2f-3c01-7b760550d12b") IDkmClrDebugMonitorExceptionCaughtNotification : public IUnknown
    {
        // OnClrDebugMonitorExceptionCaught is invoked as part of event processing. See
        // interface definition for more information.
        // pClrCaughtException: [In] Provides information about an exception which was caught
        // in the target process. This information includes details of the exception that was
        // caught.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnClrDebugMonitorExceptionCaught(
            _In_ Clr::DkmClrCaughtExceptionInformation* pClrCaughtException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Interface for resolving types from strings into method id's or type id's.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrTypeResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrTypeResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("369aef0a-8d41-9914-4d66-bb9444ba059d") IDkmClrTypeResolver : public IUnknown
    {
        // Resolves a method name belonging to a given class into a DkmClrMethodId.
        // pClrType        : [In] Represents a managed type.
        // pMethodName     : [In] The name of the method.
        // pParameterTypes : [In,Optional] Optional array of parameter types.
        // pResult         : [Out] A DkmClrMethodId describing the method.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ResolveMethodName(
            _In_ Clr::DkmClrType* pClrType,
            _In_ DkmString* pMethodName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pParameterTypes,
            _Out_ Clr::DkmClrMethodId* pResult
            ) = 0;

        // Resolves a type name into a type.  If the type is generic, the generic parameters
        // will not be instantiated.
        // pClrModuleInstance: [In] 'DkmClrModuleInstance' is used for modules which are
        // loaded into the Common Language Runtime.
        // pTypeName       : [In] The name of the type.
        // pGenericParameters: [In,Optional] If the type is generic, specifies the generic
        // parameters for the type.
        // ppResult        : [Out] A DkmClrType describing the type.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ResolveTypeName(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _In_ DkmString* pTypeName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericParameters,
            _Deref_out_ Clr::DkmClrType** ppResult
            ) = 0;
    };

    // Provides execution of compiled inspection queries.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompiledInspectionQueryKind, EngineId, RuntimeId.
    #define IID_IDkmCompiledInspectionQueryProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCompiledInspectionQueryProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d8e2fa09-8d12-0e6a-c15e-4dc0968bcbf4") IDkmCompiledInspectionQueryProcessor : public IUnknown
    {
        // Executes a compiled inspection query and returns any results.
        // pQuery          : [In] Represents a query which is produced by an expression
        // evaluator or similar component and set to the target computer to obtain
        // information about the dynamic state of the program (ex: the current value of a
        // register).
        // pParameters     : [In,Optional] Optional array of parameter values to pass to the
        // IL stream.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // Timeout         : [In] This is the timeout to be used for potentially slow
        // operations such as a function evaluation. This value is in milliseconds.
        // FuncEvalFlags   : [In] Flags impacting how function evaluation requests are
        // performed.
        // pResults        : [Out] Results of the evaluations. Each ILEvaluationResult object
        // contains an index that indicates which DkmILInstruction in the instructions
        // parameter this result came from. NOTE: some instructions will not return a result.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pFailureReason  : [Out] If an expected error occurs evaluating the DkmIL,
        // indicates the reason for the failure.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ExecuteQuery(
            _In_ Evaluation::DkmCompiledInspectionQuery* pQuery,
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason::e* pFailureReason
            ) = 0;
    };

    // IDkmDebugMonitorExceptionNotification is implemented by components that want to listen
    // for the DebugMonitorException event. When this notification fires, the target process
    // will be suspended and can be examined. The 'DebugMonitorException' event provides
    // notification from debug monitors about exceptions which occur within the target
    // process. This event notification is consumed by the exception manager, and by debug
    // monitors operating at component levels above the debug monitor which detected the
    // exception. Higher level components should use exception triggers instead. See
    // DkmExceptionTrigger for more information.
    //
    // If the exception is sent unhandled (DkmExceptionProcessingStage.Unhandled is set) then
    // the IDE will stop. Other exceptions may stop depending on any DkmExceptionTriggers set
    // by the AD7 AL or other components. The AD7 AL reads the default set of triggers from
    // %VSRegistryRoot%\AD7Metrics\Exception\%CategoryGuid%\*.
    //
    // DebugMonitorException events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmDebugMonitorExceptionNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDebugMonitorExceptionNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c919aea0-537d-2b9d-9369-e607b9632523") IDkmDebugMonitorExceptionNotification : public IUnknown
    {
        // OnDebugMonitorException is invoked as part of event processing. See interface
        // definition for more information.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnDebugMonitorException(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmExceptionContinuedNotification is implemented by components that want to listen
    // for the ExceptionContinued event. When this notification fires, the target process
    // will be suspended and can be examined. ExceptionContinued is sent by a debug monitor
    // when execution is resumed in the target process and the given exception has not been
    // squashed. In other words, the target process will continue with its standard exception
    // processing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionContinuedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionContinuedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0bd32e9f-3116-f724-fd7d-e197ffceac9d") IDkmExceptionContinuedNotification : public IUnknown
    {
        // OnExceptionContinued is invoked as part of event processing. See interface
        // definition for more information.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnExceptionContinued(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // This interface is implemented by debug monitors that provide support for unwinding
    // exceptions to a specific frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmFrameExceptionInterceptProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFrameExceptionInterceptProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1e02530a-7d51-4f8f-601a-63cc4d34748c") IDkmFrameExceptionInterceptProvider : public IUnknown
    {
        // InterceptCurrentException is used to unwind to this frame as if there was an
        // exception handler at that frame.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // InterceptAction : [In] Specifies exception interception actions.
        // pCookie         : [Out] Cookie that represents this intercept request. The value
        // is returned when an exception interception completed event is sent.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE InterceptCurrentException(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Exceptions::DkmExceptionInterceptActionFlags::e InterceptAction,
            _Out_ UINT64* pCookie
            ) = 0;

        // Returns the address that represents the location if an exception were to be
        // intercepted to this frame.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // ppNewAddress    : [Out] Possible new address if an exception was unwound to this
        // frame.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetUnwindAddress(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _Deref_out_ DkmInstructionAddress** ppNewAddress
            ) = 0;
    };

    // IDkmGPUSingleStepCompleteNotification is implemented by components that want to listen
    // for the GPUSingleStepComplete event. IDkmGPUSingleStepCompleteNotification is invoked
    // after all implementations of IDkmGPUSingleStepCompleteReceived. When this notification
    // is called, the target process is stopped and implementers are able to either inspect
    // the process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent when single stepping a GPU thread is complete. The event can be fired by a
    // different thread from the request thread in the same warp.
    //
    // GPUSingleStepComplete events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmGPUSingleStepCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSingleStepCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("95954fd6-9dd4-f461-8907-6e34a1085cf4") IDkmGPUSingleStepCompleteNotification : public IUnknown
    {
        // OnGPUSingleStepComplete is invoked as part of event processing. See interface
        // definition for more information.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnGPUSingleStepComplete(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmGPUSingleStepCompleteReceived is implemented by components that want to listen for
    // the GPUSingleStepComplete event. IDkmGPUSingleStepCompleteReceived is invoked before
    // IDkmGPUSingleStepCompleteNotification. From within this notification, it is not
    // possible to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent when single stepping a GPU thread is complete. The event can be fired by a
    // different thread from the request thread in the same warp.
    //
    // GPUSingleStepComplete events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmGPUSingleStepCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSingleStepCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1b7fa450-5329-7b50-c04b-775791576b79") IDkmGPUSingleStepCompleteReceived : public IUnknown
    {
        // OnGPUSingleStepCompleteReceived is invoked as part of event processing. See
        // interface definition for more information.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnGPUSingleStepCompleteReceived(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Used to execute compiled group expression processing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompiledInspectionQueryKind, EngineId, RuntimeId.
    #define IID_IDkmGroupCompiledInspectionQueryProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGroupCompiledInspectionQueryProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("946b64d3-390e-ce97-026e-1b6d86075bc9") IDkmGroupCompiledInspectionQueryProcessor : public IUnknown
    {
        // Executes a compiled inspection query and returns any results.
        // pDkmILQuery     : [In] An inspection query compiled to one or more DkmIL
        // instructions.
        // pILContext      : [In] The stack frame context we are evaluating on.
        // pThreads        : [In] The compute threads to use when executing the query.
        // pParameters     : [In,Optional] Parameters to pass to each thread.  The collection
        // should be empty if unused, or have exactly as many members as the Threads
        // parameter.
        // ppResult        : [Out] Results of the evaluations.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ExecuteQueryOnThreads(
            _In_ Evaluation::IL::DkmCompiledILInspectionQuery* pDkmILQuery,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_opt_ DkmReadOnlyCollection<Evaluation::Group::DkmILParameterValueCollection*>* pParameters,
            _Deref_out_ Evaluation::Group::DkmContextGroupEvaluationILResult** ppResult
            ) = 0;
    };

    // Interface for interpreting IL.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmILInterpreter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmILInterpreter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("be7346a5-7bff-ab79-dd9e-ebfac2644677") IDkmILInterpreter : public IUnknown
    {
        // Simulates the execution of a method on an object by interpreting the method's MSIL
        // code. The result of the method will be returned back to the caller.  However,
        // unlike a function evaluation, in which the method is actually running in the
        // target, interpreting a method does not actually execute the method, but instead,
        // merely simulates the behavior of the method.  Because the method never actually
        // executes, any side effects resulting from the method's execution are discarded
        // after the interpretation of the method is complete, leaving the target process in
        // an identical state to that from before the call.
        // pClrModuleInstance: [In] 'DkmClrModuleInstance' is used for modules which are
        // loaded into the Common Language Runtime.
        // Method          : [In] The method to be interpreted.  This function does not
        // support interpreting certain types of methods, including, but not limited to: -
        // Methods that consume ref or out parameters - Methods whose implementation calls
        // into native code via P/Invoke, COM interop, or some other means.
        // pGenericTypeParameters: [In,Optional] If the method belongs to a generic class,
        // specifies the instantiations of the type's generic parameters.
        // pGenericMethodParameters: [In,Optional] If the method is generic, specifies the
        // instantiations of the method's generic parameters.
        // pThisParameter  : [In,Optional] If the method to be interpreted is non-static,
        // specifies the non-null object instance that the method should be called on. If the
        // method to be interpreted is a class constructor, this can be either null or
        // non-null.  A null this parameter on a class constructor will cause us to virtually
        // create a new object and interpret the constructor. A non-null this parameter to a
        // constructor will cause us to interpret the call to the constructor on the existing
        // object.
        // pParameters     : [In,Optional] Parameters to be passed into the function,
        // excluding the 'this' parameter.  This may be null if the function to be
        // interpreted takes no parameters. If the function takes parameters, the length of
        // this array must be equal to the number of parameters specified in the method
        // signature.
        // MaxInstructionCount: [In] The maximum number of total IL instructions that we are
        // allowed to interpret.  The IL interpretation will be aborted with an error code of
        // E_ABORT if the actual number of instructions exceeds this limit.  This limit
        // prevents Visual Studio from hanging if the code being interpreted enters an
        // infinite loop.
        // Options         : [In] Additional options for the IL interpreter.
        // ppReturnValue   : [Out,Optional] The return value of the method.  This will be
        // null if the method returns void or throws an exception.
        // ppExceptionType : [Out,Optional] If the method throws an unhandled exception, the
        // type of the exception that got thrown.
        // Return value    : S_OK is returned if *ppReturnValue is non-NULL, S_FALSE is
        // returned when *ppReturnValue is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE InterpretManagedMethod(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _In_ const Clr::DkmClrMethodId& Method,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericTypeParameters,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericMethodParameters,
            _In_opt_ Clr::DkmILInterpreterValue* pThisParameter,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmILInterpreterValue*>* pParameters,
            _In_ UINT32 MaxInstructionCount,
            _In_ Clr::DkmILInterpreterOptions::e Options,
            _Deref_out_opt_ Clr::DkmILInterpreterValue** ppReturnValue,
            _Deref_out_opt_ DkmString** ppExceptionType
            ) = 0;
    };

    // Interface to provide runtime-specific CPU address resolution. This could be
    // implemented either on server or client side (e.g. CLR native compilation).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmInstructionAddressResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionAddressResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b071902e-dc75-5b4c-4db1-f0d4a7c5ac61") IDkmInstructionAddressResolver : public IUnknown
    {
        // Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress
        // object.
        //
        // This API is currently only supported by CLR DkmRuntimeInstance objects, and the
        // CLR runtime instance can currently only find instruction addresses which are in a
        // method that is currently on the call stack of one of the threads in the target
        // process.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // InstructionPointer: [In] Memory address where the native instruction is located.
        // ppAddressObject : [Out] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // pFirstAddress   : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ResolveCPUInstructionAddress(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 InstructionPointer,
            _Deref_out_ DkmInstructionAddress** ppAddressObject,
            _Out_ bool* pFirstAddress
            ) = 0;

        // Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse
        // mapping of ResolveCPUInstructionAddress. This API is currently only supported by
        // CLR DkmRuntimeInstance objects.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // pInstructionPointers: [Out] An array of the current CPU Instruction Addresses that
        // map to this DkmInstructionAddress.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCPUAddress(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _Out_ DkmArray<UINT64>* pInstructionPointers
            ) = 0;
    };

    // Interface to determine if a particular location is user code.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmJustMyCodeProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmJustMyCodeProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f24e7455-e56c-dc04-c886-7bb8c741d16a") IDkmJustMyCodeProvider : public IUnknown
    {
        // Determines if a given instruction address is user code or not.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsUserCode(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Symbols::DkmIsUserCodeAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Examines the portion of the stack which is from a particular DkmRuntimeInstance and
    // returns frames from this runtime. IDkmMonitorStackWalk is used to do this walking on
    // the target computer, and generally does this walk without symbols. It should be noted
    // that accurate monitor stack walk generally requires either: 1. The runtime monitor to
    // fully understand the calling convention of its underlying runtime AND the runtime
    // employs some mechanism so that it doesn't need code from other runtimes which are on
    // the stack to be walked. For example, the CLR maintains stack ranges so when managed
    // code calls off into native, the CLR can still find the managed code without needing to
    // walk through native. -or- 2. A uniform calling convention that all code needs to
    // follow. For example, all code must follow a uniform calling convention on x64 and
    // IA-64 versions of Windows. Microsoft will provide five implementations of
    // IDkmMonitorStackWalk: 1. An implementation for ICorDebug v2 2. An implementation for
    // ICorDebug v4 3. An implementation for x64/ia64 PDATA walking. 4. An implementation for
    // ActiveScript. 5. A default implementation that bundles together unknown regions to be
    // walked in the engine process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmMonitorStackWalk __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMonitorStackWalk)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3229efcc-f591-3f24-3639-70f0a90c9b00") IDkmMonitorStackWalk : public IUnknown
    {
        // Initialize is invoked on each walker exactly once at the beginning of the walk
        // process. This gives each walker a chance to initialize any state.
        // pMonitorStackWalkContext: [In] DkmMonitorStackWalkContext allows the various
        // components DkmSymbolStackWalkContext with this call stack.
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmMonitorStackWalkContext* pMonitorStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            ) = 0;

        // UpdatePosition is invoked by the stack merger after another walker has walked one
        // or more frames, and so this walker must be updated before invoking WalkNextFrame.
        // Runtimes that maintain their own internal stack range state within in the target
        // process will likely have nothing to do within this method.
        // pMonitorStackWalkContext: [In] DkmMonitorStackWalkContext allows the various
        // components DkmSymbolStackWalkContext with this call stack.
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmMonitorStackWalkContext* pMonitorStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            ) = 0;

        // Attempt to walk the next stack frame. The DkmMonitorStackWalkResult structure
        // indicates if this monitor was able to walk the frame.
        // pMonitorStackWalkContext: [In] DkmMonitorStackWalkContext allows the various
        // components DkmSymbolStackWalkContext with this call stack.
        // pResult         : [Out] Return result from IDkmMonitorStackWalk.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _In_ CallStack::DkmMonitorStackWalkContext* pMonitorStackWalkContext,
            _Out_ CallStack::DkmMonitorStackWalkResult* pResult
            ) = 0;
    };

    // Called by Native IDkmSteppingCodePathDecoder implementer to enumerate Native
    // CodePaths.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmNativeSteppingCallSiteProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeSteppingCallSiteProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("42c82633-168e-4fa4-cb32-d81e42526c44") IDkmNativeSteppingCallSiteProvider : public IUnknown
    {
        // GetSteppingCallSites is called to get call sites reachable from an instruction.
        // pNativeAddress  : [In] DkmNativeInstructionAddress is used for addresses that
        // resolve to within a native module. This is used regardless as to if there are
        // symbols for the module.
        // SteppingRanges  : [In] The stepping ranges to evaluate for call sites.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pCallSites      : [Out] DkmNativeSteppingCallSite[] specifies a call instruction
        // and it's target..
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSteppingCallSites(
            _In_ Native::DkmNativeInstructionAddress* pNativeAddress,
            _In_ const DkmArray<Symbols::DkmSteppingRange>& SteppingRanges,
            _Out_ DkmArray<Stepping::DkmNativeSteppingCallSite*>* pCallSites
            ) = 0;
    };

    // IDkmOutOfBandExceptionNotification is implemented by components that want to listen
    // for the OutOfBandException event. When this notification fires, the target process
    // will be suspended and can be examined. The 'OutOfBandException' event provides
    // notification from debug monitors about out-of-band exceptions which occur within the
    // target process while managed/native interop debugging.  This event notification is
    // consumed by the exception manager. Out-of-band events can occur at any time (including
    // when stopped) and must be continued immediately.
    //
    // OutOfBandException events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmOutOfBandExceptionNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmOutOfBandExceptionNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("90e4575e-1442-b444-115c-ba831c02395e") IDkmOutOfBandExceptionNotification : public IUnknown
    {
        // OnOutOfBandException is invoked as part of event processing. See interface
        // definition for more information.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnOutOfBandException(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Optional interface which can be implemented to customize the environment of the target
    // process before it is started. It is possible to customize the environment from two
    // points. From the IDE side, the caller of LaunchDebugTargets may specify an environment
    // block. From the debug monitor side, this API can be implemented. This API is suggested
    // if either the IDE side doesn't have enough information to correctly specify the
    // environment, or if the extension doesn't control the call to LaunchDebugTargets.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId.
    #define IID_IDkmProcessLaunchEnvironmentFilter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessLaunchEnvironmentFilter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bdfa8fd2-093d-3d18-14a6-1fe13b432740") IDkmProcessLaunchEnvironmentFilter : public IUnknown
    {
        // Obtains any environment variables which the extension would like to add.
        // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
        // from a project system or other caller of LaunchDebugTargets (or various other
        // start debugging APIs).
        // Scenario        : [In] Enumeration of the scenarios where
        // IDkmProcessLaunchEnvironmentFilter implementations are invoked.
        // ppAdditionalEnvironmentBlock: [Out,Optional] One or more environment variables
        // which should be passed to the target process. Multiple variables are separated
        // with an embedded null ('\0'). For example: "MyVariable1=1\0MyVariable2=12".
        //
        // Null or empty string are returned if the caller doesn't want to customize the
        // environment block for this launch.
        // Return value    : S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL,
        // S_FALSE is returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes
        // are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalEnvironmentVariables(
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario::e Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            ) = 0;
    };

    // Provides the ability to read or write a register value by CV constant.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRegisterWrite __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRegisterWrite)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6c77ba81-0bd4-b09b-375d-ceffe69b48c0") IDkmRegisterWrite : public IUnknown
    {
        // Sets the value of the register in the thread's context. Sub registers that are
        // made up of larger registers are supported.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStackWalkFrame : [In] The stack frame the register is being set in. For most
        // runtime instances, this is used to verify the stack frame is the top of the stack
        // and stop the write if it isn't.
        // RegisterIndex   : [In] The CV constant of the register to set.
        // pValue          : [In] The value to set the register to. The size of the byte
        // array must match the width of the register being set.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetRegisterValue(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ CallStack::DkmStackWalkFrame* pStackWalkFrame,
            _In_ CV_HREG_e RegisterIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValue
            ) = 0;
    };

    // IDkmRuntimeSetNextStatement is the interface runtime monitors implement to support set
    // next statement.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmRuntimeSetNextStatement __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeSetNextStatement)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("19f373d3-f684-891d-0239-1ae39bca8bac") IDkmRuntimeSetNextStatement : public IUnknown
    {
        // SetNextStatement moves the IP of a stack frame. The stack frame is always the leaf
        // stack frame on a particular thread.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // pNewStatement   : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetNextStatement(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ DkmInstructionAddress* pNewStatement
            ) = 0;
    };

    // IDkmRuntimeStepper is the interface runtime monitors implement to support stepping.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9f1c95a5-868c-edaf-c078-17105c5a232a") IDkmRuntimeStepper : public IUnknown
    {
        // BeforeEnableNewStepper is called by the stepping manager before a new stepper is
        // enabled. This gives runtimes the ability to do any initialization that might be
        // required such as performing pre-step function evaluations.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE BeforeEnableNewStepper(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;

        // OwnsCurrentExecutionLocation is called by the stepping manager while it is
        // searching for monitors to perform a step. If the current location in the debuggee
        // is understood by this monitor it can return true here to take control of the step.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pOwnsFrame      : [Out] If the runtime instance wants control of the step, it
        // should set this to true. It should be set to false to not take control.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OwnsCurrentExecutionLocation(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _Out_ bool* pOwnsFrame
            ) = 0;

        // Step is called by the stepping manager after it determines this monitor is the
        // correct monitor to perform the step.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Step(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason
            ) = 0;

        // StopStep is called by the stepping manager when the process is being continued to
        // clear out any remaining stepping state for a stepper.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE StopStep(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;

        // AfterSteppingArbitration is called by the stepping manager on the old controlling
        // runtime instance after stepping arbitration is complete but before the next
        // runtime instance starts stepping. This allows runtimes to clear any stepping state
        // if another runtime took control. If no other runtime monitor claimed the current
        // location, the original monitor should finish the step. This is indicated by
        // NewControllingRuntimeInstance being null. For instance, a runtime instance may
        // choose to step back out if a step-in landed in a location without symbols and no
        // other runtime took control.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pNewControllingRuntimeInstance: [In,Optional] The DkmRuntimeInstance class
        // represents an execution environment which is loaded into a DkmProcess and which
        // contains code to be debugged.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE AfterSteppingArbitration(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_opt_ DkmRuntimeInstance* pNewControllingRuntimeInstance
            ) = 0;

        // OnNewControllingRuntimeInstance is called by the stepping manager on all
        // non-controlling runtime instances after step arbitration has selected a new
        // controlling runtime instance.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pControllingRuntimeInstance: [In] The DkmRuntimeInstance class represents an
        // execution environment which is loaded into a DkmProcess and which contains code to
        // be debugged.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnNewControllingRuntimeInstance(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pControllingRuntimeInstance
            ) = 0;

        // StepControlRequested is called by the stepping manager when a non-controlling
        // runtime instance detects that the thread has hit a transition into its runtime. If
        // the current controlling runtime instance can stop stepping, it should set Granted
        // to true. Actual control is not given until the requesting runtime calls
        // DkmStepper.TakeStepControl. This two part process allows callers to request
        // control of multiple steppers at the same time.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // pGranted        : [Out] The controlling runtime can stop the step and give control
        // to the caller, then it should set this to true.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE StepControlRequested(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
            _Out_ bool* pGranted
            ) = 0;

        // TakeStepControl is called by the stepping manager when a non-controlling runtime
        // instance detects that the thread has hit a transition into its runtime. The
        // stepping manager will forward the call to the current controlling runtime
        // instance. The runtime instance requesting control should first call
        // StepControlRequested on all steppers it wants control of. If they all set Granted
        // to true, the runtime instance should then call this method on each stepper it is
        // taking control of.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // LeaveGuardsInPlace: [In] Set to true by the caller if it would like the current
        // controlling runtime instance to leave guards in place to stop the step if
        // necessary. For instance, this can be used to leave guard breakpoints after a call
        // instruction so another runtime can step back out if the target of the call doesn't
        // have source. However, any stepping state that affects the immediate step, such as
        // trap flags, should be removed by the controlling runtime instance.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TakeStepControl(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool LeaveGuardsInPlace,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            ) = 0;

        // NotifyStepComplete is called by the stepping manager on all non-controlling
        // runtime instances when a step is complete.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NotifyStepComplete(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;
    };

    // IDkmSingleStepCompleteNotification is implemented by components that want to listen
    // for the SingleStepComplete event. IDkmSingleStepCompleteNotification is invoked after
    // all implementations of IDkmSingleStepCompleteReceived. When this notification is
    // called, the target process is stopped and implementers are able to either inspect the
    // process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent when single stepping a thread is complete.
    //
    // SingleStepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmSingleStepCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSingleStepCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a48fdaa3-b501-43cf-a213-81c0ecd593e0") IDkmSingleStepCompleteNotification : public IUnknown
    {
        // OnSingleStepComplete is invoked as part of event processing. See interface
        // definition for more information.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnSingleStepComplete(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmSingleStepCompleteReceived is implemented by components that want to listen for
    // the SingleStepComplete event. IDkmSingleStepCompleteReceived is invoked before
    // IDkmSingleStepCompleteNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent when single stepping a thread is complete.
    //
    // SingleStepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmSingleStepCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSingleStepCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a7aa8f4f-e5cb-45bf-2f66-b8384fd2d2f5") IDkmSingleStepCompleteReceived : public IUnknown
    {
        // OnSingleStepCompleteReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnSingleStepCompleteReceived(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // This interface is implemented by components that contribute stack frames, and wish to
    // provide an additional inspection interface for expression evaluators and other
    // components that need to inspect the stack frame.
    //
    // NOTE: The data container API should not be used from the implementation of the
    // returned custom interface.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmStackWalkFrameInterfaceProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStackWalkFrameInterfaceProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5aef1394-3062-c525-9ae6-f47531631aa3") IDkmStackWalkFrameInterfaceProvider : public IUnknown
    {
        // GetFrameInspectionInterface is used to obtain a ICorDebugFrame or other
        // implementation-specific interfaces which a component can use to deeply inspect the
        // stack frame.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // pSession        : [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // InterfaceID     : [In] The GUID of the desired interface. IID_ICorDebugFrame can
        // be used to obtain the CorDebug frame interface for a managed frame. Other debug
        // monitors or stack walkers may provide their own interface.
        // ppFrameInterface: [Out] Returned frame interface. This may be cast to the
        // interface pointer corresponding to 'InterfaceID'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFrameInspectionInterface(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmInspectionSession* pSession,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppFrameInterface
            ) = 0;
    };

    // This interface is implemented by runtime debug monitors to return the most recent
    // WinRT exception information on the given thread.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmThreadCurrentWinRtExceptionQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadCurrentWinRtExceptionQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d6bd56eb-2905-91a2-3e1c-bcf785d58e2d") IDkmThreadCurrentWinRtExceptionQuery : public IUnknown
    {
        // GetThreadCurrentWinRtErrorInfo is used to get the address of the current
        // IErrorInfo object for this thread.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pWinRTErrorInfo : [Out,Optional] Address of the current IErrorInfo object on this
        // thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetThreadCurrentWinRtErrorInfo(
            _In_ DkmThread* pThread,
            _Out_ UINT64* pWinRTErrorInfo
            ) = 0;
    };

    // Used to determine a thread's category.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmThreadDisplayPropertiesQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadDisplayPropertiesQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("8cf2518b-16e7-d19a-9ed9-16e8eb3ff867") IDkmThreadDisplayPropertiesQuery : public IUnknown
    {
        // Gets the Display Properties of the Thread including the Display Name and Thread
        // Category.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThread         : [In] The Thread.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetThreadDisplayProperties(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Used to determine a thread's name. Does not return the thread's display name.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmThreadNameQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadNameQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("314a1608-cad1-1345-f02b-ca582df587e4") IDkmThreadNameQuery : public IUnknown
    {
        // Compute the name of a thread.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pThread         : [In] The Thread.
        // ppName          : [Out,Optional] The Thread Name.
        // Return value    : S_OK is returned if *ppName is non-NULL, S_FALSE is returned
        // when *ppName is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetThreadName(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _Deref_out_opt_ DkmString** ppName
            ) = 0;
    };

}; // end of Runtime debug monitors interfaces


// Symbol handlers interfaces
// Provides the ability to search for symbol files (ex: PDBs) and retrieve information
// from them. Symbol handlers are typically implemented to support debugging native
// languages.
//
// See also: IDkmModuleInstanceLoadNotification
namespace ComponentInterfaces
{
    // This interface contains methods implemented by the symbol provider to allow debug
    // monitors to search for binaries on symbol servers and local disks. This is required
    // because the symbol server APIs are not thread safe and the symbol provider owns access
    // to them.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmBinaryLocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryLocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("181533cb-6f9a-9f65-6bb1-51631de38cb8") IDkmBinaryLocator : public IUnknown
    {
        // This method will search the local disk and any configured symbol servers for a
        // binary that matches the parameters. The path to this file on the local disk is
        // returned. If the file was on a symbol server, it is downloaded to a cache and the
        // local path is returned.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pApplicationPath: [In] The original path to the exe stored in the minidump.
        // pDumpPath       : [In] The path to the dump file.
        // pOriginalPath   : [In] The original path to the binary stored in the minidump.
        // TimeDateStamp   : [In] The time date stamp of the binary in the time_t format.
        // ImageSize       : [In] The size of the image.
        // ppFoundPath     : [Out,Optional] The path on the local disk of the local (or
        // downloaded) binary.
        // Return value    : S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is
        // returned when *ppFoundPath is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE LocateBinary(
            _In_ DkmProcess* pProcess,
            _In_ DkmString* pApplicationPath,
            _In_ DkmString* pDumpPath,
            _In_ DkmString* pOriginalPath,
            _In_ UINT32 TimeDateStamp,
            _In_ UINT32 ImageSize,
            _Deref_out_opt_ DkmString** ppFoundPath
            ) = 0;
    };

    // Extends binary locator functionality.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmBinaryLocator11a __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryLocator11a)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0848f212-f24f-6c1b-2008-f4e6f81d4a19") IDkmBinaryLocator11a : public IUnknown
    {
        // Called to initiate locating of binaries whose images might not have previously
        // found or attempted to be loaded. This method will search the local disk and any
        // configured symbol servers for a binary that matches the parameters. The path to
        // this file on the local disk is returned. If the file was on a symbol server, it is
        // downloaded to a cache and the local path is returned.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pApplicationPath: [In] The original path to the exe stored in the minidump.
        // pDumpPath       : [In] The path to the dump file.
        // pOriginalPath   : [In] The original path to the binary stored in the minidump.
        // TimeDateStamp   : [In] The time date stamp of the binary in the time_t format.
        // ImageSize       : [In] The size of the image.
        // ppFoundPath     : [Out,Optional] The path on the local disk of the local (or
        // downloaded) binary.
        // Return value    : S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is
        // returned when *ppFoundPath is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE TryLocateBinary(
            _In_ DkmProcess* pProcess,
            _In_ DkmString* pApplicationPath,
            _In_ DkmString* pDumpPath,
            _In_ DkmString* pOriginalPath,
            _In_ UINT32 TimeDateStamp,
            _In_ UINT32 ImageSize,
            _Deref_out_opt_ DkmString** ppFoundPath
            ) = 0;
    };

    // Interface to provide runtime-specific operations for instruction addresses. For native
    // and managed instructions, this service is provided by the symbol provider.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmInstructionAddressOperator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionAddressOperator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ddb4c8fb-b4bd-82b3-c76f-6c9c7d01843c") IDkmInstructionAddressOperator : public IUnknown
    {
        // Compares two instruction addresses and determines if they are within the same
        // function.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // pOther          : [In] An address to compare with this address.
        // pResult         : [Out] True if the two addresses are from the same function.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsInSameFunction(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ DkmInstructionAddress* pOther,
            _Out_ bool* pResult
            ) = 0;
    };

    // Determines if a module is user code or nonuser code.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmModuleUserCodeDeterminer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleUserCodeDeterminer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("172f19fb-cb40-6c11-714a-a2d4f8b58460") IDkmModuleUserCodeDeterminer : public IUnknown
    {
        // Determines if a module is considered user code.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pIsUserCode     : [Out] True if some or all of the module is user code.  False if
        // the entire module is nonuser code.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsUserCode(
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ bool* pIsUserCode
            ) = 0;
    };

    // This API is used to undecorate symbol names. Microsoft provides an implementation of
    // this to undecorate symbol names in PDBs.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmNameUndecorator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNameUndecorator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("25911e14-acc1-2fdc-d9ed-bf8abbe28779") IDkmNameUndecorator : public IUnknown
    {
        // Undecorates a symbol name.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pDecoratedName  : [In] The name to be undecorated.
        // Options         : [In] Options to change the undecorated name. These are specific
        // to the implementation being used. For Microsoft PDB, pass one or more of the
        // values described in the documentation for DbgHelp.dll UnDecorateSymbolName or one
        // of these three extended options: UNDNAME2_STRIP_ILT  0x10000  - to remove the
        // leading ILT from Incremental Linking Thunks UNDNAME2_STRIP_CONST 0x20000 - to
        // remove leading "const" from the front of the string UNDNAME2_STRINGS  0x30000 - to
        // use pooled strings by name.
        // ppUndecoratedName: [Out] The undecorated name.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UndecorateName(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pDecoratedName,
            _In_ UINT32 Options,
            _Deref_out_ DkmString** ppUndecoratedName
            ) = 0;
    };

    // Callback interface which is implemented by the PDB symbol provider for returning
    // information about symbols to the base debug monitor. This interface should generally
    // be implemented on the Visual Studio computer. Debug monitor side implementations may
    // not be called.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmNativeSymbolProviderCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeSymbolProviderCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6d7f18b0-05fb-a8ba-a458-5951c03b5b6f") IDkmNativeSymbolProviderCallback : public IUnknown
    {
        // Returns address information to the native debug monitor.
        // pNativeInstruction: [In] DkmNativeInstructionSymbol represents a native
        // instruction within a module of the target process. DkmNativeInstructionSymbol are
        // 1:1 with the underlying native instructions. So if there are two template
        // instantiations of a method (ex: MyMethod<CString> and MyMethod<int>) if the linker
        // merges the two instantiations into a single function through COMDAT folding then
        // the methods will be identical. If the linker isn't able to merge the two
        // instantiations then both user-level functions will appear as one
        // DkmNativeInstructionSymbol.
        // pInstructionAddress: [In,Optional] Abstract representation of an executable code
        // location (ex: EIP value). If resolved, an Instruction Address will be within a
        // particular module instance. An Instruction Address is always within a particular
        // Runtime Instance.
        // ppMetadata      : [Out,Optional] DkmNativeAddressMetadata represents symbol based
        // metadata about addresses. This includes if the address is a thunk, a prolog, or a
        // trampoline.
        // Return value    : S_OK is returned if *ppMetadata is non-NULL, S_FALSE is returned
        // when *ppMetadata is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetNativeInstructionMetadataCallback(
            _In_ Native::DkmNativeInstructionSymbol* pNativeInstruction,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _Deref_out_opt_ Native::DkmNativeAddressMetadata** ppMetadata
            ) = 0;

        // Return the RVA for an S_PUBLIC32 for a particular name by string.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pPublicName     : [In] The name of the public symbol to lookup.
        // ppAddress       : [Out,Optional] The native instruction symbol for this public
        // symbol.
        // Return value    : S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned
        // when *ppAddress is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetPublicSymbolByNameCallback(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pPublicName,
            _Deref_out_opt_ Native::DkmNativeInstructionSymbol** ppAddress
            ) = 0;
    };

    // Callback interface implemented by script symbol providers in order to support stepping
    // customizations for languages that compile to JavaScript (or possibly other script
    // languages as well).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptSymbolCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptSymbolCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b8dce0a2-be5e-215a-cfd7-ceed6a76870e") IDkmScriptSymbolCallback : public IUnknown
    {
        // Call back implemented by the script symbol provider to tell the script debug
        // monitor what to do next when stepping.
        // pScriptInstruction: [In] DkmScriptInstructionSymbol is used to represent an
        // executable statement in a script-based runtime environment such the Microsoft
        // JavaScript engine.
        // pStartingInstruction: [In,Optional] The instruction symbol of the process at the
        // time this step started. This will be NULL if the step originated on a thread with
        // no frames.
        // IsSteppingByLine: [In] true if the step is by line (instead of by statement).
        // pResult         : [Out] Enum value indicating the next action that the script dm
        // should perform.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. NotImplementedException/E_NOTIMPL indicates that no symbol provider is
        // available for the script symbol.
        virtual HRESULT STDMETHODCALLTYPE GetNextSteppingAction(
            _In_ Script::DkmScriptInstructionSymbol* pScriptInstruction,
            _In_opt_ Script::DkmScriptInstructionSymbol* pStartingInstruction,
            _In_ bool IsSteppingByLine,
            _Out_ Script::DkmScriptSymbolNextSteppingAction::e* pResult
            ) = 0;
    };

    // Allows the UI to query if the current instruction can be set to an address. Must be
    // implemented on the Client side as it can be called in scenarios requiring a fast
    // result such as dragging the IP in the debugger editor.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmSetNextStatementQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSetNextStatementQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1c7c0349-1524-527e-af52-ec49fc35a418") IDkmSetNextStatementQuery : public IUnknown
    {
        // CanSetNextStatement determines if it is possible to move the IP of a stack frame.
        // The stack frame is always the leaf stack frame on a particular thread. This API
        // may only be implemented within the engine process. The Result out parameter should
        // be S_OK or the value of a failed HRESULT that the UI can map to an error message.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // pNewStatement   : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // pResult         : [Out] The error code to return to the UI. This should be S_OK or
        // the value of a failed HRESULT that the UI can map to an error message.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CanSetNextStatement(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ DkmInstructionAddress* pNewStatement,
            _Out_ UINT32* pResult
            ) = 0;
    };

    // This API is used to read information about source server data from a symbol provider.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmSourceServerSymbolQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSourceServerSymbolQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("938cb349-2835-d665-0c30-355e319be5e7") IDkmSourceServerSymbolQuery : public IUnknown
    {
        // Returns the contents of the source server stream data for a module if the stream
        // exists.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pModuleInstance : [In] The module instance for which symbol server data is being
        // requested.
        // pStreamData     : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSourceServerData(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ DkmArray<BYTE>* pStreamData
            ) = 0;
    };

    // Used by AD7 to get step into specific options.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, RuntimeId, SymbolProviderId.
    #define IID_IDkmSteppingCodePathProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingCodePathProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c5ac6ff5-23cc-6c6a-d841-ed27b45289d6") IDkmSteppingCodePathProvider : public IUnknown
    {
        // GetCodePaths is called to get step into specific targets.
        // pSteppingCodePathSource: [In] Object used for filtering for step into specific.
        // pStackFrame     : [In] Specifies the current frame.
        // StepUnit        : [In] Specifies if code paths are for current statement or line.
        // pCodePaths      : [Out] DkmSteppingCodePath[] represents a location that user can
        // step to from current location.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCodePaths(
            _In_ Stepping::DkmSteppingCodePathSource* pSteppingCodePathSource,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Stepping::DkmStepUnit::e StepUnit,
            _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
            ) = 0;
    };

    // This API is used to fetch the compiler id for a given symbol. It is implemented by
    // symbol providers that support symbol stores where the binary may contain multiple
    // languages. In other words, this interface only needs to be implemented when
    // DkmModule.CompilerId is Guid.Empty/Guid.Empty.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolCompilerIdQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolCompilerIdQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("06890e81-01ed-2817-8044-5a60b4206a00") IDkmSymbolCompilerIdQuery : public IUnknown
    {
        // Returns the compiler id (LanguageId/VendorId) of a given symbol. See
        // DkmSymbol.GetCompilerId for a more detailed description.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pCompilerId     : [Out] LanguageId/VendorId for the compiler which produced the
        // code for this symbol. If this is unknown (ex: no symbols info for this block),
        // both values will be Guid.Empty. Otherwise, both values should be non-zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCompilerId(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ Evaluation::DkmCompilerId* pCompilerId
            ) = 0;
    };

    // This API is used to fetch the compiler id for a given symbol. It is implemented by
    // symbol providers that support symbol stores where the binary may contain multiple
    // languages. In other words, this interface only needs to be implemented when
    // DkmModule.CompilerId is Guid.Empty/Guid.Empty.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolCompilerIdQueryCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolCompilerIdQueryCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1d8b5a15-af5d-3e93-0072-dab51a2d2b2a") IDkmSymbolCompilerIdQueryCallback : public IUnknown
    {
        // Returns the compiler id (LanguageId/VendorId) of a given symbol. See
        // DkmSymbol.GetCompilerId for a more detailed description.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pCompilerId     : [Out] LanguageId/VendorId for the compiler which produced the
        // code for this symbol. If this is unknown (ex: no symbols info for this block),
        // both values will be Guid.Empty. Otherwise, both values should be non-zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCompilerIdCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ Evaluation::DkmCompilerId* pCompilerId
            ) = 0;
    };

    // This API is used to resolve symbols in the disassembly window.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolDisassemblyQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolDisassemblyQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("eab7b813-f0fc-2310-a110-1ea17600cae2") IDkmSymbolDisassemblyQuery : public IUnknown
    {
        // Return the name of the symbol as it should appear in the disassembly window. For
        // Microsoft C++ code, this is based on the public symbol name.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // ppLabel         : [Out,Optional] The label to use for this instruction.
        // Return value    : S_OK is returned if *ppLabel is non-NULL, S_FALSE is returned
        // when *ppLabel is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetDisassemblyLabel(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ DkmString** ppLabel
            ) = 0;
    };

    // API implemented by symbol providers to allow the breakpoints manager and other
    // components to query the collection of documents inside of a symbol store.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmSymbolDocumentCollectionQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolDocumentCollectionQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("80df6353-6253-e5ed-1dec-80505da7b92e") IDkmSymbolDocumentCollectionQuery : public IUnknown
    {
        // Returns document objects from search parameters contained in the document query.
        // If the symbol file does not contain a reference to this document the returned
        // document object will be NULL (S_FALSE return code in native). The returned
        // document objects must be explicitly closed by the caller when the caller is done
        // with the document.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pSourceFileId   : [In] Identifies a source file and provides the information which
        // a symbol handler could use to search a symbol file (PDB) for information on this
        // source file.
        // pDocuments      : [Out] A collection of the documents that matched the query.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pDocuments contains any elements, S_FALSE is
        // indicates the array is empty, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE FindDocuments(
            _In_ Symbols::DkmModule* pModule,
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Out_ DkmArray<Symbols::DkmResolvedDocument*>* pDocuments
            ) = 0;
    };

    // API implemented by symbol providers to allow the breakpoints manager and other
    // components to query the 'document text span->symbol' map which is inside a symbol
    // store.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmSymbolDocumentSpanQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolDocumentSpanQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("afcb73f7-9873-5130-b3dd-a9437699fc85") IDkmSymbolDocumentSpanQuery : public IUnknown
    {
        // Finds the symbols within the document which best match the input text span.
        //
        // For IL-based languages, the symbol handler always return the DkmInstructionSymbol
        // for sequence points. It will prefer sequence points which exactly match the text
        // span followed by the sequence point or points which is left-most and which is
        // inside the input span.
        // pResolvedDocument: [In] Object which represents the result of a source file query
        // against a symbol file (PDB). The resolved document object might encapsulate
        // multiple document records with the symbol file. For example, in C++ compilation,
        // each time that a header file is included there is another reference within the
        // PDB. However, there is only one DkmResolvedDocument object for the header file.
        // TextSpan        : [In] The text range (lines/column) to search for.
        // pText           : [In,Optional] The text to search for. When available, this will
        // be provided if ResolvedDocument.TextRequested is set.
        // pInstructionSymbols: [Out] The found instruction symbols which are within the
        // specified text span.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pSymbolLocation : [Out] The source location of each returned instruction symbol.
        // The length of this array should be the same of the returned instruction symbol
        // array.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pInstructionSymbols contains any elements,
        // S_FALSE is indicates the array is empty, and failure codes are used for any error.
        // E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        // specified script document. E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan
        // could not be mapped to a location in the specified script document.
        // E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file
        // loaded by the target process doesn't match the provided Text.
        virtual HRESULT STDMETHODCALLTYPE FindSymbols(
            _In_ Symbols::DkmResolvedDocument* pResolvedDocument,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _In_opt_ DkmString* pText,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pInstructionSymbols,
            _Out_ DkmArray<Symbols::DkmSourcePosition*>* pSymbolLocation
            ) = 0;
    };

    // This API is used to read information about a symbol.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolHiddenAttributeQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolHiddenAttributeQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("24d28567-6961-0144-9f37-1c617e915b57") IDkmSymbolHiddenAttributeQuery : public IUnknown
    {
        // Returns if this instruction symbol is in hidden code. For instance, in managed
        // code, the line number 0xfeefee marks a source line as hidden.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // pInstructionAddress: [In] Abstract representation of an executable code location
        // (ex: EIP value). If resolved, an Instruction Address will be within a particular
        // module instance. An Instruction Address is always within a particular Runtime
        // Instance.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsHiddenCode(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ IDkmCompletionRoutine<Symbols::DkmIsHiddenCodeAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by symbol providers which deal with symbol search. In other
    // words, this interface would not be implemented by symbol providers which deal only
    // with symbol formats which are inside the debugged binary.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId, TransportKind.
    #define IID_IDkmSymbolLocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolLocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3dc0644b-3e46-080a-3fe8-2fdc8695d0c3") IDkmSymbolLocator : public IUnknown
    {
        // Called to initiate loading of symbols for DkmModuleInstances whose symbols were
        // not found when the module loaded.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TryLoadSymbols(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;

        // Returns the path to the symbol file which backs a DkmModule object.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // ppFilePath      : [Out] Full path to the symbol file (ex:
        // c:\myproj\bin\debug\myproj.pdb).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSymbolFilePath(
            _In_ Symbols::DkmModule* pModule,
            _Deref_out_ DkmString** ppFilePath
            ) = 0;

        // Obtain a localized a string description of the current symbol status.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // ExcludeCommonErrors: [In] This value will be true for creating the initial load
        // output message, and false for obtaining the output window text.
        // ppStatus        : [Out] Localized status string (ex: 'Symbols Loaded', 'No symbols
        // loaded', etc.).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSymbolStatusMessage(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ bool ExcludeCommonErrors,
            _Deref_out_ DkmString** ppStatus
            ) = 0;

        // Returns a string describing the various locations in which symbols were searched
        // for, and the result of checking that location. This information is used to
        // populate the 'Symbol Load Information' in the modules window.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // ppDescription   : [Out] String containing information about the symbol search. The
        // typical format is 'location1:result1\r\nlocation2:result2...'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSymbolLoadInformation(
            _In_ DkmModuleInstance* pModuleInstance,
            _Deref_out_ DkmString** ppDescription
            ) = 0;
    };

    // Callback interface which is implemented by symbol providers to provide information
    // from the symbol store to debug monitors.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmSymbolProviderCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolProviderCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ddc27912-0815-d9ed-dfe7-5888a86a4c92") IDkmSymbolProviderCallback : public IUnknown
    {
        // Queries the symbol provider to determine the ranges of instructions which the base
        // debug monitor should step through to implement a step.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // RangeBoundary   : [In] Indicates to the symbol provider the type of instructions
        // to include in the 'no-step' regions.
        // IncludeInline   : [In] True if the symbol provider should stop the stepping range
        // when it encounters an inline functions. False otherwise. The Native DM will pass
        // true for a step in so steps will stop in inline functions. It will pass false when
        // doing a step-over so the stepper will not stop in inline functions.
        // pRanges         : [Out] Array of ranges to step through. This array will be empty
        // if there is no source information for the given instruction.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSteppingRanges(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSteppingRangeBoundary::e RangeBoundary,
            _In_ bool IncludeInline,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            ) = 0;

        // Queries the symbol provider to determine if we have line info. Used by debug
        // monitor to decide if location can be considered user code.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pResult         : [Out] True if there is line info for this location.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE HasLineInfo(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _Out_ bool* pResult
            ) = 0;

        // GetEntryPointSymbols is used by the breakpoint manager to find the entry point
        // symbol(s) in the launching executable. For managed code, this symbol is defined
        // using ISymUnmanagedWriter::SetUserEntryPoint. For native code, this symbol is
        // found by looking for the various 'main' function (main, WinMain, etc). A third can
        // override the entry point either by implementing their own symbol provider or by
        // implementing IDkmEntryPointQuery.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pPossibleEntryPoints: [Out] DkmInstructionSymbol[] represents a method in the
        // target process.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pPossibleEntryPoints contains any elements,
        // S_FALSE is indicates the array is empty, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetEntryPointSymbols(
            _In_ Symbols::DkmModule* pModule,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pPossibleEntryPoints
            ) = 0;

        // This method returns the IL offset range that contains the current IL offset as
        // specified in the instruction address.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pResult         : [Out] A offset/size pair which is returned from the symbol
        // provider to a debug monitor to indicate a range of instructions which the debugger
        // should not stop at.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentStatementRange(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _Out_ Symbols::DkmSteppingRange* pResult
            ) = 0;

        // Search a module's symbols for a function with the specified name. Returns the RVA
        // and size if it is found.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pFunctionName   : [In] The name of the function to search for.
        // pResults        : [Out] The RVA / size pairs from the query.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pFunctionName,
            _Out_ DkmArray<Symbols::DkmRVASizePair>* pResults
            ) = 0;
    };

    // This API is used to read information about a symbol.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmSymbolQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("50279314-b4bf-95de-7ef2-c83f7fe7953e") IDkmSymbolQuery : public IUnknown
    {
        // GetSymbolInterface is used to obtain a raw COM interface to a symbol store. This
        // is useful to either callers that find the symbol abstraction presented by the
        // debugger to be either too restrictive for their needs, or simply undesirable due
        // to how their component is implemented.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // InterfaceID     : [In] The GUID of the desired interface. Microsoft supports
        // IID_IDiaSession for Native DkmModule's, and IID_ISymUnmanagedReader for Managed
        // modules.
        // ppSymbolInterface: [Out] Returned symbol interface. This may be cast to the
        // interface pointer corresponding to 'InterfaceID'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ Symbols::DkmModule* pModule,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppSymbolInterface
            ) = 0;

        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file then null
        // is returned (S_FALSE return code in native).
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // Flags           : [In] Flags which affect the behavior of 'GetSourcePosition'.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pStartOfLine    : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // ppSourcePosition: [Out,Optional] Source code position which corresponds to a code
        // element. The could represent a location which has been extracted from a symbol
        // (PDB) file, or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is
        // returned when *ppSourcePosition is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSourcePositionFlags::e Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // Allows remote components to obtain source position information when the symbol
    // provider is on the VS machine.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolQueryCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolQueryCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("fba8efe6-fd22-340c-3188-6ae79d95c9d7") IDkmSymbolQueryCallback : public IUnknown
    {
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file then null
        // is returned (S_FALSE return code in native).
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // Flags           : [In] Flags which affect the behavior of 'GetSourcePosition'.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // pStartOfLine    : [Out] True if this address is the first address in the line's
        // range. False otherwise.
        // ppSourcePosition: [Out,Optional] Source code position which corresponds to a code
        // element. The could represent a location which has been extracted from a symbol
        // (PDB) file, or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is
        // returned when *ppSourcePosition is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetSourcePositionCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSourcePositionFlags::e Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // Determines if a frame is user or nonuser when such determination was not made when the
    // frame was created.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmUserCodeDeterminer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmUserCodeDeterminer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("73ba8775-e814-4f5b-8581-89f0a3fa7efb") IDkmUserCodeDeterminer : public IUnknown
    {
        // Determines whether or not a frame is user code.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // pInspectionSession: [In,Optional] Optional inspection session which may be used
        // for caching purposes.  The same inspection session is reused when computing the
        // user status of multiple frames in succession.
        // pUser           : [Out] True if the frame is user code, false if the frame is
        // nonuser code.
        // pExceptionImplementation: [Out] True if the frame is library code that implements
        // the throwing of exceptions.  This will cause the frame to be collapsed if we are
        // stopped here in response to an exception being thrown.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ComputeUserStatus(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pUser,
            _Out_ bool* pExceptionImplementation
            ) = 0;
    };

}; // end of Symbol handlers interfaces


// Events interfaces
// These interfaces may be implemented by any component. They provide notification about
// events that occurred in the target process.
namespace ComponentInterfaces
{
    // IDkmAsyncBreakCompleteNotification is implemented by components that want to listen
    // for the AsyncBreakComplete event. IDkmAsyncBreakCompleteNotification is invoked after
    // all implementations of IDkmAsyncBreakCompleteReceived. When this notification is
    // called, the target process is stopped and implementers are able to either inspect the
    // process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent by a debug monitor after a request to async break the process has completed.
    //
    // AsyncBreakComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmAsyncBreakCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncBreakCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("badc52a7-5bc0-82dc-122d-ad6136dd381f") IDkmAsyncBreakCompleteNotification : public IUnknown
    {
        // OnAsyncBreakComplete is invoked as part of event processing. See interface
        // definition for more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Status          : [In] Indicates the type of async-break that occurred.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnAsyncBreakComplete(
            _In_ DkmProcess* pProcess,
            _In_ DkmAsyncBreakStatus::e Status,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmAsyncBreakCompleteReceived is implemented by components that want to listen for
    // the AsyncBreakComplete event. IDkmAsyncBreakCompleteReceived is invoked before
    // IDkmAsyncBreakCompleteNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by a debug monitor after a request to async break the process has completed.
    //
    // AsyncBreakComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmAsyncBreakCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncBreakCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f7956633-ffd0-dab1-5b16-ca5327112b93") IDkmAsyncBreakCompleteReceived : public IUnknown
    {
        // OnAsyncBreakCompleteReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Status          : [In] Indicates the type of async-break that occurred.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnAsyncBreakCompleteReceived(
            _In_ DkmProcess* pProcess,
            _In_ DkmAsyncBreakStatus::e Status,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmComputeKernelExitNotification is implemented by components that want to listen for
    // the ComputeKernelExit event. The target process may continue to run during this
    // notification. The event when a GPU compute kernel completes.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmComputeKernelExitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmComputeKernelExitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("03881c24-d3ab-0fab-93f6-f78ea8491a8e") IDkmComputeKernelExitNotification : public IUnknown
    {
        // OnComputeKernelExit is invoked as part of event processing. See interface
        // definition for more information.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // ExitCode        : [In] 32-bit value that the compute kernel returned on exit.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnComputeKernelExit(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ UINT32 ExitCode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmCustomStopNotification is implemented by components that want to listen for the
    // CustomStop event. IDkmCustomStopNotification is invoked after all implementations of
    // IDkmCustomStopReceived. When this notification is called, the target process is
    // stopped and implementers are able to either inspect the process or cause it to execute
    // in a controlled manner (slip, func-eval).
    //
    // The CustomStop event allows a concord component to raise a stopping event to a custom
    // UI component or to a higher level Concord component.
    //
    // CustomStop events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomStopNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomStopNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9ac75ab7-f351-4583-f4cc-cddbb17b38d0") IDkmCustomStopNotification : public IUnknown
    {
        // OnCustomStop is invoked as part of event processing. See interface definition for
        // more information.
        // pCustomMessage  : [In] Message structure used to pass information between custom
        // debugger backend components and custom visual studio UI components (packages,
        // add-ins, etc).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // VsService       : [In] Visual Studio service that this event should be sent to. A
        // VS package must register this service id (ex:
        // Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package must
        // implement the IVsCustomDebuggerStoppingEventHandler110 interface.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnCustomStop(
            _In_ DkmCustomMessage* pCustomMessage,
            _In_ DkmThread* pThread,
            _In_ const GUID& VsService,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmCustomStopReceived is implemented by components that want to listen for the
    // CustomStop event. IDkmCustomStopReceived is invoked before IDkmCustomStopNotification.
    // From within this notification, it is not possible to cause the target process to
    // execute (no func-eval, no slipping).
    //
    // The CustomStop event allows a concord component to raise a stopping event to a custom
    // UI component or to a higher level Concord component.
    //
    // CustomStop events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomStopReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomStopReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a22ab482-c40e-aae0-a1a0-d1e461a80551") IDkmCustomStopReceived : public IUnknown
    {
        // OnCustomStopReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pCustomMessage  : [In] Message structure used to pass information between custom
        // debugger backend components and custom visual studio UI components (packages,
        // add-ins, etc).
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // VsService       : [In] Visual Studio service that this event should be sent to. A
        // VS package must register this service id (ex:
        // Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package must
        // implement the IVsCustomDebuggerStoppingEventHandler110 interface.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnCustomStopReceived(
            _In_ DkmCustomMessage* pCustomMessage,
            _In_ DkmThread* pThread,
            _In_ const GUID& VsService,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmEmbeddedBreakpointHitNotification is implemented by components that want to listen
    // for the EmbeddedBreakpointHit event. IDkmEmbeddedBreakpointHitNotification is invoked
    // after all implementations of IDkmEmbeddedBreakpointHitReceived. When this notification
    // is called, the target process is stopped and implementers are able to either inspect
    // the process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent by the exception manager when an embedded breakpoint exception is encountered.
    // Components beneath the exception manager must listen for the platform specific
    // exception event instead.
    //
    // EmbeddedBreakpointHit events can be suppressed. If this event reaches the AD7 layer,
    // the debugger will enter break mode.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEmbeddedBreakpointHitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEmbeddedBreakpointHitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0649e942-bb3d-6cf0-44e9-0378b3b2a263") IDkmEmbeddedBreakpointHitNotification : public IUnknown
    {
        // OnEmbeddedBreakpointHit is invoked as part of event processing. See interface
        // definition for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pInstructionAddress: [In,Optional] The address where the embedded breakpoint was
        // hit.
        // ShowAsException : [In] If true, the UI will display an exception hit dialog for a
        // breakpoint exception. If false, UI will simply break and the DkmInstructionAddress
        // is not used.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnEmbeddedBreakpointHit(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ bool ShowAsException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmEmbeddedBreakpointHitReceived is implemented by components that want to listen for
    // the EmbeddedBreakpointHit event. IDkmEmbeddedBreakpointHitReceived is invoked before
    // IDkmEmbeddedBreakpointHitNotification. From within this notification, it is not
    // possible to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by the exception manager when an embedded breakpoint exception is encountered.
    // Components beneath the exception manager must listen for the platform specific
    // exception event instead.
    //
    // EmbeddedBreakpointHit events can be suppressed. If this event reaches the AD7 layer,
    // the debugger will enter break mode.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEmbeddedBreakpointHitReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEmbeddedBreakpointHitReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("498ca3ad-e538-b4b7-5323-657234721f9f") IDkmEmbeddedBreakpointHitReceived : public IUnknown
    {
        // OnEmbeddedBreakpointHitReceived is invoked as part of event processing. See
        // interface definition for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pInstructionAddress: [In,Optional] The address where the embedded breakpoint was
        // hit.
        // ShowAsException : [In] If true, the UI will display an exception hit dialog for a
        // breakpoint exception. If false, UI will simply break and the DkmInstructionAddress
        // is not used.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnEmbeddedBreakpointHitReceived(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ bool ShowAsException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmExceptionTriggerHitNotification is implemented by components that want to listen
    // for the ExceptionTriggerHit event. IDkmExceptionTriggerHitNotification is invoked
    // after all implementations of IDkmExceptionTriggerHitReceived. When this notification
    // is called, the target process is stopped and implementers are able to either inspect
    // the process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // The 'ExceptionTriggerHit' event provides notification that a previously set
    // DkmExceptionTrigger has been met.
    //
    // ExceptionTriggerHit events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmExceptionTriggerHitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionTriggerHitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ee701d2f-eabe-6525-51cf-60578d77548f") IDkmExceptionTriggerHitNotification : public IUnknown
    {
        // OnExceptionTriggerHit is invoked as part of event processing. See interface
        // definition for more information.
        // pHit            : [In] Provides information about an exception trigger which was
        // satisfied (hit) by an exception coming from the target process.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnExceptionTriggerHit(
            _In_ Exceptions::DkmExceptionTriggerHit* pHit,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmExceptionTriggerHitReceived is implemented by components that want to listen for
    // the ExceptionTriggerHit event. IDkmExceptionTriggerHitReceived is invoked before
    // IDkmExceptionTriggerHitNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // The 'ExceptionTriggerHit' event provides notification that a previously set
    // DkmExceptionTrigger has been met.
    //
    // ExceptionTriggerHit events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmExceptionTriggerHitReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionTriggerHitReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b999d394-289b-6845-52ee-c742f756690e") IDkmExceptionTriggerHitReceived : public IUnknown
    {
        // OnExceptionTriggerHitReceived is invoked as part of event processing. See
        // interface definition for more information.
        // pHit            : [In] Provides information about an exception trigger which was
        // satisfied (hit) by an exception coming from the target process.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnExceptionTriggerHitReceived(
            _In_ Exceptions::DkmExceptionTriggerHit* pHit,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmFuncEvalCompletedNotification is implemented by components that want to listen for
    // the FuncEvalCompleted event. The target process may continue to run during this
    // notification. The FuncEvalCompleted event is sent after a function evaluation has
    // completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmFuncEvalCompletedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFuncEvalCompletedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("fdda405d-d47d-5f7f-0dc0-e0de4550160d") IDkmFuncEvalCompletedNotification : public IUnknown
    {
        // OnFuncEvalCompleted is invoked as part of event processing. See interface
        // definition for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Flags           : [In] Flags impacting how function evaluation requests are
        // performed.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnFuncEvalCompleted(
            _In_ DkmThread* pThread,
            _In_ Evaluation::DkmFuncEvalFlags::e Flags,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmFuncEvalStartingNotification is implemented by components that want to listen for
    // the FuncEvalStarting event. The target process may continue to run during this
    // notification. The FuncEvalStarting event is sent just before a function evaluation is
    // started. In the case of nested break state, each new function evaluation will trigger
    // another FuncEvalStarting event. In this scenario, the target stops, and a user
    // performs an evaluation from the immediate window which triggers a FuncEvalStarting
    // event. The user hits a breakpoint within their evaluated function, the user does a
    // second evaluation from there which triggers a second FuncEvalStarting event. The user
    // lets both evaluations complete and this triggers two FuncEvalCompleted events.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmFuncEvalStartingNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFuncEvalStartingNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bace2c45-da04-b755-9a20-56dbf143d5ca") IDkmFuncEvalStartingNotification : public IUnknown
    {
        // OnFuncEvalStarting is invoked as part of event processing. See interface
        // definition for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Flags           : [In] Flags impacting how function evaluation requests are
        // performed.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnFuncEvalStarting(
            _In_ DkmThread* pThread,
            _In_ Evaluation::DkmFuncEvalFlags::e Flags,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmInterceptExceptionCompletedNotification is implemented by components that want to
    // listen for the InterceptExceptionCompleted event.
    // IDkmInterceptExceptionCompletedNotification is invoked after all implementations of
    // IDkmInterceptExceptionCompletedReceived. When this notification is called, the target
    // process is stopped and implementers are able to either inspect the process or cause it
    // to execute in a controlled manner (slip, func-eval).
    //
    // Sent by a debug monitor after an exception has been unwound to a specified frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInterceptExceptionCompletedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInterceptExceptionCompletedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("563d7656-69cb-a569-1ffd-32c3c6947c7c") IDkmInterceptExceptionCompletedNotification : public IUnknown
    {
        // OnInterceptExceptionCompleted is invoked as part of event processing. See
        // interface definition for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Cookie          : [In] Cookie that was handed out when intercept exception request
        // came in.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnInterceptExceptionCompleted(
            _In_ DkmThread* pThread,
            _In_ UINT64 Cookie,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmInterceptExceptionCompletedReceived is implemented by components that want to
    // listen for the InterceptExceptionCompleted event.
    // IDkmInterceptExceptionCompletedReceived is invoked before
    // IDkmInterceptExceptionCompletedNotification. From within this notification, it is not
    // possible to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by a debug monitor after an exception has been unwound to a specified frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInterceptExceptionCompletedReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInterceptExceptionCompletedReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("be0d2a66-c172-f03c-5ac5-019034714c90") IDkmInterceptExceptionCompletedReceived : public IUnknown
    {
        // OnInterceptExceptionCompletedReceived is invoked as part of event processing. See
        // interface definition for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Cookie          : [In] Cookie that was handed out when intercept exception request
        // came in.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnInterceptExceptionCompletedReceived(
            _In_ DkmThread* pThread,
            _In_ UINT64 Cookie,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmLoadCompleteNotification is implemented by components that want to listen for the
    // LoadComplete event. When this notification fires, the target process will be suspended
    // and can be examined. LoadComplete is sent by the base debug monitor when launching or
    // attaching to the process has completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmLoadCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLoadCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("cdc5ec64-65bf-7daa-c591-da0b1f4174d9") IDkmLoadCompleteNotification : public IUnknown
    {
        // OnLoadComplete is invoked as part of event processing. See interface definition
        // for more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnLoadComplete(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleCreateNotification is implemented by components that want to listen for the
    // ModuleCreate event. The target process may continue to run during this notification.
    // ModuleCreate is sent when a symbol provider loads a new symbols, and thus a new
    // DkmModule is created. A DkmModule will exist only for module instances that have
    // symbols.
    //
    // ModuleCreate events can be suppressed. In this case the module will be invisible to
    // components above the level where the module was suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("81e5403b-0fb0-24fe-c2ed-0cafff8b2da2") IDkmModuleCreateNotification : public IUnknown
    {
        // OnModuleCreate is invoked as part of event processing. See interface definition
        // for more information.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnModuleCreate(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleInstanceLoadNotification is implemented by components that want to listen
    // for the ModuleInstanceLoad event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleInstanceLoad is fired when a module is
    // loaded by a target process. Among other things, this event is used for symbol
    // providers to load symbols, and for the breakpoint manager to set breakpoints.
    // ModuleInstanceLoad fires for all modules, even if there are no symbols loaded.
    //
    // ModuleInstanceLoad events can be suppressed. In this case the module will be invisible
    // to components above the level where the module was suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleInstanceLoadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleInstanceLoadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dce74a01-7d98-358b-4a2a-71f0f2ab7af4") IDkmModuleInstanceLoadNotification : public IUnknown
    {
        // OnModuleInstanceLoad is invoked as part of event processing. See interface
        // definition for more information.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnModuleInstanceLoad(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleInstanceUnloadNotification is implemented by components that want to listen
    // for the ModuleInstanceUnload event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleInstanceUnload is sent when the monitor
    // detects that a module has unloaded from within the target process.
    //
    // ModuleInstanceUnload events cannot be suppressed. However, if the ModuleLoad event was
    // suppressed then ModuleUnload will stop processing at the level where ModuleLoad was
    // suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleInstanceUnloadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleInstanceUnloadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a77edc8e-82c8-7718-a67b-3fa2b8a33d71") IDkmModuleInstanceUnloadNotification : public IUnknown
    {
        // OnModuleInstanceUnload is invoked as part of event processing. See interface
        // definition for more information.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnModuleInstanceUnload(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleSymbolsLoadedNotification is implemented by components that want to listen
    // for the ModuleSymbolsLoaded event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleSymbolsLoaded is sent after symbols have
    // been loaded for a particular module instance. This is sent either when symbols are
    // loaded as a dll/exe loads in the target process, or after the user asks to reload
    // symbols.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleSymbolsLoadedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleSymbolsLoadedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("942ad74e-dc07-38e9-b86e-1ba99fed3c41") IDkmModuleSymbolsLoadedNotification : public IUnknown
    {
        // OnModuleSymbolsLoaded is invoked as part of event processing. See interface
        // definition for more information.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // IsReload        : [In] True if symbols are being reloaded for an existing module,
        // False if this is happening as part of module load processing.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnModuleSymbolsLoaded(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ Symbols::DkmModule* pModule,
            _In_ bool IsReload,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleSymbolsUpdatedNotification is implemented by components that want to listen
    // for the ModuleSymbolsUpdated event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleSymbolsUpdated is sent by a debug monitor
    // when dynamic code in the target process updates the symbol state.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleSymbolsUpdatedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleSymbolsUpdatedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9671534b-ebb8-64d9-c606-fdb7b3a04e79") IDkmModuleSymbolsUpdatedNotification : public IUnknown
    {
        // OnModuleSymbolsUpdated is invoked as part of event processing. See interface
        // definition for more information.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnModuleSymbolsUpdated(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Provides notification when the target process is about to be resumed from an out of
    // band debug event while doing managed-native interop debugging on the in-process
    // pipeline.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmOutOfBandProcessContinueNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmOutOfBandProcessContinueNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("aec025cc-2c92-6d39-6383-a5c503642c82") IDkmOutOfBandProcessContinueNotification : public IUnknown
    {
        // Handler which is notified before the target process is resumed.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OutOfBandProcessContinue(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Provides notification when the target process is about to be resumed. This will be
    // fired after the user hits F5, begins a func-eval, a pausing event is complete (ex:
    // module load) or a stopping event is complete. This primary purpose of this event is to
    // allow components to flush any caches that they have.
    //
    // This notification may be fired from any thread, but will not be fired reentrantly.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessContinueNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessContinueNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("4dd3cc9c-a9f7-31f7-375d-2f456ac4c58a") IDkmProcessContinueNotification : public IUnknown
    {
        // Handler which is notified before the target process is resumed.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnProcessContinue(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // IDkmProcessCreateNotification is implemented by components that want to listen for the
    // ProcessCreate event. When this notification fires, the target process will be
    // suspended and can be examined. ProcessCreate is fired when a DkmProcess object is
    // created. This indicates that the debugger has started attaching to the specified
    // process. In launch scenarios, this event is fired before any code in the target
    // process is allowed to run.
    //
    // Implementations can only crudely filter based on the type of code in the target
    // process, and handlers also will run while the UI thread is blocked waiting for the
    // engine to return. For these reasons, is is often better to listen for the
    // RuntimeInstanceLoad event instead.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d09408cf-0131-19ee-164d-b2662fe572f9") IDkmProcessCreateNotification : public IUnknown
    {
        // OnProcessCreate is invoked as part of event processing. See interface definition
        // for more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnProcessCreate(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmProcessExitNotification is implemented by components that want to listen for the
    // ProcessExit event. The target process may continue to run during this notification.
    // ProcessExit is fired when the debugger is no longer debugging the specified process.
    // This can either be because the debugger has detached from the specified process or
    // because the process exited.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessExitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessExitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6fc11c87-c334-9299-2d50-cc03af307830") IDkmProcessExitNotification : public IUnknown
    {
        // OnProcessExit is invoked as part of event processing. See interface definition for
        // more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // ExitCode        : [In] 32-bit value which the processed returned on exit. This is
        // the same value that would be reported from the kernel32!GetExitCodeProcess.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnProcessExit(
            _In_ DkmProcess* pProcess,
            _In_ UINT32 ExitCode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeBreakpointNotification is implemented by components that want to listen for
    // the RuntimeBreakpoint event. IDkmRuntimeBreakpointNotification is invoked after all
    // implementations of IDkmRuntimeBreakpointReceived. When this notification is called,
    // the target process is stopped and implementers are able to either inspect the process
    // or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Provides notification that a runtime breakpoint (DkmRuntimeBreakpoint) has been hit.
    // Runtime breakpoints are the low-level breakpoint objects. Notification for the higher
    // level breakpoints (DkmPendingBreakpoint/DkmBoundBreakpoint) is obtained through the
    // BoundBreakpointHit event.
    //
    // RuntimeBreakpoint events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmRuntimeBreakpointNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeBreakpointNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("73b53ed1-ebc4-01d4-ea32-367b3ec69995") IDkmRuntimeBreakpointNotification : public IUnknown
    {
        // OnRuntimeBreakpoint is invoked as part of event processing. See interface
        // definition for more information.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the thread which hit the breakpoint. Currently,
        // only managed runtime instances ever set this. This is used to quickly determine if
        // exception specific logic should apply without making another network round-trip.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeBreakpointReceived is implemented by components that want to listen for the
    // RuntimeBreakpoint event. IDkmRuntimeBreakpointReceived is invoked before
    // IDkmRuntimeBreakpointNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Provides notification that a runtime breakpoint (DkmRuntimeBreakpoint) has been hit.
    // Runtime breakpoints are the low-level breakpoint objects. Notification for the higher
    // level breakpoints (DkmPendingBreakpoint/DkmBoundBreakpoint) is obtained through the
    // BoundBreakpointHit event.
    //
    // RuntimeBreakpoint events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmRuntimeBreakpointReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeBreakpointReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3dc65314-7cf0-f174-ad0d-616b0e0ee6bd") IDkmRuntimeBreakpointReceived : public IUnknown
    {
        // OnRuntimeBreakpointReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the thread which hit the breakpoint. Currently,
        // only managed runtime instances ever set this. This is used to quickly determine if
        // exception specific logic should apply without making another network round-trip.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeBreakpointReceived(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeInstanceLoadNotification is implemented by components that want to listen
    // for the RuntimeInstanceLoad event. The target process may continue to run during this
    // notification. RuntimeInstanceLoad is fired when a DkmRuntimeInstance object is
    // created. This event can be used to detect that a particular type of code (ex: native)
    // is now being debugged in this target process. In launch scenarios, the
    // RuntimeInstanceLoad event will be fired before any code of the specified type has a
    // chance to run in the target process. When debugging native code, this includes all
    // code in the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeInstanceLoadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeInstanceLoadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c13a1419-139d-878d-8470-17da0674a194") IDkmRuntimeInstanceLoadNotification : public IUnknown
    {
        // OnRuntimeInstanceLoad is invoked as part of event processing. See interface
        // definition for more information.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeInstanceLoad(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeInstanceUnloadNotification is implemented by components that want to listen
    // for the RuntimeInstanceUnload event. The target process may continue to run during
    // this notification. RuntimeInstanceUnload is fired when an execution environment
    // unloads from the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeInstanceUnloadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeInstanceUnloadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("20c89371-8e8e-39cd-d66e-4c558b8d3f79") IDkmRuntimeInstanceUnloadNotification : public IUnknown
    {
        // OnRuntimeInstanceUnload is invoked as part of event processing. See interface
        // definition for more information.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeInstanceUnload(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentContentInsertNotification is implemented by components that want to
    // listen for the ScriptDocumentContentInsert event. The target process may continue to
    // run during this notification. Notification that new content has been added to the
    // target process. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is
    // set), this is a new document section.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentContentInsertNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentContentInsertNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2d4bb681-882c-30fc-90a3-36249993d46e") IDkmScriptDocumentContentInsertNotification : public IUnknown
    {
        // OnScriptDocumentContentInsert is invoked as part of event processing. See
        // interface definition for more information.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // Span            : [In] The text span of the inserted text. For aggregate documents
        // (DkmScriptDocumentFlags.AggregateDocument is set), this must start on a new line,
        // and at at the end of a line immediately before a new section would begin.
        // pNewText        : [In] The new text content which is inserted into the document.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentContentInsert(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ DkmString* pNewText,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentContentRemoveNotification is implemented by components that want to
    // listen for the ScriptDocumentContentRemove event. The target process may continue to
    // run during this notification. Notification that content has been removed from the
    // target process. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is
    // set), this will correspond to a deleted text section.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentContentRemoveNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentContentRemoveNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f27427d4-2808-6d82-95cc-64d3e82dee9c") IDkmScriptDocumentContentRemoveNotification : public IUnknown
    {
        // OnScriptDocumentContentRemove is invoked as part of event processing. See
        // interface definition for more information.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // Span            : [In] The text span of the removed text. For aggregate documents
        // (DkmScriptDocumentFlags.AggregateDocument is set), this must start at the begging
        // of a line, and correspond to a previously added section.
        // CharsToRemove   : [In] Number of characters within the section to remove.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentContentRemove(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ UINT32 CharsToRemove,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentTreeNodeCreateNotification is implemented by components that want to
    // listen for the ScriptDocumentTreeNodeCreate event. When this notification fires, the
    // target process will be suspended and can be examined. Notification when a new
    // DkmScriptDocumentTreeNode object is created.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmScriptDocumentTreeNodeCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentTreeNodeCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("740b8825-f45c-3cd0-333d-009ab90550b8") IDkmScriptDocumentTreeNodeCreateNotification : public IUnknown
    {
        // OnScriptDocumentTreeNodeCreate is invoked as part of event processing. See
        // interface definition for more information.
        // pScriptDocumentTreeNode: [In] Represents a node in the 'Script Documents' virtual
        // tree within solution explorer. Nodes may either be a virtual container, or they
        // can be a document. In the latter case, they will be a DkmScriptDocument.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentTreeNodeCreate(
            _In_ Script::DkmScriptDocumentTreeNode* pScriptDocumentTreeNode,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentTreeNodeUnloadNotification is implemented by components that want to
    // listen for the ScriptDocumentTreeNodeUnload event. The target process may continue to
    // run during this notification. Notification that a DkmScriptDocumentTreeNode has been
    // unloaded from the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmScriptDocumentTreeNodeUnloadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentTreeNodeUnloadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ff22fc68-c65b-a726-a65f-b0c4cd8e4153") IDkmScriptDocumentTreeNodeUnloadNotification : public IUnknown
    {
        // OnScriptDocumentTreeNodeUnload is invoked as part of event processing. See
        // interface definition for more information.
        // pScriptDocumentTreeNode: [In] Represents a node in the 'Script Documents' virtual
        // tree within solution explorer. Nodes may either be a virtual container, or they
        // can be a document. In the latter case, they will be a DkmScriptDocument.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentTreeNodeUnload(
            _In_ Script::DkmScriptDocumentTreeNode* pScriptDocumentTreeNode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptSymbolsUpdatedNotification is implemented by components that want to listen
    // for the ScriptSymbolsUpdated event. When this notification fires, the target process
    // will be suspended and can be examined. Notification that symbol state for one or more
    // script documents have been updated. This is used to rebind breakpoints in script-based
    // modules.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmScriptSymbolsUpdatedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptSymbolsUpdatedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("cd719ead-c44b-6f43-0466-943e5d6fdcfb") IDkmScriptSymbolsUpdatedNotification : public IUnknown
    {
        // OnScriptSymbolsUpdated is invoked as part of event processing. See interface
        // definition for more information.
        // pScriptRuntimeInstance: [In] Represents a script-based execution environment
        // executing in a target process.
        // Documents       : [In] Set of documents which have been updated.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnScriptSymbolsUpdated(
            _In_ Script::DkmScriptRuntimeInstance* pScriptRuntimeInstance,
            _In_ const DkmArray<Script::DkmScriptDocument*>& Documents,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmTaskProviderCreateNotification is implemented by components that want to listen
    // for the TaskProviderCreate event. The target process may continue to run during this
    // notification. Indicates that a task provider object has been created.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TaskProviderId.
    #define IID_IDkmTaskProviderCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskProviderCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b346af13-65e1-8e44-e9f1-2e5de6d1e08c") IDkmTaskProviderCreateNotification : public IUnknown
    {
        // OnTaskProviderCreate is invoked as part of event processing. See interface
        // definition for more information.
        // pTaskProvider   : [In] Represents a task provider which is loaded into the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnTaskProviderCreate(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmThreadCreateNotification is implemented by components that want to listen for the
    // ThreadCreate event. When this notification fires, the target process will be suspended
    // and can be examined. ThreadCreate is fired when a new thread starts in the target
    // process.
    //
    // ThreadCreate events can be suppressed. In this case the thread will be invisible to
    // components above the level where the thread was suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e815c419-f857-75e2-0f79-8cd82018eaa1") IDkmThreadCreateNotification : public IUnknown
    {
        // OnThreadCreate is invoked as part of event processing. See interface definition
        // for more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pWorkList       : WorkList to append additional event processing work to. This
        // work list will begin execution after all listeners have been notifiied. The event
        // will not finish until after the work list fully executes.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnThreadCreate(
            _In_ DkmThread* pThread,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmThreadExitNotification is implemented by components that want to listen for the
    // ThreadExit event. The target process may continue to run during this notification.
    // ThreadExit is fired when a thread in the target process exits. It will not be fired if
    // the target process exits while the thread is still running.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadExitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadExitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ec1c3fc-8fe9-6f86-6f9b-5b3473924209") IDkmThreadExitNotification : public IUnknown
    {
        // OnThreadExit is invoked as part of event processing. See interface definition for
        // more information.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ExitCode        : [In] 32-bit value that the process returned on exit. This is the
        // same value that would be reported from the kernel32!GetExitCodeThread.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnThreadExit(
            _In_ DkmThread* pThread,
            _In_ UINT32 ExitCode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

}; // end of Events interfaces


// Settings update notifications interfaces
// These interfaces may be implemented by any component. They provide notifications when
// debugger settings are changed.
namespace ComponentInterfaces
{
    // IDkmAfterSetNextStatementNotification implemented by components that wish to receive
    // notification after a set next statement completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmAfterSetNextStatementNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAfterSetNextStatementNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("8ef24f26-7e73-7719-706d-c0fabf136515") IDkmAfterSetNextStatementNotification : public IUnknown
    {
        // OnSetNextStatementCompleted is a general purpose method to allow components to
        // clear state after a set next statement completed. The DkmStackWalkFrame will be
        // the frame prior to to the SetNextStatement call.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // pNewStatement   : [In] Abstract representation of an executable code location (ex:
        // EIP value). If resolved, an Instruction Address will be within a particular module
        // instance. An Instruction Address is always within a particular Runtime Instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnSetNextStatementCompleted(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ DkmInstructionAddress* pNewStatement
            ) = 0;
    };

    // Interface to update components when 'IsGpuRaceHazardsAllowSameSettingEnabled' is
    // enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmGpuRaceHazardsAllowSameNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGpuRaceHazardsAllowSameNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e3e083eb-ec58-1cfa-dd32-86ca6a87f395") IDkmGpuRaceHazardsAllowSameNotification : public IUnknown
    {
        // Called when 'IsGpuRaceHazardsAllowSameSettingEnabled' is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnGpuRaceHazardAllowSameSettingChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when JustMyCode is enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmJustMyCodeEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmJustMyCodeEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ede97f9f-a05a-2818-4f5d-7e9bd5aa688b") IDkmJustMyCodeEnableNotification : public IUnknown
    {
        // Called when 'IsJustMyCodeEnabled' is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnJustMyCodeChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when native debugging is enabled or disabled for a
    // particular process. Note that for Visual Studio 11, native debugging cannot be
    // enabled/disabled on the fly, but future versions may support this functionality.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmNativeDebuggingEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeDebuggingEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e126c5d6-bb96-562e-ebae-5dae8d2e5df1") IDkmNativeDebuggingEnableNotification : public IUnknown
    {
        // Called when 'IsNativeDebuggingEnabled' is changed.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnNativeDebuggingEnabledChanged(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Interface to update components when 'IsNativeExportsEnabled' is enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmNativeExportsEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeExportsEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ac1d537a-6899-f914-86ee-8c728c01d312") IDkmNativeExportsEnableNotification : public IUnknown
    {
        // Called when 'IsNativeExportsEnabled' is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnNativeExportsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when RequireFullTrustForSourceServer is enabled or
    // disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmRequireFullTrustForSourceServerNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRequireFullTrustForSourceServerNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0649fcb4-60d9-599d-6f60-f72d0f986b8f") IDkmRequireFullTrustForSourceServerNotification : public IUnknown
    {
        // Called when 'RequireFullTrustForSourceServer' is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnRequireFullTrustForSourceServerChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when 'IsStepOverPropertiesAndOperatorsEnabled' is
    // enabled or  disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmStepOverPropertiesAndOperatorsEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStepOverPropertiesAndOperatorsEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5a8587ed-a475-7af6-a3ce-0246c3d86c60") IDkmStepOverPropertiesAndOperatorsEnableNotification : public IUnknown
    {
        // Called when 'IsStepOverPropertiesAndOperatorsEnabled' is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnStepOverPropertiesAndOperatorsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when 'IsSuppressOptimizationsEnabled' is enabled or
    // disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmSuppressOptimizationsEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSuppressOptimizationsEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bb69f4b9-fd42-ad8a-f0f6-6bd1c48b8e7a") IDkmSuppressOptimizationsEnableNotification : public IUnknown
    {
        // Called when 'IsSuppressOptimizationsEnabled' is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnSuppressOptimizationsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when symbol settings change.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmSymbolPathChangeNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolPathChangeNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6e177901-05d1-ed76-1ce4-cbfeca02295d") IDkmSymbolPathChangeNotification : public IUnknown
    {
        // Called when the symbol path is changed.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnSymbolPathChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

}; // end of Settings update notifications interfaces


// Call stack walkers (native code generators) interfaces
// These interfaces are implemented by partners who have a native code generator (ex:
// compiler) where the generated code produces call stacks that cannot be walked without
// access to symbols (ex: non-EBP framed x86 code).
//
// See also: IDkmStackWalkFrameInterfaceProvider
namespace ComponentInterfaces
{
    // Provides a mechanism for the Base Debug Monitor and Native Debug Monitor to obtain
    // information about the stack frames that may require symbol support.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmNativeStackCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeStackCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f5e432fb-b862-5df5-91b8-e0380145480d") IDkmNativeStackCallback : public IUnknown
    {
        // GetCurrentFrameInfo is used to obtain the frame base and return address for the
        // current context of the thread. This takes into account Frame Pointer Omission and
        // if the current instruction pointer is in a prolog, epilog etc... NOTE: In some
        // cases this will get it wrong if the frame has Frame Pointer Omission and there are
        // no symbols loaded.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pReturnAddress  : [Out] The return address of the frame.
        // pFrameBase      : [Out] The frame base of the frame.
        // pVFrame         : [Out] The vframe of the current frame. Only valid on x86.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFrameInfo(
            _In_ DkmThread* pThread,
            _Out_ UINT64* pReturnAddress,
            _Out_ UINT64* pFrameBase,
            _Out_ UINT64* pVFrame
            ) = 0;
    };

    // Provides a mechanism for walking native stack frames using information from symbol
    // files. This mechanism is used to walk any stack frames which could not be resolved on
    // the target computer.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SymbolProviderId.
    #define IID_IDkmSymbolStackWalk __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolStackWalk)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("cc886169-aa9c-d9c9-0ee1-42c9d6f280d0") IDkmSymbolStackWalk : public IUnknown
    {
        // Initialize is invoked on each walker exactly once at the beginning of the walk
        // process. This gives each walker a chance to initialize any state.
        // pSymbolStackWalkContext: [In] DkmSymbolStackWalkContext allows the various symbol
        // providers which walk the call stack to store private data which is associated with
        // this call stack.
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmSymbolStackWalkContext* pSymbolStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            ) = 0;

        // UpdatePosition is invoked by the stack provider after another walker has walked
        // one or more frames, and so this walker must be updated before invoking
        // WalkNextFrame.
        // pSymbolStackWalkContext: [In] DkmSymbolStackWalkContext allows the various symbol
        // providers which walk the call stack to store private data which is associated with
        // this call stack.
        // pRegisters      : [In] Registers to attempt to walk from.
        // StackRangeSize  : [In] Size of the stack range that the debugger will attempt to
        // walk through.
        // pInstructionAddress: [In] Address from the instruction pointer in the registers.
        // This will be either a 'Native' or 'Unresolved' address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmSymbolStackWalkContext* pSymbolStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize,
            _In_ DkmInstructionAddress* pInstructionAddress
            ) = 0;

        // Walk the next stack frame from the call stack.
        // pSymbolStackWalkContext: [In] DkmSymbolStackWalkContext allows the various symbol
        // providers which walk the call stack to store private data which is associated with
        // this call stack.
        // ppNextRegisters : [Out,Optional] NextRegisters indicates the registers of the next
        // frame (the caller of 'FrameObject'). It is used to invoke UpdatePosition if the
        // next frame is owned by a different symbol provider. A null NextRegisters value
        // indicates that the returned frame is the last frame of the call stack, so the
        // stack walk will end here.
        // ppFrameObject   : [Out,Optional] Created frame object for the current registers.
        // Return value    : S_OK is returned if *ppFrameObject is non-NULL, S_FALSE is
        // returned when *ppFrameObject is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _In_ CallStack::DkmSymbolStackWalkContext* pSymbolStackWalkContext,
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Deref_out_opt_ CallStack::DkmStackWalkFrame** ppFrameObject
            ) = 0;
    };

}; // end of Call stack walkers (native code generators) interfaces


// Customize the debugging experience for a library interfaces
// The following interfaces are primarily intended to be implemented by a library
// developer who wants to improve the debugging experience of clients consuming their
// library. For example, this category includes the breakpoint manager interfaces. A
// library which did text processing could use the breakpoint manager interfaces to
// interpret input file breakpoints as a request to stop in the library just before this
// part of the text document was processed.
//
// See also: IDkmModuleInstanceLoadNotification, IDkmProcessLaunchEnvironmentFilter,
// IDkmRuntimeBreakpointNotification, IDkmRuntimeBreakpointReceived,
// IDkmStopDebuggingOperations, IDkmThreadDisplayPropertiesQuery, IDkmThreadNameQuery
namespace ComponentInterfaces
{
    // Implemented by callers of DkmRuntimeBreakpoint.SetCompiledConditionPending to provide
    // compiled conditions when a breakpoint is hit.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmBreakpointConditionProcessorClient __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessorClient)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("fe8268ed-63b3-beed-8458-5e74841a650b") IDkmBreakpointConditionProcessorClient : public IUnknown
    {
        // Call back invoked from the breakpoint condition processor to the breakpoint
        // manager (or other component which calls SetCompiledConditionPending) when the
        // breakpoint condition needs to be re-compiled for a new instruction address.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pInstructionAddress: [In] The instruction address to compile the condition
        // against.
        // pConditionOperator: [Out] Operator to use when evaluating the condition.
        // ppCompiledCondition: [Out,Optional] The compiled condition to be used for the
        // specified instruction address. This value is null in the case that the condition
        // failed to compile. In this case, the condition processor should stop on the
        // breakpoint.
        // Return value    : S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is
        // returned when *ppCompiledCondition is NULL, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCompiledCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _Out_ Breakpoints::DkmBreakpointConditionOperator::e* pConditionOperator,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition
            ) = 0;

        // Call back invoked from the breakpoint condition processor to the breakpoint
        // manager when a breakpoint condition encounters a runtime error.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pErrorMessage   : [In] The message to display to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointConditionFailed(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmString* pErrorMessage
            ) = 0;
    };

    // This interface is implemented by the Breakpoint Manager component to provide the
    // default handling for breakpoints. Other components in the system may also implement
    // this interface to remap the meaning of breakpoints for certain languages.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBreakpointManager __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointManager)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("21ad9ecf-0707-b85a-8b40-32cf146308e7") IDkmBreakpointManager : public IUnknown
    {
        // Sets the state of the pending breakpoint so that instances of the breakpoint that
        // bind in the future will get hit. If the pending breakpoint is not yet enrolled,
        // then this method will also enroll the breakpoint. Enrolling a pending breakpoint
        // consists of attempting to resolve the breakpoint against any modules which are
        // currently loaded and adding the breakpoint to the list of breakpoints which the
        // breakpoint manager will bind on any module load. If the pending breakpoint is
        // already enrolled, existing bound breakpoints will not automatically get enabled.
        // Bound breakpoints must get enabled separately.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnablePendingBreakpoint(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnablePendingBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        // Disable the pending breakpoint object so that it will no longer fire. If the
        // pending breakpoint is already bound, any bound breakpoints will be implicitly
        // disabled.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DisablePendingBreakpoint(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisablePendingBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        // This method will enroll the pending breakpoint without enabling it. The result is
        // a breakpoint which the breakpoint manager will attempt to resolve, but which will
        // not fire. Enrolling a pending breakpoint consists of attempting to resolve the
        // breakpoint against any modules which are currently loaded and adding the
        // breakpoint to the list of breakpoints which the breakpoint manager will bind on
        // any module load.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnrollPendingBreakpoint(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnrollPendingBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        // Initialize, update or clear the language-level condition on all bound breakpoints
        // of this condition breakpoint.  If the same breakpoint has both a language-level
        // condition, and a hit count condition, the language-level condition is applied
        // first.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetPendingBreakpointCondition(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>* pCompletionRoutine
            ) = 0;

        // Initialize, update or clear the hit count condition on all bound breakpoints of
        // this pending breakpoint. If the same breakpoint has both a language-level
        // condition, and a hit count condition, the language-level condition is applied
        // first.
        //
        // Note that the hit count condition acts independently on each bound breakpoint,
        // rather than being aggregated together on the pending breakpoint. For example, if
        // the hit count is configured to stop at hit #2, and the breakpoint to two separate
        // locations, each of which hit the breakpoint once, the UI will still not have gone
        // into break mode because neither individual bound breakpoint has hit twice.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetPendingBreakpointHitCountCondition(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            ) = 0;

        // Enables the bound breakpoint so that it can be hit. If the bound breakpoint is
        // already enabled, this operation has no effect.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnableBoundBreakpoint(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnableBoundBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        // Disable the bound breakpoint so that it will no longer hit. If the bound
        // breakpoint is already disabled, this operation has no effect.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DisableBoundBreakpoint(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisableBoundBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        // Query to determine if the bound breakpoint is enabled.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pResult         : [Out] 'true' if the breakpoint is enabled.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsBoundBreakpointEnabled(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _Out_ bool* pResult
            ) = 0;

        // Initialize or update or clear the condition on a breakpoint.  If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetBoundBreakpointCondition(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition
            ) = 0;

        // Initialize, update or clear the hit count condition on a breakpoint. If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pCondition      : [In,Optional] Condition to apply to this breakpoint. This value
        // may be 'null' if the caller wishes to remove the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetBoundBreakpointHitCountCondition(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition
            ) = 0;

        // Modifies the value for a breakpoint hit count.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // NewValue        : [In] New value for the hit count.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetBoundBreakpointHitCountValue(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ UINT32 NewValue
            ) = 0;

        // Returns the number of times that a bound breakpoint has been hit. This value
        // should not include any times when the breakpoint's instruction was executed, but
        // the breakpoint's condition indicated that the debugger should not stop.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetBoundBreakpointHitCountValue(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by breakpoint managers which wish to receive notification when
    // files are updated in the IDE.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    #define IID_IDkmBreakpointManagerFileUpdate __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointManagerFileUpdate)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("90fe337d-d8a4-ee91-fe3f-53efde6520d4") IDkmBreakpointManagerFileUpdate : public IUnknown
    {
        // Provides notification that one or more files containing breakpoints have been
        // updated.
        // pFileUpdateNotification: [In] Object used to send file update notifications to
        // breakpoint managers.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointFilesUpdated(
            _In_ Breakpoints::DkmBreakpointFileUpdateNotification* pFileUpdateNotification,
            _In_ DkmWorkList* pWorkList
            ) = 0;
    };

    // Allows a component to add additional annotation to the call stack or remove physical
    // frames from the call stack. For performance reasons, stack frame filters are invoked
    // prior to evaluation by expression evaluators. One example stack frame filter is to
    // hide external code in the call stack.  Frame filters that add async stack walk
    // contexts must have a priority of Normal or above.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmCallStackFilter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCallStackFilter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("56f90ba7-54a6-001e-c419-0c8b60821376") IDkmCallStackFilter : public IUnknown
    {
        // Provides a filter with the next stack frame. A filter can simply pass this frame
        // on through, it can suppress the frame by returning nothing, or it can provide its
        // own set of annotated frames. The stack provider will ignore
        // NotImplementedException (E_NOTIMPL). All other errors will truncate stack walk.
        // pStackContext   : [In] DkmStackContext objects are created by components that wish
        // to request the stack from the stack provider. A component needs to close the
        // context after they have completed the stack walk. To obtain the stack a component
        // should create this object and then call GetNextFrames.
        // pInput          : [In,Optional] Input is the next frame to examine. After all
        // frame have been filtered, this function will be called one last time with a null
        // input frame. This lets the filter know that the call stack is fully processed.
        // pResult         : [Out] DkmStackWalkFrame[] represents a frame on a call stack
        // which has been walked, but may not have been formatted or filtered. Formatted
        // frames are represented by DkmStackFrame instead.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pResult contains any elements, S_FALSE is
        // indicates the array is empty, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE FilterNextFrame(
            _In_ CallStack::DkmStackContext* pStackContext,
            _In_opt_ CallStack::DkmStackWalkFrame* pInput,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pResult
            ) = 0;
    };

    // Implemented by components that wish to receive custom messages from another Concord
    // component. This is interface is similar to IDkmCustomMessageForwardReceiver, except
    // that this method requires that the caller be at a lower level in the component
    // hierarchy than the component that receives the notification (ex: Base Debug Monitor ->
    // AD7 AL). Implementers of this interface typically use a SourceId filter.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomMessageCallbackReceiver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomMessageCallbackReceiver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dd14a9f2-498e-eb3f-3e3a-21218e758d6e") IDkmCustomMessageCallbackReceiver : public IUnknown
    {
        // Sends a message to a listening component which is higher in the hierarchy.
        // pCustomMessage  : [In] Message structure used to pass information between custom
        // debugger backend components and custom visual studio UI components (packages,
        // add-ins, etc).
        // ppReplyMessage  : [Out,Optional] Message sent back from the implementation.
        // Return value    : S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is
        // returned when *ppReplyMessage is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE SendHigher(
            _In_ DkmCustomMessage* pCustomMessage,
            _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
            ) = 0;
    };

    // Implemented by components that wish to receive custom messages from the IDE or from
    // another Concord component. This is interface is similar to
    // IDkmCustomMessageCallbackReceiver, except that this method requires that the caller be
    // at a higher level in the component hierarchy than the component that receives the (ex:
    // AD7 AL -> Base Debug Monitor). Implementers of this interface typically use a SourceId
    // filter.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomMessageForwardReceiver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomMessageForwardReceiver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("043c14a8-13aa-fece-cdc5-ad57bfc8d1a7") IDkmCustomMessageForwardReceiver : public IUnknown
    {
        // Sends a message to a listening component which is lower in the hierarchy.
        // pCustomMessage  : [In] Message structure used to pass information between custom
        // debugger backend components and custom visual studio UI components (packages,
        // add-ins, etc).
        // ppReplyMessage  : [Out,Optional] Message sent back from the implementation.
        // Return value    : S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is
        // returned when *ppReplyMessage is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE SendLower(
            _In_ DkmCustomMessage* pCustomMessage,
            _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
            ) = 0;
    };

    // Allows a library that implements exception objects that maintain a captured stack
    // trace to expose this stack trace to the debugger.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmExceptionStackTraceProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionStackTraceProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e62065ff-66b2-f2c6-8fe7-1ce92fabd74b") IDkmExceptionStackTraceProvider : public IUnknown
    {
        // Obtains the captured stack trace associated with the exception, if one is
        // available.
        // pException      : [In] Provides information about an exception which was raised in
        // the target process. This information includes details of what exception was raised
        // and the current stage of exception processing.
        // ppStackTrace    : [Out,Optional] An array of frames that were running at the time
        // the exception got thrown.
        // Return value    : S_OK is returned if *ppStackTrace is non-NULL, S_FALSE is
        // returned when *ppStackTrace is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetExceptionStackTrace(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>** ppStackTrace
            ) = 0;
    };

    // IDkmLaunchResumeProcess is used to launch and resume a process. It is called from the
    // debug monitor in F5, and from the transport in Ctrl-F5.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmLaunchResumeProcess __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLaunchResumeProcess)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("38ee0541-48c8-7a9a-9dfe-1fd4cbe3c111") IDkmLaunchResumeProcess : public IUnknown
    {
        // This API is remote-able version of the Win32 CreateProcess API. The implementation
        // will merge the environment block, process command line redirection and launch the
        // process. Unless the NoDebug flag is used, CreateProcess will use the DEBUG_PROCESS
        // flag when creating the Win32 process.
        // pRequest        : [In] DkmProcessLaunchRequest is used to describe the process
        // that debugger should launch.
        // AdditionalWin32Flags: [In] Win32 process creation flags in addition to those found
        // in the DkmProcessLaunchRequest.Win32Flags. This is often used to pass
        // DEBUG_PROCESS (0x1), DEBUG_ONLY_THIS_PROCESS (0x2), or CREATE_SUSPENDED (0x4).
        // pLaunchedProcess: [Out] DkmLaunchedProcessInfo is returned from APIs that launch a
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE LaunchProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest,
            _In_ UINT32 AdditionalWin32Flags,
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            ) = 0;

        // This API is used to resume a process which was launched from CreateProcess with
        // the LaunchSuspended flag set to true.
        // pRequest        : [In] DkmProcessLaunchRequest is used to describe the process
        // that debugger should launch.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest
            ) = 0;
    };

}; // end of Customize the debugging experience for a library interfaces


// Breakpoint creator interfaces
// Breakpoints are typically by the AD7 adaptation layer in response to a new breakpoint
// request from the UI or from a debugger automation-layer client. Low-level breakpoints
// are also typically created. These can be set through the DkmRuntimeBreakpoint class.
// In addition to these two methods, it is also possible for high-level breakpoints to be
// added to the breakpoint manager through the DkmPendingBreakpoint class. When a
// component chooses to add breakpoints through DkmPendingBreakpoint it should implement
// these interfaces to obtain status.
namespace ComponentInterfaces
{
    // IDkmBoundBreakpointHitNotification is implemented by components that want to listen
    // for the BoundBreakpointHit event. IDkmBoundBreakpointHitNotification is invoked after
    // all implementations of IDkmBoundBreakpointHitReceived. When this notification is
    // called, the target process is stopped and implementers are able to either inspect the
    // process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Provides notification that a bound breakpoint (DkmBoundBreakpoint) has been hit. Bound
    // breakpoints are the high-level breakpoint objects. Notification for the low level
    // breakpoints (DkmRuntimeBreakpoint) is obtained through the RuntimeBreakpoint event.
    //
    // BoundBreakpointHit events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBoundBreakpointHitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBoundBreakpointHitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("4a9d4453-aeae-b181-1694-f66637cb196d") IDkmBoundBreakpointHitNotification : public IUnknown
    {
        // OnBoundBreakpointHit is invoked as part of event processing. See interface
        // definition for more information.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the thread which hit the breakpoint. Currently,
        // only managed runtime instances ever set this. This is used to quickly determine if
        // exception specific logic should apply without making another network round-trip.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBoundBreakpointHit(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmBoundBreakpointHitReceived is implemented by components that want to listen for
    // the BoundBreakpointHit event. IDkmBoundBreakpointHitReceived is invoked before
    // IDkmBoundBreakpointHitNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Provides notification that a bound breakpoint (DkmBoundBreakpoint) has been hit. Bound
    // breakpoints are the high-level breakpoint objects. Notification for the low level
    // breakpoints (DkmRuntimeBreakpoint) is obtained through the RuntimeBreakpoint event.
    //
    // BoundBreakpointHit events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBoundBreakpointHitReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBoundBreakpointHitReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("11907038-fbf4-ac6f-9b86-00612f438738") IDkmBoundBreakpointHitReceived : public IUnknown
    {
        // OnBoundBreakpointHitReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pBoundBreakpoint: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the thread which hit the breakpoint. Currently,
        // only managed runtime instances ever set this. This is used to quickly determine if
        // exception specific logic should apply without making another network round-trip.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBoundBreakpointHitReceived(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // This interface is implemented by components that add breakpoints to the breakpoint
    // manager (such as the AD7 AL). This allows a component to be notified when the
    // breakpoint manager binds a breakpoint or detects a breakpoint error or warning.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBreakpointManagerNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointManagerNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ce868706-c4b9-08e9-b2a3-a8d64ce034a2") IDkmBreakpointManagerNotification : public IUnknown
    {
        // Notification from the breakpoint manager when a breakpoint has been bound. In the
        // case of user-set breakpoints, this notification will be sent to the AD7 AL, and
        // the AD7 AL will fire a IDebugBreakpointBoundEvent2 to the Visual Studio Debugger
        // UI.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // BoundBreakpoints: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointBound(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints
            ) = 0;

        // Notification from the breakpoint manager which indicates that the given breakpoint
        // is being unbound.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // BoundBreakpoints: [In] Represents a breakpoint which has been bound (resolved) to
        // a particular code instruction address or a particular data element. For example,
        // in C++ templates one could create a DkmPendingBreakpoint for a source line. The
        // breakpoint manager would resolve it to zero (ex: module not loaded), one (ex:
        // template is only used on 'int') or many (ex: template is used with many template
        // arguments) location. Each location would have a DkmBoundBreakpoint object.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Reason          : [In] Describes the reason for a breakpoint to be unbound.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointUnbound(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints,
            _In_ Breakpoints::DkmBreakpointUnboundReason::e Reason
            ) = 0;

        // Notification from the breakpoint manager concerning the status of binding the
        // breakpoint.
        // pPendingBreakpoint: [In] High level breakpoint object which is tied to a
        // user-level construct (ex: source file, function name) which may map to zero or
        // more code-level constructs (DkmBoundBreakpoint) and which may be tracked over
        // time.
        // Level           : [In] Describes the severity of a message sent from a breakpoint
        // manager back to the source component. This list is sorted in order of priority, as
        // the UI will only display the most important warning. All warnings are ignored if
        // the breakpoint is bound.
        // pMessage        : [In] Message string to display to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointMessage(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ Breakpoints::DkmBreakpointMessageLevel::e Level,
            _In_ DkmString* pMessage
            ) = 0;
    };

    // This interface is implemented by components that wish to add
    // DkmPendingFileLineBreakpoint objects to the breakpoint manager. The breakpoint manager
    // will query for the current location on the first bind and during an Edit-and-Continue
    // apply.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmPendingFileLineBreakpointCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmPendingFileLineBreakpointCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bc7a2f08-8934-01ad-1e67-ff937eab25fc") IDkmPendingFileLineBreakpointCallback : public IUnknown
    {
        // Returns the current location of a file/line breakpoint. In edit and continue
        // scenarios, the location of the text marker may change within a debug session.
        // pFileLineBreakpoint: [In] Pending breakpoint which is requested to bind against
        // code elements that point back to a text span within a source file.
        // ppCurrentPosition: [Out] Source code position which corresponds to a code element.
        // The could represent a location which has been extracted from a symbol (PDB) file,
        // or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourcePosition(
            _In_ Breakpoints::DkmPendingFileLineBreakpoint* pFileLineBreakpoint,
            _Deref_out_ Symbols::DkmSourcePosition** ppCurrentPosition
            ) = 0;

        // Returns the current text at the location of a file/line breakpoint.
        // pFileLineBreakpoint: [In] Pending breakpoint which is requested to bind against
        // code elements that point back to a text span within a source file.
        // ppCurrentText   : [Out,Optional] The current source text.
        // Return value    : S_OK is returned if *ppCurrentText is non-NULL, S_FALSE is
        // returned when *ppCurrentText is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourceText(
            _In_ Breakpoints::DkmPendingFileLineBreakpoint* pFileLineBreakpoint,
            _Deref_out_opt_ DkmString** ppCurrentText
            ) = 0;
    };

}; // end of Breakpoint creator interfaces


// Microsoft implemented interfaces
// For the following interfaces, it is expected that they will only be implemented by a
// Microsoft-provided component.
//
// See also: IDkmBinaryLoadedNotification,
// IDkmClrDebugMonitorExceptionCaughtNotification, IDkmDebugMonitorExceptionNotification,
// IDkmOutOfBandExceptionNotification
namespace ComponentInterfaces
{
    // Interface implemented by the Script DM to provide direct access to the target script
    // runtime.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmActiveScriptDebugMonitor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmActiveScriptDebugMonitor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1290ef94-6ae5-c0f5-b6bf-929c2f63a447") IDkmActiveScriptDebugMonitor : public IUnknown
    {
        // Allows a caller to obtain a direct access to the IRemoteDebugApplication interface
        // from the target process. This can be used to load dlls into the target
        // application, or inspect the target application. Note that this should never be
        // used for execution control, breakpoints, or evaluation.
        // pScriptRuntimeInstance: [In] Represents a script-based execution environment
        // executing in a target process.
        // ppApplication   : [Out] Debug application interface from the debugged process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetRemoteDebugApplication(
            _In_ Script::DkmScriptRuntimeInstance* pScriptRuntimeInstance,
            _Deref_out_ IRemoteDebugApplication** ppApplication
            ) = 0;

        // API which is called from break mode which tells the script runtime that execution
        // should be aborted when resuming (BREAKRESUMEACTION_ABORT). This API requires an
        // MSHTML v10+ target execution environment.
        // pScriptRuntimeInstance: [In] Represents a script-based execution environment
        // executing in a target process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE AbortExecutionOnResume(
            _In_ Script::DkmScriptRuntimeInstance* pScriptRuntimeInstance
            ) = 0;
    };

    // Interface to enumerate App Package information on the local or remote system.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmAppPackageInfo __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAppPackageInfo)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("be5a0e92-d115-3691-7e4f-c621900ec0cd") IDkmAppPackageInfo : public IUnknown
    {
        // Enumerates installed and launchable (App Packages with applications) App Packages.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pPackages       : [Out] Array of App Packages found.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnumPackages(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _Out_ DkmArray<DefaultPort::DkmInstalledAppPackageInfo*>* pPackages
            ) = 0;
    };

    // Interface implemented on the target computer to handle evaluating breakpoint
    // conditions and hit counts.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmBreakpointConditionProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f7dcc8b5-fee9-38be-0d1b-9e4ed8dc0f7c") IDkmBreakpointConditionProcessor : public IUnknown
    {
        // This sets an associated compiled condition on the specified runtime instruction
        // breakpoint. The breakpoint condition processor will then test the condition
        // whenever it is hit. This is used for languages which are evaluated in the IDE
        // process (ex: C++).
        // pInstructionBreakpoint: [In] Low-level breakpoint which is set on an instruction
        // address.
        // pCompiledCondition: [In] Compiled query used to evaluate the condition.
        // ConditionOperator: [In] Operator to use when evaluating the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetCompiledCondition(
            _In_ Breakpoints::DkmRuntimeInstructionBreakpoint* pInstructionBreakpoint,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator
            ) = 0;

        // This method is similar to SetCompiledCondition, but is used in cases where the
        // instruction address is not known up front, such as data breakpoints. In these
        // cases, when the breakpoint is first hit at a particular address, a call will be
        // made to the breakpoint client to obtain a new compiled condition for this address
        // (IDkmBreakpointConditionProcessorClient.GetCompiledCondition).  This is used for
        // languages which are evaluated in the IDE process (ex: C++).
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetCompiledConditionPending(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        // Sets a breakpoint condition which is evaluated on the target computer. This is
        // used for .NET languages.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pCondition      : [In] Conditions under which a breakpoint should fire.
        // ppErrorText     : [Out,Optional] If the condition could not be parsed, this
        // indicates the reason why. This value should be null if the compile succeeded.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetEvaluationCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        // Clear any compiled/evaluation condition associated with the specified
        // DkmRuntimeBreakpoint. This method is implicitly called when the
        // DkmRuntimeBreakpoint is closed.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearConditions(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        // Initialize or update the hit count condition/value on a breakpoint. If the same
        // breakpoint has both a language-level condition, and a hit count condition, the
        // language-level condition is applied first. The condition is implicitly removed if
        // the DkmRuntimeBreakpoint is closed.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pCondition      : [In] Condition to apply to this breakpoint.
        // HitCountValue   : [In] The initial value of the breakpoint's hit count. A value of
        // -1/MAXDWORD indicates that the current hit count value should be preserved.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ UINT32 HitCountValue
            ) = 0;

        // Clears the hit count condition on a breakpoint.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pCondition      : [In] Condition to apply to this breakpoint.
        // pCurrentHitCount: [Out] Number of times that the breakpoint has been hit as of the
        // time that the condition was removed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearHitCountCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _Out_ UINT32* pCurrentHitCount
            ) = 0;

        // Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit
        // count condition. This function will fail if the DkmRuntimeBreakpoint does not
        // currently have a hit count condition.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pCurrentHitCount: [Out] Number of times that the breakpoint has been hit.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetHitCountConditionStatus(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _Out_ UINT32* pCurrentHitCount
            ) = 0;
    };

    // Extension interface for GPU debugging, implemented on the target computer to handle
    // evaluating breakpoint conditions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmBreakpointConditionProcessorGpuExtension __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessorGpuExtension)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("092f0ce3-bfa7-56bd-53d3-9cab54b0acb8") IDkmBreakpointConditionProcessorGpuExtension : public IUnknown
    {
        // This tries to push the associated condition on the specified runtime instruction
        // breakpoint to the target. This is useful for GPU debugging since testing the
        // condition on the target (GPU hardware or VSD3D ref) is much more efficient than
        // doing it in the debugger. Once this method succeeds, breakpoint event will only be
        // received by the debugger when the condition tests to be true on the debuggee; if
        // it fails, the debugger can still test the condition.
        // pInstructionBreakpoint: [In] Low-level breakpoint which is set on an instruction
        // address.
        // pCompiledCondition: [In] Compiled query used to evaluate the condition.
        // ConditionOperator: [In] Operator to use when evaluating the condition.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TryPushConditionToTargetDevice(
            _In_ Breakpoints::DkmRuntimeInstructionBreakpoint* pInstructionBreakpoint,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator
            ) = 0;

        // Clear any condition associated with the specified DkmRuntimeInstructionBreakpoint.
        // pInstructionBreakpoint: [In] Low-level breakpoint which is set on an instruction
        // address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TryClearConditionOnTargetDevice(
            _In_ Breakpoints::DkmRuntimeInstructionBreakpoint* pInstructionBreakpoint
            ) = 0;

        // The breakpoint condition processor decides not to break on the given thread but
        // another thread of the same warp, so the breakpoint condition processor instructs
        // the base debug monitor to re-send the breakpoint event on the other thread.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pModifiedBreakThread: [In] The base debug monitor should re-send breakpoint event
        // on this thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE RequestBreakpointEventOnModifiedThread(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pModifiedBreakThread
            ) = 0;
    };

    // Interface implemented on the target computer to handle evaluating breakpoint
    // conditions on all stopped threads and select the thread whose condition is true for
    // GPU.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmBreakpointConditionThreadSelectorForGpu __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionThreadSelectorForGpu)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f8eddcb0-ef7e-13da-2362-f7ac536bcd1b") IDkmBreakpointConditionThreadSelectorForGpu : public IUnknown
    {
        // The base debug monitor asks the breakpoint condition processor to evaluate on all
        // stopped threads, and selects the thread whose condition is true.
        // pRuntimeBreakpoint: [In] Low-level breakpoint object which is supported by debug
        // monitors.
        // pFirstStoppedThread: [In] The first stopped thread.
        // ppConditionMetThread: [Out,Optional] The thread whose condition is true. The value
        // is null in the case that no thread is found to have a true condition.
        // Return value    : S_OK is returned if *ppConditionMetThread is non-NULL, S_FALSE
        // is returned when *ppConditionMetThread is NULL, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EvaluateConditionAndSelectThread(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pFirstStoppedThread,
            _Deref_out_opt_ DkmThread** ppConditionMetThread
            ) = 0;
    };

    // Interface to update name of the AppDomain.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmClrAppDomainNameChanged __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrAppDomainNameChanged)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6b35c9be-346f-108b-02c4-99532b0869cb") IDkmClrAppDomainNameChanged : public IUnknown
    {
        // Called when 'Name' is changed.
        // pAppDomain      : [In] DkmClrAppDomain represents a CLR app domain inside a
        // process which is being debugged.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnAppDomainNameChanged(
            _In_ Clr::DkmClrAppDomain* pAppDomain
            ) = 0;
    };

    // Interface implemented by the managed DM to obtain the metadata from a given module.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmClrMetaDataProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrMetaDataProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("eb718ded-9ed6-3c7d-fbcf-8bb4b4c1c332") IDkmClrMetaDataProvider : public IUnknown
    {
        // Obtains the CLR metadata from a given module. See IMetaDataImport documentation in
        // MSDN for more information on metadata.
        // pClrModuleInstance: [In] 'DkmClrModuleInstance' is used for modules which are
        // loaded into the Common Language Runtime.
        // ppMetaData      : [Out] The IMetaDataImport interface for this managed module
        // instance.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataImport(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Deref_out_ IUnknown** ppMetaData
            ) = 0;
    };

    // Obtains the DkmClrModuleInstance from an ICorDebugModule.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmClrModuleLookup __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrModuleLookup)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("627f8870-1e8e-b0f7-52de-cac9608e9d35") IDkmClrModuleLookup : public IUnknown
    {
        // Obtains the DkmClrModuleInstance from an ICorDebugModule.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pCorModule      : [In] The CLR module to get the module instance for.
        // ppResult        : [Out] The DkmClrModuleInstance that matches the provided
        // ICorDebugModule.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE FindClrModuleInstance(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ ICorDebugModule* pCorModule,
            _Deref_out_ Clr::DkmClrModuleInstance** ppResult
            ) = 0;
    };

    // Interface implemented by the managed DM to obtain information about the current
    // runtime state of the process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmClrRuntimeDebugMonitor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrRuntimeDebugMonitor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a5f24014-9404-5db0-72cd-d4566d8dfcfa") IDkmClrRuntimeDebugMonitor : public IUnknown
    {
        // Obtains non user code status for this instruction address.
        // pClrAddress     : [In] DkmClrInstructionAddress is used for addresses in managed
        // code.
        // pNonUserCodeFlags: [Out] The non user code status for this instruction address.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetNonUserCodeMetadataFlags(
            _In_ Clr::DkmClrInstructionAddress* pClrAddress,
            _Out_ Clr::DkmNonUserCodeFlags::e* pNonUserCodeFlags
            ) = 0;

        // Provides the map of how this method was compiled to native code.
        // pClrAddress     : [In] DkmClrInstructionAddress is used for addresses in managed
        // code.
        // pStackFrame     : [In,Optional] Stack frame where this address is from. This is
        // necessary for CLR v2 support. This argument will be ignored for CLR v4.
        // pMap            : [Out] Structure to define the IL instruction mapping for one or
        // more native instructions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetNativeCodeMap(
            _In_ Clr::DkmClrInstructionAddress* pClrAddress,
            _In_opt_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ DkmArray<Clr::DkmClrNativeCodeMapEntry>* pMap
            ) = 0;

        // Obtains the bytes of the CLR metadata from a given module. These bytes can then be
        // passed to IMetaDataDispenser::OpenScope to decode the metadata.
        // pClrModuleInstance: [In] 'DkmClrModuleInstance' is used for modules which are
        // loaded into the Common Language Runtime.
        // pMetaData       : [Out] The raw metadata for this module.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataBytes(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Out_ DkmArray<BYTE>* pMetaData
            ) = 0;
    };

    // Interface implemented by the managed DM to provide expression evaluators and other
    // components direct access to ICorDebug interfaces.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmClrRuntimeDebugMonitorDirect __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrRuntimeDebugMonitorDirect)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9a0b913c-81d3-13c9-b127-5d088cf85f8b") IDkmClrRuntimeDebugMonitorDirect : public IUnknown
    {
        // Provides direct access to the ICorDebugAppDomain object, which expression
        // evaluators or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        // pAppDomain      : [In] DkmClrAppDomain represents a CLR app domain inside a
        // process which is being debugged.
        // ppCorAppDomain  : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCorAppDomain(
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _Deref_out_ ICorDebugAppDomain** ppCorAppDomain
            ) = 0;

        // Provides direct access to the ICorDebugThread object, which expression evaluators
        // or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pThread         : [In] DkmThread object that should be mapped to the CorDebug
        // thread.
        // ppCorThread     : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCorThread(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _Deref_out_ ICorDebugThread** ppCorThread
            ) = 0;

        // Provides direct access to the ICorDebugProcess object, which expression evaluators
        // or other components can use for inspection.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // ppCorProcess    : [Out] ICorDebug interface representing a process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCorProcess(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _Deref_out_ ICorDebugProcess** ppCorProcess
            ) = 0;

        // Provides direct access to the ICorDebugModule object, which expression evaluators
        // or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        // pClrModuleInstance: [In] 'DkmClrModuleInstance' is used for modules which are
        // loaded into the Common Language Runtime.
        // ppCorModule     : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCorModule(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Deref_out_ ICorDebugModule** ppCorModule
            ) = 0;

        // Provides direct access to the ICorDebugFunction object, which expression
        // evaluators or other components can use to inspect the app domain.
        //
        // The returned interface may ONLY be used to inspect the target process, and should
        // NEVER be used to control execution (no stepping, no breakpoints, no continue,
        // etc). Doing so is unsupported and will result in undefined behavior.
        // pClrAddress     : [In] DkmClrInstructionAddress is used for addresses in managed
        // code.
        // ppCorFunction   : [Out] ICorDebug interface representing an app domain inspection.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCorFunction(
            _In_ Clr::DkmClrInstructionAddress* pClrAddress,
            _Deref_out_ ICorDebugFunction** ppCorFunction
            ) = 0;
    };

    // This API allows an Expression Evaluator to obtain information contained within a CLR
    // PDB File or CLR dynamic module symbol store.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmClrSymbolCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrSymbolCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c4644cb3-10fc-16cd-bd1b-e25a03dbde4f") IDkmClrSymbolCallback : public IUnknown
    {
        // Returns the scopes within a method. There will always be at least one scope.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // MethodId        : [In] DkmClrMethodId is a token/version pair which is used to
        // uniquely identify the symbol store's understanding of a particular CLR method
        // within a module.
        // pScopes         : [Out] DkmClrMethodScopeData[] describes a scope within a method.
        // These are defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreData(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            ) = 0;

        // Returns the first method in the first document.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pMethod         : [Out] DkmClrMethodId is a token/version pair which is used to
        // uniquely identify the symbol store's understanding of a particular CLR method
        // within a module.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFirstMethodInFirstDocument(
            _In_ Symbols::DkmModule* pModule,
            _Out_ Clr::DkmClrMethodId* pMethod
            ) = 0;

        // Returns the scopes within a method. There will always be at least one scope.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // MethodId        : [In] Method Id PreRemap.
        // pRemapToken     : [Out] Method token after the Remap.
        // pScopes         : [Out] DkmClrMethodScopeData[] describes a scope within a method.
        // These are defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreDataPreRemap(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ UINT32* pRemapToken,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            ) = 0;

        // Gets a custom attribute based upon its name. Not to be confused with Metadata
        // custom attributes, these attributes are held in the symbol store.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // ParentToken     : [In] The token of the method where the symbol store attribute is
        // stored.
        // IsPreRemap      : [In] True if the specified token value is not a real method
        // token but rather was internally computed by the compiler before the method was
        // emitted using the CLR image creation APIs.
        // pAttributeName  : [In] The name of the attribute to find.
        // pData           : [Out] The value of the requested symbol store attribute.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTokenSymbolStoreAttribute(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 ParentToken,
            _In_ bool IsPreRemap,
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            ) = 0;

        // Gets the location of the instruction symbol in it's method.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pAsyncLocation  : [Out] The location of the given instruction.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMethodLocation(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ Clr::DkmClrAsyncMethodLocation::e* pAsyncLocation
            ) = 0;

        // Gets the yield and resume points contained within the statement surrounding the
        // given instruction symbol.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pAsyncExpressionInfo: [Out] An array of the yield and resume points for the
        // statement.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAllAwaitExpressionInfoForStatement(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ DkmArray<Clr::DkmClrAwaitExpressionInfo>* pAsyncExpressionInfo
            ) = 0;

        // Gets the optional starting IL offset of an async method's generated catch handler.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pHasCatchHandlerILOffset: [Out] True if async method has a catch handler IL offset
        // in the PDB.
        // pCatchHandlerILOffset: [Out] The catch handler's starting IL offset.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMethodCatchHandlerILOffset(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ bool* pHasCatchHandlerILOffset,
            _Out_ UINT32* pCatchHandlerILOffset
            ) = 0;

        // Get the yield and resume information of the next await expression.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pAwaitExpressionInfo: [Out] Next await expression info.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetNextAwaitExpressionInfo(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ Clr::DkmClrAwaitExpressionInfo* pAwaitExpressionInfo
            ) = 0;

        // If the current method is an async method then return the kickoff method for this
        // async method.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pKickoffMethodToken: [Out] Kickoff method token.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAsyncKickoffMethod(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ UINT32* pKickoffMethodToken
            ) = 0;
    };

    // Enhancement to IDkmClrSymbolCallback to allow it to support ClrNc scenarios.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrSymbolCallback120 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrSymbolCallback120)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f84bbb43-2253-59c4-5cdb-70ad53358374") IDkmClrSymbolCallback120 : public IUnknown
    {
        // Returns the scopes within a method. There will always be at least one scope.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pScopes         : [Out] DkmClrMethodScopeData[] describes a scope within a method.
        // These are defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMethodLocalSymbols(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            ) = 0;

        // Gets a custom attribute based upon its name. Not to be confused with Metadata
        // custom attributes, these attributes are held in the symbol store.
        // pClrInstruction : [In] DkmClrInstructionSymbol represents an IL instruction that
        // runs under the Common Language Runtime (CLR) in the target process. This object
        // contains the method version number. So in Edit-and-Continue scenarios, the
        // instruction symbol would be different for different versions of the method. This
        // object does not contain information about generic binding parameters. So different
        // generic instantiations of a method (ex: MyMethod<string> and MyMethod<int>) are
        // represented by the same instruction symbol since the CLR represents them with a
        // single method token.
        // pAttributeName  : [In] The name of the attribute to find.
        // pData           : [Out] The value of the requested symbol store attribute.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreAttribute(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            ) = 0;
    };

    // Provides APIs to expression evaluators to obtain the signature of local variables and
    // constants.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmClrSymbolSignatureCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrSymbolSignatureCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2503e78b-ebb8-ef6b-1a41-c1fc743e6d5e") IDkmClrSymbolSignatureCallback : public IUnknown
    {
        // Provides the COR_SIGNATURE for a local constant.
        // pClrLocalConstant: [In] Represents a local constant defined within a method scope.
        // These are defined with ISymUnmanagedWriter::DefineConstant or
        // ISymUnmanagedWriter2::DefineConstant2.
        // pSignature      : [Out] The COR_SIGNATURE for the constant, which defines the type
        // of this constant.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSignatureForConstant(
            _In_ Clr::DkmClrLocalConstant* pClrLocalConstant,
            _Out_ DkmArray<BYTE>* pSignature
            ) = 0;

        // Provides the COR_SIGNATURE for a local Variable.
        // pClrLocalVariable: [In] Represents a local variable defined within a method scope.
        // These are defined with ISymUnmanagedWriter::DefineLocalVariable or
        // ISymUnmanagedWriter2::DefineLocalVariable2.
        // pSignature      : [Out] The COR_SIGNATURE for the Variable, which defines the type
        // of this Variable.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSignatureForVariable(
            _In_ Clr::DkmClrLocalVariable* pClrLocalVariable,
            _Out_ DkmArray<BYTE>* pSignature
            ) = 0;
    };

    // Implemented by expression evaluators which support the C# EE's method of custom
    // viewers (i.e. IPropertyProxyEESide). This interface is subject to change in future
    // releases.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    #define IID_IDkmClrUIVisualizerService __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrUIVisualizerService)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1c940299-48aa-be63-2520-d83d3427b07c") IDkmClrUIVisualizerService : public IUnknown
    {
        // Not described (internal API).
        // pPropertyProxy  : [In] Concord wrapper around IPropertyProxyEESide.
        // ppDataOut       : [Out,Optional] the result bytes.
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE InitSourceDataProvider(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;

        // Not described (internal API).
        // pPropertyProxy  : [In] Concord wrapper around IPropertyProxyEESide.
        // ppAssemblyName  : [Out,Optional] Not described (internal API).
        // ppAssemblyBytes : [Out,Optional] Not described (internal API).
        // ppAssemblyPdb   : [Out,Optional] Not described (internal API).
        // ppClassName     : [Out,Optional] class name.
        // pAssemblyResolution: [Out] enum_ASSEMBLYLOCRESOLUTION enumeration.
        // pReplacementOk  : [Out] replacement ok.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetManagedViewerCreationData(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _Deref_out_opt_ DkmString** ppAssemblyName,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppClassName,
            _Out_ UINT32* pAssemblyResolution,
            _Out_ bool* pReplacementOk
            ) = 0;

        // Not described (internal API).
        // pPropertyProxy  : [In] Concord wrapper around IPropertyProxyEESide.
        // DataIn          : [In] Not described (internal API).
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // ppDataOut       : [Out,Optional] Not described (internal API).
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE InPlaceUpdateObject(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;

        // Implements IPropertyProxyEESide::ResolveAssemblyReference().
        // pPropertyProxy  : [In] Concord wrapper around IPropertyProxyEESide.
        // pAssemblyName   : [In] Not described (internal API).
        // Flags           : [In] GETASSEMBLY flags.
        // ppAssemblyBytes : [Out,Optional] Not described (internal API).
        // ppAssemblyPdb   : [Out,Optional] Not described (internal API).
        // ppAssemblyLocation: [Out,Optional] Not described (internal API).
        // pAssemblyResolution: [Out] ASSEMBLYLOCRESOLUTION enum.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ResolveAssemblyReference(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _In_ DkmString* pAssemblyName,
            _In_ UINT32 Flags,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppAssemblyLocation,
            _Out_ UINT32* pAssemblyResolution
            ) = 0;
    };

    // Implemented by expression evaluators which support the C# EE's method of custom
    // viewers (i.e. IPropertyProxyEESide). This interface is subject to change in future
    // releases.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrUIVisualizerService120 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrUIVisualizerService120)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("249ac8c4-54ed-188e-69ad-c8e688482851") IDkmClrUIVisualizerService120 : public IUnknown
    {
        // Not described (internal API).
        // pPropertyProxy  : [In] Concord wrapper around IPropertyProxyEESide.
        // ppDataOut       : [Out,Optional] Not described (internal API).
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetInitialData(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;

        // Not described (internal API).
        // pPropertyProxy  : [In] Concord wrapper around IPropertyProxyEESide.
        // DataIn          : [In] Not described (internal API).
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // ppDataOut       : [Out,Optional] Not described (internal API).
        // Return value    : S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned
        // when *ppDataOut is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE CreateReplacementObject(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;
    };

    // Callback interface implemented by callers of DkmDeploymentCommand.Start to receive
    // notification of events in the deployment command.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SourceId, TransportKind.
    #define IID_IDkmDeploymentCommandCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDeploymentCommandCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bd5a772b-2b1b-636c-aafd-839a7b5c0a0a") IDkmDeploymentCommandCallback : public IUnknown
    {
        // Indication that the launched command has completed. After this is received, no
        // further notifications will be sent.
        // pDeploymentCommand: [In] Object representing an arbitrary executable which is
        // executed on the target computer.
        // ExitCode        : [In] 32-bit value which the processed returned on exit. This is
        // the same value that would be reported from the kernel32!GetExitCodeProcess.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnProcessExit(
            _In_ DefaultPort::DkmDeploymentCommand* pDeploymentCommand,
            _In_ UINT32 ExitCode
            ) = 0;

        // Indication that the target wrote to stdout. This is also used for StdErr if the
        // DkmDeploymentCommandFlags.CombineStdErr flag is used.
        // pDeploymentCommand: [In] Object representing an arbitrary executable which is
        // executed on the target computer.
        // pText           : [In] Text written to stdout.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnStdOut(
            _In_ DefaultPort::DkmDeploymentCommand* pDeploymentCommand,
            _In_ DkmString* pText
            ) = 0;

        // Indication that the target wrote to stderr. This will not be used if the
        // DkmDeploymentCommandFlags.CombineStdErr flag is used. Note that the output from
        // stderr and stdout is not synchronized, so if a program writes to stdout before
        // stderr, a listener may still get the stderr output first (or vice versa).
        // pDeploymentCommand: [In] Object representing an arbitrary executable which is
        // executed on the target computer.
        // pText           : [In] Text written to stderr.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnStdErr(
            _In_ DefaultPort::DkmDeploymentCommand* pDeploymentCommand,
            _In_ DkmString* pText
            ) = 0;
    };

    // IDkmEntryPointNotification is implemented by components that want to listen for the
    // EntryPoint event. IDkmEntryPointNotification is invoked after all implementations of
    // IDkmEntryPointReceived. When this notification is called, the target process is
    // stopped and implementers are able to either inspect the process or cause it to execute
    // in a controlled manner (slip, func-eval).
    //
    // Fired from the breakpoint manager when the entry point breakpoint has been hit.
    //
    // EntryPoint events cannot be suppressed. To override the entry point, implement
    // IDkmEntryPointQuery.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEntryPointNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEntryPointNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("537825af-498e-b770-9103-b6b5fbf5e58d") IDkmEntryPointNotification : public IUnknown
    {
        // OnEntryPoint is invoked as part of event processing. See interface definition for
        // more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnEntryPoint(
            _In_ DkmProcess* pProcess,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmEntryPointReceived is implemented by components that want to listen for the
    // EntryPoint event. IDkmEntryPointReceived is invoked before IDkmEntryPointNotification.
    // From within this notification, it is not possible to cause the target process to
    // execute (no func-eval, no slipping).
    //
    // Fired from the breakpoint manager when the entry point breakpoint has been hit.
    //
    // EntryPoint events cannot be suppressed. To override the entry point, implement
    // IDkmEntryPointQuery.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEntryPointReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEntryPointReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("818a549c-975d-0253-de0d-0ed090868103") IDkmEntryPointReceived : public IUnknown
    {
        // OnEntryPointReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pEventDescriptor: [In] Describes the event being processed.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnEntryPointReceived(
            _In_ DkmProcess* pProcess,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Interface implemented by the exception manager component to allow exception triggers
    // to be enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmExceptionManager __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionManager)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2b0c253b-41ae-8816-3290-e47bfe3e29f1") IDkmExceptionManager : public IUnknown
    {
        // Adds an exception trigger so that ExceptionTriggerHit events will be sent when the
        // exception trigger has been met.
        //
        // If there is already an exception triggered defined for this {SourceId,
        // DkmExceptionTrigger} tuple then the existing trigger will be modified with the new
        // settings. For example, if a component defines a trigger to stop when an access
        // violation exception is thrown and later sets a trigger to fire when any Win32
        // exception goes unhandled, then the access violation trigger will be removed.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // pTrigger        : [In] Describes an exception or collection of exceptions which a
        // component wants to break on. When a higher level components wants to be notified
        // about certain exceptions, it should create one or more exception triggers, and
        // then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when
        // the exception occurs, a ExceptionTriggerHit exception will be fired whenever this
        // trigger is met.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE AddExceptionTrigger(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ Exceptions::DkmExceptionTrigger* pTrigger
            ) = 0;

        // Removes all the exception triggers which have been set with a particular SourceId.
        // After this method returns, the exception triggers will no longer raise
        // ExceptionTriggerHit events. Exception triggers are automatically cleared when the
        // DkmProcess object is closed.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // SourceId        : [In] Identifies the source of an object. SourceIds are used to
        // enable filtering in scenarios when multiple components may be creating instances
        // of a class. For example, source ids can be used to determine if a breakpoint comes
        // from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM
        // level) instead of a breakpoint which may be created by another component (for
        // example an internal breakpoint used for stepping).
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearExceptionTriggers(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId
            ) = 0;
    };

    // Optional internal interface which can be implemented to customize the environment of
    // the GPU target process before it is started. From the debug monitor side, this API, or
    // IDkmGPUEnvironmentFilter, can be implemented.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId.
    #define IID_IDkmGPUEnvironmentFilter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUEnvironmentFilter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("badaf0d3-5c93-a55a-c3f1-1daa99e2b1aa") IDkmGPUEnvironmentFilter : public IUnknown
    {
        // Obtains any environment variables which the extension would like to add.
        // pDebugLaunchSettings: [In] Settings supplied during a start debugging operation
        // from a project system or other caller of LaunchDebugTargets (or various other
        // start debugging APIs).
        // Scenario        : [In] Enumeration of the scenarios where
        // IDkmProcessLaunchEnvironmentFilter implementations are invoked.
        // ppAdditionalEnvironmentBlock: [Out,Optional] One or more environment variables
        // which should be passed to the target process. Multiple variables are separated
        // with an embedded null ('\0'). For example: "MyVariable1=1\0MyVariable2=12".
        //
        // Null or empty string are returned if the caller doesn't want to customize the
        // environment block for this launch.
        // Return value    : S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL,
        // S_FALSE is returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes
        // are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetGPUAdditionalEnvironmentVariables(
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario::e Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            ) = 0;
    };

    // IDkmHeuristicStackWalker is invoked by the stack provider. It is invoked when
    // attempting to walk through frames without symbols.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmHeuristicStackWalker __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmHeuristicStackWalker)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("313dd6f8-9b34-364a-1434-e0ddc85ce48e") IDkmHeuristicStackWalker : public IUnknown
    {
        // Attempt to walk through a region of the stack using a heuristic stack walk
        // algorithm. This is used in x86 when no symbols are available. It is not
        // implemented on other platforms as PDATA allows walking of all frames.
        // pStackWalkContext: [In] DkmStackWalkContext allows the various components which
        // walk, filter, or examine call stacks to store private data which is associated
        // with this call stack.
        // pRegisters      : [In] Registers to attempt to walk from.
        // RequestSize     : [In] RequestSize is the number of frames that the caller would
        // like returned. The implementation of HeuristicWalkFrames may return fewer frames
        // in the case that stack does not contain that many frames.
        // EndStackPointer : [In] Stack address to stop the unwinding at. This value is
        // UInt64.MaxValue if the no end stack pointer is present.
        // pFrames         : [Out] DkmStackWalkFrame[] represents a frame on a call stack
        // which has been walked, but may not have been formatted or filtered. Formatted
        // frames are represented by DkmStackFrame instead.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppNextRegisters : [Out,Optional] NextRegisters indicates the registers of the next
        // frame (the caller of 'FrameObject'). This will be null if the stack is complete,
        // or if the EndStackPointer was reached.
        // pEndOfStack     : [Out] Returns true if the monitor reached the end of the stack.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE HeuristicWalkFrames(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 RequestSize,
            _In_ UINT64 EndStackPointer,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Out_ bool* pEndOfStack
            ) = 0;
    };

    // Interface to provide IIS debugging facilities to the SDM.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmIISDebuggingServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIISDebuggingServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("251e4dab-7136-dce5-a863-d287c5e5bdba") IDkmIISDebuggingServices : public IUnknown
    {
        // Internal API to diagnose IIS start debugging failures.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pUrl            : [In] URL that the debug verb was sent to.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DiagnoseRemoteWebDebuggingError(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pUrl
            ) = 0;
    };

    // Interface to provide URL->Work process resolution on the Visual Studio computer.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmIISResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIISResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("92a528b4-98bd-8f15-52c4-74a15a6da8c5") IDkmIISResolver : public IUnknown
    {
        // Internal API to determine the IIS processes which the debugger should
        // automatically attach to.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pUrl            : [In] URL that the debug verb was sent to.
        // pDnsNames       : [In] Semi-colon delimitated string of addresses that URL's host
        // name resolves to. These are only IPv4 addresses because IIS only supports
        // filtering on IPv4 addresses. This resolution is always done on the VS computer to
        // match the request from IE.
        // pProcesses      : [Out] IIS worker processes to attach to.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // ppExceptionText : [Out,Optional] Exception text for any caught exception. This may
        // be present in the S_FALSE case.
        // Return value    : S_OK is returned if pProcesses contains any elements, S_FALSE is
        // indicates the array is empty, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE ResolveUrlToProcessIds(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pUrl,
            _In_ DkmString* pDnsNames,
            _Out_ DkmArray<UINT32>* pProcesses,
            _Deref_out_opt_ DkmString** ppExceptionText
            ) = 0;
    };

    // Interface to provide process specific instruction addresses.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInstructionAddressProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionAddressProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c26a0dec-b1da-600d-f8c0-51c334bdbb13") IDkmInstructionAddressProvider : public IUnknown
    {
        // Resolves a CPU InstructionAddress to a DkmInstructionAddress.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // InstructionPointer: [In] Memory address where the native instruction is located.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetInstructionAddress(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT64 InstructionPointer,
            _In_ IDkmCompletionRoutine<DkmGetInstructionAddressAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by components that wish to receive notification when the base
    // debug monitor performs a memory write to the instruction stream. This interface may
    // only be implemented in the monitor process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInstructionPatchNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionPatchNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5068f663-791d-e66a-bf5e-459a63325fc6") IDkmInstructionPatchNotification : public IUnknown
    {
        // Method called by the base debug monitor to inform other components that the
        // instruction memory of the target process was modified. Currently, this is only
        // used for breakpoint insertion.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to write the target process's
        // memory.
        // OriginalMemory  : [In] The original code bytes which were replaced in the target
        // process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnInstructionPatchInserted(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& OriginalMemory
            ) = 0;

        // Method called by the base debug monitor to inform other components that the
        // instruction memory of the target process was restored to its original state.
        // Currently, this is only used for breakpoint removal.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Address         : [In] The base address from which to write the target process's
        // memory.
        // OriginalMemory  : [In] The original code bytes which were restored in the target
        // process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnInstructionPatchRemoved(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& OriginalMemory
            ) = 0;
    };

    // Obtains information to construct continuation frames of a managed task.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedAsyncTaskDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedAsyncTaskDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c6201787-bdb7-f70d-9bc1-2cc581ca1c7d") IDkmManagedAsyncTaskDecoder : public IUnknown
    {
        // Returns a list of frames that will execute when this task completes.  The order
        // that the frames will execute in is arbitrary and might not be the order returned
        // here.  Only frames that will execute as a direct result of this task are included,
        // not frames that will execute as a result of another task that will execute after
        // this task completes.
        // pAsyncStackWalkContext: [In] Provides a context for walking async return stacks
        // and task creation stacks.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetManagedTaskContinuationFrames(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetManagedTaskContinuationFramesAsyncResult>* pCompletionRoutine
            ) = 0;

        // Returns a list of frames that will execute when this task completes.  The order
        // that the frames will execute in is arbitrary and might not be the order returned
        // here.  Only frames that will execute as a direct result of this task are included,
        // not frames that will execute as a result of another task that will execute after
        // this task completes.
        // pAsyncStackWalkContext: [In] Provides a context for walking async return stacks
        // and task creation stacks.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pTaskObject     : [In] The task object that we are retrieving continuation frames
        // from.
        // pTaskAppDomain  : [In] The AppDomain of the Task object.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetContinuationFramesFromTaskObject(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ ICorDebugHandleValue* pTaskObject,
            _In_ Clr::DkmClrAppDomain* pTaskAppDomain,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetContinuationFramesFromTaskObjectAsyncResult>* pCompletionRoutine
            ) = 0;

        // Returns the task handle that was used to create this frame.
        // pManagedReturnStackFrame: [In] Contains information needed to construct a managed
        // DkmStackWalkFrame.
        // ppTaskHandle    : [Out] The task handle that matches this frame.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskHandleFromManagedReturnFrame(
            _In_ Clr::DkmManagedReturnStackFrame* pManagedReturnStackFrame,
            _Deref_out_ ICorDebugHandleValue** ppTaskHandle
            ) = 0;
    };

    // Interface provided by the managed debug monitor to continue the process for a managed
    // function evaluation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmManagedFuncEvalServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedFuncEvalServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a22ace5c-f5d0-89dd-97d7-e9b93c5fed9e") IDkmManagedFuncEvalServices : public IUnknown
    {
        // Continue the process and wait for a func-eval to complete.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pThread         : [In] The thread for which to do the func-eval.
        // pCorEval        : [In] The object.
        // FuncEvalFlags   : [In] Function evaluation flags.
        // Timeout         : [In] The timeout.
        // pEvaluationString: [In] The text being evaluated. Displayed in the call stack
        // window if the function evaluation re-enters break mode.
        // pResult         : [Out] The result of doing the function evaluation. S_OK if all
        // went well. Other possible values include S_EVAL_TIMEDOUT, S_EVAL_ABORTED, or
        // E_PROCESS_DESTROYED.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ContinueForFuncEval(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ ICorDebugEval* pCorEval,
            _In_ Evaluation::DkmFuncEvalFlags::e FuncEvalFlags,
            _In_ UINT32 Timeout,
            _In_ DkmString* pEvaluationString,
            _Out_ HRESULT* pResult
            ) = 0;

        // Checks if the given thread is in a state in which the CLR supports managed
        // func-evals.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pResult         : [Out] The result of doing the function evaluation. S_OK if all
        // went well. Other possible values include E_EVAL_FUNCEVAL_IN_MINIDUMP or
        // S_EVAL_BAD_THREAD_STATE.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CanDoFuncEval(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _Out_ HRESULT* pResult
            ) = 0;
    };

    // Interface implemented by sampler to obtain sampled managed heap.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedHeapSampler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedHeapSampler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ebb0305-8e03-b0f8-8733-9325a2219e26") IDkmManagedHeapSampler : public IUnknown
    {
        // Initializes heap sampler.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // TargetObjectCount: [In] The number of sampled objects to return.
        // LiveObjectStatsOnly: [In] Whether the sampler should calculate stats for only the
        // live objects on the heap.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 TargetObjectCount,
            _In_ bool LiveObjectStatsOnly
            ) = 0;

        // Walks the given number of objects on the heap.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // RequestCount    : [In] Count of items requested.
        // pFetchedCount   : [Out] Count of items fetched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            ) = 0;

        // Walks the given number of references on the heap.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // RequestCount    : [In] Count of items requested.
        // pFetchedCount   : [Out] Count of items fetched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            ) = 0;

        // Walks the given number of GC roots on the heap.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // RequestCount    : [In] Count of items requested.
        // pFetchedCount   : [Out] Count of items fetched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            ) = 0;

        // Returns the next requested portion of serialized object graph data.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Sampled heap data.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSampledHeapData(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<BYTE>* pItems
            ) = 0;

        // Returns the heap type stats.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // pItems          : [Out] Sampled heap type stats.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSampledHeapTypeStats(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _Out_ DkmArray<Clr::DkmManagedHeapTypeInfo>* pItems
            ) = 0;

        // Returns roots from the sampled heap.
        // pManagedHeapSampler: [In] DkmManagedHeapSampler represents a sampler for objects
        // in the managed heap.
        // pItems          : [Out] Sampled heap roots.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetRoots(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            ) = 0;
    };

    // Interface implemented by managed dm to allow walking the managed heap.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedHeapWalker __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedHeapWalker)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d19e8743-c1aa-7d86-7d40-55862926d93c") IDkmManagedHeapWalker : public IUnknown
    {
        // Prepares enumerator for walking the objects in the heap, returns error if heap
        // cannot be enumerated.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker
            ) = 0;

        // Prepares enumeration for reporting references between objects in the heap, returns
        // error if heap cannot be enumerated.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapReferenceWalk(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker
            ) = 0;

        // Prepares enumeration for reporting roots in the heap, returns error if heap cannot
        // be enumerated.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a
        // state that can be enumerated.
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapRootsWalk(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker
            ) = 0;

        // Returns the next set of objects from the enumeration.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Array containing the managed heap object infos.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapObjectInfo>* pItems
            ) = 0;

        // Returns the next set of elements from the enumeration.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Array containing the managed heap reference infos.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedObjectReferenceInfo>* pItems
            ) = 0;

        // Returns the next set of roots from the enumeration.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // RequestCount    : [In] Count of items requested.
        // pItems          : [Out] Array containing the managed heap root infos.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            ) = 0;

        // Gets the type names for the given type ids.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // TypeIds         : [In] The list of managed type ids.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pTypeNames      : [Out] The list of type names.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTypeNames(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ const DkmArray<Clr::DkmManagedTypeId>& TypeIds,
            _Out_ DkmArray<DkmString*>* pTypeNames
            ) = 0;

        // Gets the list of segments in the heap.
        // pManagedHeapWalker: [In] DkmManagedHeapWalker represents an enumerator for managed
        // heap.
        // pSegments       : [Out] The list of heap segments.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSegments(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _Out_ DkmArray<Clr::DkmManagedHeapSegmentInfo>* pSegments
            ) = 0;
    };

    // Obtains managed return value information from ManagedDM for evaluation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedReturnValueFetcher __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedReturnValueFetcher)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ab682bc-c602-8c59-6bb7-4efe9bbb0737") IDkmManagedReturnValueFetcher : public IUnknown
    {
        // Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        // pManagedReturnValueContext: [In] Provides a context for managed return value.
        // ppValueInfo     : [Out] Return value from CLR.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetReturnValueInfo(
            _In_ Clr::DkmManagedReturnValueContext* pManagedReturnValueContext,
            _Deref_out_ Clr::DkmManagedReturnValueInfo** ppValueInfo
            ) = 0;
    };

    // Used by ManagedDM to query code path info.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedSteppingCodePathProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedSteppingCodePathProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("132fa9df-a8eb-caf0-0d83-856e70510813") IDkmManagedSteppingCodePathProvider : public IUnknown
    {
        // GetCodePathsInRange is called to get code paths in specific IL range.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pCorFrame       : [In] The ICorDebugFrame to query for code paths.
        // StartILOffset   : [In] Specifies the query start IL offset, inclusively.
        // EndILOffset     : [In] Specifies the query end IL offset, inclusively.
        // pCodePaths      : [Out] DkmSteppingCodePath[] represents a location that user can
        // step to from current location.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCodePathsInRange(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ ICorDebugFrame* pCorFrame,
            _In_ UINT32 StartILOffset,
            _In_ UINT32 EndILOffset,
            _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
            ) = 0;
    };

    // Provides services to task providers and to Debug Monitors for getting managed task
    // information.  This is implemented by the Shim Managed EE.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedTaskServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedTaskServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("71275006-d86e-b4a7-7126-0eaed1503f3b") IDkmManagedTaskServices : public IUnknown
    {
        // Gets the metadata token for a CLR method.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pClassName      : [In] The fully qualified class name.
        // pMethodName     : [In] The method name.
        // MethodArguments : [In] The list of fully qualified arguments for the method.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // pMetadataToken  : [Out] The metadata token or 0 if not found.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMethodMetadataToken(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmString* pClassName,
            _In_ DkmString* pMethodName,
            _In_ const DkmArray<DkmString*>& MethodArguments,
            _Out_ UINT32* pMetadataToken
            ) = 0;

        // Get a DkmManagedTaskInfo from a stack frame parameter.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pStackFrame     : [In] The stack frame to get the task info from.
        // ArgumentIndex   : [In] The index of the task argument.
        // pTaskInfo       : [Out] The DkmManagedTaskInfo for the task.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskInfoFromFrame(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ UINT32 ArgumentIndex,
            _Out_ ParallelTasks::DkmManagedTaskInfo* pTaskInfo
            ) = 0;

        // Get a DkmManagedTaskInfo array from a stack frame parameter.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pStackFrame     : [In] The stack frame to get the task info from.
        // ArgumentIndex   : [In] The index of the task argument.
        // pTaskInfoArray  : [Out] The DkmManagedTaskInfo array for the tasks.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskInfoArrayFromFrame(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ UINT32 ArgumentIndex,
            _Out_ DkmArray<ParallelTasks::DkmManagedTaskInfo>* pTaskInfoArray
            ) = 0;

        // Get a DkmManagedTaskInfo from an ICorDebugHandleValue.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pTaskHandle     : [In] The ICorDebugHandleValue for the task.
        // pAppDomain      : [In] The AppDomain of the task.
        // pTaskInfo       : [Out] The DkmManagedTaskInfo for the task.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskInfoFromHandle(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ ICorDebugHandleValue* pTaskHandle,
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _Out_ ParallelTasks::DkmManagedTaskInfo* pTaskInfo
            ) = 0;
    };

    // Exposes properties of a managed thread such as Managed Thread ID.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmManagedThreadProperties __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedThreadProperties)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6facf9de-f299-7f13-184c-6356ed266681") IDkmManagedThreadProperties : public IUnknown
    {
        // Get a managed thread's properties.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pManagedThreadId: [Out] The managed thread id of the thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetManagedThreadProperties(
            _In_ DkmThread* pThread,
            _Out_ INT32* pManagedThreadId
            ) = 0;
    };

    // IDkmMergedMonitorStackWalk is invoked by the stack provider. It will arbitrate between
    // the various implementations of IDkmMonitorStackWalk to walk portions of the stack
    // which should be walked inside the monitor (instead of walked inside the engine).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmMergedMonitorStackWalk __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMergedMonitorStackWalk)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1f06bb96-5e18-46d8-648d-3eb252339537") IDkmMergedMonitorStackWalk : public IUnknown
    {
        // Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call
        // stack is still valid.
        // pStackWalkContext: [In] DkmStackWalkContext allows the various components which
        // walk, filter, or examine call stacks to store private data which is associated
        // with this call stack.
        // RequestSizeHintIfCacheIsValid: [In] RequestSizeHintIfCacheIsValid is a hint as to
        // the number of frame that the caller needs. This value is treated as a hint because
        // this API can return frames which are not yet walked, so this API may return more
        // or less than the hint value.  A request size hint of 0 means not to do any stack
        // walking at all if the cache is valid.
        // RequestSizeHintIfCacheIsInvalid: [In] RequestSizeHintIfCacheIsInvalid is a hint as
        // to the number of frame that the caller needs. This value is treated as a hint
        // because this API can return frames which are not yet walked, so this API may
        // return more or less than the hint value.
        // pCachedHash     : [In,Optional] Cached call stack hash, will not walk the stack if
        // cache is still valid.  This parameter is optional.  If null, we will still compute
        // the actual hash and do the stack walk, but will skip the comparing of the actual
        // hash against the cached hash to suppress the stack walk.
        // pFrames         : [Out] Array of walked frames. For, unresolved frames, both
        // InstructionAddress and Description will be null.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pEndOfStack     : [Out] Returns true if the monitor reached the end of the stack.
        // ppActualStackHash: [Out,Optional] The actual hash of the call stack.  This may be
        // NULL for runtimes that don't support call stack hashing.
        // ppActualStackWalkContext: [Out] The DkmStackWalkContext object that can used later
        // to continue the walk. If the cache is valid, this is the original context.  If the
        // cache is invalid, this will be a new DkmStackWalkContext object.
        // pIsCacheValid   : [Out] True if the cache was valid, false if not.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE RuntimeWalkNextFramesAndCheckCache(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ UINT32 RequestSizeHintIfCacheIsValid,
            _In_ UINT32 RequestSizeHintIfCacheIsInvalid,
            _In_opt_ CallStack::DkmStackHash* pCachedHash,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack,
            _Deref_out_opt_ CallStack::DkmStackHash** ppActualStackHash,
            _Deref_out_ CallStack::DkmStackWalkContext** ppActualStackWalkContext,
            _Out_ bool* pIsCacheValid
            ) = 0;

        // Attempt to walk the stack without the use of symbols. This will call into various
        // components that know how to walk portions of the stack (ex: CLR frames will be
        // walked by the CLR debug monitor). An 'unresolved' frame will be left for portions
        // of the stack which cannot be walked without information stored within the symbol
        // file. These 'unresolved' frames have no InstructionAddress or Description.
        // pStackWalkContext: [In] DkmStackWalkContext allows the various components which
        // walk, filter, or examine call stacks to store private data which is associated
        // with this call stack.
        // RequestSizeHint : [In] RequestSizeHint is a hint as to the number of frame that
        // the caller needs. This value is treated as a hint because this API can return
        // frames which are not yet walked, so this API may return more or less than the hint
        // value.
        // pFrames         : [Out] Array of walked frames. For, unresolved frames, both
        // InstructionAddress and Description will be null.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pEndOfStack     : [Out] Returns true if the monitor reached the end of the stack.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE RuntimeWalkNextFrames(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ UINT32 RequestSizeHint,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack
            ) = 0;

        // Return the top stack frame for a thread. This frame can come from a runtime
        // instance, or a monitor unwinder. This can only be called from the server process.
        // To obtain the top frame in the client process, use GetTopStackFrame.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pRuntimeInstance: [In] The runtime instance of the frame.
        // ppFrame         : [Out] The top stack frame.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTopStackWalkFrame(
            _In_ DkmThread* pThread,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppFrame
            ) = 0;
    };

    // Obtains information about the minidump being debugged.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmMinidumpQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMinidumpQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("75081e2d-93e7-3cb3-9eda-d8f00ce6b4da") IDkmMinidumpQuery : public IUnknown
    {
        // Returns the path to the primary executable in the minidump being debugged.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // ppExePath       : [Out] Path to the debuggee's primary executable file.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetDumpExePath(
            _In_ DkmProcess* pProcess,
            _Deref_out_ DkmString** ppExePath
            ) = 0;
    };

    // When managed minidump debugging, determines whether metadata is available for a given
    // module instance.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmModuleMetadataStatusQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleMetadataStatusQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b4867696-9369-efd5-22e7-dd1d035989f6") IDkmModuleMetadataStatusQuery : public IUnknown
    {
        // Get metadata status.
        // pClrModuleInstance: [In] 'DkmClrModuleInstance' is used for modules which are
        // loaded into the Common Language Runtime.
        // pMetadataStatus : [Out] Metadata status.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetMetadataStatus(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Out_ Clr::DkmMetadataStatus::e* pMetadataStatus
            ) = 0;
    };

    // Provides decoding of export tables in Windows PE files.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmNativeExportTableDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeExportTableDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("29e2f2c0-4eb4-2b46-6992-4444cd14e34b") IDkmNativeExportTableDecoder : public IUnknown
    {
        // Finds the nearest module export from the specified instruction address. The export
        // could either be a function or data export, though function exports are far more
        // common. Because exports do not have address ranges, the specified address may not
        // actually be associated with the returned export.
        // pNativeAddress  : [In] DkmNativeInstructionAddress is used for addresses that
        // resolve to within a native module. This is used regardless as to if there are
        // symbols for the module.
        // ppExportName    : [Out,Optional] Name of the export.
        // pByteOffset     : [Out] Byte offset from the start of the export.
        // Return value    : S_OK is returned if *ppExportName is non-NULL, S_FALSE is
        // returned when *ppExportName is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE FindNearestExport(
            _In_ Native::DkmNativeInstructionAddress* pNativeAddress,
            _Deref_out_opt_ DkmString** ppExportName,
            _Out_ INT32* pByteOffset
            ) = 0;

        // Finds the address of the specified named exported function (or data export).
        // pNativeModuleInstance: [In] 'DkmNativeModuleInstance' is used for modules which
        // contain CPU code and/or are loaded by the Win32 loader.
        // pName           : [In] The export name to search for in the module's export table.
        // IgnoreDataExports: [In] If true, the implementation will ignore any export which
        // is in non-executable memory.
        // ppAddress       : [Out,Optional] If the export was found in the specified module,
        // this will contain the target address. Note that this instruction address object
        // may be in a different module than the searched module. This can happen if the
        // export was forwarded and the destination module is already loaded. If the
        // destination module is not loaded, the export will be ignored.
        // Return value    : S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned
        // when *ppAddress is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE FindExportName(
            _In_ Native::DkmNativeModuleInstance* pNativeModuleInstance,
            _In_ DkmString* pName,
            _In_ bool IgnoreDataExports,
            _Deref_out_opt_ Native::DkmNativeInstructionAddress** ppAddress
            ) = 0;
    };

    // IDkmReturnValuesNotification is implemented by components that want to listen for the
    // ReturnValues event. The target process may continue to run during this notification.
    // The ReturnValues event is sent during a step, when one or more DkmRawReturnValues have
    // been collected.  The actual evaluation will be performed on the StepComplete event on
    // the thread where the Return Values were recorded.
    //
    // ReturnValues events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmReturnValuesNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmReturnValuesNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9ec52d3e-017f-65ed-fa75-a6b1c1eebe71") IDkmReturnValuesNotification : public IUnknown
    {
        // OnReturnValues is invoked as part of event processing. See interface definition
        // for more information.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // pReturnValues   : [In,Optional] DkmRawReturnValues recorded.
        // LastValueInCurrentContext: [In] If true, it is valid to use the current thread
        // context to evaluate the last return value.  This is true only in the case
        // immediately after processing the return instruction, and so should only be set if
        // raising this event immediately before, and on the same thread, as the StepComplete
        // event.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnReturnValues(
            _In_ Stepping::DkmStepper* pStepper,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmRawReturnValue*>* pReturnValues,
            _In_ bool LastValueInCurrentContext,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Interface implemented by the base DM services to provide a process listing, and
    // provide basic information about running processes without attaching a debugger to the
    // process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmRunningProcessInfoProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRunningProcessInfoProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e8a1cd8d-e271-c089-189a-55dc4d08ad66") IDkmRunningProcessInfoProvider : public IUnknown
    {
        // Provides a listing of all the processes running on the target computer (including
        // processes not being debugged).
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // IncludeFromAllUsers: [In] If true, processes from all users should be included.
        // RequestedPropertyMask: [In] Flags indicating which properties of
        // DkmRunningProcessInfo should be computed.
        // pProcesses      : [Out] Array of processes running on the target computer.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnumRunningProcesses(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ bool IncludeFromAllUsers,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask,
            _Out_ DkmArray<DefaultPort::DkmRunningProcessInfo*>* pProcesses
            ) = 0;

        // Obtain information about a process running on the target computer.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // Id              : [In] Process Id (PID) assigned by the operating system.
        // StartTime       : [In] 64-bit date time value indicating when the process was
        // started. The start time along with the id and the machine where the process was
        // started can uniquely identify a process. '0' can be passed if the start time is
        // unknown.
        // IsDebuggee      : [In] When true, the request will fail if the debugger has
        // insufficient privileges to complete the request. If false, the implementation
        // should calculate what it can.
        // RequestedPropertyMask: [In] Flags indicating which properties of
        // DkmRunningProcessInfo should be computed.
        // ppProcessInfo   : [Out] Information about the requested process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetRunningProcessInfo(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ bool IsDebuggee,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppProcessInfo
            ) = 0;

        // Called by the SDM prior to start debugging. It is used to obtain current
        // information about the process, ensure that the process can be debugged, and to
        // make any operating system configuration changes (ex: enabling enhanced error
        // reporting) to improve debugging.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // Id              : [In] Process Id (PID) assigned by the operating system.
        // StartTime       : [In] 64-bit date time value indicating when the process was
        // started. The start time along with the id and the machine where the process was
        // started can uniquely identify a process. '0' can be passed if the start time is
        // unknown.
        // RequestedPropertyMask: [In] Flags indicating which properties of
        // DkmRunningProcessInfo should be computed.
        // ppProcessInfo   : [Out] Information about the requested process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE PrepareForDebuggingProcess(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppProcessInfo
            ) = 0;

        // Terminates a process running on target computer which is not being debugged.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // Id              : [In] Process Id (PID) assigned by the operating system.
        // StartTime       : [In] 64-bit date time value indicating when the process was
        // started. The start time along with the id and the machine where the process was
        // started can uniquely identify a process. '0' can be passed if the start time is
        // unknown.
        // ExitCode        : [In] The exit code to be used by the process and threads
        // terminated as a result of this call. Use the GetExitCodeProcess function to
        // retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a
        // thread's exit value.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TerminateRunningProcess(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ UINT32 ExitCode
            ) = 0;

        // Provides information about the computer where the debug monitor is running.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // NativeSystemInfo: [In] If true and if the debug monitor is running under WOW64,
        // this function will return information about the native subsystem rather than WOW.
        // If the debug monitor is not running under WOW, this function is ignored.
        // ppSystemInfo    : [Out] Object describing the system where the debugger is
        // running.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSystemInformation(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ bool NativeSystemInfo,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppSystemInfo
            ) = 0;

        // Provides the version string for the CLR that the debugger expects a given
        // executable to load. The return value is based on the content of the executable's
        // PE header (if the exe is managed), the executable's config file, CLR environment
        // variables, and loader policy in the registry. The return value may be incorrect,
        // especially in the case of a native executable.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pExePath        : [In] Path to the executable file.
        // ppClrVersionString: [Out] Version string of the CLR. Ex:'v4.0.30319'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetClrVersionOfExecutable(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pExePath,
            _Deref_out_ DkmString** ppClrVersionString
            ) = 0;

        // Determines if the given executable file will execute within WOW64 (Windows On
        // Windows), which is used to execute 32-bit processes on a 64-bit OS.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // pExePath        : [In] Path to the executable file.
        // pResult         : [Out] true if the specified executable file will execute under
        // WOW.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE QueryIsWOW64Executable(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pExePath,
            _Out_ bool* pResult
            ) = 0;

        // Returns the version of the CLR which is loaded in the monitor process.
        // pConnection     : [In] This represents a connection between the monitor and the
        // IDE. It can either be a local connection if the monitor is running in the same
        // process as the IDE, or it can be a remote connection. In the monitor process,
        // there is only one connection.
        // ppClrVersionString: [Out] Version string of the CLR. Ex:'v4.0.30319'.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetDefaultClrVersion(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _Deref_out_ DkmString** ppClrVersionString
            ) = 0;
    };

    // This interface is implemented by the breakpoint manager so it can receive notification
    // that a runtime function resolution request has resolved into a new function.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId.
    #define IID_IDkmRuntimeFunctionResolverClient __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeFunctionResolverClient)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a7e133e3-3039-9082-21da-bc009198b0ae") IDkmRuntimeFunctionResolverClient : public IUnknown
    {
        // Called by runtime function resolvers when a new resolution has been discovered for
        // a DkmRuntimeFunctionResolutionRequest instance.
        // pRuntimeFunctionResolutionRequest: [In] DkmRuntimeFunctionResolutionRequest
        // represents an expression to be parsed and evaluated by a runtime based expression
        // evaluator and is bound to a particular process. Resolutions will send
        // DkmModuleInstance::FunctionResolved events.
        // pAddress        : [In] The address the request bound to. Multiple addresses will
        // result in multiple calls to this function.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnFunctionResolved(
            _In_ FunctionResolution::DkmRuntimeFunctionResolutionRequest* pRuntimeFunctionResolutionRequest,
            _In_ DkmInstructionAddress* pAddress
            ) = 0;

        // Called by runtime function resolvers when the resolver wishes to notify its client
        // an error/warning occurred while attempting to resolve the breakpoint.
        // pRuntimeFunctionResolutionRequest: [In] DkmRuntimeFunctionResolutionRequest
        // represents an expression to be parsed and evaluated by a runtime based expression
        // evaluator and is bound to a particular process. Resolutions will send
        // DkmModuleInstance::FunctionResolved events.
        // Level           : [In] Describes the severity of a message sent from a breakpoint
        // manager back to the source component. This list is sorted in order of priority, as
        // the UI will only display the most important warning. All warnings are ignored if
        // the breakpoint is bound.
        // pMessage        : [In] Message string to display to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnResolverMessage(
            _In_ FunctionResolution::DkmRuntimeFunctionResolutionRequest* pRuntimeFunctionResolutionRequest,
            _In_ Breakpoints::DkmBreakpointMessageLevel::e Level,
            _In_ DkmString* pMessage
            ) = 0;
    };

    // This interface allows Concord components to compare two ICorDebugHandleValue objects'
    // values by routing the calls to GetValue through the shim EE in order to have the
    // proper LocalContext set up.  Calling GetValue directly on a ICorDebugHandleValue
    // object from Concord will result in an exception thrown from the VIL host.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeHandleComparer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeHandleComparer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1191179b-74b8-e0a5-b043-951e4ab33484") IDkmRuntimeHandleComparer : public IUnknown
    {
        // This method takes two ICorDebugHandleValues, calls GetValue on each, and compares
        // the resulting values to see if they are equal.  If necessary, it will set up a
        // LocalContext for the VIL interpreter.
        // pClrRuntimeInstance: [In] Represents a CLR instance running in a target process.
        // pHandleValue1   : [In] The first ICorDebugHandleValue object.
        // pHandleValue2   : [In] The second ICorDebugHandleValue object.
        // pEqual          : [Out] Set to true if the two given ICorDebugHandleValue objects
        // have the same value, false otherwise.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CompareHandleValuesThroughVil(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ ICorDebugHandleValue* pHandleValue1,
            _In_ ICorDebugHandleValue* pHandleValue2,
            _Out_ bool* pEqual
            ) = 0;
    };

    // Interface to update components when the project item path is set for a script
    // document.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentSourceProjectItemChanged __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentSourceProjectItemChanged)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c34aab5d-d57c-d163-e4c6-4beaeab324ab") IDkmScriptDocumentSourceProjectItemChanged : public IUnknown
    {
        // Called when 'SourceProjectItem' is changed.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnSourceProjectItemChanged(
            _In_ Script::DkmScriptDocument* pScriptDocument
            ) = 0;
    };

    // IDkmScriptJmcStateChangeNotification is implemented by components that want to be
    // notified when the JMC state changes for a script document.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmScriptJmcStateChangeNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptJmcStateChangeNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d1472ad3-9aea-c4d7-8fd5-bf9cd2d8a69b") IDkmScriptJmcStateChangeNotification : public IUnknown
    {
        // This method is called by the dispatcher when the JMC state of a script document
        // changes.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnJmcStateChanged(
            _In_ Script::DkmScriptDocument* pScriptDocument
            ) = 0;
    };

    // Provides the stack for view by the user. This stack has been filtered, annotated, and
    // mixed together.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmStackProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStackProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("05a9eaaf-64af-63fa-36b1-2e59b5522b81") IDkmStackProvider : public IUnknown
    {
        // Obtain the next frames from the call stack. If this is the first call on a
        // particular DkmStackContext then this will return the first frames. This method is
        // the recommended way to obtain the call stack because the stack provider maintains
        // a cache of the physical stack.
        // pStackContext   : [In] DkmStackContext objects are created by components that wish
        // to request the stack from the stack provider. A component needs to close the
        // context after they have completed the stack walk. To obtain the stack a component
        // should create this object and then call GetNextFrames.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // RequestSize     : [In] RequestSize is the number of frames that the caller would
        // like returned. The implementation of GetNextFrames may return fewer frames in the
        // case that stack does not contain that many frames. Negative values, or request to
        // read more than MaxFrames (currently 5,000) will be capped to MaxFrames.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetNextFrames(
            _In_ CallStack::DkmStackContext* pStackContext,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSize,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetNextFramesAsyncResult>* pCompletionRoutine
            ) = 0;

        // Format a DkmStackWalkFrame into a DkmStackFrame. Formatting a frame is one step of
        // what the stack provider does during GetNextFrames. This method can be used to
        // format a frame in a different way than was originally performed by the stack
        // provider in GetNextFrames.
        // pFrame          : [In] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // pInspectionSession: [In] DkmInspectionSession allows the various components which
        // inspect data to store private data which is associated with a group of
        // evaluations.
        // Options         : [In] Collection of settings that affect how the stack provider
        // formats a DkmStackFrame.
        // ppFormattedFrame: [Out] DkmStackFrame represents a frame on the call stack after
        // filtering and translation.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Format(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const CallStack::DkmFrameFormatOptions& Options,
            _Deref_out_ CallStack::DkmStackFrame** ppFormattedFrame
            ) = 0;

        // Returns the top call stack frame for a thread. This value is normally cached after
        // the first stack walk and cleared on continue. This is only callable above the
        // stack provider in the client process. To obtain the top frame in the server
        // process, call GetTopStackWalkFrame.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // ppTopFrame      : [Out] DkmStackWalkFrame represents a frame on a call stack which
        // has been walked, but may not have been formatted or filtered. Formatted frames are
        // represented by DkmStackFrame instead.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTopStackFrame(
            _In_ DkmThread* pThread,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppTopFrame
            ) = 0;
    };

    // IDkmStepCompleteNotification is implemented by components that want to listen for the
    // StepComplete event. IDkmStepCompleteNotification is invoked after all implementations
    // of IDkmStepCompleteReceived. When this notification is called, the target process is
    // stopped and implementers are able to either inspect the process or cause it to execute
    // in a controlled manner (slip, func-eval).
    //
    // Sent by a runtime monitor when a step has completed successfully. Note that the step
    // might actually finish on a different thread than it was started on.
    //
    // StepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmStepCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStepCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("89c6cea7-ab24-c1e5-b53d-b1ad5cdc0f3e") IDkmStepCompleteNotification : public IUnknown
    {
        // OnStepComplete is invoked as part of event processing. See interface definition
        // for more information.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // pThread         : [In] The thread the step actually finished on. Normally, this is
        // the same as the thread in DkmStepper, but in some scenarios, it could be
        // different.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the stepping thread. Currently, only managed
        // runtime instances ever set this. This is used to quickly determine if exception
        // specific logic should apply without making another network round-trip.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnStepComplete(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmStepCompleteReceived is implemented by components that want to listen for the
    // StepComplete event. IDkmStepCompleteReceived is invoked before
    // IDkmStepCompleteNotification. From within this notification, it is not possible to
    // cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by a runtime monitor when a step has completed successfully. Note that the step
    // might actually finish on a different thread than it was started on.
    //
    // StepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmStepCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStepCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("af658e40-330a-b079-43ff-a284e8ffb3d1") IDkmStepCompleteReceived : public IUnknown
    {
        // OnStepCompleteReceived is invoked as part of event processing. See interface
        // definition for more information.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // pThread         : [In] The thread the step actually finished on. Normally, this is
        // the same as the thread in DkmStepper, but in some scenarios, it could be
        // different.
        // HasException    : [In] Contains true if the source runtime instance can determine
        // that an exception is in flight on the stepping thread. Currently, only managed
        // runtime instances ever set this. This is used to quickly determine if exception
        // specific logic should apply without making another network round-trip.
        // pEventDescriptor: [In] Describes the event being processed and provides the
        // ability for a component to suppress this event.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnStepCompleteReceived(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Interface of the stepping manager. This component is implemented by Microsoft and it
    // provides stepping arbitration between the various debug monitors active in the
    // process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmSteppingManager __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingManager)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7f43d33d-d66b-ff27-8806-21d23ced8ad2") IDkmSteppingManager : public IUnknown
    {
        // Called by the stopping event manager before a step operation actually begins The
        // stopping event manager will notify all runtime instances so they can setup any
        // necessary state before the the stopping event manager starts blocking function
        // evaluations.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE BeforeEnableNewStepper(
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;

        // Used to initialize a stepper object so that the step will be performed when
        // execution is next resumed. This method is implemented by the stepping manager by
        // finding an appropriate runtime debug monitor, and asking this runtime debug
        // monitor to setup a step. This method should only be called once for a given
        // stepper object.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // RemoveOtherSteppers: [In] Set to true if other steppers are to be removed. This is
        // normally only set in response to user initiated step requests.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnableStepper(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool RemoveOtherSteppers
            ) = 0;

        // Allows a stepper to be cancelled after creation by the controlling runtime
        // instance. The calling runtime instance must match the current controlling runtime
        // instance. This is generally used in cross thread stepping scenarios where the
        // original stepper may be reactivated. The stepping manager will close the stepper
        // and not send step complete.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE CancelStepper(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            ) = 0;

        // Called by the stopping manager prior to resuming execution in order to clear all
        // steppers from a given thread. The stepping manager will call StopStep on the
        // controlling runtime instance and then close the stepper objects.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearSteppers(
            _In_ DkmThread* pThread
            ) = 0;
    };

    // Allows runtime monitors to obtain information from the stepping manager.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmSteppingManagerCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingManagerCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c3ebc33d-5b77-2486-a3b8-256573a63623") IDkmSteppingManagerCallback : public IUnknown
    {
        // Returns the runtime instance currently in-control of this DkmStepper.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // ppRuntimeInstance: [Out] The runtime instance currently in control of this
        // stepper.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetControllingRuntimeInstance(
            _In_ Stepping::DkmStepper* pStepper,
            _Deref_out_ DkmRuntimeInstance** ppRuntimeInstance
            ) = 0;

        // StepControlRequested is called when a non-controlling runtime instance detects
        // that the thread has hit a transition into its runtime. The stepping manager will
        // forward the call to the current controlling runtime instance. If the current
        // controlling runtime instance can stop stepping, it should set Granted to true.
        // Actual control is not given until the requesting runtime calls
        // DkmStepper.TakeStepControl. This two part process allows callers to request
        // control of multiple steppers at the same time.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // pGranted        : [Out] The the controlling runtime can stop the step and give
        // control to the caller, then it should set this to true.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE StepControlRequested(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
            _Out_ bool* pGranted
            ) = 0;

        // TakeStepControl is called when a non-controlling runtime instance detects that the
        // thread has hit a transition into its runtime. The stepping manager will forward
        // the call to the current controlling runtime instance. The runtime instance
        // requesting control should first call StepControlRequested on all steppers it wants
        // control of. If they all set Granted to true, the runtime instance should then call
        // this method on each stepper it is taking control of.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // LeaveGuardsInPlace: [In] Set to true by the caller if it would like the current
        // controlling runtime instance to leave guards in place to stop the step if
        // necessary. For instance, this can be used to leave guard breakpoints after a call
        // instruction so another runtime can step back out if the target of the call doesn't
        // have source. However, any stepping state that affects the immediate step, such as
        // trap flags, should be removed by the controlling runtime instance.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCallingRuntimeInstance: [In] The calling runtime instance that wishes to take
        // control of the step.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TakeStepControl(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool LeaveGuardsInPlace,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            ) = 0;

        // Called by a runtime monitor when a step has left the confines of what the runtime
        // monitor understands or a potential transition into another runtime has been
        // encountered during a step. The stepping manager will initiate stepping arbitration
        // to give each runtime monitor a chance to inspect the process and determine which
        // runtime should complete the step. The runtimes are called in priority order. After
        // this process is complete, the stepping manager will call AfterSteppingArbitration
        // on the monitor that requested arbitration so it can respond to the new controlling
        // monitor if one was found, or finish the step if one was not found.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCurrentControllingRuntimeInstance: [In] The runtime instance requesting
        // arbitration.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnStepArbitration(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance
            ) = 0;

        // Called by a runtime monitor when a step is continuing on a different thread. The
        // stepping manager will create a new DkmStepper to be used on the new thread and
        // initiate stepping arbitration to determine which runtime should complete the step
        // just as OnStepArbitration does. The new stepper uses the same step kind and step
        // unit as the original stepper. A new starting instruction address must be given and
        // is set as the stepper's starting address. The original stepper remains alive and
        // when the new stepper completes the stepping manager will suppress the event and
        // notify the original stepper of the completion.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Reason          : [In] DkmStepArbitrationReason the reason step arbitration is
        // occurring.
        // pCurrentControllingRuntimeInstance: [In] The runtime instance requesting
        // arbitration.
        // pNewThread      : [In] The thread on which to create the new stepper.
        // pNewStartingInstructionAddress: [In] Starting address of the new stepper.
        // ppNewStepper    : [Out,Optional] The new stepper.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE OnCrossThreadStepArbitration(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason::e Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance,
            _In_ DkmThread* pNewThread,
            _In_ DkmInstructionAddress* pNewStartingInstructionAddress,
            _Deref_out_opt_ Stepping::DkmStepper** ppNewStepper
            ) = 0;
    };

    // Extends the information runtime monitors can obtain from the stepping manager.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmSteppingManagerCallback11a __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingManagerCallback11a)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("302768d4-02fd-3b75-570f-444ecae444c4") IDkmSteppingManagerCallback11a : public IUnknown
    {
        // Runtime monitors call this to set or clear a flag on the DkmStepper that can be
        // used by cooperating runtimes to change the behavior of stepping if an exception is
        // current in flight. Called by runtime monitors when an exception is encountered
        // while stepping.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // Enable          : [In] If true, the exception in flight flag is set. If false, it
        // is cleared.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetExceptionInFlight(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool Enable
            ) = 0;

        // Gets the flag on the DkmStepper that states if a runtime monitor believes an
        // exception is currently in flight during this step. This can be used by runtime
        // monitors to change the behavior of stepping.
        // pStepper        : [In] DkmStepper represents a request to step a thread. It
        // facilitates shared object lifetime between the various runtime debug monitors that
        // participate in stepping.
        // pEnabled        : [Out] If true, the exception in flight flag is set. If false, it
        // is cleared.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsExceptionInFlight(
            _In_ Stepping::DkmStepper* pStepper,
            _Out_ bool* pEnabled
            ) = 0;
    };

    // Provides the location of a thread, as visible in the threads window, or threads drop
    // down in the debug location toolbar. This is implemented by the Microsoft stack
    // provider component.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadLocationProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadLocationProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("eb604088-3862-4590-1ddf-3906a9b43ed4") IDkmThreadLocationProvider : public IUnknown
    {
        // Provides the location of a thread, as visible in the threads window, or threads
        // drop down in the debug location toolbar.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation(
            _In_ DkmThread* pThread,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetCurrentLocationAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Returns the stack base and limit of a thread.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadStackRangeProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadStackRangeProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("498145fc-1ad4-1faf-ac1c-214ee568f19a") IDkmThreadStackRangeProvider : public IUnknown
    {
        // Retrieves the stack limit/stack base of the given thread. Note that its possible
        // for this value to change over time, for example, in the case of fibers.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // pMemoryRange    : [Out] The limit/base address for the memory containing a
        // thread's stack.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error. E_INVALID_MEMORY_ADDRESS indicates that the address containing the TEB
        // structure could not be read from the target process. This may be returned for
        // minidumps without heap.
        virtual HRESULT STDMETHODCALLTYPE GetStackAddressRange(
            _In_ DkmThread* pThread,
            _Out_ CallStack::DkmStackMemoryRange* pMemoryRange
            ) = 0;
    };

    // Provides the ability to read and write from Win32 TLS slots within the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmTlsReadWrite __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTlsReadWrite)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("61ab705f-f69a-b4d9-c1f6-ef69e5cb0fa9") IDkmTlsReadWrite : public IUnknown
    {
        // Retrieves the value in the debuggee thread's thread local storage (TLS) slot for
        // the specified TLS index. Each thread of a process has its own slot for each TLS
        // index.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // TlsIndex        : [In] The TLS index that was allocated when the target process
        // called the TlsAlloc function.
        // pValue          : [Out] The pointer-sized value which was stored in the thread's
        // TLS slot. If the target thread is 32-bit, the upper 32-bits of this value will be
        // zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTlsValue(
            _In_ DkmThread* pThread,
            _In_ UINT32 TlsIndex,
            _Out_ UINT64* pValue
            ) = 0;

        // Stores a value in the debuggee thread's thread local storage (TLS) slot for the
        // specified TLS index. Each thread of a process has its own slot for each TLS index.
        // pThread         : [In] DkmThread represents a thread running in the target
        // process.
        // TlsIndex        : [In] The TLS index that was allocated when the target process
        // called the TlsAlloc function.
        // Value           : [In] The pointer-sized value to store in the thread's TLS slot.
        // If the target thread is 32-bit, the upper 32-bits of this value will be ignored.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetTlsValue(
            _In_ DkmThread* pThread,
            _In_ UINT32 TlsIndex,
            _In_ UINT64 Value
            ) = 0;
    };

    // Interface implemented by the AD7AL as a gateway to services provided by the rest of
    // Visual Studio.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    #define IID_IDkmVisualStudioServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVisualStudioServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("39fc0e53-030a-7710-05f2-fb8a31e7380c") IDkmVisualStudioServices : public IUnknown
    {
        // Displays a message to the user inside the Visual Studio debugger IDE. This
        // function does not block waiting for the user to dismiss the error message.
        // pUserMessage    : [In] Contains information about a message that is to be
        // displayed to the user.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE PostUserMessage(
            _In_ DkmUserMessage* pUserMessage
            ) = 0;

        // Displays a message to the user inside the Visual Studio debugger IDE. This
        // function waits for the Visual Studio IDE to complete processing this message. This
        // method may not be called from code that runs as part of UI event processing. Doing
        // so will cause a deadlock. This method requires DkmUserMessage.Process to be
        // non-null.
        // pUserMessage    : [In] Contains information about a message that is to be
        // displayed to the user.
        // pResult         : [Out] Win32 'ID' code from displaying the message box (ex:
        // IDYES). These codes are defined in winuser.h from the Windows SDK.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DisplayUserMessagePrompt(
            _In_ DkmUserMessage* pUserMessage,
            _Out_ UINT32* pResult
            ) = 0;

        // Returns the enumeration of DkmCodeViewCompilerId values. This enumeration may then
        // be used by a symbol provider to map the information within a code view record to
        // the DkmCompilerId structure.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // pCodeViewCompilers: [Out] DkmCodeViewCompilerId[] is used to translate information
        // that is within the S_COMPILE* code view records into a DkmCompilerId. This allows
        // the debugger to load an appropriate expression evaluator for a stack frame. Symbol
        // providers may obtain this collection through DkmEngineSettings. Expression
        // evaluators may add additional entries to this collection by having their setup add
        // sub key(s) to the '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCodeViewCompilers(
            _In_ DkmEngineSettings* pSettings,
            _Out_ DkmArray<Symbols::DkmCodeViewCompilerId>* pCodeViewCompilers
            ) = 0;

        // Sends a custom message to a Visual Studio package. This can be used, for example,
        // to drive a custom UI or make a custom UI visible by enabling a command context
        // (IVsMonitorSelection.SetCmdUIContext).
        //
        // For local 32-bit debugging, the custom message parameters
        // (DkmCustomMessage.Parameter1/2), may contain any value (ex: object/IUnknown,
        // string, etc), however, values are transferred between threads without marshalling,
        // so in cases where this will not work, the sender is responsible for converting the
        // parameter into a form which can be used from the VS service (ex: calling
        // ole32!CoMarshalInterThreadInterfaceInStream).
        //
        // For remote debugging, and 64-bit debugging, the custom message parameters are
        // marshalled across machines, and so the restrictions describe in the
        // DkmCustomMessage.Parameter1 documentation applies.
        // pCustomMessage  : [In] Message structure used to pass information between custom
        // debugger backend components and custom visual studio UI components (packages,
        // add-ins, etc).
        // VsService       : [In] Visual Studio service that this event should be sent to. A
        // VS package must register this service id. The service class must implement the
        // IVsCustomDebuggerEventHandler110 interface. Services can be registered in the
        // registry ($RootKey$\Services\{VsService}), or through the VS shell IProfferService
        // interface. Registry keys may be set through through .pkgdef files. If the service
        // should be called even if it is not already loaded, then the registry approach
        // should be used. If the service should only be called if it has already been
        // started, then IProfferService should be used.
        // IsBlocking      : [In] True if SendToPackage should block waiting for the package
        // to finish processing this message. When true, DkmCustomMessage.Process must be
        // non-null.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SendToVsService(
            _In_ DkmCustomMessage* pCustomMessage,
            _In_ const GUID& VsService,
            _In_ bool IsBlocking
            ) = 0;

        // Reads language-specific from the registry.  The settings are stored under
        // HKLM\Software\Microsoft\VisualStudio\12.0\AD7Metrics\ExpressionEvaluator\[Language
        // Guid]\[Vendor Guid].
        // pLanguage       : [In] Describes a programming language.
        // pSettings       : [Out] Pairing between the name of a setting and its value.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetLanguageSettings(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _Out_ DkmArray<DkmLanguageRegistrySetting*>* pSettings
            ) = 0;

        // Get the user document visual studio folder path.
        // pSettings       : [In] Contains the session-wide debug settings. There is one
        // instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one
        // instance for COMPlusNativeEng).
        // ppUserDocumentPath: [Out] Returns the user document visual studio path.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetUserDocumentPath(
            _In_ DkmEngineSettings* pSettings,
            _Deref_out_ DkmString** ppUserDocumentPath
            ) = 0;

        // Queries the language service (IVsLanguageDebugInfoScript) to obtain script block
        // information from the associated project item of the specified script document.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // ppScriptBlocks  : [Out] Set of script blocks returned from the language service.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetProjectItemScriptBlocks(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _Deref_out_ DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>** ppScriptBlocks
            ) = 0;
    };

    // Interface implemented by the AD7AL as a gateway to services provided by the rest of
    // Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmVisualStudioServices120 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVisualStudioServices120)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9149fbca-eb46-9e45-2689-bf597e4099e1") IDkmVisualStudioServices120 : public IUnknown
    {
        // Displays a message to the user inside the Visual Studio debugger IDE. This method
        // is the Async implementation.  Once it is executed the completion routine will be
        // called with the DkmProcess and the user response (Yes/No).  This method requires
        // DkmUserMessage.Process to be non-null.
        // pUserMessage    : [In] Contains information about a message that is to be
        // displayed to the user.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE DisplayUserMessagePrompt(
            _In_ DkmUserMessage* pUserMessage,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<DkmDisplayUserMessagePromptAsyncResult>* pCompletionRoutine
            ) = 0;
    };

}; // end of Microsoft implemented interfaces


// Disassembly providers interfaces
// Components that can disassemble instructions in the debuggee address space.
namespace ComponentInterfaces
{
    // Used to disassemble instructions in the debuggee address space.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmDisassemblyProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDisassemblyProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("867cafe9-35a7-36b0-f567-955c81ae4316") IDkmDisassemblyProvider : public IUnknown
    {
        // Disassemble an address range in the debuggee process.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pAddress        : [In] The address where disassembly should start.
        // Count           : [In] The number of instructions to disassemble.
        // pDisassembledInstructions: [Out] The results of disassembling the address range.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Disassemble(
            _In_ DkmProcess* pProcess,
            _In_ DkmInstructionAddress* pAddress,
            _In_ UINT32 Count,
            _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
            ) = 0;

        // Returns the address of the kth instruction relative to a starting address. For
        // constant length instruction sets, this is simple arithmetic. For variable length
        // instruction sets, reverse-disassembly is required to obtain this address.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pStartAddress   : [In] The address of the current instruction where the offset
        // should begin.
        // InstructionOffset: [In] The number of instructions relative to StartAddress to
        // find the desired address. This value can be negative.
        // ppAddress       : [Out] The address of the instruction InstructionOffset
        // instructions from StartAddress.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetInstructionAddress(
            _In_ DkmProcess* pProcess,
            _In_ DkmInstructionAddress* pStartAddress,
            _In_ INT32 InstructionOffset,
            _Deref_out_ DkmInstructionAddress** ppAddress
            ) = 0;

        // A method that calculates and returns the effective addresses for the requested
        // address. The effective address is the calculated address that an instruction
        // operand represents. For instance, on x86, an instruction may be of the form
        // dwordptr [esp-12]. The effective address of this operand will be the result of
        // subtracting 12 from esp. The number of operands and effective addresses are
        // architecture specific.
        // pFrame          : [In] DkmStackFrame represents a frame on the call stack after
        // filtering and translation.
        // pAddress        : [In] The address for which to obtain the effective addresses.
        // ppEffectiveAddresses: [Out] The collection of effective addresses for this
        // instruction if any.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetEffectiveAddresses(
            _In_ CallStack::DkmStackFrame* pFrame,
            _In_ DkmInstructionAddress* pAddress,
            _Deref_out_ DkmReadOnlyCollection<Disassembly::DkmEffectiveAddress>** ppEffectiveAddresses
            ) = 0;
    };

    // Used to disassemble instructions in the debuggee address space with respect to a
    // specific runtime.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmRuntimeDisassemblyProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeDisassemblyProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2fd9551e-2957-9c1e-ce24-c73f59463200") IDkmRuntimeDisassemblyProvider : public IUnknown
    {
        // Disassemble an address range in the debuggee runtime.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pAddress        : [In] The address where disassembly should start.
        // Count           : [In] The number of instructions to disassemble.
        // pDisassembledInstructions: [Out] The results of disassembling the address range.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Disassemble(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmInstructionAddress* pAddress,
            _In_ UINT32 Count,
            _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
            ) = 0;

        // Returns the address of the kth instruction relative to a starting address. For
        // constant length instruction sets, this is simple arithmetic. For variable length
        // instruction sets, reverse-disassembly is required to obtain this address.
        // pRuntimeInstance: [In] The DkmRuntimeInstance class represents an execution
        // environment which is loaded into a DkmProcess and which contains code to be
        // debugged.
        // pStartAddress   : [In] The address of the current instruction where the offset
        // should begin.
        // InstructionOffset: [In] The number of instructions relative to StartAddress to
        // find the desired address. This value can be negative.
        // ppAddress       : [Out] The address of the instruction InstructionOffset
        // instructions from StartAddress.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetInstructionAddress(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmInstructionAddress* pStartAddress,
            _In_ INT32 InstructionOffset,
            _Deref_out_ DkmInstructionAddress** ppAddress
            ) = 0;
    };

}; // end of Disassembly providers interfaces


// GPU component interfaces
// Provides GPU debugging functionality such as operations on GPU compute kernel and its
// hierarchy of GPU compute threads, operations on GPU memory, registers, and
// disassembly.
namespace ComponentInterfaces
{
    // Interface for querying the GPU debugging breakpoint behavior.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUBreakpointBehaviorQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUBreakpointBehaviorQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("26e132aa-dd1d-eb87-7df2-1e44ec6d3f99") IDkmGPUBreakpointBehaviorQuery : public IUnknown
    {
        // Get the breakpoint behavior of the process.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // pBreakpointBehavior: [Out] The breakpoint behavior of the process.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetGPUBreakpointBehavior(
            _In_ DkmProcess* pProcess,
            _Out_ GPU::DkmGPUBreakpointBehaviorFlags::e* pBreakpointBehavior
            ) = 0;
    };

    // Provides the compute kernel hierarchy, i.e., the thread group, compute vector and
    // compute thread for view by the user.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUComputeKernelOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUComputeKernelOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5f2afaed-ff79-0b4d-c849-40d37db4c5c5") IDkmGPUComputeKernelOperation : public IUnknown
    {
        // Obtain the warp size of the hardware or emulator.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pWidth          : [Out] Width of the hardware.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetComputeVectorWidth(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ UINT32* pWidth
            ) = 0;

        // Obtain the active thread groups from the compute kernel.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pActiveThreadGroups: [Out] List of global Thread group id of all active thread
        // groups.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfGroups : [Out] Number of active thread groups in the compute kernel.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetActiveThreadGroups(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT64>* pActiveThreadGroups,
            _Out_ UINT32* pNumberOfGroups
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadDimensions(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pGroupDimensions: [Out] Grid Dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Grid dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCurrentGroupDimensions(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // pThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetThisThreadDimension(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // pGroupDimensions: [Out] Grid dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Grid dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetThisGroupDimension(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        // Get the name of compute kernel.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // ppComputeKernelName: [Out] Name of the ComputeKernel that is launched.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetComputeKernelName(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Deref_out_ DkmString** ppComputeKernelName
            ) = 0;

        // Get properties of the compute kernel.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pComputeProperties: [Out] List of Compute kernel properties.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfProperties: [Out] Number of properties in the compute kernel.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetComputeKernelProperties(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<GPU::DkmComputeProperty>* pComputeProperties,
            _Out_ UINT32* pNumberOfProperties
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // pThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetThreadId(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // pGroupDimensions: [Out] Grid dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Grid dimensions.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetGroupId(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        // Runs the select query on thread info objects.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pFrom           : [In] From clause specification for selection (can be empty to
        // select from all available threads).
        // Where           : [In] Where clause specification for selection.
        // pThreadInfoArray: [Out] The result set of compute thread info objects.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE Select(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            ) = 0;

        // Runs the group by query on thread info objects.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // GroupByFlags    : [In] Flags specifying on which columns the group by is run.
        // pFrom           : [In] From clause specification for selection (can be empty to
        // select from all available threads).
        // Where           : [In] Where clause specification for group by.
        // pThreadInfoArray: [Out] The result set of compute thread info objects.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GroupBy(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ GPU::DkmQueryComputeThreadInfoFlags::e GroupByFlags,
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            ) = 0;

        // Get all threads that hit breakpoint.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pThreadIdArray  : [Out] The result set of compute thread ids that hit breakpoint.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetStoppedThreads(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT64>* pThreadIdArray
            ) = 0;

        // Gets the DkmGPUComputeThread object for a given thread ID.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // ThreadId        : [In] ID of the thread to return.
        // ppThread        : [Out] Thread object that matches the given thread ID.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetThreadFromId(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ UINT64 ThreadId,
            _Deref_out_ GPU::DkmGPUComputeThread** ppThread
            ) = 0;

        // Update flagged state of compute threads.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // Where           : [In] Where clause specification for update.
        // Flagged         : [In] The value to update with.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UpdateFlaggedState(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Flagged
            ) = 0;

        // Update frozen state of compute threads.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // Where           : [In] Where clause specification for update.
        // Frozen          : [In] The value to update with.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UpdateFrozenState(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Frozen
            ) = 0;

        // Get the dimension of the thread block.
        // pComputeKernel  : [In] DkmGPUComputeKernel represents a GPU compute kernel running
        // in the target process.
        // pFlatThreadDimensions: [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pFlatIndexBase  : [Out] Thread group dimensions.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pNumberOfDimensions: [Out] Number of Thread block dimensions.
        // pModel          : [Out] Model Type.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetFlatComputeKernelDimensions(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT32>* pFlatThreadDimensions,
            _Out_ DkmArray<INT32>* pFlatIndexBase,
            _Out_ UINT32* pNumberOfDimensions,
            _Out_ GPU::DkmComputeKernelModel::e* pModel
            ) = 0;
    };

    // Used to query raw disassembly in the GPU debuggee byte code.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmGPUDisassemblyQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUDisassemblyQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5ac63247-f76d-3014-8c80-1ca6672fb9d6") IDkmGPUDisassemblyQuery : public IUnknown
    {
        // Obtain the disassembly of the address range in the debuggee module instance.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // Address         : [In] The address where disassembly should start.
        // Count           : [In] The number of instructions to disassemble.
        // IsForward       : [In] True if this is forward disassembling, otherwise this is
        // reverse disassembling.
        // pDisassembly    : [Out] The results of disassembly read from the debuggee byte
        // code.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pIsEnd          : [Out] True if the disassembly has reached the end of byte code,
        // false otherwise.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetGPUDisassembly(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ UINT64 Address,
            _In_ UINT32 Count,
            _In_ bool IsForward,
            _Out_ DkmArray<BYTE>* pDisassembly,
            _Out_ bool* pIsEnd
            ) = 0;

        // Returns the disassembly size in the debuggee module instance.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // pSize           : [Out] The disassembly size.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetGPUDisassemblySize(
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ UINT64* pSize
            ) = 0;

        // Returns the address of the next instruction relative to a starting address.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // StartAddress    : [In] The address of the current instruction.
        // pNextAddress    : [Out] The address of the next instruction from StartAddress.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetNextGPUInstructionAddress(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ UINT64 StartAddress,
            _Out_ UINT64* pNextAddress
            ) = 0;
    };

    // Implemented by base debug monitors to provide access to the memory of the target GPU
    // process. Base debug monitors are responsible for performing the memory I/O.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUMemoryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUMemoryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("23e4188c-7499-b774-7878-d13b3ba8410f") IDkmGPUMemoryOperation : public IUnknown
    {
        // Read the memory of the target GPU process. The method is on DkmGPUComputeThread
        // because it may read thread local memory, group shared memory or global memory.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // Address         : [In] The address from which to read the target GPU process's
        // memory.
        // InstructionPointer: [In] The instruction pointer where to resolve address to
        // register location.
        // Flags           : [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        // pBuffer         : [In,Out] A buffer that receives the contents from the address
        // space of the target process. On failure, the content of this buffer is
        // unspecified.
        // Size            : [In] The number of bytes to be read from the process.
        // pBytesRead      : [Out] Indicates the number of bytes read from the target GPU
        // process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this value
        // will always be exactly equal to the input size. If
        // DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be
        // greater than zero.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ReadMemory(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ DkmReadMemoryFlags::e Flags,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            ) = 0;

        // Writes memory to the target GPU process. The method is on DkmGPUComputeThread
        // because it may write thread local memory, group shared memory or global memory.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // Address         : [In] The base address from which to write the target GPU
        // process's memory.
        // InstructionPointer: [In] The instruction pointer where to resolve address to
        // register location.
        // Data            : [In] Data to be written in the address space of the specified
        // GPU process.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE WriteMemory(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;

        // Checks if a tag for a buffer has been forwarded for this kernel execution.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // InputTag        : [In] The C++ AMP pointer tag.
        // pForwardedTag   : [Out] The forwarded tag value.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE UpdateBufferTag(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT32 InputTag,
            _Out_ UINT32* pForwardedTag
            ) = 0;

        // Validate the specified GPU memory address.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // Address         : [In] The address to validate.
        // pIsValidGpuMemoryAddress: [Out] True if the specified address is a valid GPU
        // memory address, false otherwise.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ValidateAddress(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 Address,
            _Out_ bool* pIsValidGpuMemoryAddress
            ) = 0;
    };

    // Implemented by base debug monitors to provide access to the registers of the GPU
    // compute thread.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPURegisterOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPURegisterOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bfd79470-a01a-6335-ce95-6cded602ba8f") IDkmGPURegisterOperation : public IUnknown
    {
        // Obtain the list of all register descriptions from the GPU compute thread.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // pRegisterDescriptions: [Out] The list of all register descriptions from the GPU
        // compute thread.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned if pRegisterDescriptions contains any elements,
        // S_FALSE is indicates the array is empty, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetRegisterDescriptions(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<GPU::DkmGPURegisterDescription>* pRegisterDescriptions
            ) = 0;

        // Set the value of a register in the GPU compute thread.
        // pComputeThread  : [In] DkmGPUComputeThread represents a compute thread running in
        // the GPU target process.
        // RegisterDescription: [In] The description of a register from the GPU compute
        // thread.
        // pRegisterValue  : [In] The value bytes of a register to be written in the GPU
        // compute thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetRegisterValue(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ const GPU::DkmGPURegisterDescription& RegisterDescription,
            _In_ DkmReadOnlyCollection<BYTE>* pRegisterValue
            ) = 0;
    };

    // IDkmGPUSetMemoryAccessWarningOperation is used to configure GPU memory access warnings
    // on the debugged GPU device. It is implemented by base debug monitors which support
    // reporting GPU Memory Access Exceptions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUSetMemoryAccessWarningOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSetMemoryAccessWarningOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("aab60381-4616-c94a-c4a3-e31442a3804b") IDkmGPUSetMemoryAccessWarningOperation : public IUnknown
    {
        // Enables / disables a particular GPU memory access warning.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // WarningCode     : [In] Warning code to set.
        // Enable          : [In] True to set the warning, false to clear it.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetGPUMemoryAccessWarning(
            _In_ DkmProcess* pProcess,
            _In_ UINT32 WarningCode,
            _In_ bool Enable
            ) = 0;

        // Disables all active GPU memory access warnings.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearAllGPUMemoryAccessWarnings(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Callback interface which is implemented by GPU symbol providers to provide information
    // from the symbol store to base debug monitors.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmGPUSymbolProviderCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSymbolProviderCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("06ae9ecf-5ee1-86c4-23e1-2e4ebea8ed4d") IDkmGPUSymbolProviderCallback : public IUnknown
    {
        // Translate accelerator pointer tag into HLSL register attributes.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // InputTag        : [In] Accelerator pointer tag found in symbols.
        // InstructionPointer: [In] current instruction pointer used to get scope for pointer
        // translation.
        // pRegisterType   : [Out] HLSL register type.
        // pRegisterIndex  : [Out] HLSL register index.
        // pFirstElement   : [Out] Index of first vector element.
        // pVectorElements : [Out] Number of vector elements.
        // pByteOffset     : [Out] Offset in bytes.
        // pVectorElementSize: [Out] Size of each vector element.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByIP(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 InputTag,
            _In_ UINT32 InstructionPointer,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            ) = 0;

        // This method returns address information to the GPU debug monitor.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pInstructionAddress: [In,Optional] Abstract representation of an executable code
        // location (ex: EIP value). If resolved, an Instruction Address will be within a
        // particular module instance. An Instruction Address is always within a particular
        // Runtime Instance.
        // pNextInstruction: [In] The next instruction address which is used to determine
        // inline function call.
        // pMetadata       : [Out,Optional] The address type information.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetGPUInstructionMetadataCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ Symbols::DkmInstructionSymbol* pNextInstruction,
            _Out_ GPU::DkmGPUAddressType::e* pMetadata
            ) = 0;

        // This method returns compiler flags of the given GPU module.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // ppCompilerOptions: [Out,Optional] returns the compiler flags.
        // Return value    : S_OK is returned if *ppCompilerOptions is non-NULL, S_FALSE is
        // returned when *ppCompilerOptions is NULL, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetCompilerOptions(
            _In_ Symbols::DkmModule* pModule,
            _Deref_out_opt_ DkmString** ppCompilerOptions
            ) = 0;

        // Queries the symbol provider to determine the ranges of instructions which do not
        // correspond to any user source statements and are used by the base debug monitor to
        // always step through during stepping.
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pRanges         : [Out] Array of no source ranges to always step through. This
        // array will be empty if there are no no-source ranges for the given instruction.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetNoSourceRanges(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            ) = 0;
    };

    // This API is used to read information about a symbol for DPC++.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmGPUSymbolQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSymbolQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7dd1cb8a-dd52-259e-ca92-61571659aaec") IDkmGPUSymbolQuery : public IUnknown
    {
        // Translate accelerator pointer tag into HLSL register attributes using relative
        // virtual address.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // InputTag        : [In] Accelerator pointer tag found in symbols.
        // Rva             : [In] RVA to use for filtering; ignored if zero.
        // pRegisterType   : [Out] HLSL register type.
        // pRegisterIndex  : [Out] HLSL register index.
        // pFirstElement   : [Out] Index of first vector element.
        // pVectorElements : [Out] Number of vector elements.
        // pByteOffset     : [Out] Offset in bytes.
        // pVectorElementSize: [Out] Size of each vector element.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByRva(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            ) = 0;

        // Verify if the accelerator pointer tag is valid.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // InputTag        : [In] Accelerator pointer tag found in symbols.
        // Rva             : [In] RVA to use for filtering; ignored if zero.
        // pIsValid        : [Out] True if the given accelerator tag is valid at the given
        // RVA.  If RVA is zero, checks if the tag is valid anywhere including as a
        // dynamically created tag.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE IsValidAcceleratorTag(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ bool* pIsValid
            ) = 0;

        // Gets a C++ AMP address for a register.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // RegisterType    : [In] Type of HLSL register.
        // RegisterIndex   : [In] Index of HLSL register.
        // FirstElement    : [In] Index of first vector element.
        // VectorElements  : [In] Number of vector elements.
        // ByteOffset      : [In] Offset from beginning of register.
        // VectorElementSize: [In] Size of vector element.
        // Rva             : [In] RVA to use for mapping register information and tag
        // address.
        // StartLiveRange  : [In] Start of live range for the symbol.
        // EndLiveRange    : [In] End of live range for the symbol.
        // pAddress        : [Out] Address for register.
        // pIsNewDynamicTag: [Out] Is the address newly generated using dynamic tag.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetPointerToHLSLRegister(
            _In_ Symbols::DkmModule* pModule,
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 Rva,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange,
            _Out_ UINT64* pAddress,
            _Out_ bool* pIsNewDynamicTag
            ) = 0;

        // Sets a C++ AMP address for a register.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // Address         : [In] Address for register.
        // RegisterType    : [In] Type of HLSL register.
        // RegisterIndex   : [In] Index of HLSL register.
        // FirstElement    : [In] Index of first vector element.
        // VectorElements  : [In] Number of vector elements.
        // ByteOffset      : [In] Offset from beginning of register.
        // VectorElementSize: [In] Size of vector element.
        // StartLiveRange  : [In] Start of live range for the symbol.
        // EndLiveRange    : [In] End of live range for the symbol.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetPointerToHLSLRegister(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT64 Address,
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange
            ) = 0;

        // Gets a C++ AMP address for a register.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // pSize           : [Out] Maximum tag value found in actual C++ AMP pointers plus
        // one.
        // pSizeOfForwardedTags: [Out] Maximum tag value that may be subject to buffer
        // forwarding plus one.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAcceleratorTagTableSize(
            _In_ Symbols::DkmModule* pModule,
            _Out_ UINT32* pSize,
            _Out_ UINT32* pSizeOfForwardedTags
            ) = 0;

        // GetInstructionOffsetForRva is used by components to query symbol provider to
        // perform instruction offset and RVA translation for DPC++.
        // pModule         : [In] The DkmModule class represents a code bundle (ex: dll or
        // exe) which is or once was loaded into one or more processes. The DkmModule class
        // is the central object to the symbol APIs, and is 1:1 with the symbol handler's
        // notation of what is loaded. If a code bundle loads into three different processes
        // (or the same process but with three different base addresses or three different
        // app domains) but the symbol handler thinks of all of these as being identical,
        // there will be only one module object.
        // RVA             : [In] The RVA within a module.
        // pInstructionOffset: [Out] The instruction offset from stub function.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetInstructionOffsetForRva(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 RVA,
            _Out_ UINT32* pInstructionOffset
            ) = 0;
    };

    // Allows remote components to obtain source position information for DPC++ when the
    // symbol provider is on the VS machine.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmGPUSymbolQueryCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSymbolQueryCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("52865d52-5245-7027-62c1-9e2f652923fc") IDkmGPUSymbolQueryCallback : public IUnknown
    {
        // Returns the source file position (ex: example.cs, line 12) of this instruction
        // symbol. If this instruction symbol is not associated with a source file or not in
        // user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).
        // pInstruction    : [In] DkmInstructionSymbol represents a method in the target
        // process.
        // pInspectionSession: [In,Optional] A reference object describing the current
        // inspection session. Common usage is for symbol providers to cache lookups using
        // its data container.
        // ppSourcePosition: [Out,Optional] Source code position which corresponds to a code
        // element. The could represent a location which has been extracted from a symbol
        // (PDB) file, or it could be the location of a breakpoint in the IDE.
        // Return value    : S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is
        // returned when *ppSourcePosition is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE GetUserCodeSourcePositionCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // Interface implemented by GPU base debug monitors to enable temporary instruction
    // breakpoints in stepping. The temporary instruction breakpoints are passed to
    // ContinueDebugEvent.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmGPUTempBreakStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUTempBreakStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("18ce801c-c0ae-8b7f-d688-500517cd84b2") IDkmGPUTempBreakStepper : public IUnknown
    {
        // Enable temporary breakpoint in stepping on a thread. This is similar to single
        // step except one or more instructions are advanced. When breakpoint is hit, step
        // complete event is sent.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // TempBreakInstructions: [In] The instruction offset of temporary breakpoints to
        // set.
        // The memory for the DkmArray members is allocated by the caller, and can be from
        // any source (stack memory, static buffer, heap, etc). The implementation should not
        // modify the members.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE EnableTempBreak(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ const DkmArray<UINT64>& TempBreakInstructions
            ) = 0;

        // Clear temporary breakpoint in stepping on a thread.
        // pSingleStepRequest: [In] DkmSingleStepRequest represents a request to single step
        // a thread.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE ClearTempBreak(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest
            ) = 0;
    };

    // Interface implemented by base debug monitors which read symbols from debuggee's memory
    // at runtime. This interface would be implemented by base debug monitors to deal with
    // symbol formats which are generated or loaded at runtime in the debuggee's memory.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmSymbolMemoryReader __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolMemoryReader)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1605c794-5589-65c7-49da-5b1f767678af") IDkmSymbolMemoryReader : public IUnknown
    {
        // This method is invoked by symbol handlers to read symbols for DkmModuleInstances
        // whose symbols reside in debuggee's memory.
        // pModuleInstance : [In] The Module Instance class represent a code bundle (ex: dll
        // or exe) which is loaded into a particular process at a particular location. Module
        // Instance objects are 1:1 with the execution environment's notion of a code bundle.
        // For example, in native code, Module Instance objects are 1:1 with base address.
        // ppSymbolBuffer  : [Out,Optional] The symbol buffer that is read from debuggee's
        // memory at runtime.
        // Return value    : S_OK is returned if *ppSymbolBuffer is non-NULL, S_FALSE is
        // returned when *ppSymbolBuffer is NULL, and failure codes are used for any error.
        virtual HRESULT STDMETHODCALLTYPE ReadSymbols(
            _In_ DkmModuleInstance* pModuleInstance,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppSymbolBuffer
            ) = 0;
    };

}; // end of GPU component interfaces


// Script Document Manager interfaces
// Interfaces implemented by components that create DkmScriptDocument objects.
namespace ComponentInterfaces
{
    // Implemented by components which create DkmScriptDocument objects in order to provide
    // document content and notifications when the content changes.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("101af814-9a31-dfdb-1df5-d6b7299b3ef7") IDkmScriptDocumentProvider : public IUnknown
    {
        // Provides the current content of the specified document object.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // EnableContentEvents: [In] If true, the script document provider should raise
        // events when the content of this document changes. Passing true is equivalent to
        // calling SetRaiseContentEvents(true). If false, the RaiseContentEvent state remains
        // the same.
        // ppContent       : [Out] The current content of this document.
        // pSectionDividers: [Out] For aggregate documents
        // (DkmScriptDocumentFlags.AggregateDocument is set), this is the 1-based line
        // numbers for where the section dividers should be drawn. For standard documents, an
        // empty array is returned.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetContent(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ bool EnableContentEvents,
            _Deref_out_ DkmString** ppContent,
            _Out_ DkmArray<UINT32>* pSectionDividers
            ) = 0;

        // Enables or disables raising events when the content of the document is changed. By
        // default, documents do not generate content events. So this method should be called
        // by any component that wishes to receive content events. The script document
        // manager maintains a count of the number of calls to enable content events, and
        // will raise events whenever this count is greater than 0. Callers should take care
        // to ensure that SetRaiseContentEvents(false) is called ONLY after a successful call
        // to SetRaiseContentEvents(true). Content events are automatically disabled when the
        // document is unloaded.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // Enable          : [In] If true, content events should be enabled for this
        // document. If false, the count of content event listeners is decremented. When the
        // count reaches zero, no further events will be sent.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetRaiseContentEvents(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ bool Enable
            ) = 0;
    };

    // API implemented by the script local agent to match script documents against breakpoint
    // requests.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ec355278-62b4-d986-e384-28c7442b1b2f") IDkmScriptDocumentQuery : public IUnknown
    {
        // This method is called when a script document is created or when the project item
        // path is set to try and bind breakpoints against the given script document.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // pSourceFileId   : [In] Identifies a source file and provides the information which
        // a symbol handler could use to search a symbol file (PDB) for information on this
        // source file.
        // ppResolvedDocument: [Out,Optional] If the given script document matches the given
        // source file id, this returns a DkmResolvedDocument for the match. Otherwise, null
        // is returned.
        // Return value    : S_OK is returned if *ppResolvedDocument is non-NULL, S_FALSE is
        // returned when *ppResolvedDocument is NULL, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE TryResolve(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Deref_out_opt_ Symbols::DkmResolvedDocument** ppResolvedDocument
            ) = 0;
    };

    // Implemented by components which create DkmScriptDocument objects, and use them as the
    // basis of symbol resolution. This interface doesn't need to be implemented by script
    // document system which leave DkmResolvedDocument.ScriptDocument as null.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentSymbolProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentSymbolProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("4b084d09-68a5-af61-49d0-e47525eb163c") IDkmScriptDocumentSymbolProvider : public IUnknown
    {
        // Enables or disables raising ScriptSymbolsUpdated when symbols in the document are
        // changed. By default, documents do not generate symbol events. So this method
        // should be called by any component that wishes to receive symbol events. The script
        // document manager maintains a count of the number of calls to enable symbol events,
        // and will raise events whenever this count is greater than 0. Callers should take
        // care to ensure that SetRaiseSymbolEvents(false) is called ONLY after a successful
        // call to SetRaiseSymbolEvents(true). Symbol events are automatically disabled when
        // the document is unloaded.
        // pScriptDocument : [In] Represents a document which is executing in a script
        // runtime environment. For example, the Microsoft JavaScript engine.
        // Enable          : [In] If true, symbol events should be enabled for this document.
        // If false, the count of symbol event listeners is decremented. When the count
        // reaches zero, no further events will be sent.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE SetRaiseSymbolEvents(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ bool Enable
            ) = 0;
    };

}; // end of Script Document Manager interfaces


// Task providers interfaces
// Components that can decode the data structures of a parallel task API running in the
// target process.
namespace ComponentInterfaces
{
    // Walk async call stack and task creation stacks.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId, TaskProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmAsyncTaskDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncTaskDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a666d01b-4bad-179a-7f02-2ec334fac1dd") IDkmAsyncTaskDecoder : public IUnknown
    {
        // Gets the logged creation stack of this task.
        // pAsyncStackWalkContext: [In] Provides a context for walking async return stacks
        // and task creation stacks.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskCreationStack(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskCreationStackAsyncResult>* pCompletionRoutine
            ) = 0;

        // Returns a list of frames that will execute when this task completes.  The order
        // that the frames will execute in is arbitrary and might not be the order returned
        // here.  Only frames that will execute as a direct result of this task are included,
        // not frames that will execute as a result of another task that will execute after
        // this task completes.
        // pAsyncStackWalkContext: [In] Provides a context for walking async return stacks
        // and task creation stacks.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskContinuationFrames(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskContinuationFramesAsyncResult>* pCompletionRoutine
            ) = 0;

        // Gets the async call stack of this thread.
        // pAsyncStackWalkContext: [In] Provides a context for walking async return stacks
        // and task creation stacks.
        // pWorkList       : WorkList which is currently being processed. This value can be
        // used to check for cancelation or to append additional work. New work items will
        // not begin executing until after this function returns.
        // pThread         : [In] The thread that the resultant frames should belong to.
        // pCompletionRoutine: Routine to fire when the request is complete. This will be
        // implicitly fired if the implementation returns failure from this interface method.
        // The implementation must fire this method in all other scenarios.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetAsyncCallStack(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetAsyncCallStackAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by the task provider component to obtain information about
    // tasks. This interface is subject to change in future versions of Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TaskProviderId.
    #define IID_IDkmTaskProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dab4a095-1346-8117-18b5-0586e1fe5852") IDkmTaskProvider : public IUnknown
    {
        // Enumerates the current set of tasks running in the target process.
        // pTaskProvider   : [In] Represents a task provider which is loaded into the target
        // process.
        // IsRoot          : [In] TODO.
        // RequestCount    : [In] Count of tasks requested.
        // pScheduledTaskCount: [Out] Number of scheduled tasks.
        // pItems          : [Out] Array contained the found tasks.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // pTaskEnumFlags  : [Out] TODO.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTasks(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_ bool IsRoot,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pScheduledTaskCount,
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems,
            _Out_ UINT32* pTaskEnumFlags
            ) = 0;

        // TODO.
        // pTaskProvider   : [In] Represents a task provider which is loaded into the target
        // process.
        // pNames          : [Out] TODO.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetPropertyNames(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _Out_ DkmArray<DkmString*>* pNames
            ) = 0;

        // Returns children tasks.
        // pTask           : [In] Represents either a managed TPL task or a native
        // Concurrency Runtime task.
        // pItems          : [Out] TODO.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetChildTasks(
            _In_ ParallelTasks::DkmTask* pTask,
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems
            ) = 0;

        // Returns task properties.
        // pTask           : [In] Represents either a managed TPL task or a native
        // Concurrency Runtime task.
        // Radix           : [In] TODO.
        // Fields          : [In] TODO.
        // pProperties     : [Out] TODO.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetTaskProperties(
            _In_ ParallelTasks::DkmTask* pTask,
            _In_ UINT32 Radix,
            _In_ UINT32 Fields,
            _Out_ ParallelTasks::DkmTaskProperties* pProperties
            ) = 0;
    };

    // Optional interface implemented by task providers to receive a notification when task
    // providers are first requested for a particular process. This interface is subject to
    // change in future versions of Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmTaskProviderInitialize __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskProviderInitialize)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("28e075cf-d77d-e3a7-3360-6e4df64e541c") IDkmTaskProviderInitialize : public IUnknown
    {
        // Invoked by the AD7 AL to provide a notification when task providers are first
        // requested from the UI for a particular process. This allows implementations to
        // delay initialization to when the task UI if first shown.
        // pProcess        : [In] DkmProcess represents a target process which is being
        // debugged. The debugger debugs processes, so this is the basic unit of debugging. A
        // DkmProcess can represent a system process or a virtual process such as minidumps.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE InitializeTaskProviders(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Interface implemented by task provider components to provide the set of
    // synchronization objects owned by a task. This interface is subject to change in future
    // versions of Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TaskProviderId.
    #define IID_IDkmTaskSynchronizationObjectProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskSynchronizationObjectProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5b455d6f-d085-6c84-9949-ab7dc0d1204e") IDkmTaskSynchronizationObjectProvider : public IUnknown
    {
        // TODO.
        // pTask           : [In] Represents either a managed TPL task or a native
        // Concurrency Runtime task.
        // pItems          : [Out] TODO.
        // The memory for the DkmArray members is allocated by the method implementation
        // using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        // CAutoDkmArray template or with DkmFreeMemory and manual element release.
        // Return value    : S_OK is returned on success, and failure codes are used for any
        // error.
        virtual HRESULT STDMETHODCALLTYPE GetSynchronizationObjects(
            _In_ ParallelTasks::DkmTask* pTask,
            _Out_ DkmArray<ParallelTasks::DkmTaskSynchronizationObject*>* pItems
            ) = 0;
    };

}; // end of Task providers interfaces


// Collection element traits
struct DkmCollectionElementDescriptor
{
    const enum
    {
        NoDispose,
        IUnknownDispose,
        StructureDispose
    } DisposeKind;
    const DWORD Size;
    const GUID& Id;

    // **********************************************************************************
    // READ ME: DkmCollectionElementDescriptor
    // **********************************************************************************
    // DkmCollectionElementDescriptor describes an element in a collection.
    //
    // Errors in this class are caused by one of the following:
    // 1. Accidental declaration of a template on an interface (T=IUnknown) instead of
    // an interface pointer (T=IUnknown*)
    // 2. An attempt to declare a template on a type which is not defined in this header
    // file. DkmCollectionElementDescriptor is NOT general purpose and was designed to
    // only deal with types which are in this header file and interface pointers. It is
    // recommended to use a more general collection class in these cases, such as one
    // from the ATL or STL.
    // **********************************************************************************

    template <class T> explicit DkmCollectionElementDescriptor(const T*) :
        DisposeKind(IUnknownDispose),
        Size(sizeof(IUnknown*)),
        Id(__uuidof(T))
    {
        // *NOTE*: This function (the non-specialized version of the constructor). Is for
        //  interface pointers. The remainder of this function enforces the constraint
        // that 'T' is an interface pointer (ex: 'T'='IDispatch*'). See comment above.

        // Interface pointers are always the size of a pointer
        C_ASSERT(sizeof(T) == sizeof(IUnknown*));

        // Interface pointers can be implicitly converted to IUnknown
        IUnknown* implicit_cast_test = (T)0x00000004;

        // When interface pointers are converted to IUnknown, the compiler does not need
        // to apply a this adjustment
        if (implicit_cast_test != (IUnknown*)0x00000004)
        {
#ifdef _DEBUG
            __debugbreak();
#endif
        }
    }
};
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmDataCreationDisposition::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmDataCreationDisposition::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmDataCreationDisposition::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmDispatcherObjectFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmDispatcherObjectFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmDispatcherObjectFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmApiVersion::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmApiVersion::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmApiVersion::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmEventCode::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmEventCode::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmEventCode::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CV_HREG_e*) :
    DisposeKind(NoDispose), Size(sizeof(CV_HREG_e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CV_HREG_e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const UINT16*) :
    DisposeKind(NoDispose), Size(sizeof(UINT16)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(UINT16& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmXmm128*) :
    DisposeKind(NoDispose), Size(sizeof(DkmXmm128)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmXmm128& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const float*) :
    DisposeKind(NoDispose), Size(sizeof(float)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(float& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const double*) :
    DisposeKind(NoDispose), Size(sizeof(double)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(double& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CorGCReferenceType*) :
    DisposeKind(NoDispose), Size(sizeof(CorGCReferenceType)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CorGCReferenceType& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GUID*) :
    DisposeKind(NoDispose), Size(sizeof(GUID)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GUID& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const HRESULT*) :
    DisposeKind(NoDispose), Size(sizeof(HRESULT)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(HRESULT& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const INT32*) :
    DisposeKind(NoDispose), Size(sizeof(INT32)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(INT32& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const INT64*) :
    DisposeKind(NoDispose), Size(sizeof(INT64)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(INT64& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const UINT32*) :
    DisposeKind(NoDispose), Size(sizeof(UINT32)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(UINT32& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const MINIDUMP_TYPE*) :
    DisposeKind(NoDispose), Size(sizeof(MINIDUMP_TYPE)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(MINIDUMP_TYPE& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKLOAD_FLAGS*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKLOAD_FLAGS)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKLOAD_FLAGS& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKPROPERTIES_FIELDS*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKPROPERTIES_FIELDS)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKPROPERTIES_FIELDS& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKPROPERTIES_FLAGS*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKPROPERTIES_FLAGS)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKPROPERTIES_FLAGS& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKSTATE_TYPE*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKSTATE_TYPE)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKSTATE_TYPE& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const UINT64*) :
    DisposeKind(NoDispose), Size(sizeof(UINT64)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(UINT64& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const BYTE*) :
    DisposeKind(NoDispose), Size(sizeof(BYTE)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(BYTE& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const FunctionResolution::DkmAddressSearchFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(FunctionResolution::DkmAddressSearchFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(FunctionResolution::DkmAddressSearchFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmAsyncBreakStatus::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmAsyncBreakStatus::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmAsyncBreakStatus::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointConditionOperator::e*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointConditionOperator::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointConditionOperator::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointHitCountConditionOperator::e*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointHitCountConditionOperator::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointHitCountConditionOperator::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointMessageLevel::e*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointMessageLevel::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointMessageLevel::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointUnboundReason::e*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointUnboundReason::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointUnboundReason::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmCallStackFilterOptions::e*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmCallStackFilterOptions::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmCallStackFilterOptions::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrAsyncMethodLocation::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrAsyncMethodLocation::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrAsyncMethodLocation::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrAwaitExpressionInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrAwaitExpressionInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrAwaitExpressionInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrDebuggingServicesId::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrDebuggingServicesId::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrDebuggingServicesId::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrHeaderStatus::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrHeaderStatus::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrHeaderStatus::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrMethodId*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrMethodId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrMethodId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrMethodScopeData*) :
    DisposeKind(StructureDispose), Size(sizeof(Clr::DkmClrMethodScopeData)), Id(__uuidof(Clr::DkmClrMethodScopeData))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrMethodScopeData& element)
{
    return Clr::DkmClrMethodScopeData::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrModuleFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrModuleFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrModuleFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrNativeCodeMapEntry*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrNativeCodeMapEntry)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrNativeCodeMapEntry& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmCodeViewCompilerId*) :
    DisposeKind(StructureDispose), Size(sizeof(Symbols::DkmCodeViewCompilerId)), Id(__uuidof(Symbols::DkmCodeViewCompilerId))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmCodeViewCompilerId& element)
{
    return Symbols::DkmCodeViewCompilerId::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmCompilerId*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmCompilerId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmCompilerId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeKernelModel::e*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmComputeKernelModel::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeKernelModel::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeProperty*) :
    DisposeKind(StructureDispose), Size(sizeof(GPU::DkmComputeProperty)), Id(__uuidof(GPU::DkmComputeProperty))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeProperty& element)
{
    return GPU::DkmComputeProperty::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeThreadInfo*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmComputeThreadInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeThreadInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeThreadState::e*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmComputeThreadState::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeThreadState::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmDataAccessStopMask::e*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmDataAccessStopMask::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmDataAccessStopMask::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmDeploymentCommandFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmDeploymentCommandFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmDeploymentCommandFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmDocumentMatchStrength::e*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmDocumentMatchStrength::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmDocumentMatchStrength::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmDumpType::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmDumpType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmDumpType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Disassembly::DkmEffectiveAddress*) :
    DisposeKind(NoDispose), Size(sizeof(Disassembly::DkmEffectiveAddress)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Disassembly::DkmEffectiveAddress& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Disassembly::DkmEffectiveAddressFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Disassembly::DkmEffectiveAddressFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Disassembly::DkmEffectiveAddressFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmEngineFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmEngineFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmEngineFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultAccessType::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultAccessType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultAccessType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultCategory::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultCategory::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultCategory::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultStorageType::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultStorageType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultStorageType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultTypeModifierFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultTypeModifierFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultTypeModifierFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Exceptions::DkmExceptionInterceptActionFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Exceptions::DkmExceptionInterceptActionFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Exceptions::DkmExceptionInterceptActionFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Exceptions::DkmExceptionProcessingStage::e*) :
    DisposeKind(NoDispose), Size(sizeof(Exceptions::DkmExceptionProcessingStage::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Exceptions::DkmExceptionProcessingStage::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmFrameFormatOptions*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmFrameFormatOptions)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmFrameFormatOptions& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmFrameNameFormatOptions::e*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmFrameNameFormatOptions::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmFrameNameFormatOptions::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmFuncEvalFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmFuncEvalFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmFuncEvalFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmFuncEvalMode::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmFuncEvalMode::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmFuncEvalMode::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmGPUAddressType::e*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmGPUAddressType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmGPUAddressType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmGPUBreakpointBehaviorFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmGPUBreakpointBehaviorFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmGPUBreakpointBehaviorFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmGPURegisterDescription*) :
    DisposeKind(StructureDispose), Size(sizeof(GPU::DkmGPURegisterDescription)), Id(__uuidof(GPU::DkmGPURegisterDescription))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmGPURegisterDescription& element)
{
    return GPU::DkmGPURegisterDescription::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmHlslThreadIdComponents::e*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmHlslThreadIdComponents::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmHlslThreadIdComponents::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILCallingConvention::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILCallingConvention::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILCallingConvention::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILFailureReason::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILFailureReason::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILFailureReason::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILFunctionEvaluationFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILFunctionEvaluationFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILFunctionEvaluationFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmILRange*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmILRange)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmILRange& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmImageDebugDirectoryFormat*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmImageDebugDirectoryFormat)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmImageDebugDirectoryFormat& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmLanguageStepIntoFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmLanguageStepIntoFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmLanguageStepIntoFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmLaunchedProcessInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmLaunchedProcessInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmLaunchedProcessInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmMD5HashValue*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmMD5HashValue)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmMD5HashValue& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmModuleFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmModuleFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmModuleFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmModuleId*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmModuleId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmModuleId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmModuleMemoryLayout::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmModuleMemoryLayout::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmModuleMemoryLayout::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmMonitorStackWalkResult*) :
    DisposeKind(StructureDispose), Size(sizeof(CallStack::DkmMonitorStackWalkResult)), Id(__uuidof(CallStack::DkmMonitorStackWalkResult))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmMonitorStackWalkResult& element)
{
    return CallStack::DkmMonitorStackWalkResult::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Native::DkmNativeAddressStepType::e*) :
    DisposeKind(NoDispose), Size(sizeof(Native::DkmNativeAddressStepType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Native::DkmNativeAddressStepType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Native::DkmNativeAddressType::e*) :
    DisposeKind(NoDispose), Size(sizeof(Native::DkmNativeAddressType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Native::DkmNativeAddressType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmNonUserCodeFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmNonUserCodeFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmNonUserCodeFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmPackageExecutionState::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmPackageExecutionState::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmPackageExecutionState::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmPackagedAppPlatform::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmPackagedAppPlatform::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmPackagedAppPlatform::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmPrimitiveObjectType::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmPrimitiveObjectType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmPrimitiveObjectType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmProcessLaunchEnvironmentFilterScenario::e*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmProcessLaunchEnvironmentFilterScenario::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmProcessLaunchEnvironmentFilterScenario::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmProcessLaunchModeFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmProcessLaunchModeFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmProcessLaunchModeFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmProcessorFeatures::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmProcessorFeatures::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmProcessorFeatures::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmQueryComputeThreadInfoFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmQueryComputeThreadInfoFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmQueryComputeThreadInfoFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmRVASizePair*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmRVASizePair)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmRVASizePair& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmReadMemoryFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmReadMemoryFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmReadMemoryFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmRemoteAuthenticationMode::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmRemoteAuthenticationMode::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmRemoteAuthenticationMode::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmResolvedDocumentWarning::e*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmResolvedDocumentWarning::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmResolvedDocumentWarning::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmRootVisualizedExpressionFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmRootVisualizedExpressionFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmRootVisualizedExpressionFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmRunningProcessFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmRunningProcessFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmRunningProcessFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmRunningProcessInfoPropertyMask::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmRunningProcessInfoPropertyMask::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmRunningProcessInfoPropertyMask::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmRuntimeInstanceId*) :
    DisposeKind(NoDispose), Size(sizeof(DkmRuntimeInstanceId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmRuntimeInstanceId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSHA1HashValue*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSHA1HashValue)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSHA1HashValue& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptDocumentFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptDocumentFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptDocumentFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptSymbolNextSteppingAction::e*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptSymbolNextSteppingAction::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptSymbolNextSteppingAction::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSourcePositionFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSourcePositionFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSourcePositionFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackMemoryRange*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackMemoryRange)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackMemoryRange& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackWalkFrameFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackWalkFrameFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackWalkFrameFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackWalkStatus::e*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackWalkStatus::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackWalkStatus::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmStartMethod::e*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmStartMethod::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmStartMethod::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmStepArbitrationReason::e*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmStepArbitrationReason::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmStepArbitrationReason::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmStepKind::e*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmStepKind::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmStepKind::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmStepUnit::e*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmStepUnit::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmStepUnit::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSteppingRange*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSteppingRange)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSteppingRange& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSteppingRangeBoundary::e*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSteppingRangeBoundary::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSteppingRangeBoundary::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmStoppingEventProcessingNextAction::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmStoppingEventProcessingNextAction::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmStoppingEventProcessingNextAction::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmSystemInformationFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmSystemInformationFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmSystemInformationFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskProperties*) :
    DisposeKind(StructureDispose), Size(sizeof(ParallelTasks::DkmTaskProperties)), Id(__uuidof(ParallelTasks::DkmTaskProperties))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskProperties& element)
{
    return ParallelTasks::DkmTaskProperties::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskStackSegment*) :
    DisposeKind(NoDispose), Size(sizeof(ParallelTasks::DkmTaskStackSegment)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskStackSegment& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmTextSpan*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmTextSpan)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmTextSpan& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmTransportConnectionFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmTransportConnectionFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmTransportConnectionFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmUserMessageOutputKind::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmUserMessageOutputKind::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmUserMessageOutputKind::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmVariableInfoFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmVariableInfoFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmVariableInfoFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ThreadProperties::DkmVolatileThreadFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(ThreadProperties::DkmVolatileThreadFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ThreadProperties::DkmVolatileThreadFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmWhereClause*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmWhereClause)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmWhereClause& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmCompiledVisualizationDataPriority::e*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmCompiledVisualizationDataPriority::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmCompiledVisualizationDataPriority::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmILInterpreterOptions::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmILInterpreterOptions::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmILInterpreterOptions::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapObjectInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedHeapObjectInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapObjectInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapRootInfo*) :
    DisposeKind(StructureDispose), Size(sizeof(Clr::DkmManagedHeapRootInfo)), Id(__uuidof(Clr::DkmManagedHeapRootInfo))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapRootInfo& element)
{
    return Clr::DkmManagedHeapRootInfo::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapSegmentInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedHeapSegmentInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapSegmentInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapTypeInfo*) :
    DisposeKind(StructureDispose), Size(sizeof(Clr::DkmManagedHeapTypeInfo)), Id(__uuidof(Clr::DkmManagedHeapTypeInfo))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapTypeInfo& element)
{
    return Clr::DkmManagedHeapTypeInfo::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedObjectReferenceInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedObjectReferenceInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedObjectReferenceInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmManagedTaskInfo*) :
    DisposeKind(StructureDispose), Size(sizeof(ParallelTasks::DkmManagedTaskInfo)), Id(__uuidof(ParallelTasks::DkmManagedTaskInfo))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmManagedTaskInfo& element)
{
    return ParallelTasks::DkmManagedTaskInfo::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedTypeId*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedTypeId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedTypeId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmMetadataStatus::e*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmMetadataStatus::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmMetadataStatus::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmRuntimeCapabilities::e*) :
    DisposeKind(NoDispose), Size(sizeof(DkmRuntimeCapabilities::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmRuntimeCapabilities::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptDocumentContentType::e*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptDocumentContentType::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptDocumentContentType::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptDocumentJmcState::e*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptDocumentJmcState::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptDocumentJmcState::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptEmbeddedDocumentKind::e*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptEmbeddedDocumentKind::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptEmbeddedDocumentKind::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackWalkOperation::e*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackWalkOperation::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackWalkOperation::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskProviderCapabilityFlags::e*) :
    DisposeKind(NoDispose), Size(sizeof(ParallelTasks::DkmTaskProviderCapabilityFlags::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskProviderCapabilityFlags::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskReturnStatus::e*) :
    DisposeKind(NoDispose), Size(sizeof(ParallelTasks::DkmTaskReturnStatus::e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskReturnStatus::e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const bool*) :
    DisposeKind(NoDispose), Size(sizeof(bool)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(bool& element)
{ /* no cleanup is necessary */ }

};};}; // end namespace Microsoft::VisualStudio::Debugger

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDataContainerSet(
    IUnknown*,
    Microsoft::VisualStudio::Debugger::DkmDataCreationDisposition::e,
    const Microsoft::VisualStudio::Debugger::DkmDataItem&
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDataContainerGet(
    IUnknown*,
    REFGUID,
    _Deref_out_ IUnknown**
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDataContainerRemove(
    IUnknown*,
    REFGUID
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmAlloc(
    size_t bytes,
    void** ppMemory
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void STDMETHODCALLTYPE ProcDkmFree(
    void* pMemory
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void STDMETHODCALLTYPE ProcDkmReleaseInterface(
    IUnknown* pObject
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void* STDMETHODCALLTYPE ProcDkmGetExtendedPart(
    IUnknown* pObject,
    REFGUID PartId
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmInitializeThread(
    REFGUID guidComponentId,
    void* Reserved
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmUninitializeThread(
    REFGUID guidComponentId
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGetCurrentComponentId(
    GUID* pComponentId
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmAllowComponentReentrancy(
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDisableComponentReentrancy(
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
bool STDMETHODCALLTYPE ProcDkmIsApiVersionSupported(
    Microsoft::VisualStudio::Debugger::DkmApiVersion::e apiVersion
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmFindComponentHandle(
    _In_ REFGUID componentInfo,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmComponentHandle* componentHandle
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmPopComponentTransition(
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmComponentHandle pComponentHandle
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmPushComponentTransition(
    _In_ Microsoft::VisualStudio::Debugger::DkmComponentHandle componentHandle
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmInitializeThreadByHandle(
    _In_ Microsoft::VisualStudio::Debugger::DkmComponentHandle componentHandle
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmUninitializeThreadByHandle(
    _In_ Microsoft::VisualStudio::Debugger::DkmComponentHandle componentHandle
    );


extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListCreate(
    Microsoft::VisualStudio::Debugger::IDkmWorkListCompletionRoutine* pCompletionRoutine,
    Microsoft::VisualStudio::Debugger::DkmWorkList** ppCreatedObject
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListQueryIsCurrentInstanceCanceled(
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListBeginExecution(
    Microsoft::VisualStudio::Debugger::DkmWorkList*
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListExecute(
    Microsoft::VisualStudio::Debugger::DkmWorkList*
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListCancel(
    Microsoft::VisualStudio::Debugger::DkmWorkList*
    );

enum VSDEBUGENG_HRESULT
{
    // Symbols are not loaded for the target dll.
    E_SYMBOLS_NOT_LOADED__ = 0x92330000,
    // Symbols for the target dll do not contain source information.
    E_SYMBOLS_STRIPPED__ = 0x92330001,
    // Breakpoint could not be written at the specified instruction address.
    E_BP_INVALID_ADDRESS__ = 0x92330002,
    // Breakpoints cannot be set in optimized code when the debugger option 'Just My Code' is enabled.
    E_BP_IN_OPTIMIZED_CODE__ = 0x92330004,
    // The Common Language Runtime was unable to set the breakpoint.
    E_BP_CLR_ERROR__ = 0x92330006,
    // Cannot set breakpoints in .NET Framework methods which are implemented in native code (ex: 'extern' function).
    E_BP_CLR_EXTERN_FUNCTION__ = 0x92330007,
    // Cannot set breakpoint, target module is currently unloaded.
    E_BP_MODULE_UNLOADED__ = 0x92330008,
    // Stopping events cannot be sent. See stopping event processing documentation for more information.
    E_STOPPING_EVENT_REJECTED__ = 0x92330009,
    // This operation is not permitted because the target process is already stopped.
    E_TARGET_ALREADY_STOPPED__ = 0x9233000A,
    // This operation is not permitted because the target process is not stopped.
    E_TARGET_NOT_STOPPED__ = 0x9233000B,
    // This operation is not allowed on this thread.
    E_WRONG_THREAD__ = 0x9233000C,
    // This operation is not allowed at this time.
    E_WRONG_TIME__ = 0x9233000D,
    // The caller is not allowed to request this operation. This operation must be requested by a different component.
    E_WRONG_COMPONENT__ = 0x9233000E,
    // Operation is only permitted on the latest version of an editted method.
    E_WRONG_METHOD_VERSION__ = 0x9233000F,
    // A memory read or write operation failed because the specified memory address is not currently valid.
    E_INVALID_MEMORY_ADDRESS__ = 0x92330010,
    // No source information is available for this instruction.
    E_INSTRUCTION_NO_SOURCE__ = 0x92330011,
    // Failed to load localizable resource from vsdebugeng.impl.resources.dll. If this problem persists, please repair your Visual Studio installation via 'Add or Remove Programs' in Control Panel.
    E_VSDEBUGENG_RESOURCE_LOAD_FAILURE__ = 0x92330012,
    // DkmVariant is of a form that marshalling is not supported. Marshalling is supported for primitives types, strings, and safe arrays of primitives.
    E_UNMARSHALLABLE_VARIANT__ = 0x92330013,
    // An incorrect version of vsdebugeng.dll was loaded into Visual Studio. Please repair your Visual Studio installation.
    E_VSDEBUGENG_DEPLOYMENT_ERROR__ = 0x92330014,
    // The remote debugger was unable to initialize Microsoft Windows Web Services (webservices.dll). If the problem continues, try reinstalling the Windows Web Services redistributable. This redistributable can be found under the 'Remote Debugger\\Common Resources\\Windows Updates' folder.
    E_WEBSERVICES_LOAD_FAILURE__ = 0x92330015,
    // Visual Studio encountered an error while loading a Windows component (Global Interface Table). If the problem persists, this may be an indication of operating system corruption, and Windows may need to be reinstalled.
    E_GLOBAL_INTERFACE_POINTER_FAILURE__ = 0x92330016,
    // Windows authentication was unable to establish a secure connection to the remote computer.
    E_REMOTE_AUTHENTICATION_ERROR__ = 0x92330017,
    // The Remote Debugger was unable to locate a resource dll (vsdebugeng.impl.resources.dll). Please ensure that the complete remote debugger folder was copied or installed on the target computer.
    E_CANNOT_FIND_REMOTE_RESOURCES__ = 0x92330018,
    // The hardware does not support monitoring the requested number of bytes.
    E_INVALID_DATABP_SIZE__ = 0x92330020,
    // The maximum number of data breakpoints have already been set.
    E_INVALID_DATABP_ALLREGSUSED__ = 0x92330021,
    // Breakpoints cannot be set while debugging a minidump.
    E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS__ = 0x92330022,
    // The minidump is from an ARM-based computer and can only be debugged on an ARM computer.
    E_DUMP_ARM_ARCHITECTURE__ = 0x92330023,
    // The minidump is from an unknown processor, and cannot be debugged with this version of Visual Studio.
    E_DUMP_UNKNOWN_ARCHITECTURE__ = 0x92330024,
    // The shell failed to find a checksum for this file.
    E_NO_CHECKSUM__ = 0x92330025,
    // On x64, context control must be included in a SetThreadContext
    E_CONTEXT_CONTROL_REQUIRED__ = 0x92330026,
    // The size of the buffer does not match the size of the register.
    E_INVALID_REGISTER_SIZE__ = 0x92330027,
    // The requested register was not found in the stack frame's unwound register collection.
    E_REGISTER_NOT_FOUND__ = 0x92330028,
    // Cannot set a read-only register.
    E_REGISTER_READONLY__ = 0x92330029,
    // Cannot set a register in a frame that is not the top of the stack.
    E_REG_NOT_TOP_STACK__ = 0x92330030,
    // String could not be read within the specified maximum number of characters.
    E_STRING_TOO_LONG__ = 0x92330031,
    // The memory region does not meet the requested protection flags.
    E_INVALID_MEMORY_PROTECT__ = 0x92330032,
    // Instruction is invalid or unknown to the disassembler.
    E_UNKNOWN_CPU_INSTRUCTION__ = 0x92330033,
    // An invliad runtime was specified for this operation.
    E_INVALID_RUNTIME__ = 0x92330034,
    // Variable is optimized away.
    E_VARIABLE_OPTIMIZED_AWAY__ = 0x92330035,
    // The text span is not currently loaded in the specified script document.
    E_TEXT_SPAN_NOT_LOADED__ = 0x92330036,
    // This location could not be mapped to client side script.
    E_SCRIPT_SPAN_MAPPING_FAILED__ = 0x92330037,
    // The file requested must be less than 100 megabytes in size
    E_DEPLOY_FILE_TOO_LARGE__ = 0x92330038,
    // The file path requested could not be written to as it is invalid. Ensure the path does not contain a file where a directory is expected.
    E_DEPLOY_FILE_PATH_INVALID__ = 0x92330039,
    // Script debugging is not enabled for WWAHost.exe.
    E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED__ = 0x92330040,
    // The file path requested for deletion does not exist.
    E_DEPLOY_FILE_NOT_EXIST__ = 0x92330041,
    // A command is already executing, only one may execute at a time. Please wait for the executable to exit, or abort the command.
    E_EXECUTE_COMMAND_IN_PROGRESS__ = 0x92330042,
    // The specified file path is a relative or unknown path format. File paths must be fully qualified.
    E_INVALID_FULL_PATH__ = 0x92330043,
    // Windows Store app debugging is not possible when the remote debugger is running as a service. Run the Remote Debugger Configuration Wizard on the target computer, and uncheck the option to start the remote debugger service. Then start the Visual Studio Remote Debugging Monitor application.
    E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE__ = 0x92330044,
    // Applications cannot be launched under the debugger when the remote debugger is running as a service. Run the Remote Debugger Configuration Wizard on the target computer, and uncheck the option to start the remote debugger service. Then start the Visual Studio Remote Debugging Monitor application.
    E_CANNOT_LAUNCH_IN_RDBSERVICE__ = 0x92330045,
    // The AD7 AL Causality bridge has already been initialized.
    E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED__ = 0x92330046,
    // App Packages may only be shutdown as part of a Visual Studio build operation.
    E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME__ = 0x92330047,
    // A Microsoft Windows component is not correctly registered. If the problem persists, try repairing your Windows installation, or reinstalling Windows.
    E_WINDOWS_REG_ERROR__ = 0x92330048,
    // The application never reached a suspended state.
    E_APP_PACKAGE_NEVER_SUSPENDED__ = 0x92330049,
    // A different version of this script file has been loaded by the debugged process. The script file may need to be reloaded.
    E_SCRIPT_FILE_DIFFERENT_CONTENT__ = 0x9233004A,
    // No stack frame was found.
    E_NO_FRAME__ = 0x9233004B,
    // Operation is not supported while interop debugging.
    E_NOT_SUPPORTED_INTEROP__ = 0x9233004C,
    // The selected accelerator does not support the run current tile to cursor operation.
    E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED__ = 0x9233004D,
    // Data breakpoints are not supported on this platform.
    E_DATABPS_NOTSUPPORTED__ = 0x9233004E,
    // An invalid NativeOffset or CPUInstructionPart value was used with a DkmClrInstructionAddress or DkmClrInstructionSymbol
    E_INVALID_CLR_INSTRUCTION_NATIVE_OFFSET__ = 0x92330055,
    // Managed heap is not in a state that can be enumerated
    E_MANAGED_HEAP_NOT_ENUMERABLE__ = 0x92330056,
    // This operation is unavailable when mixed mode debugging with Script
    E_OPERATION_UNAVAILABLE_SCRIPT_INTEROP__ = 0x92330057,
    // This operation is unavailable when debugging native-compiled .NET code.
    E_OPERATION_UNAVAILABLE_CLR_NC__ = 0x92330058,
    // Symbol file contains data which is in an unexpected format.
    E_BAD_SYMBOL_DATA__ = 0x92330059,
    // Dynamically enabling script debugging in the target process failed.
    E_ENABLE_SCRIPT_DEBUGGING_FAILED__ = 0x9233005A,
    // Expression evaluation is not available in async call stack frames.
    E_SCRIPT_ASYNC_FRAME_EE_UNAVAILABLE__ = 0x9233005B
};
#define E_SYMBOLS_NOT_LOADED _HRESULT_TYPEDEF_(E_SYMBOLS_NOT_LOADED__)
#define E_SYMBOLS_STRIPPED _HRESULT_TYPEDEF_(E_SYMBOLS_STRIPPED__)
#define E_BP_INVALID_ADDRESS _HRESULT_TYPEDEF_(E_BP_INVALID_ADDRESS__)
#define E_BP_IN_OPTIMIZED_CODE _HRESULT_TYPEDEF_(E_BP_IN_OPTIMIZED_CODE__)
#define E_BP_CLR_ERROR _HRESULT_TYPEDEF_(E_BP_CLR_ERROR__)
#define E_BP_CLR_EXTERN_FUNCTION _HRESULT_TYPEDEF_(E_BP_CLR_EXTERN_FUNCTION__)
#define E_BP_MODULE_UNLOADED _HRESULT_TYPEDEF_(E_BP_MODULE_UNLOADED__)
#define E_STOPPING_EVENT_REJECTED _HRESULT_TYPEDEF_(E_STOPPING_EVENT_REJECTED__)
#define E_TARGET_ALREADY_STOPPED _HRESULT_TYPEDEF_(E_TARGET_ALREADY_STOPPED__)
#define E_TARGET_NOT_STOPPED _HRESULT_TYPEDEF_(E_TARGET_NOT_STOPPED__)
#define E_WRONG_THREAD _HRESULT_TYPEDEF_(E_WRONG_THREAD__)
#define E_WRONG_TIME _HRESULT_TYPEDEF_(E_WRONG_TIME__)
#define E_WRONG_COMPONENT _HRESULT_TYPEDEF_(E_WRONG_COMPONENT__)
#define E_WRONG_METHOD_VERSION _HRESULT_TYPEDEF_(E_WRONG_METHOD_VERSION__)
#define E_INVALID_MEMORY_ADDRESS _HRESULT_TYPEDEF_(E_INVALID_MEMORY_ADDRESS__)
#define E_INSTRUCTION_NO_SOURCE _HRESULT_TYPEDEF_(E_INSTRUCTION_NO_SOURCE__)
#define E_VSDEBUGENG_RESOURCE_LOAD_FAILURE _HRESULT_TYPEDEF_(E_VSDEBUGENG_RESOURCE_LOAD_FAILURE__)
#define E_UNMARSHALLABLE_VARIANT _HRESULT_TYPEDEF_(E_UNMARSHALLABLE_VARIANT__)
#define E_VSDEBUGENG_DEPLOYMENT_ERROR _HRESULT_TYPEDEF_(E_VSDEBUGENG_DEPLOYMENT_ERROR__)
#define E_WEBSERVICES_LOAD_FAILURE _HRESULT_TYPEDEF_(E_WEBSERVICES_LOAD_FAILURE__)
#define E_GLOBAL_INTERFACE_POINTER_FAILURE _HRESULT_TYPEDEF_(E_GLOBAL_INTERFACE_POINTER_FAILURE__)
#define E_REMOTE_AUTHENTICATION_ERROR _HRESULT_TYPEDEF_(E_REMOTE_AUTHENTICATION_ERROR__)
#define E_CANNOT_FIND_REMOTE_RESOURCES _HRESULT_TYPEDEF_(E_CANNOT_FIND_REMOTE_RESOURCES__)
#define E_INVALID_DATABP_SIZE _HRESULT_TYPEDEF_(E_INVALID_DATABP_SIZE__)
#define E_INVALID_DATABP_ALLREGSUSED _HRESULT_TYPEDEF_(E_INVALID_DATABP_ALLREGSUSED__)
#define E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS _HRESULT_TYPEDEF_(E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS__)
#define E_DUMP_ARM_ARCHITECTURE _HRESULT_TYPEDEF_(E_DUMP_ARM_ARCHITECTURE__)
#define E_DUMP_UNKNOWN_ARCHITECTURE _HRESULT_TYPEDEF_(E_DUMP_UNKNOWN_ARCHITECTURE__)
#define E_NO_CHECKSUM _HRESULT_TYPEDEF_(E_NO_CHECKSUM__)
#define E_CONTEXT_CONTROL_REQUIRED _HRESULT_TYPEDEF_(E_CONTEXT_CONTROL_REQUIRED__)
#define E_INVALID_REGISTER_SIZE _HRESULT_TYPEDEF_(E_INVALID_REGISTER_SIZE__)
#define E_REGISTER_NOT_FOUND _HRESULT_TYPEDEF_(E_REGISTER_NOT_FOUND__)
#define E_REGISTER_READONLY _HRESULT_TYPEDEF_(E_REGISTER_READONLY__)
#define E_REG_NOT_TOP_STACK _HRESULT_TYPEDEF_(E_REG_NOT_TOP_STACK__)
#define E_STRING_TOO_LONG _HRESULT_TYPEDEF_(E_STRING_TOO_LONG__)
#define E_INVALID_MEMORY_PROTECT _HRESULT_TYPEDEF_(E_INVALID_MEMORY_PROTECT__)
#define E_UNKNOWN_CPU_INSTRUCTION _HRESULT_TYPEDEF_(E_UNKNOWN_CPU_INSTRUCTION__)
#define E_INVALID_RUNTIME _HRESULT_TYPEDEF_(E_INVALID_RUNTIME__)
#define E_VARIABLE_OPTIMIZED_AWAY _HRESULT_TYPEDEF_(E_VARIABLE_OPTIMIZED_AWAY__)
#define E_TEXT_SPAN_NOT_LOADED _HRESULT_TYPEDEF_(E_TEXT_SPAN_NOT_LOADED__)
#define E_SCRIPT_SPAN_MAPPING_FAILED _HRESULT_TYPEDEF_(E_SCRIPT_SPAN_MAPPING_FAILED__)
#define E_DEPLOY_FILE_TOO_LARGE _HRESULT_TYPEDEF_(E_DEPLOY_FILE_TOO_LARGE__)
#define E_DEPLOY_FILE_PATH_INVALID _HRESULT_TYPEDEF_(E_DEPLOY_FILE_PATH_INVALID__)
#define E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED _HRESULT_TYPEDEF_(E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED__)
#define E_DEPLOY_FILE_NOT_EXIST _HRESULT_TYPEDEF_(E_DEPLOY_FILE_NOT_EXIST__)
#define E_EXECUTE_COMMAND_IN_PROGRESS _HRESULT_TYPEDEF_(E_EXECUTE_COMMAND_IN_PROGRESS__)
#define E_INVALID_FULL_PATH _HRESULT_TYPEDEF_(E_INVALID_FULL_PATH__)
#define E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE _HRESULT_TYPEDEF_(E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE__)
#define E_CANNOT_LAUNCH_IN_RDBSERVICE _HRESULT_TYPEDEF_(E_CANNOT_LAUNCH_IN_RDBSERVICE__)
#define E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED _HRESULT_TYPEDEF_(E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED__)
#define E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME _HRESULT_TYPEDEF_(E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME__)
#define E_WINDOWS_REG_ERROR _HRESULT_TYPEDEF_(E_WINDOWS_REG_ERROR__)
#define E_APP_PACKAGE_NEVER_SUSPENDED _HRESULT_TYPEDEF_(E_APP_PACKAGE_NEVER_SUSPENDED__)
#define E_SCRIPT_FILE_DIFFERENT_CONTENT _HRESULT_TYPEDEF_(E_SCRIPT_FILE_DIFFERENT_CONTENT__)
#define E_NO_FRAME _HRESULT_TYPEDEF_(E_NO_FRAME__)
#define E_NOT_SUPPORTED_INTEROP _HRESULT_TYPEDEF_(E_NOT_SUPPORTED_INTEROP__)
#define E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED _HRESULT_TYPEDEF_(E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED__)
#define E_DATABPS_NOTSUPPORTED _HRESULT_TYPEDEF_(E_DATABPS_NOTSUPPORTED__)
#define E_INVALID_CLR_INSTRUCTION_NATIVE_OFFSET _HRESULT_TYPEDEF_(E_INVALID_CLR_INSTRUCTION_NATIVE_OFFSET__)
#define E_MANAGED_HEAP_NOT_ENUMERABLE _HRESULT_TYPEDEF_(E_MANAGED_HEAP_NOT_ENUMERABLE__)
#define E_OPERATION_UNAVAILABLE_SCRIPT_INTEROP _HRESULT_TYPEDEF_(E_OPERATION_UNAVAILABLE_SCRIPT_INTEROP__)
#define E_OPERATION_UNAVAILABLE_CLR_NC _HRESULT_TYPEDEF_(E_OPERATION_UNAVAILABLE_CLR_NC__)
#define E_BAD_SYMBOL_DATA _HRESULT_TYPEDEF_(E_BAD_SYMBOL_DATA__)
#define E_ENABLE_SCRIPT_DEBUGGING_FAILED _HRESULT_TYPEDEF_(E_ENABLE_SCRIPT_DEBUGGING_FAILED__)
#define E_SCRIPT_ASYNC_FRAME_EE_UNAVAILABLE _HRESULT_TYPEDEF_(E_SCRIPT_ASYNC_FRAME_EE_UNAVAILABLE__)
enum XAPI_HRESULT
{
    // A component dll failed to load. Try to restart this application. If failures continue, try disabling any installed add-ins or repair your installation.
    E_XAPI_COMPONENT_LOAD_FAILURE__ = 0x8EDE0000,
    // Xapi has not been initialized on this thread. Call ComponentManager.InitializeThread.
    E_XAPI_NOT_INITIALIZED__ = 0x8EDE0001,
    // Xapi has already been initialized on this thread.
    E_XAPI_ALREADY_INITIALIZED__ = 0x8EDE0002,
    // Xapi event thread aborted unexpectedly.
    E_XAPI_THREAD_ABORTED__ = 0x8EDE0003,
    // Component failed a call to QueryInterface. QueryInterface implementation or component configuration is incorrect.
    E_XAPI_BAD_QUERY_INTERFACE__ = 0x8EDE0004,
    // Object requested which is not available at the caller's component level.
    E_XAPI_UNAVAILABLE_OBJECT__ = 0x8EDE0005,
    // Failed to process configuration file. Try to restart this application. If failures continue, try to repair your installation.
    E_XAPI_BAD_CONFIG__ = 0x8EDE0006,
    // Failed to initialize managed/native marshalling system. Try to restart this application. If failures continue, try to repair your installation.
    E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE__ = 0x8EDE0007,
    // This operation may only be preformed while processing the object's 'Create' event.
    E_XAPI_DURING_CREATE_EVENT_REQUIRED__ = 0x8EDE0008,
    // This operation may only be preformed by the component which created the object.
    E_XAPI_CREATOR_REQUIRED__ = 0x8EDE0009,
    // The work item cannot be appended to the work list because it is already complete.
    E_XAPI_WORK_LIST_COMPLETE__ = 0x8EDE000A,
    // 'Execute' may not be called on a work list which has already started.
    E_XAPI_WORKLIST_ALREADY_STARTED__ = 0x8EDE000B,
    // The interface implementation released the completion routine without calling it.
    E_XAPI_COMPLETION_ROUTINE_RELEASED__ = 0x8EDE000C,
    // Operation is not supported on this thread.
    E_XAPI_WRONG_THREAD__ = 0x8EDE000D,
    // No component with the given component id could be found in the configuration store.
    E_XAPI_COMPONENTID_NOT_FOUND__ = 0x8EDE000E,
    // Call was attempted to a remote connection from a server-side component (component level > 100000). This is not allowed.
    E_XAPI_WRONG_CONNECTION_OBJECT__ = 0x8EDE000F,
    // Destination of this call is on a remote connection and this method doesn't support remoting.
    E_XAPI_METHOD_NOT_REMOTED__ = 0x8EDE0010,
    // The network connection to the Visual Studio Remote Debugger was lost.
    E_XAPI_REMOTE_DISCONNECTED__ = 0x8EDE0011,
    // The network connection to the Visual Studio Remote Debugger has been closed.
    E_XAPI_REMOTE_CLOSED__ = 0x8EDE0012,
    // A protocol compatibility error occurred between Visual Studio and the Remote Debugger. Please ensure that the Visual Studio and Remote debugger versions match.
    E_XAPI_INCOMPATIBLE_PROTOCOL__ = 0x8EDE0013,
    // Maximum allocation size exceeded while processing a remoting message.
    E_XAPI_MAX_PACKET_EXCEEDED__ = 0x8EDE0014,
    // An object already exists with the same key value.
    E_XAPI_OBJECT_ALREADY_EXISTS__ = 0x8EDE0015,
    // An object cannot be found with the given key value.
    E_XAPI_OBJECT_NOT_FOUND__ = 0x8EDE0016,
    // A data item already exists with the same key value.
    E_XAPI_DATA_ITEM_ALREADY_EXISTS__ = 0x8EDE0017,
    // A data item cannot be for this component found with the given data item ID.
    E_XAPI_DATA_ITEM_NOT_FOUND__ = 0x8EDE0018,
    // Interface implementation failed to provide a required out param.
    E_XAPI_NULL_OUT_PARAM__ = 0x8EDE0019,
    // Strong name signature validation error while trying to load the managed dispatcher
    E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR__ = 0x8EDE0020,
    // Method may only be called by components which load in the IDE process (copmonent level > 100000).
    E_XAPI_CLIENT_ONLY_METHOD__ = 0x8EDE0021,
    // Method may only be called by components which load in the remote debugger process (copmonent level < 100000).
    E_XAPI_SERVER_ONLY_METHOD__ = 0x8EDE0022,
    // A component dll could not be found. If failures continue, try disabling any installed add-ins or repairing your installation.
    E_XAPI_COMPONENT_DLL_NOT_FOUND__ = 0x8EDE0023,
    // Operation requires the remote debugger be updated to a newer version.
    E_XAPI_REMOTE_NEW_VER_REQUIRED__ = 0x8EDE0024
};
#define E_XAPI_COMPONENT_LOAD_FAILURE _HRESULT_TYPEDEF_(E_XAPI_COMPONENT_LOAD_FAILURE__)
#define E_XAPI_NOT_INITIALIZED _HRESULT_TYPEDEF_(E_XAPI_NOT_INITIALIZED__)
#define E_XAPI_ALREADY_INITIALIZED _HRESULT_TYPEDEF_(E_XAPI_ALREADY_INITIALIZED__)
#define E_XAPI_THREAD_ABORTED _HRESULT_TYPEDEF_(E_XAPI_THREAD_ABORTED__)
#define E_XAPI_BAD_QUERY_INTERFACE _HRESULT_TYPEDEF_(E_XAPI_BAD_QUERY_INTERFACE__)
#define E_XAPI_UNAVAILABLE_OBJECT _HRESULT_TYPEDEF_(E_XAPI_UNAVAILABLE_OBJECT__)
#define E_XAPI_BAD_CONFIG _HRESULT_TYPEDEF_(E_XAPI_BAD_CONFIG__)
#define E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE _HRESULT_TYPEDEF_(E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE__)
#define E_XAPI_DURING_CREATE_EVENT_REQUIRED _HRESULT_TYPEDEF_(E_XAPI_DURING_CREATE_EVENT_REQUIRED__)
#define E_XAPI_CREATOR_REQUIRED _HRESULT_TYPEDEF_(E_XAPI_CREATOR_REQUIRED__)
#define E_XAPI_WORK_LIST_COMPLETE _HRESULT_TYPEDEF_(E_XAPI_WORK_LIST_COMPLETE__)
#define E_XAPI_WORKLIST_ALREADY_STARTED _HRESULT_TYPEDEF_(E_XAPI_WORKLIST_ALREADY_STARTED__)
#define E_XAPI_COMPLETION_ROUTINE_RELEASED _HRESULT_TYPEDEF_(E_XAPI_COMPLETION_ROUTINE_RELEASED__)
#define E_XAPI_WRONG_THREAD _HRESULT_TYPEDEF_(E_XAPI_WRONG_THREAD__)
#define E_XAPI_COMPONENTID_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_COMPONENTID_NOT_FOUND__)
#define E_XAPI_WRONG_CONNECTION_OBJECT _HRESULT_TYPEDEF_(E_XAPI_WRONG_CONNECTION_OBJECT__)
#define E_XAPI_METHOD_NOT_REMOTED _HRESULT_TYPEDEF_(E_XAPI_METHOD_NOT_REMOTED__)
#define E_XAPI_REMOTE_DISCONNECTED _HRESULT_TYPEDEF_(E_XAPI_REMOTE_DISCONNECTED__)
#define E_XAPI_REMOTE_CLOSED _HRESULT_TYPEDEF_(E_XAPI_REMOTE_CLOSED__)
#define E_XAPI_INCOMPATIBLE_PROTOCOL _HRESULT_TYPEDEF_(E_XAPI_INCOMPATIBLE_PROTOCOL__)
#define E_XAPI_MAX_PACKET_EXCEEDED _HRESULT_TYPEDEF_(E_XAPI_MAX_PACKET_EXCEEDED__)
#define E_XAPI_OBJECT_ALREADY_EXISTS _HRESULT_TYPEDEF_(E_XAPI_OBJECT_ALREADY_EXISTS__)
#define E_XAPI_OBJECT_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_OBJECT_NOT_FOUND__)
#define E_XAPI_DATA_ITEM_ALREADY_EXISTS _HRESULT_TYPEDEF_(E_XAPI_DATA_ITEM_ALREADY_EXISTS__)
#define E_XAPI_DATA_ITEM_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_DATA_ITEM_NOT_FOUND__)
#define E_XAPI_NULL_OUT_PARAM _HRESULT_TYPEDEF_(E_XAPI_NULL_OUT_PARAM__)
#define E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR _HRESULT_TYPEDEF_(E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR__)
#define E_XAPI_CLIENT_ONLY_METHOD _HRESULT_TYPEDEF_(E_XAPI_CLIENT_ONLY_METHOD__)
#define E_XAPI_SERVER_ONLY_METHOD _HRESULT_TYPEDEF_(E_XAPI_SERVER_ONLY_METHOD__)
#define E_XAPI_COMPONENT_DLL_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_COMPONENT_DLL_NOT_FOUND__)
#define E_XAPI_REMOTE_NEW_VER_REQUIRED _HRESULT_TYPEDEF_(E_XAPI_REMOTE_NEW_VER_REQUIRED__)

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmString0(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& InputString,
    Microsoft::VisualStudio::Debugger::DkmString** ppString
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmString1(
    DWORD CodePage,
    _In_bytecount_(cbMultiByte) const char* pMultiByteString,
    size_t cbMultiByte,
    Microsoft::VisualStudio::Debugger::DkmString** ppString
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
int STDMETHODCALLTYPE ProcDkmString2(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
int STDMETHODCALLTYPE ProcDkmString3(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    );


extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmString4(
    _In_count_(cSources) const Microsoft::VisualStudio::Debugger::DkmSourceString sources[],
    DWORD cSources,
    Microsoft::VisualStudio::Debugger::DkmString** ppString
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE ProcDkmString5(
    );


extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmReadOnlyCollectionCreate(
    _In_count_(ElementCount) const void* source,
    DWORD ElementCount,
    const Microsoft::VisualStudio::Debugger::DkmCollectionElementDescriptor& elementDescriptor,
    void** ppCollection
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void* STDMETHODCALLTYPE ProcDkmReadOnlyCollectionEmpty(
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void __declspec(noreturn) STDMETHODCALLTYPE ProcDkmReadOnlyCollectionBadIndex(
    void* pCollection,
    size_t index
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmVariant0(
    _Inout_ VARIANT* pSource,
    _Deref_out_opt_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmVariant1(
    _In_count_(size) const BYTE* pValue,
    DWORD size,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
LCID STDMETHODCALLTYPE ProcDkmGlobalSettings0();

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings1(Microsoft::VisualStudio::Debugger::DkmString**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings2(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings3(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
DWORD STDMETHODCALLTYPE ProcDkmGlobalSettings4();

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings5(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);


DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Create(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& InputString,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    return ProcDkmString0(InputString, ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Create(
    _In_ DWORD CodePage,
    _In_bytecount_(cbMultiByte) const char* pMultiByteString,
    _In_ size_t cbMultiByte,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    return ProcDkmString1(CodePage, pMultiByteString, cbMultiByte, ppString);
}

DECLSPEC_NOTHROW /*static*/ inline int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::CompareOrdinal(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    )
{
    return ProcDkmString2(a,b);
}

DECLSPEC_NOTHROW /*static*/ inline int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::CompareOrdinalIgnoreCase(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    )
{
    return ProcDkmString3(a,b);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item7,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6, item7 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item7,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item8,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6, item7, item8 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item7,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item8,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item9,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6, item7, item8, item9 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::ConcatV(
    _In_count_(cSources) const Microsoft::VisualStudio::Debugger::DkmSourceString sources[],
    _In_ DWORD cSources,
    _Deref_out_ DkmString** ppString
    )
{
#pragma warning(suppress:6385) // Disable 'Invalid data: accessing 'argument 1', the readable size is 'cSources*0' bytes, but '8' bytes might be read'
    return ProcDkmString4(sources, cSources, ppString);
}

_Ret_ DECLSPEC_NOTHROW /*static*/ inline Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Empty(
    )
{
    return ProcDkmString5();
}

template <class T>
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>::Create(
    _In_count_(Count) const T* pItemArray,
    _In_ DWORD Count,
    _Deref_out_ DkmReadOnlyCollection<T>** ppCollection
    )
{
    C_ASSERT(__alignof(T) <= 16); // This collection class can only be used with types that require 16-byte alignment or less
    DkmCollectionElementDescriptor elementDescriptor(pItemArray);

    return ProcDkmReadOnlyCollectionCreate(pItemArray, Count, elementDescriptor, (void**)ppCollection);
}

template <class T>
DECLSPEC_NOTHROW /*static*/ inline const T& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>::Element(
    size_t index
    )
{
    if (index >= m_Count)
    {
        ProcDkmReadOnlyCollectionBadIndex(this, index);
    }

    return m_Items[index];
}

template <class T>
_Ret_ DECLSPEC_NOTHROW /*static*/ inline Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>::Empty(
    )
{
    return (DkmReadOnlyCollection<T>*)ProcDkmReadOnlyCollectionEmpty();
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmVariant::Convert(
    _Inout_ VARIANT* pSource,
    _Deref_out_opt_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    )
{
    return ProcDkmVariant0(pSource, ppVariant);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmVariant::Create(
    _In_count_(size) const BYTE* pValue,
    DWORD size,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    )
{
    return ProcDkmVariant1(pValue, size, ppVariant);
}


DECLSPEC_NOTHROW /*static*/ inline LCID STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::Locale()
{
    return ProcDkmGlobalSettings0();
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetRegistryRoot(_Deref_out_opt_ DkmString** ppValue)
{
    return ProcDkmGlobalSettings1(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetVisualizerPaths(_Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppValue)
{
    return ProcDkmGlobalSettings2(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetStepFilterPaths(_Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppValue)
{
    return ProcDkmGlobalSettings3(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline DWORD STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::RootProcessId()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS11FeaturePack1) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return ProcDkmGlobalSettings4();
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetJustMyCodePaths(_Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppValue)
{
    return ProcDkmGlobalSettings5(ppValue);
}

extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1E8D5F0C922FF9B67FDDD80B2ED6503B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEDC75945D166F34184CD05BE77F99EE5(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCAF4269E8986B80CE0D8D9E03E81B4D3(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc220C93F26AF511DF6CEB8F7ED67347FD(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CB5A7081B1ECE9D3867EC558F028B01(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableBoundBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC8789CC74E265D785FAC9687BCA58590(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableBoundBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF294D5B58C198B7ACF2AF61B645BFE5E(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD12950265C8C561E2385E7B1918F3B8B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc10B0816A10DF6638455B6A097A890E3A(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDFB5690535A81F9A14E31EEFC96C6363(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB6A0881929281E26ADD0F69F08CB7E3B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDBD59238A6D89616EAEA09CCF81580D0(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc06959BB0D92CB78ACC5BB9232D136227(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc15ECE005CF581C5BE953A8E33738CF90(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification*, Microsoft::VisualStudio::Debugger::DkmWorkList*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc897268949AF157149CA77541A54929EF(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountConditionOperator::e, UINT32, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc95D0D3C69B29592470F0BAE106585FD5(Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList*, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CD293451372A9D9382BD97F8B7920A6(Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7076BF819350B9FA03C236373E15B497(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const GUID&, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEE6D45A22822D04D9205C8DEAAD59330(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc547EB931F10F0693AD8703D28E7D7E56(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc04C30C6994A0A82EB150AF86435B3156(UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc433E97E57EED993B1935CE0F8FCDFBC9(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA3074544DDDC4B69C83EE3A63BB51CC0(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc29ECFBE77883E77E9949C40B2DDD0D24(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, ICorDebugAppDomain**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1A0826709868B99EFD98472E97E97AA8(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc46C70E124C967BA573D28ABE0C365815(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc86E901A98609A3892236B80CC83BC545(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, UINT32, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCA87389EB16C25D55399B86CC7697716(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::Clr::DkmNonUserCodeFlags::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc68D78BE71363649843A328B368564247(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrNativeCodeMapEntry>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9514CD34D91549CCC50F8A227CDD1ACD(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, ICorDebugFunction**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc04CC599737BBF61C58A0FFFE1C870BEE(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE0EAB9E1275E364CAA5CDF5BF2BF219(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc49AD48ADCB8A261A843D2BA12C9F32C5(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::Clr::DkmClrAsyncMethodLocation::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc27CEF809C4A5195C4D6661A549F86174(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncMethodLocationAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55C9EB068F3F789821C74F5AA300C95A(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA4C73DE4731C0DDF331ED2FDB8844E4D(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAllAwaitExpressionInfoForStatementAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE4BE46E4F2212642D86BC4DCBC0F16DE(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, bool*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0AB3766D13B1A2E65AADEEF04F334E90(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73D36C87372025D0A2C8F5A4D47D55B8(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetNextAwaitExpressionInfoAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA02F1303E8DBAEECF20626244D70D1FE(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc98766C6DD35ADF90EA215031CEB4FDCB(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncKickoffMethodAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA933649E990648AA1B06DB796A61472B(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc54648C4626062C911464BDF85C437D99(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodLocalSymbolsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0FEE6D1828309260C0A02D36CE0D615B(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB66B51DF3FDA3AB6DBF96A21F58208D6(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodSymbolStoreAttributeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc149EE765B2389BDD6C5B91E33BDBE963(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc69943C1ACC9E2BF01923C60E0ADABD4A(Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC58244BD2C547AB8EB3BF80233F4021A(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc65A467389235866CD2C6B92C00AE6D2A(Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc876A5E63BBBE04526596CB8A99A5E9E0(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcC0378E1124166D86890CA327620CB640(Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA9BDAC6B67EE4CBC82EDEA2AB8AA48EF(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e, UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags::e, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAEA58B7861C86E08A55546A1C4D0ACAD(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e, UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags::e, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, UINT32, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF4BC786AEBAC294EE9C4C0BB1B0F56A7(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc423E0CAAC5C839003AD794CCD62FA0AC(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc007981F40FEA39E044F4D8CF4A9AC416(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, ICorDebugModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCFC27B46EBDEFADA1E91D0A90B77634C(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC2A7595A78323D9ED538F97DF8858518(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue*>*, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterOptions::e, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBA9A7ADBEAC8F47A27529954272992A2(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::Clr::DkmMetadataStatus::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA5B161350506D3C0213719EA3CA946C7(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA8484D0DF6D845608CC611EB2C6E61F9(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc494202493BBFB43009A6715156984C4D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc30CD194706F2789B39BDA5888D5809D6(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc81F4DF12CD2E79C82CFA7D02F085DE1D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, ICorDebugModule*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AC8F22DCEDC5109A8CFCCDB1698A28C(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, ICorDebugThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4F2ACCA282DF893ACD2710806F488982(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, ICorDebugProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc47E089E532D16825286594316453806D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, bool*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0132C3722F8DEFF0E84DABDD6B5DCCBA(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA58F0A1DAF5C4DEA3A4923BA8F90EF34(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, ICorDebugEval*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, HRESULT*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C53A066D18791671CC9C01BFA0C6D8D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, HRESULT*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcC3CB7743B5DBB83116E9365BACFA6AF3(Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0C158E97206654F945E7158521D7796B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB0E7C63F4B37AB192D3B02A003BD771F(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52A14AC059F0DEB8A5DD37CE238BCAA4(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>*, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99FA7DE19BFA48E79B8C772F04C5C0F7(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmExecuteQueryOnThreadsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc830BF1EC32B2D50A6F454C73132E8D95(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDAC5F1C0332F717B7A78BCF000B235F3(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmExecuteQueryAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc558180C0AA1756192A5B4EECD2C72DAE(const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc2CC5FE15ED9552B8D71D8052FAB0ABA3(Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1951845DC0A598B7D01BE514C5C6242(HRESULT, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection*>*, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99CFA8EC6ABD1D93AFE145CA709A7FBD(Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA53162B525391FF931A42627F7AAD6A9(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, UINT64, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation*, Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6DFAC5682AB3B324F2B704053BEE6004(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, HRESULT, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc424C754CDDD2CF45A942C20EED3CC893(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, HRESULT, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>*, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0293D2889DE6E0C14B909BC2A4CE0670(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE315DFDB6AEB76AA580E27B52F91F5AF(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc166F47D8BD25C8CC59B1502B3F4A5DDB(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6D698C640DFDABA88B6B6A8B78565B1C(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, UINT32, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmCustomMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C808A6463557CF774E01775628F0DCA(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BAFA69EABAF1980E4618AC80AEECB47(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmCustomMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA035DEDBF7F91EB78B75DE7CDEB4644C(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmCustomMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73CBBC77F9E0A5C530459780952936FE(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmSendLowerAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc387497D446792B6386776489669D2D7B(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, const GUID&, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCCE122D321D1AFDE76D7CACE58F839C7(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e, UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3C62BEDE7059A6F82EF5950D9B08F212(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F93893A27AD0F7C9A3E108C73ABCEF6(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1A4BA89C2192C5ED79E0F488CA118164(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc439EB6AA207DB70F8ED3430FFCAB70A6(const GUID&, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA9F782A3E84B2CDB9646FDCE26477F26(UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc76C4E68C18BC734895D4A803EED86642(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1BDFF0E74198F9E97B1200C099D36B2(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3B2F13165414C4F66EE876593C947FF7(Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario::e, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55CE06AE749FE4FDB97CE54A455619A3(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8FCA18285F43AB559217B26B94231774(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommandFlags::e, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc533B990E9F9B15A54DDC4E3E1D2E1078(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE2CA685D8412F7CDB1945E19E677AEA(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA8DA7BD7B83089DE1427BED550F265FD(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc72A6761FCC1029893756B99ADC6B9E6C(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc86DE7C8070519AEDC00A37E1FA5E127C(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3416010C84D4A08CE249F39B46310F4B(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<CV_HREG_e>*, bool, Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2CDF0821065EEEAF4BF0768BBC714CF9(const GUID&, Microsoft::VisualStudio::Debugger::Symbols::DkmDynamicSymbolFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0AD4448F733B3969810D3200D16F7571(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc212CD04490F098DD69043824CE41E472(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5CB574B305F260A0A4DC51E163157D25(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32*, UINT32*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc19D6B8616421D55B78D376D6CD3A5C5D(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc71288BA136E46AD8363AFD5AA013391E(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD089BFE2A48AC9E0A8F4B1DDDC4A9F71(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB619FA0B30165B806D34B9DE6755888B(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD5E0390E2DDF834E43AC2E8528EFDE3(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94B68F827E58FE88F3FA8771B9D09337(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Get250481482FAEDAA4BBEBC807B24DD715(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEAB82333D65B545623818EFFC257B255(const GUID&, Microsoft::VisualStudio::Debugger::DkmEngineSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB58779AE70E61CE2C137F2DC7C7E39A2(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmEngineSettings*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc66C5B8466345C8B890DE700EC642A0DF(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCFA56E1A30696A54C78DD3B62C48CB58(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55C239704FB9EE8A91BCDFF2A41E9307(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc712AEE7B1CBFE90A27AABC87EDA764C0(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc785B704BB677152C77F39C102DD245C6(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22A1D0256F691113C635408F3AB12787(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, bool, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7DFB0CC45F58E9F2422E3D6ADD30D56C(Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDA01083FD1F7BC6E21CF70FEBE852E08(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC551A87289B36A81E4E7DC67503FA13B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22969485654512BB4766B642E35146B1(Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, bool*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc18F3F98E2BDA11EE2E0551E6EB174A15(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc304D6F6048468BB211A98ECADD5190CC(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetChildrenAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0D96A87BB543F851A5DE00719E779D3C(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4943C591B2842416B41CCEDF949F0CAA(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4F92F70F3E82F62D90F9A64274110E0E(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7EB085795DD0AF19384C3FEDDC02346(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc893685F10EC87472D047E00FE7DBEF94(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0C60D4E64737DC5E907AC0500338F29(UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2CB7DED0F650EA239322E6F3A6CB5A2(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationEnumAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA277FC9EA1AD7D48A50697B88E56D01A(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDC69BC0A967710B649D98D8171E6AB4E(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD3051BA529DC1A0C80DE71D6B8A5D237(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionGlobalTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc46F4EBD73CFB584D76BA34433F61DB86(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2BDC566C9437414EFB44DCA2FB0655BF(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC4606A8DA0BC602AF74AB3F9240E24F8(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7CBBB15E9B8502248D458346A2C09640(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6D04FF97A36E6FBE5A873E9E4D373191(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA507F5EA1FFFB25DB6C264A1A3E9D9A0(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32C54A299942A4DF0FC187766A44B6D8(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8DE481C3F9EEB3173D2DF9D68D38D3BE(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4102811B876B002C9EBF58B1231D3419(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2997D2B4489466E485DF7E7BA9519AA0(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc82C475324C56B876A52EA3F7C064EFC7(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7C607E439F8FC343B781AA531EE6CBEB(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB462A99D32FCE88A7D5A90C41736C64D(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF87D21978E9C526845E798A88842F450(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, HRESULT, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc25600235530C4F6D98FFF804F230681D(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB940B4E5BD2C7FE35C1403BA8667C6F(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1DED409EDEADF892DF44AC593A875CA(UINT64, Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc128B9579786732D548FB332A0B330884(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT64, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE20B1EDA2CA598DA00992416EE3EBC95(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc512DAF21364C293BE3611EE0A2AB259B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBF5C3FB352B37CE289A04F7F698B6005(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, UINT64, UINT64, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc394EABA320D7CFF611EB0D16BA910E50(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8213AA4FF03A692BCCC88DDB65068B50(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, void*, UINT32, UINT32*, UINT64*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B59AAB03E31F3B304B956E0EAA505B4(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0B7E2AD76C535C1C35C3948F1F2C45DF(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC0AB0BE9B5D47BDCB64470DFC9FA2B70(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc14365162F719EE309833526528F9F58D(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc70432FE96C3AD9E0FF944F8DEDE6D609(UINT32, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>*, UINT32, Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD8C5AEC94B361E4D97A914AAFF227264(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7555F39063D612CCEC13E6563676F002(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6DE89FDFD6A2F6751D3C5B48FF2E1B99(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc08309D087A5DE326E3C34B180D4043BE(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT64>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc26BA35089930A40C5436AE4DC5794A7A(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3E4C247AE33A7932565EF80AD32F3135(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc00D7D596CD9722CDE7B7901FFBB9DBF2(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2E465FDD46A4B4DC92D709FF51472ADC(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9C1FD869706730AA7EFF44A78D267C92(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD4C3C1C4B0F5F1BAA4647C8F7EF693FD(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::GPU::DkmQueryComputeThreadInfoFlags::e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EB53CEDD4070927EF381FE18879D14F(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT64>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAA5382361712FF7C2DB61AF2F559F507(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc91AD1E7974AB8724E982A8D9BDA27FAF(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA153D09816AF6B9868DED1F2AA6D1A13(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC21FFEF8BC14B5A4DD66728B44AE9EC2(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, Microsoft::VisualStudio::Debugger::DkmArray<INT32>*, UINT32*, Microsoft::VisualStudio::Debugger::GPU::DkmComputeKernelModel::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE1CD74A61F4598BDC8CE45676C134C2C(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, bool, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, const Microsoft::VisualStudio::Debugger::DkmThread::System*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5E4EC8BBF3CBA2610A47A3950747990A(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, bool, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmThread::System*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDE293BC2897E94BBAB8BAC9654D13D93(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFE2ED3D7FCB8CBBF9CB8C6E5DAF90BED(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc835E736595E58DBBC0780B8878972850(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc064A81821D7B41B5152C78C6D4D1B1F8(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2FAC62524E17B80FA70A0CC17E6ACC59(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD076451B3D57BBE20AF66FD87DB7A3CA(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DBDC9183214716614E7527CD4D03D0B(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc48C49A28A6651642540A84275D9B1CA0(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFB143392ABCA694056F9F89070E283E4(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB4B5B53005AB2ACB4A337CC2906C6988(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, const Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc865C2DC79B308E28B79594200F171F1B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55A345846D53FC406B1E062190CCBFF1(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, UINT64, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc5685DA4F5C12B2EFEE7911100FE853C7(Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc59332EB271778BB3304504B24A36496A(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AC349E33ACBF2C7B296609A50B19D40(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAmpAdjustBufferTag**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF71648263D0EBB6AB423F469F8345896(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc274F93BAEC7EDA11FB3D8D31398F3E66(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE164CFE08792BADA3AFC457FC373E7CD(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3CC641081A4F8E38DBA8B9D7F910E648(UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC88C854EE79528CEF5806D3E9A5AAD3E(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC065B509F9ABC0BAC4BBD770D73E7FEB(UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD8A3508ABF025DFCBF615679CA43098(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc67294CD5516F29DD623A0335B01E2B2D(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF28A7C520914A2C602F64AC12940AEDD(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB1F5C35BB7205E5859519C63CAB11717(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF7DC8A9B604DB7991F313B300879DB14(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc513A853ACBA57C6224E96AFED178B6FC(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7F719CBB10CD5D871FFE04E029F3DB2E(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF61679F72873B9BAE44FF902F92DDDCC(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc42D2B23BCA47F96E95181509DEC12952(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc651C8C57EB784CC5D51DA3D9F911EC27(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5F637D126578416C0D844318F488E927(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C34599EEC6D0C6D02539A6CE0D3F759(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA18DDACFF36E48D6F0D56719700A0A68(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9F997DC1F7AF29677A4047813E08FDCB(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF41F3F1AB2ABAEF7FFBC76C3B591E7F9(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1CC800269002F7E3A1DA22DF715FE41(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDuplicateTop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C9051E01C0BD1E2540034FD47353BE5(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEndTry**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2F8C324E55FE9F51080FF9117FD8A9C(const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6E64A892D574E60D055678E92E919AB5(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCallingConvention::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationFlags::e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e>*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBA18CD27180C60E9E997C0A6FE75438(const GUID&, const GUID&, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc97F5838B80CF47DFBB5C7A66C074A06E(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3E3D0B3952EE50F42598DF26DF31016(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEF0A249A2437F16F1944B917B7FD8CB2(CV_HREG_e, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc85D3C05E777E3DDC1C1378AC47BC997D(Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD5E9535C1990A0F26896BACBB2E116E(bool, bool, Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9D1082BBE4C79FA90A9A6DB49A461250(CV_HREG_e, UINT32, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0E7C3B425A75C063D8423649080FECF2(CV_HREG_e, UINT32, UINT32, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc54CE95E6EDCFE52433F058A2FCD32205(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE724C2C7F8598586BC2AE84E232C2A4B(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFB2CBC90C25CF40C1EC0ADEF943DD21(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2A6EFECEEC08A414F708C9237A23820A(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFA7E1E2E0DFF33CDC7B49FE9A2BF2A22(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBB0D564A3653A0A30F1FC72C203C9C15(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52F772C3D63AAE4A52633DD19BFDC964(UINT32, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDA48987D0C3B6A7E18E3AC29CAAD314D(Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e, UINT16, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc61C52246DE45479B72BA6997F2B2A8F1(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryWrite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc401CC9B272AC84D4FD02EB44812606BA(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc45F2C6048794F68C28A16C1614F4F4EA(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILNop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD4EE301C59FC0351D8CF4431CBC623B(UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DF1C12E7E667FAA07405E2EB93A3FA5(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>*, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1DC79D92A0938AE9690076CE9323DAC7(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE4F5DD31DD2BC1EDC34C6E1135328142(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc58B9915C02C6BE805485E625EBF9C530(CV_HREG_e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDCC91AD8A2E048D1EA602989BF72949C(CV_HREG_e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF5C9FC936A5A04CE6DF00B7345A7E8CA(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF3C1D5377032837C2404235250E0B451(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILReturnTop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD8B6F020C004300F488AA5F72045BC59(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc256DC5FA8167A7B12392751E76AD665A(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSetBytesRegion**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB74FE600C741C9E0EA9A5EB02EC32244(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDC178BD53797D38351843A49AAE130A1(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDCD8B82D3B57686F096172A6C076243(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILTlsGetValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3E44E2254CE4725B5E4A486A9B526329(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1B8F796B6C622B33C8D151185C0D2B9C(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc086780F7AB96BE98E973B6DADFEEC905(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF7531579429F4DBD3A2C1DEED15F6A9B(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateExpressionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22DAB17B5E419C4DFC5198EFBCADBC18(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameLocalsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCEB972D13FE445A9D304AD753C757552(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameArgumentsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44DBDEA6AB474E8EB67B5F2348EDCC20(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags::e, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameNameAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc281BD02CCE55B2A58FC2C8301699BF33(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameReturnTypeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8100E1C553B1AE153B3AEF9DAE275F33(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateReturnValueAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2DCEF64A20FA074BCCA5B25B25800DEC(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc094F295F322424992BB5E795A7035884(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2EA0223CA2C28FD2A44B1ABE5EAA38E6(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo*>*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C4A41F2572CF238937F847AC2A3B828(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2063EA8A5827C04D2BF6A7BA85E27556(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94A165B2D7D457C800C0044AEE4DF1CB(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, INT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCAA57817DCAB36FA6857F059CC28E22C(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52D25C4E1682ABDE2CA361EA4457EC20(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmArray<UINT64>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcACB1ED9131E740FA3BE29B6308FECCB2(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetCurrentCPUAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B7FAC38CDD9E0656EF668FB4B062428(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsUserCodeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAC852ACB3B15D4C2B177E7AA9ED66C3F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc31D347AE67B44CCB5C5B5025DAC7D49F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::GPU::DkmGPUAddressType::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc862FD79FBD0E048B914012C907E6262E(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDD11793EA51E5D4A4A47BB5D6AF1606(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC8D8FC52CDB2195F51CF25F6E35EF5FB(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetUserCodeSourcePositionCallbackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11B96E95076AEBD19435335693648C9F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc25C283D1FA9B4F1F3979BA9CA8917013(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA273139AC02E5BE47E4FAD7C165037C1(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsHiddenCodeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE3287B6AD1874438A4638A94F83D8907(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRangeBoundary::e, bool, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc23E28172B8ED4C1CF1065854ACDA6236(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEECEDA2F659A9B7F31A4E9CEBAF928D5(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmHasLineInfoAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc312C43C3EBD40AA19100FC0BE9A909AB(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc74625D16DFFBC0BBB0B76F58AC775415(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, bool*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1DC26DBD878FEE1EC011A3321EF806F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc93764ECF9C2251D624F78B0CE24C436C(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, bool*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc04DEBA8C7D7338ACBE9E489F5CDDEEC3(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionCallbackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc456FB60B9E4993FCB92B225C95A1B152(Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc59530E264B592B0BFF5FDCD149513A30(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1D4F60E91C176CB2494DD14B47089A1(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetLanguageSettingsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD69DC66A57C38CA4CAB503AEA3C31D11(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CE02648478ABDF8A3F6F73CE84429FA(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc425C8315F654ADA55907101C9C65A89A(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EACD04F3FD1CA479AF6A3CE86B9E9FA(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4A691C7F7E4EA945A06F4071763491F1(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc02B8A45DC663391C88C64FF8F16423AE(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags::e, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6217600D01C4D2ECBE61829AFD936139(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Stepping::DkmLanguageStepIntoFlags::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc68AD630132C16798EB187E26E4B8E18B(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc19F3BC72A701F59F6D869826B65D2C66(const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5291958220F6BA230E62F74538F8E025(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&, Microsoft::VisualStudio::Debugger::Symbols::DkmModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CBFCEEC88661ADC3F294DFCA4AF14BD(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmModule*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD60BA609E5572E71FE7454972F0CC2FE(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Symbols::DkmModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1893989E63FB4502D761835AA167574F(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc787E6277F93875EC906A2F61947281D1(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F050A725D2A1A68D6AEA249072A74CA(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBBD87DA3F9E7D240B27461DD59C7F82(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB14A3D49AB97EEE5634A0BE1114A8DB(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFA4AE503D69BFA42C4969ADBDC1209A3(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataPreRemapAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD01D70ACAE8430CBB07B5F422017B9D6(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA0F5CAEEAAB4BB662F0A035412F7BBC6(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetTokenSymbolStoreAttributeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD04C7DFC744864F9E28B48FDE7FC2E93(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1FA09A66CFC6C30956FDF9F38B06E31F(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc09E6E2514FF654881B54EB0150C7AC32(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8C41A92D8B47ABE0375B9D7756FD489D(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5F33BB9A16D050DC6A11F8D02254B011(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, CV_HREG_e, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT64*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DF311E58282BDB725263E4F8096A4C5(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT64, CV_HREG_e, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4621B3FD8E354DF3C09CD7AF4EFA6890(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5134BC888343F0CBDC3CFF37F53CE11F(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc101685421B67B01CA3E0DB5E650B022E(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE94B97BDA30ADC68B86021B4E04E88B9(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB78DCC1D97D2784074F1B8AD23A79A8D(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6F7D7F50E471D11AD110BF84C52571CC(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCCBBBEED8A02B87E7A41F8504E31545E(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc203BC1170806E54DBAAF1B3530F58C16(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindDocumentsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc63D01FE35215A6F186CDAAF3981ECB78(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1DA8568A04474B5C880F261EDF65D23(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3AE544A716277EBD21AB3A79E73A97D(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmRVASizePair>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8BFB1F00FB320ADA9A2FD47EB5E00505(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetFunctionInfoAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1B19E03C0D1B1CB1DFED383F9D9A51C(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc1B02BC6A77ED80B4C26F62A6EA215225(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&, const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Get645AD40C25493913B4F735C441506A16(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEC7B013CEB23AA93633EDBA7FAB549B1(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2068CD9D703B7D4CE4B42E82A5C761E(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, UINT64, UINT32, bool, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc07E9A8763D0D6AD6ACDBED6ED0AFEC7A(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5CE38E6CF8E905E0A2FDD562AE2B9F6F(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, UINT64, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc00D734DD81ACDC01605A9CFD79A152DD(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2A87FA9B2EABE057C973454C4D0E0FE(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5A1A29171D03FC392A4795717141E0C3(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1880B774E3CEB4FFE43F3E5FFFFFC505(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4B179835811F44DCE0F243F176717948(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0B9652121F6BC866281A1E15F8B76330(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc34893D26C250199161E3A453FFEEF918(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE57162D15B9C4A9B50CAF4AF489C894F(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC2B6CE7C926FEA8B7BB1737D6705C84C(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5411B0DDBEF94775850CBFCCE24FDAA0(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1DF3FBE6FE204B1CB87244F8FE368C24(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7C740EFAED2FCAE33007EF4EB2BCA3CF(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3FCE740432071F95E811C82C437CB8D0(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF386FCA16584C1EAE2CEB33B55A36BA3(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2717980A0CDDDFF0805419095281221C(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmModuleVersion**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDC7ED1E90FA2A6178BEA83BB0A11B501(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA29A9B6A00CD4E346ACD54992947A817(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2D82CAC96183DD7B6D1DF3394318FC27(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8A1248C3A4D0B316E04BDEB5C39F281A(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc35BF8659E4F78CFC4EDCF9F8C35DCF25(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcF077EF6B9A532BB38F440A3E41457FEE(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3CC4BB810E58E0616B44FC6441DB2E43(Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressType::e, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressStepType::e, UINT32, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1EA107D7E0BFF457B5E6A661C838536A(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, UINT32, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc918993F014B90FB01D72E7053BB1AAF2(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString**, INT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc60E84CC95C998F0AD7E7E519F0209668(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindNearestExportAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44EADD160F31BE6B3796FA9A467F646C(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc62D0A91244300EC2F3874A30E936DF26(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA5DB4FF28172AC8EE337B4F616F0D8FC(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB8D112804ACF0EF98486C2DBE47F5860(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrHeaderStatus::e, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7C33005073B197E468D344B6CC30046F(Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc88303C178160F6B7A48F74A2AE8D50B5(Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc80A9F462958D3BF363A4E3F18DB01E46(Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindExportNameAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC6565F2B8739BF2909221336A3BBE9C6(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc12B8AEBDE8DC06ECC146022EFDF43BA0(CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0C813EFC4A612A8F0E0975C93D9CA8B2(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcACB567FCFFFF620887A60A7FEDA08D1F(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32F748045CAE5D710346099F66C76CBF(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD045CFE2611847953C966E4D4891465(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9712D292D3F561C85D575D1D1A169743(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD1ECC0384614A7BB087DDC735CC263F(const GUID&, const GUID&, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0887F8CD77331C223C58112B02B3D06(const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc60332A18F85A4FFB428E5704BCDD2A1E(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4921BEC0D30D1765A57ECFF2126DBB4B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1322FBC5A4F53CD71D904A9129D140F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA128E99A1AEAC21ACBFA950EE3F3B480(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnablePendingBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3AA44FB37FBBCFFA6FBBE1CA72E86896(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisablePendingBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEFEC79D1BCD21D1131F213381B99DD64(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnrollPendingBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc477ABB8F3A0820484777E4374E219075(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc292FF758655DE22ECB36F4C74707AA8A(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB460D8699FACB2F98617CEE663F430B5(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA9A34CABE5D34924B96CEC8E5546A656(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointUnboundReason::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99CA4912ED11CCD3CA63F744165160AB(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel::e, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8ECC658EC2242BE249FD192CBE25E53F(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6053B28C3096673FC90D26445A76528D(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B0261EA0FE6234EFD936CB4480EA78D(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF9D4693132F4DAF29D2D657F564DEF25(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE56F511514FFDB6E7EBB991014B63565(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC2C38CE8A50D042DEED2E1DBADC5CB25(UINT64, Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3878B0A51524BC8FD74356AF6390338C(const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc33E7E6971423BF9A85008A3E9CFD7DC9(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC475EB6F33F01CF8E23EBF14281DC9D5(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation*, const GUID&, bool, const Microsoft::VisualStudio::Debugger::DkmProcess::Live*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc106265AC3459BC4D58F9E120E7890A5B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation*, const GUID&, bool, bool, const Microsoft::VisualStudio::Debugger::DkmProcess::Live*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC36364A347A1331856E21EB8986BAE70(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc271368D023C6928C09CB19546C3F1AD1(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32, Microsoft::VisualStudio::Debugger::DkmThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcED5672D2B090E000D7A7F7AD376C8B29(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmAsyncBreakStatus::e, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4A0E15FDF157B102C15D0945524E44EA(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE26FC60E9788891FD620E40D02F8214A(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6A4CB9E6ACE0329D50B59CB473BB5DA6(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc83904421FD75D950D0C529A5A96F888B(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFE2313088C600310FB7FB38145E2E44A(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDF334C7812DE5779F127659C7CD0F4FC(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5A54344DA99A8E8110ED35DAA5DA2324(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF4FA5D54D06ED8FB9E7DEB680FC83C0D(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8A6D7EC2A52F26AD397C691D3330A926(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, bool, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAF31D72F6E65E289D17CCB5D3D2F418F(Microsoft::VisualStudio::Debugger::DkmProcess*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BA75E1240F3CFD277658D59B4759BAB(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BFA716C410EE92B5D9550D310574100(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc418F9EE0619D1B155F4CBF61E05C3742(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, INT32, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc78457549C84AD5A4D3E96DDC28B4A91D(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmDumpType::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9FB80C6A3DB27E2C52259C3282AE46F7(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc433805FB32119EF9F52D897E3DB167CC(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Exceptions::DkmAddExceptionTriggerAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2F3BF5A81EA26B2F9702DE5AA7F854E(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94A9989CD07F6E368BE9234F2C761007(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT64*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2A48A9D77297CAE270C2A2DBC52F163B(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::GPU::DkmGPUBreakpointBehaviorFlags::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc221A1C16A0CA91E399F361A5B5A38AC9(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8D47871CB4A49A7D7E9DB77822948CFD(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9D6623C601DB3190377A91A37C7419B0(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT64, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetInstructionAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBC3412E622A85C7A9C9A2B97362ACC4(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6B1CD2F016C6DF558BBBB8943EC462EA(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc43F8B1A71560988CDA93783A20518F4C(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFB08A1C7BD77B71CAE548E8932D320E1(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e, UINT16, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB54C33EFFC65296BF4C0F6267CAF6B9(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6918CAE6B208EA57C2B5EFC585308EA4(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc264596E3D714E689ED29EB416C0EDB59(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc535260FC7FAE6E6D8632B4D1639CFB53(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4013D302AF1F5E1D81F7B9F13E7BE15C(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9FA203E127EE0B8B16CF94D1DBF8F7E5(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6CE4E58CC03DB77D9C770472F95BCF46(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc47D4E3D46CE7EA40D78544A4E2F2CCCB(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AB53941FD46A190C2C1AA3D528041D9(Microsoft::VisualStudio::Debugger::DkmProcess*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD53F280F1F4958974C7D9C5765C56D3D(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmStoppingEventProcessingNextAction::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4DD206531745B166ED6A848124817007(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEC0AAA177C50B8CBA6F8BDF561155D7D(Microsoft::VisualStudio::Debugger::DkmProcess*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFC48FDC6FDEA04D6E5196CF1CBEEE2E4(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA863A9CAB9B57E2180E37E0162F20CE1(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT32, UINT32, UINT32, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C097F77E57173F0A64E1BC1D0723263(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT32, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc38B421E6EE7506792532303AF2226FCE(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, void*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DE0E3BEAA03DD17B309B44950EB2366(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1045230454C0D39659EA1D5AD3413E7E(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc353AC2FCF8655B4292847535571BE6DA(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc912C6A5D8C8520F4EE9D8D805F709792(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F286FA438BB0A3E8BE280B348C50768(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc95205A6BC436A6D493CD550A588C10F8(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e, const GUID&, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc609FC4C1EFA5159E8A99CB48C4A049B6(Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest*, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF505EE31F3B51D5736BBC626A76BFA18(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList*, UINT32, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario::e, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7E7DA05F4F334A3C130300B9DE219574(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc133D28FFA03AD3445985EA795062324F(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE60681703B6B3BE0727ACD155F1F4B0(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags::e, UINT32, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEE04EDDA44575ACCE2D895843CC5E455(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*, UINT32, Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc92D5E0C5D4EAF1F319BEA651257EFED6(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB93000BE4745096FE67A3B4F7FC0E930(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*, Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc048095810FEB921258184BC243942C8C(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*, const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA8FADDCF3708A1A38F469A40A28BA3B8(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT16, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5E7FD8F8CCFD4B162EAF3C29B5240CD8(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAC74F0017B56DBED5A20E546C72C4091(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD00A582A8E46FA8DA5A6390AC691465D(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC17D73FF4688C3A6F221FDC45D39BEFA(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc24A65EB99D5591E0DD35D8B55E0614F8(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc53BD85DE362C9852CF729B63A0D58D8B(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7E66F613557B51733EA6A6D6A87087D7(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc302B29EB2B5017008BE1DC136F1ED5EE(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2DB31E954D2ED062F8C66B849EE60429(Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4E2ECDABAF53878BC2CB86BB0CA5DE92(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength::e, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning::e, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1A9C348A582748AB15065E17A667A486(Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB9407B9EAA35C920D32759FE968A25CA(Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindSymbolsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc00BCCC33F43438DB686C5A05BE34F2E9(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength::e, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning::e, bool, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE236B855866DB4A74880D6FEA3185901(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const GUID&, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags::e, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc37D73B0F874CC8F77777D40219EDB14A(UINT32, UINT64, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo*>*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessFlags::e, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7729A748D025D8D1D27D5F70D2E2971C(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFC9C6DD35B19AD87E29CF388843DEF42(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0245E3B12859026D7920DFF4858DF38F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionPendingAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE46325D07FF9ECFA31F70280E1A0DD0F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA19DF47DA04A1D5C32B02E7F4032BED7(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetEvaluationConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF4A3B764CCDEFECC871133DFB3DABD74(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99E8152F458A4714289FF221F4100D2F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointConditionsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1E9AD8DA5F656684C0C7A9CBFACB19A3(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2F391C137BC1096F8C013BDECD30B957(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetRuntimeBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF9E386AD9771E9F2C3058D5834F64CB5(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8F395CEE476179C6FEBC6905D21E7A85(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2933A0DFA7612550A1AF4A41C1E9C15F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C9A3BE3A5112A28D0AF6CA87F562C70(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetRuntimeBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc41499D88B1F6924ECF29547583D8DD95(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE8EF7EF6768418441FE22C86348944FC(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39CF936CBBD422C18149B4C96CF48257(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA6288D90C3F6D3DECB145E59C1E2E0BE(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmRequestBreakpointEventOnModifiedThreadAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc93E2EB641A58D187BC71A1FD19D779A4(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9893B43ADE803E4FF563307C23A5DE77(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableRuntimeBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFE7BBBBC1EC94B9CB3791B48190C3C2(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB4964C8D77D3256EFE0D6A44501C685(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTestRuntimeBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc37D0CD0D0909DE69E045690F177B6ED0(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7F86958C6499B678D002E26D8724C3E4(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableRuntimeBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11942CA3E32D2CC5E71549580B4EEE2F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA744AE7AD70089B93C050396189C0E6D(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc654E5E6C9B16E21E572DC1F61E81FC11(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluateConditionAndSelectThreadAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1CB7AA5C0E18E7C2533CABD78EF033B3(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc02F5B636B11CFD1F31E0C794EE4631B8(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags::e, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDF15402D0A339E45CC2A57DB2F63EBE3(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB7DF07C7E259E057345053EA721F2BCE(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C6C4F1118EF07A4E19E8D544DBDEEA0(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnFunctionResolvedAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc10A22778D523D607BD6C09729AD0F35E(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel::e, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1543CFD5ACC8E9540123E1C97C081EC(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnResolverMessageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc473E9833342ED425C288649015CC324B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, Microsoft::VisualStudio::Debugger::Breakpoints::DkmDataAccessStopMask::e, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0E8B280F47F46C4B2A2734040F7FA707(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc245EB5834F220A1C282AA6E2B457151C(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9E83BEF15E45216D9E571931B801FC8F(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF47641A9B4F4EF84594FF51457BD43AD(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDA5249C91A40BC1C63ABF57EE417F35(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT64, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmResolveCPUInstructionAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc10463036625AB2B5AAA7F05509328531(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc49AB6C5E8A36B60EA1D587680080E9ED(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc003CEB61065326C60432436C71B15AF3(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFF2EBEF240F6308F4BC2649DFFAED7C9(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc803C37AF1E9AECCD4C7CAE2B2785162A(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC0CB9DB875E57138C93DFCE332C3D32C(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAA61459CFDC30CEC49DA6E3BBD21802C(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C79DBE9F40FE80E961282947D988039(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0247C5D3632A8B6B5A018211C1D2410(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc17820A171C58275B4CB2469D9614049B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2344FF3BDFEDB69A0DC72C3155B8F61B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB0B79064BF97FA5726711951AECE4E77(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2EA1B4DEDF4599B865E8E1A2E5718E86(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA73EB0668CACF4528C6378839C71F455(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadNameAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCA285C60E7286A27F6D525028789BEB1(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB94CF78451EDBCA915BAFD75C300EF35(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA4A36CF75EB42A472782FD7825A58C9D(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1DF54DB322921281DE98E82C2A0D2D12(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, ICorDebugFrame*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA67728A0C5C3D3B4EACB1F1C598A20D7(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc147D5B957653AEED0BF962688F3879AE(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, INT32, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE ProcE97BC9882851F8E9E5A3179B48A6A534(const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB83857C81F60315EF70D865BF0E4B1A(const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE485A2033078735C920AC84BD6F97736(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AF36FD7B7E0B4CE88AC133EBE2CA062(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB7BFDF6A5DD40400B07E77E9E74DD0ED(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3ABAEA10372ACE2485C57CA038BBC209(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryPushConditionToTargetDeviceAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc720EFC94A30F2FDA0A06EC4DDEA4C417(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc79B572DB628856A7B5E44CCD638AF7DC(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryClearConditionOnTargetDeviceAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc3DE111A28EFA51314B6DEABFD2A12DB2(const Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue&, const Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc50B5D8DA1C11FB7B3B25AF5A65A55FB0(Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetC5849E9833F5F36297EB088EC664A234(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEA0F13D8EBAAD5C57D07D7CA0ADFBE54(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags::e, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA673B7F58C93640EC322B5C0A2E63F79(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags::e, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentContentType::e, Microsoft::VisualStudio::Debugger::Script::DkmScriptEmbeddedDocumentKind::e, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState::e, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc605D280FE9838181FA3A4A2B68F0F82B(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, bool, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB907C0A7AFABDB032781F0EB78062FA2(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3070F6337FAFE9328B926573E08C6350(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDEE08F4607BF904380CD375869159CAA(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2E0CDF0E0AEBB33AA8AE4C476F46A6E1(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::DkmWorkList*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmSetRaiseSymbolEventsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C9638A955AE91EA6325FFD14E45E14C(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE2EA22D316F3FD9C3A1E03841E45F509(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc28927B0EE826B95D2F3582541114A6FB(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6110C67BD847D8134C925AC608E254E1(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1AE37B2274C1C965566B6B7955EABD47(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc14A934ACD96B407ADFD71AE6C2B5C520(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1A9A362454701895C74085D767B0A84(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB0BD63F2B9661E923F8200970F45D067(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const GUID&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc35C553500D44E1B4057B6A4FA0819122(Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol*, bool, Microsoft::VisualStudio::Debugger::Script::DkmScriptSymbolNextSteppingAction::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc470676CA7F49CBA39017F29721BF5721(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB33C67B27C7D54EBA23E2C2FB33D4DBC(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7BC07BA209278B7749391B532A06C4B1(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, IRemoteDebugApplication**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc69A328E0ADD079DF0ACFF13D910911C8(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc128384C8203A27AA4CD3890344DFF576(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmOnScriptCriticalErrorAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAEDE145089DD531D49D8D3AFC3277A6C(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2F17F66CDE0E78674E5011F343327F56(Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8C8881FB7D3648D13E24DE5A80DD1F83(const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcADBB6CC055D2BD215B9891EC59C55284(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C34DFAF0E3CA60C3523472E5C911930(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*, const Microsoft::VisualStudio::Debugger::DkmArray<UINT64>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39295C4B4207546A5413781780E09C01(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAE64E2E60E05EDDB9DBF80F18CB6B1D1(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE5290FEE5BE393C4CBEFDBC334154102(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc96B2A0869281F2E9E1E8FB63DDDC012B(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CB20AF3128815B290295CECB4F778C2(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5Hash*, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1Hash*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC7F5C260E52A1B26A2C10C0D8BF7787C(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFE6AA7C220F41C1F306FAAC721E5E76(Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDEEC88626A3FA552218C1327D95542B1(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc25F3629003D01C15D2C699A63D201EAD(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation::e, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC523C229635B2E14B58D880FD561BD8B(Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetNextFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc28D1273D015808E5A637BACE1F82718C(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C1B28C21F3C11BDC1687B7F3D78B840(Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Disassembly::DkmEffectiveAddress>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7F3F889DF5BFA8C78C8D53CD3D56516D(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange&, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc9828B496783EE3A4837AA6A8CB8EA07F(const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange&, const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F86415E78B3D06F5C59926FF40D2E0A(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA34DFAA73EBF7F9AFDC8E6C494472623(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC5D26383F8A6987AA14E7F72D5BAB969(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc565FEFF060E22589D7A3DA86DBF0C5A9(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, UINT64, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD8298F6AEBCFE639A5277E7C6B4C291E(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, UINT64, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmHeuristicWalkFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc919F289A3BBDF586B90161CC0F85674B(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*, bool*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash**, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext**, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc582931453CE802630963C16E4C3CE31C(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD6F5490DFB1533AA47E6BFB583FACB52(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD7B60D34DF9743384ECC91AAED076C34(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA0BA43B79BBE61B6ED073DE327837C99(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc279D105745DA281D3F61B6DCF5411056(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4E67D055D6D2E433A2852293B6E54BA1(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1630B1D062AC4FA4C48876B44B526781(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInterceptActionFlags::e, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB774E248DFD633FF0DB4E742857915BF(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA21A0DDB349EAED3F11615E3530AE002(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB4069C4360C0041F560E048681EFCB5E(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD6009FD4D2BFA6D9143568A4A20A299E(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0EE400E922AE4C51108614E9BA744DBA(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc08B4418EC0C18825B12F3E72299F915C(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44D0BCBEFEC7D375AC47BA3B8004849F(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, bool*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6094CA2A993E3F9848322098956FD3F5(const GUID&, UINT64, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDD11033D3489012566EDD562BBE02571(Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc46A6B17E652C2B421E2B2F3B3E34CD21(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc614B3EA5586AF72A6005519B6F6C9C50(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind::e, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e, const GUID&, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1A3683E892B091686163189B43D1000(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind::e, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e, const GUID&, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc969AFD652C52B34DFBA58A08419D9038(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7B97F0FF86BD2E2D682B864DFF17E77F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc63E53E7C4821AF09FA0624C5CADC370F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7A61A9F049FF2D74FDA1483C449EB9F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8A5F09971F6A17F44FEF05D97B445AFD(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc154EECF6D0808A631400840CD20CE9A7(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C4711ACA8448D643F9553C50E310375(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc75944E1AEDA5BD6E213831B42B08C09F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1E64E1BAA30DE49027A7DBE4849ED6D(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*>*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc23A5971C1BF1E602DEE5AB4BEFB31342(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc687EB6BCECC901CC320D6678FDA635CC(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE3FC472EC679C1DE3AB9FFAD538956CA(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9E2248E24ABD99A8B1E10B4450E75955(Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB8F55C2292C5362692D5A78BF5A1E049(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0339C3F8A834349475BA153214394E66(Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0BB87DD0FEF959F7D6EBC724EA4C6B07(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, HRESULT, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags::e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc42A2B316A229EB6E25BB276960D29FB9(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags::e, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3932AEFE94C36823D1A160EFA97E3F11(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags::e, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5AFC8CFC0FF188C22A757EFC938F0AB2(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDF0D5748E83AE15E24B5B1687A335C2(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2953E3BF3583689D4AA360B2A068724(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, const GUID&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11DEBCF91819AB5C7D511F5CC8132865(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8EA48BC824C9B98D3446CD1284310781(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE53FE4708620D30C1080556AF0FFBE3F(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc35DBD0B3A9C4D65B34C9C9DC38DEEA7A(UINT16, UINT32, UINT32, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags::e, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures::e, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBB4C4C507C3D48982BF5C6EA6D711C9C(UINT16, UINT32, UINT32, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags::e, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures::e, MINIDUMP_TYPE, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE195EB82A3658BBE184BF772FE70EE44(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3BC141B0950632BBEDF0F3A329B42598(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, UINT64, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF67FD0F8724B847483F082B115F61994(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, UINT64, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskReturnStatus::e, double, double, double, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6F163AC98BAF7B488B85A75616791C9F(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc678BC032D274C3D145554F7DA4BCF98C(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEAFDA659BBC3E7B5DECD28D58939CC40(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcA07FAFB63F4649DD290A721E8EFE4162(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc21FB0093543B45F8828E79D9EEF3AA3A(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCCE97B15762479275D3FB2967C597CCB(const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF5AF3CCABE57E88CB0B16B900C3902FB(const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProviderCapabilityFlags::e, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc62E124921D164B7AECA13D786603EC06(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, UINT64, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCDD4E8C991BEBFAC2D35C0F765297B11(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, bool, UINT32, UINT32*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1C52C73B1F05AD5D701CFE684EFF003B(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF54418460BC26AF2C3429E967BAEDB56(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA598DC6767B6B5E321EA1C7E6742268C(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc94CE83C176C18E080657DE893B3FB7D1(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc660872E9B1A72FBC89EE136ED9490954(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT64, bool, const Microsoft::VisualStudio::Debugger::DkmThread::System*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DkmThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32245DDCC51A1CA87768FB26C135C6CF(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EC9594DE9AD4721F7CA1A6661474411(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc21018EEF594F640991F4C8723510500B(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCC77495B04753F1B0085CAF63BCF1679(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC85E3C661A3F69393C3308D5AA724031(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDA2C88FCD29A13D41642E51A73A0C5F3(Microsoft::VisualStudio::Debugger::DkmThread*, CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCFC90B74E86F409E42174D75C612ECC1(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1F8112701DC8FD65384408A8F7AC2688(Microsoft::VisualStudio::Debugger::DkmThread*, INT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32E9F18F7EC761620221F110A2CE057F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetManagedThreadPropertiesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8877C3D70304E8D4D8932D1B95A128BC(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc13E806B9B3C4319EF36A2D0160C5F358(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64*, UINT64*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF5A59EE47B626A7A0FF46B584F2CF13F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc764B89CAFFE718355031F1555E23D68B(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE07A59DADEB847529B1EDACF190F9622(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0960E067C6E6CE7EBFEEDBBDFE1D27A8(Microsoft::VisualStudio::Debugger::DkmThread*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc82FF1FA4E1EEAE6244230B42302688EF(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF525CDEB2CCDEEF6A83975AAF4A2818E(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEBB9C20B7D84DC94119D75E52F0311D0(Microsoft::VisualStudio::Debugger::DkmThread*, bool, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7E936BAFB8A03BADC8D5E852E215D5F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmFuncEvalMode::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc47057DDC632AD45CEC7B2F19D7C55FC5(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C71BAFC0CA8B6BB34725A9DB87FBDAC(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, void*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4560E9791A28974C03DBB766B0923E3F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetCurrentLocationAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBF51E4F2615C39213EB93E638D855420(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8B5D381DB7DEAB34963D4ED0B1F13B59(Microsoft::VisualStudio::Debugger::DkmThread*, bool, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0CD674D84CB44BC00252F10D501563F9(Microsoft::VisualStudio::Debugger::DkmThread*, bool, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1CE80C145D86692B21A5385E307B03C(Microsoft::VisualStudio::Debugger::DkmThread*, bool, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc43848E55BF00ABC986124109B62D5595(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73F92C73F402A0645B5F0E13E132A009(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2953901DB8E2A56A7761ADC76A4C51C9(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, UINT64);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB686005B0C45325B528A4AB178C8DDA(Microsoft::VisualStudio::Debugger::DkmThread*, INT32*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc85E5BDCC65DBFBFD46BD72850AB5598D(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatilePropertiesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc72D8789037B29D9BE4656FCAB8B158C1(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::ThreadProperties::DkmVolatileThreadFlags::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE025EC0D8596C9875C1203A22839D44C(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatileFlagsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc28873A94D65410FCC0056B9C83596DD0(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCEC10D8029BB7FE6392177BA9943EDE1(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA889D7143B7FAC827A4BAE8265E8FB6A(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE6D433576CE0AC1C21EE4E98D3422D5A(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB7E84604904D5C915B4A266F97F80F5(const GUID&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C8F3653A7BDEAB26FDAC5E12529D820(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF8399B27892C4BBF5D648783DCDCBA5A(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC071CA11E0A11A2E283015A2F9433338(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD6035EBBD17B0D0141A839FB20A8A90F(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, UINT32, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDB0050730FB328F4C9D7C1BB448007A9(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC43FD22B022A5A6DDF7F66F3A86E698F(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA792859DA394A6CB2C2E468A8805621E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform::e, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDE7401ACE2C30C377F9CBF611BDF4337(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmSuspendAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2B975D78F12643226D0BB33B75EAD13(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB34EA264F4F8FECA9A9F132A25DCD7D8(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmShutDownAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD10A03178A61DDA50CE791FE7A50CE1A(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFE6C80165E565AC3EC08B717C8E51C9E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackageExecutionState::e*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF45761B62AD6B1092A2DF893E962C810(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmEnumerateBackgroundTasksAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc30FEC696C9945D2B0417493F60C0A048(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, const GUID&, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmActivateBackgroundTaskAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc98A6A894DD93626ADCA0978BCE953839(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDD014885B12C65BD78508D907B44AD7(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3652ACA5E5318812E35FB3CA4438BE02(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD5CB3FCA82CC14A00D5F13D7E222756B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmDownloadFileAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB8D5E627A1202BFABE708EACCB652FBB(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc215DD9BC078CB88CF23C40B8C2910BE3(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc97FB9A3F5C72B5CCF8B0B70D68A04767(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc42B2E39E095C8CC924104C96D815A87F(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBA58E5F29495587EE83647ED4B7CA047(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc78D9244B76EA8F1DE4E149D466A3067E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, bool, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask::e, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39246E41B82608CB696343435CB621CC(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, UINT32, UINT64, bool, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask::e, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc865805A776E7741A6D402D348F5B10C8(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, UINT32, UINT64, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C5C54E587F4180B257B172F561B9D86(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, bool, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc64B5767554228566D9C77062DA22744E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0869184C622FC2631C3092D1F9F56171(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8B8D1408689D364C99D8A5AEA2A33BF9(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc455ECE81CE1CDD87D2DA5494FE7B4B03(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8EDE4866600ED1B4F51326202AD7B614(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::DkmUnknownInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc466368E9818C5AAA5A91F1B4871168C3(CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFDD9B7914B7C22033996520394B90F8A(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind::e, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, HRESULT, Microsoft::VisualStudio::Debugger::DkmUserMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBA1057B67974B1DAE7A677E1B7156D48(Microsoft::VisualStudio::Debugger::DkmUserMessage*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA3E4FFDD239F6E8EB98DECB7AD2660ED(Microsoft::VisualStudio::Debugger::DkmUserMessage*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc724F9A5CAEC412BD5A71787991347219(Microsoft::VisualStudio::Debugger::DkmUserMessage*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmDisplayUserMessagePromptAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc37A7A04E658357DDF89FD94C01950EDE(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc775646EA9C2CEA81FE5E83FA6B154C80(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2EAA5EF1A1F3D78893EF5BF262A09FF1(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, bool*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc16C97186D55550648ABE74675D33BF50(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0A069DACDF37E06B697F148BFAE76960(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEC64BFA42F296CC9011D7887E9AA821E(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2DAB6617600220DC44DEB7DBC7D87FA6(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA236F77AF12387A7771096B443CA3FC7(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7138B8A8F36654C2D04C9FD6EB1981F5(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7CC624DFD52EBFD7D8D4328B80F7B8B(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, INT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCC231CEFF16CBD971CC342AC73007747(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE50B12FF94F4FB40DEF8945C53BB3691(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7EEBF387B7C2B848675D0F50E63E9996(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAED1622BD40E6A09C5DE0FE3F1603171(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc83735219E8CC0CD40DBBF6F68C286948(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e, UINT32, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0820CA92D0247DC5DF701F1C1ECEA7DF(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*>*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc86FDCE2F5D7CA7AEEFDCA32E39728044(Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskCreationStackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4CE2773DE0FDDAF90435E6FDFCFAAAED(Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskContinuationFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1C7E85CB433B74A1BE139D8B40E53768(Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetAsyncCallStackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7A6C7A0227D6BD610F97D032767448A8(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB099C958E2B4BDC4A6A8969DF728294(Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc75FF43FC6B24BBA9BCB13405C170E6F2(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc07F31C87616869864CBF6033F37DAAB9(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD535CEE9B7C2831AB2793C7873F721C8(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB9BAA2DA346F0AF91423145A3413CA27(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol*>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0CF9D0EC7EF8995BD39E312B58463B27(Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B089C79F9336B6ABA00EF766311F77F(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc249AAF78F1239055957393B3DC7BE289(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC6E2961BDBDC1A9CA97272FF4B74A350(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEDF0FCE8A74B5D0C131F7752E8991D3D(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8538455986C021ACA81FB03C2A62E0A6(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc323D69516EBA1BCDC37105AA207724E0(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFA215BDCF150EB6AB9820C4A27727AC2(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA39016543127594E0FEB0444CDC3DF07(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EB16C97D0F941B559CA036DF7F4341E(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc16C7D428BB76D469DE0C081CC2EB0A62(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, ICorDebugHandleValue*, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1061F6811AA7AD0D33CC213D93488771(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc0C053A2A86820E43F81FB08DAC8CE244(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94B18169AB0EDFAE1D81988AA6E03752(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD924583F9543AD80E04AE68B28A15BDE(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCC7C33549F96E9BFCC53D8D4796C4789(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3A6D0DF639ECB96F5A8FCD3BFF85AE11(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE8071A89F43A788EBFEBB41CBC4489AA(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBB2B6145A59219AFF600BAA441C73A8(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7DE701BDD91AE12A722F8CC317D19BC(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFE0C8AF37E73BF497ECBCABECEEA17A(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD96B04D45E8105CE11F115D9F742F71C(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcBEDC326A3D66F01DD50255E127A47AEA(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc79FC2AA34BD6D341512F69F8135965C1(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc01ED18A9A87787ECBAFD76CA6F41C042(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3C9F5EA2C9BFB8EB3DB4F9E5D8BB6DE(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE18D30D305F175DD1817B8F658179FD9(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc797764A0BAC725C4193977B374A1E5A4(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39D50FE942130684A08B74A259BEAAD4(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapObjectInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc089C4F654C8E15E4AE89DDF3A1A857B2(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedObjectReferenceInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDA1C4B8B62A848BDDA4ED914C3950B5(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDC4469B03A149435C884CD60D958A3E(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId>&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0789C5EB42EE609273BB5E426139B584(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSegmentInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF307798AFAEC3339F0F539394CF897AD(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3190D0E445D2FE7421CF79FA67C8F250(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc978E4E1F1C2A124CCD52C37CE7B3FE2F(Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD87D1398C6DB7E1C5819A7AEF3065005(ICorDebugType*, UINT32, UINT32, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD5CA6002328EC4403BAE43C674FC3C77(ICorDebugType*, ICorDebugValue*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc1E701FEAF4CA56487DDB8AD758EC4739(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmManagedTaskInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8D47D19688BAF506460B4626D5B8D8EF(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4BD013B67BCF30535C934FEC828B0D2F(Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmRegistryTweak**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc096C4143603B1A366F404656A77DF808(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation::e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc75D8E6CFCFD2990F41F14B42601A66B9(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData**);

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::InitializeThread(_In_ REFGUID guidComponentId)
{
    return ProcDkmInitializeThread(guidComponentId, NULL);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::UninitializeThread(_In_ REFGUID guidComponentId)
{
    return ProcDkmUninitializeThread(guidComponentId);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::GetCurrentComponentId(_Out_ GUID* pComponentId)
{
    return ProcDkmGetCurrentComponentId(pComponentId);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::AllowComponentReentrancy()
{
    return ProcDkmAllowComponentReentrancy();
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::DisableComponentReentrancy()
{
    return ProcDkmDisableComponentReentrancy();
}
inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::IsApiVersionSupported(_In_ DkmApiVersion::e apiVersion)
{
    return ProcDkmIsApiVersionSupported(apiVersion);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::FindComponentHandle(
    _In_ REFGUID componentInfo,
    _Deref_out_ DkmComponentHandle* pComponentHandle
    )
{
    return ProcDkmFindComponentHandle(componentInfo, pComponentHandle);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::PushComponentTransition(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmPushComponentTransition(ComponentHandle);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::PopComponentTransition(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmPopComponentTransition(ComponentHandle);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::InitializeThreadByHandle(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmInitializeThreadByHandle(ComponentHandle);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::UninitializeThreadByHandle(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmUninitializeThreadByHandle(ComponentHandle);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::SetDataItem(_In_ DkmDataCreationDisposition::e CreationDisposition, _In_ const DkmDataItem& item)
{
    return ProcDkmDataContainerSet(this, CreationDisposition, item);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::GetDataItem(_In_ REFGUID guidDataId, _Deref_out_ IUnknown** ppObject)
{
    return ProcDkmDataContainerGet(this, guidDataId, ppObject);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::RemoveDataItem(_In_ REFGUID guidDataId)
{
    return ProcDkmDataContainerRemove(this, guidDataId);
}
inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::IsUnloaded()
{
    const DkmDispatcherObjectFlags::e mask = (DkmDispatcherObjectFlags::ObjectAlive | DkmDispatcherObjectFlags::ObjectUnloaded);
    return (m_ObjectFlags & mask) != DkmDispatcherObjectFlags::ObjectAlive;
}
#ifndef NO_DATA_CONTAINER_TEMPLATES
template <class T>
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::GetDataItem(_Deref_out_ T** ppObject)
{
    IUnknown* pObject = NULL;
    HRESULT hr = GetDataItem(__uuidof(T), &pObject);
    *ppObject = static_cast<T*>(pObject);
    return hr;
}
template <class T>
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::RemoveDataItem()
{
    return ProcDkmDataContainerRemove(this, __uuidof(T));
}
#endif
inline const Microsoft::VisualStudio::Debugger::DkmDataItem& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataItem::Null()
{
    C_ASSERT(sizeof(DkmDataItem) % sizeof(size_t) == 0);
    static const size_t null_value[sizeof(DkmDataItem)/sizeof(size_t)] = {0};

    return *reinterpret_cast<const DkmDataItem*>(&null_value[0]);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmAllocBytes(
    _In_ size_t bytes,
    _Out_bytecap_(bytes) void** ppMemory
    )
{
    return ProcDkmAlloc(bytes, ppMemory);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmFreeMemory(
    _Post_ptr_invalid_ void* pMemory
    )
{
    ProcDkmFree(pMemory);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReleaseInterface(
    _In_opt_ IUnknown* pObject
    )
{
    ProcDkmReleaseInterface(pObject);
}

template <class T>
DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmAllocArray(
    _In_ size_t elements,
    _Out_ Microsoft::VisualStudio::Debugger::DkmArray<T>* pArray
    )
{
    HRESULT hr;

    pArray->Members = NULL;
    pArray->Length = 0;

    if (elements == 0)
    {
        return S_OK;
    }

    if (elements > MAXDWORD / sizeof(T))
    {
        return E_OUTOFMEMORY;
    }

    hr = DkmAllocBytes(elements * sizeof(T), (void**)&pArray->Members);
    if (FAILED(hr))
    {
        return hr;
    }

    pArray->Length = (DWORD)elements;
    return S_OK;
}

template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReleaseElement(
    T& element
    )
{
    // The non-specialized version of DkmReleaseElement assumes that element is
    // an interface pointer. This header file defines many specialized versions of this
    // function to handle all the other types in this header file. This template is not
    // designed to be used with types defined outside of this header file.
    DkmReleaseInterface(element);
}

template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmFreeArray(
    _In_ const DkmArray<T>& Array
    )
{
    for (DWORD c = 0; c < Array.Length; c++)
    {
        DkmReleaseElement(Array.Members[c]);
    }

    if (Array.Members != NULL)
    {
        DkmFreeMemory(Array.Members);
    }
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::Create(_In_opt_ IDkmWorkListCompletionRoutine* pCompletionRoutine, _Deref_out_ DkmWorkList** ppCreatedObject)
{
    return ProcDkmWorkListCreate(pCompletionRoutine, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::QueryIsCurrentInstanceCanceled()
{
    return ProcDkmWorkListQueryIsCurrentInstanceCanceled();
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::IsCanceled()
{
    return (this->m_Flags & DkmWorkListFlags::Canceled) != 0;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::BeginExecution()
{
    return ProcDkmWorkListBeginExecution(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::Execute()
{
    return ProcDkmWorkListExecute(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::Cancel()
{
    return ProcDkmWorkListCancel(this);
}

#pragma warning(push)
#pragma warning(disable:6387) // disable 'return value might be 0' warning when return fields
#pragma warning(disable:6385) // disable 'invalid data access' warning for static_casts

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId::AppPlatform()
{
    return this->m_AppPlatform;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform::e AppPlatform, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId** ppCreatedObject)
{
    return Proc1E8D5F0C922FF9B67FDDD80B2ED6503B(AppPlatform, pFullName, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmArmFrameRegisters::Pc()
{
    return this->m_Pc;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmArmFrameRegisters::Sp()
{
    return this->m_Sp;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::PendingBreakpoint()
{
    return this->m_pPendingBreakpoint;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Target()
{
    return this->m_pTarget;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SourcePosition()
{
    return this->m_pSourcePosition;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SourceId()
{
    return this->m_pPendingBreakpoint->SourceId();
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::CompilerId()
{
    return this->m_pPendingBreakpoint->CompilerId();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Process()
{
    return this->m_pPendingBreakpoint->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Close()
{
    return ProcEDC75945D166F34184CD05BE77F99EE5(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* pTarget, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pSourcePosition, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint** ppCreatedObject)
{
    return ProcCAF4269E8986B80CE0D8D9E03E81B4D3(pPendingBreakpoint, pTarget, pSourcePosition, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::OnHit(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool HasException)
{
    return Proc220C93F26AF511DF6CEB8F7ED67347FD(this, pThread, HasException);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Enable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableBoundBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc8CB5A7081B1ECE9D3867EC558F028B01(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Disable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableBoundBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcC8789CC74E265D785FAC9687BCA58590(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::IsEnabled(bool* pResult)
{
    return ProcF294D5B58C198B7ACF2AF61B645BFE5E(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SetCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition)
{
    return ProcD12950265C8C561E2385E7B1918F3B8B(this, pCondition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition)
{
    return Proc10B0816A10DF6638455B6A097A890E3A(this, pCondition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SetHitCountValue(UINT32 NewValue)
{
    return ProcDFB5690535A81F9A14E31EEFC96C6363(this, NewValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::GetHitCountValue(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>* pCompletionRoutine)
{
    return ProcB6A0881929281E26ADD0F69F08CB7E3B(this, pWorkList, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Operator()
{
    return this->m_Operator;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::CompilerId()
{
    return this->m_CompilerId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::CompilationFlags()
{
    return this->m_CompilationFlags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Text()
{
    return this->m_pText;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Timeout()
{
    return this->m_Timeout;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e Operator, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e CompilationFlags, Microsoft::VisualStudio::Debugger::DkmString* pText, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition** ppCreatedObject)
{
    return ProcDBD59238A6D89616EAEA09CCF81580D0(Operator, CompilerId, CompilationFlags, pText, Timeout, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification::FilePaths()
{
    return this->m_pFilePaths;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pFilePaths, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification** ppCreatedObject)
{
    return Proc06959BB0D92CB78ACC5BB9232D136227(pFilePaths, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification::Send(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList)
{
    return Proc15ECE005CF581C5BE953A8E33738CF90(this, pWorkList);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountConditionOperator::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition::Operator()
{
    return this->m_Operator;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition::Operand()
{
    return this->m_Operand;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountConditionOperator::e Operator, UINT32 Operand, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition** ppCreatedObject)
{
    return Proc897268949AF157149CA77541A54929EF(Operator, Operand, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList::FilterNextFrame(UINT32 ImplementationIndex, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext* pStackContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pInput, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pResult)
{
    return Proc95D0D3C69B29592470F0BAE106585FD5(this, ImplementationIndex, pStackContext, pInput, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList** ppCreatedObject)
{
    return Proc8CD293451372A9D9382BD97F8B7920A6(ppCreatedObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::EvaluationResult()
{
    return this->m_pEvaluationResult;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::Parent()
{
    return this->m_pParent;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const GUID& VisualizerId, const GUID& SourceId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* pValueHome, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pEvaluationResult, Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression* pParent, UINT32 Index, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression** ppCreatedObject)
{
    return Proc7076BF819350B9FA03C236373E15B497(pInspectionContext, VisualizerId, SourceId, pStackFrame, pValueHome, pEvaluationResult, pParent, Index, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetName(_Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return GetEE6D45A22822D04D9205C8DEAAD59330(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Close()
{
    return Proc547EB931F10F0693AD8703D28E7D7E56(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmString* pName, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain** ppCreatedObject)
{
    return Proc04C30C6994A0A82EB150AF86435B3156(Id, pRuntimeInstance, pName, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::FindClrModuleInstance(const GUID& Mvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppClrModuleInstance)
{
    return Proc433E97E57EED993B1935CE0F8FCDFBC9(this, Mvid, ppClrModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetClrModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*>* pClrModuleInstances)
{
    return ProcA3074544DDDC4B69C83EE3A63BB51CC0(this, pClrModuleInstances);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetCorObject(ICorDebugAppDomain** ppCorAppDomain)
{
    return Proc29ECFBE77883E77E9949C40B2DDD0D24(this, ppCorAppDomain);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetManagedRuntimeModule(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppRuntimeModule)
{
    return Proc1A0826709868B99EFD98472E97E97AA8(this, ppRuntimeModule);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation::Name()
{
    return static_cast<Microsoft::VisualStudio::Debugger::DkmString*>(DkmExceptionInformation::Name());
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation::InstructionAddress()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*>(DkmExceptionInformation::InstructionAddress());
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation** ppCreatedObject)
{
    return Proc46C70E124C967BA573D28ABE0C365815(pRuntimeInstance, pThread, ProcessingStage, pName, pInstructionAddress, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*>(DkmInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*>(DkmInstructionAddress::ModuleInstance());
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::MethodId()
{
    return this->m_MethodId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::NativeOffset()
{
    return this->m_NativeOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::ILOffset()
{
    return this->m_ILOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 NativeOffset, UINT32 ILOffset, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress** ppCreatedObject)
{
    return Proc86E901A98609A3892236B80CC83BC545(pRuntimeInstance, pModuleInstance, MethodId, NativeOffset, ILOffset, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::GetNonUserCodeMetadataFlags(Microsoft::VisualStudio::Debugger::Clr::DkmNonUserCodeFlags::e* pNonUserCodeFlags)
{
    return ProcCA87389EB16C25D55399B86CC7697716(this, pNonUserCodeFlags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::GetNativeCodeMap(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrNativeCodeMapEntry>* pMap)
{
    return Proc68D78BE71363649843A328B368564247(this, pStackFrame, pMap);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::GetCorFunction(ICorDebugFunction** ppCorFunction)
{
    return Proc9514CD34D91549CCC50F8A227CDD1ACD(this, ppCorFunction);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::IsUserCodeWithoutCheckingLineInfo(bool* pUserCode)
{
    return Proc04CC599737BBF61C58A0FFFE1C870BEE(this, pUserCode);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::MethodId()
{
    return this->m_MethodId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::ILOffset()
{
    return this->m_ILOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 ILOffset, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol** ppCreatedObject)
{
    return ProcCE0EAB9E1275E364CAA5CDF5BF2BF219(pModule, MethodId, ILOffset, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncMethodLocation(Microsoft::VisualStudio::Debugger::Clr::DkmClrAsyncMethodLocation::e* pAsyncLocation)
{
    return Proc49AD48ADCB8A261A843D2BA12C9F32C5(this, pAsyncLocation);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncMethodLocation(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncMethodLocationAsyncResult>* pCompletionRoutine)
{
    return Proc27CEF809C4A5195C4D6661A549F86174(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAllAwaitExpressionInfoForStatement(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo>* pAsyncExpressionInfo)
{
    return Proc55C9EB068F3F789821C74F5AA300C95A(this, pAsyncExpressionInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAllAwaitExpressionInfoForStatement(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAllAwaitExpressionInfoForStatementAsyncResult>* pCompletionRoutine)
{
    return ProcA4C73DE4731C0DDF331ED2FDB8844E4D(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncMethodCatchHandlerILOffset(bool* pHasCatchHandlerILOffset, UINT32* pCatchHandlerILOffset)
{
    return ProcE4BE46E4F2212642D86BC4DCBC0F16DE(this, pHasCatchHandlerILOffset, pCatchHandlerILOffset);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetNextAwaitExpressionInfo(Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo* pAwaitExpressionInfo)
{
    return Proc0AB3766D13B1A2E65AADEEF04F334E90(this, pAwaitExpressionInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetNextAwaitExpressionInfo(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetNextAwaitExpressionInfoAsyncResult>* pCompletionRoutine)
{
    return Proc73D36C87372025D0A2C8F5A4D47D55B8(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncKickoffMethod(UINT32* pKickoffMethodToken)
{
    return ProcA02F1303E8DBAEECF20626244D70D1FE(this, pKickoffMethodToken);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncKickoffMethod(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncKickoffMethodAsyncResult>* pCompletionRoutine)
{
    return Proc98766C6DD35ADF90EA215031CEB4FDCB(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodLocalSymbols(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>* pScopes)
{
    return ProcA933649E990648AA1B06DB796A61472B(this, pScopes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodLocalSymbols(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodLocalSymbolsAsyncResult>* pCompletionRoutine)
{
    return Proc54648C4626062C911464BDF85C437D99(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodSymbolStoreAttribute(Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pData)
{
    return Proc0FEE6D1828309260C0A02D36CE0D615B(this, pAttributeName, pData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodSymbolStoreAttribute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodSymbolStoreAttributeAsyncResult>* pCompletionRoutine)
{
    return ProcB66B51DF3FDA3AB6DBF96A21F58208D6(this, pWorkList, pAttributeName, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Value()
{
    return this->m_pValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant** ppCreatedObject)
{
    return Proc149EE765B2389BDD6C5B91E33BDBE963(pModule, pName, pValue, pAdditionalData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::GetSignature(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pSignature)
{
    return Proc69943C1ACC9E2BF01923C60E0ADABD4A(this, pSignature);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Attributes()
{
    return this->m_Attributes;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Slot()
{
    return this->m_Slot;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Attributes, UINT32 Slot, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable** ppCreatedObject)
{
    return ProcC58244BD2C547AB8EB3BF80233F4021A(pModule, pName, Attributes, Slot, pAdditionalData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::GetSignature(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pSignature)
{
    return Proc65A467389235866CD2C6B92C00AE6D2A(this, pSignature);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId::CompareTo(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& other) const
{
    return Proc876A5E63BBBE04526596CB8A99A5E9E0(*this, other);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData::Release(Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData* pItem)
{
    return ProcC0378E1124166D86890CA327620CB640(pItem);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*>(DkmModuleInstance::RuntimeInstance());
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::Mvid()
{
    return this->m_Mvid;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::ClrFlags()
{
    return this->m_ClrFlags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::AppDomain()
{
    return this->m_pAppDomain;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::ILImageSize()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ILImageSize;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e MemoryLayout, UINT64 BaseAddress, UINT32 LoadOrder, UINT32 Size, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, const GUID& Mvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags::e ClrFlags, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* pAppDomain, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppCreatedObject)
{
    return ProcA9BDAC6B67EE4CBC82EDEA2AB8AA48EF(pName, pFullName, TimeDateStamp, pVersion, pSymbolFileId, Flags, MemoryLayout, BaseAddress, LoadOrder, Size, pLoadContext, pRuntimeInstance, Mvid, ClrFlags, pAppDomain, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e MemoryLayout, UINT64 BaseAddress, UINT32 LoadOrder, UINT32 Size, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, const GUID& Mvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags::e ClrFlags, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* pAppDomain, UINT32 ILImageSize, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppCreatedObject)
{
    return ProcAEA58B7861C86E08A55546A1C4D0ACAD(pName, pFullName, TimeDateStamp, pVersion, pSymbolFileId, Flags, MemoryLayout, BaseAddress, LoadOrder, Size, pLoadContext, pRuntimeInstance, Mvid, ClrFlags, pAppDomain, ILImageSize, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetaDataImport(IUnknown** ppMetaData)
{
    return ProcF4BC786AEBAC294EE9C4C0BB1B0F56A7(this, ppMetaData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetaDataBytes(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pMetaData)
{
    return Proc423E0CAAC5C839003AD794CCD62FA0AC(this, pMetaData);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetCorObject(ICorDebugModule** ppCorModule)
{
    return Proc007981F40FEA39E044F4D8CF4A9AC416(this, ppCorModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::ResolveTypeName(Microsoft::VisualStudio::Debugger::DkmString* pTypeName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericParameters, Microsoft::VisualStudio::Debugger::Clr::DkmClrType** ppResult)
{
    return ProcCFC27B46EBDEFADA1E91D0A90B77634C(this, pTypeName, pGenericParameters, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::InterpretManagedMethod(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& Method, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericTypeParameters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericMethodParameters, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue* pThisParameter, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue*>* pParameters, UINT32 MaxInstructionCount, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterOptions::e Options, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue** ppReturnValue, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionType)
{
    return ProcC2A7595A78323D9ED538F97DF8858518(this, Method, pGenericTypeParameters, pGenericMethodParameters, pThisParameter, pParameters, MaxInstructionCount, Options, ppReturnValue, ppExceptionType);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetadataStatus(Microsoft::VisualStudio::Debugger::Clr::DkmMetadataStatus::e* pMetadataStatus)
{
    return ProcBA9A7ADBEAC8F47A27529954272992A2(this, pMetadataStatus);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::CORSystemDirectory()
{
    return this->m_pCORSystemDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::RuntimeVersion()
{
    return this->m_pRuntimeVersion;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmString* pCORSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pRuntimeVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance** ppCreatedObject)
{
    return ProcA5B161350506D3C0213719EA3CA946C7(pProcess, Id, pCORSystemDirectory, pRuntimeVersion, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, Microsoft::VisualStudio::Debugger::DkmString* pCORSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pRuntimeVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance** ppCreatedObject)
{
    return ProcA8484D0DF6D845608CC611EB2C6E61F9(pProcess, Id, Capabilities, pParentRuntime, pCORSystemDirectory, pRuntimeVersion, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::FindAppDomain(UINT32 Id, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain** ppAppDomain)
{
    return Proc494202493BBFB43009A6715156984C4D(this, Id, ppAppDomain);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetAppDomains(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*>* pAppDomains)
{
    return Proc30CD194706F2789B39BDA5888D5809D6(this, pAppDomains);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::FindClrModuleInstance(ICorDebugModule* pCorModule, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppResult)
{
    return Proc81F4DF12CD2E79C82CFA7D02F085DE1D(this, pCorModule, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetCorThread(Microsoft::VisualStudio::Debugger::DkmThread* pThread, ICorDebugThread** ppCorThread)
{
    return Proc7AC8F22DCEDC5109A8CFCCDB1698A28C(this, pThread, ppCorThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetCorProcess(ICorDebugProcess** ppCorProcess)
{
    return Proc4F2ACCA282DF893ACD2710806F488982(this, ppCorProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::PrepareForFuncEvalQuickAbort(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool* pSkipLoad, UINT64* pMemoryAddress)
{
    return Proc47E089E532D16825286594316453806D(this, pThread, pSkipLoad, pMemoryAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::OnFuncEvalQuickAbortDllLoaded(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool Result)
{
    return Proc0132C3722F8DEFF0E84DABDD6B5DCCBA(this, pThread, Result);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::ContinueForFuncEval(Microsoft::VisualStudio::Debugger::DkmThread* pThread, ICorDebugEval* pCorEval, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e FuncEvalFlags, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString* pEvaluationString, HRESULT* pResult)
{
    return ProcA58F0A1DAF5C4DEA3A4923BA8F90EF34(this, pThread, pCorEval, FuncEvalFlags, Timeout, pEvaluationString, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::CanDoFuncEval(Microsoft::VisualStudio::Debugger::DkmThread* pThread, HRESULT* pResult)
{
    return Proc4C53A066D18791671CC9C01BFA0C6D8D(this, pThread, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId::Release(Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId* pItem)
{
    return ProcC3CB7743B5DBB83116E9365BACFA6AF3(pItem);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery::Instructions()
{
    return this->m_pInstructions;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& QueryKind, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pInstructions, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery** ppCreatedObject)
{
    return Proc0C158E97206654F945E7158521D7796B(pRuntimeInstance, QueryKind, pInstructions, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::Instructions()
{
    return this->m_pInstructions;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>* pInstructions, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery** ppCreatedObject)
{
    return ProcB0E7C63F4B37AB192D3B02A003BD771F(pRuntimeInstance, pInstructions, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::ExecuteQueryOnThreads(Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreads, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult** ppResult)
{
    return Proc52A14AC059F0DEB8A5DD37CE238BCAA4(this, pILContext, pThreads, pParameters, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::ExecuteQueryOnThreads(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreads, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>* pParameters, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmExecuteQueryOnThreadsAsyncResult>* pCompletionRoutine)
{
    return Proc99FA7DE19BFA48E79B8C772F04C5C0F7(this, pWorkList, pILContext, pThreads, pParameters, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::QueryKind()
{
    return this->m_QueryKind;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Execute(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e FuncEvalFlags, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e* pFailureReason)
{
    return Proc830BF1EC32B2D50A6F454C73132E8D95(this, pParameters, pILContext, Timeout, FuncEvalFlags, pResults, pFailureReason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Execute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e FuncEvalFlags, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmExecuteQueryAsyncResult>* pCompletionRoutine)
{
    return ProcDAC5F1C0332F717B7A78BCF000B235F3(this, pWorkList, pParameters, pILContext, Timeout, FuncEvalFlags, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId::CompareTo(const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& other) const
{
    return Proc558180C0AA1756192A5B4EECD2C72DAE(*this, other);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty::Release(Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty* pItem)
{
    return Proc2CC5FE15ED9552B8D71D8052FAB0ABA3(pItem);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult::EvaluationResults()
{
    return this->m_EvaluationResults;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult::ResultData()
{
    return this->m_pResultData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult::Create(HRESULT EvaluationResults, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection*>* pResultData, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult** ppCreatedObject)
{
    return ProcD1951845DC0A598B7D01BE514C5C6242(EvaluationResults, pResultData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::ThreadIds()
{
    return this->m_pThreadIds;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::EvaluationResults()
{
    return this->m_EvaluationResults;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::Close()
{
    return Proc99CFA8EC6ABD1D93AFE145CA709A7FBD(this);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::Name()
{
    return static_cast<Microsoft::VisualStudio::Debugger::DkmString*>(DkmExceptionInformation::Name());
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::ExceptionObjectPointer()
{
    return this->m_ExceptionObjectPointer;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::Address()
{
    return this->m_Address;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::WinRTExceptionInfo()
{
    return this->m_pWinRTExceptionInfo;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pImplementationException, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT64 ExceptionObjectPointer, UINT64 Address, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation* pWinRTExceptionInfo, Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation** ppCreatedObject)
{
    return ProcA53162B525391FF931A42627F7AAD6A9(pRuntimeInstance, pThread, pInstructionAddress, ProcessingStage, pImplementationException, pName, ExceptionObjectPointer, Address, pWinRTExceptionInfo, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::Description()
{
    return this->m_pDescription;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::RestrictedDescription()
{
    return this->m_pRestrictedDescription;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::RestrictedReference()
{
    return this->m_pRestrictedReference;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::RestrictedCapabilitySid()
{
    return this->m_pRestrictedCapabilitySid;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::ExceptionHR()
{
    return this->m_ExceptionHR;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::ErrorInfoAddress()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ErrorInfoAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::CapturedStack()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pCapturedStack;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedCapabilitySid, HRESULT ExceptionHR, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation** ppCreatedObject)
{
    return Proc6DFAC5682AB3B324F2B704053BEE6004(pDescription, pRestrictedDescription, pRestrictedReference, pRestrictedCapabilitySid, ExceptionHR, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedCapabilitySid, HRESULT ExceptionHR, UINT64 ErrorInfoAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* pCapturedStack, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation** ppCreatedObject)
{
    return Proc424C754CDDD2CF45A942C20EED3CC893(pDescription, pRestrictedDescription, pRestrictedReference, pRestrictedCapabilitySid, ExceptionHR, ErrorInfoAddress, pCapturedStack, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation::AdditionalInformation()
{
    return this->m_pAdditionalInformation;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& ExceptionCategory, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pImplementationException, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalInformation, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation** ppCreatedObject)
{
    return Proc0293D2889DE6E0C14B909BC2A4CE0670(pRuntimeInstance, ExceptionCategory, pThread, pInstructionAddress, pName, Code, ProcessingStage, pImplementationException, pAdditionalInformation, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance*>(DkmInstructionAddress::ModuleInstance());
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::EntityId()
{
    return this->m_pEntityId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::Offset()
{
    return this->m_Offset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pEntityId, UINT64 Offset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress** ppCreatedObject)
{
    return ProcE315DFDB6AEB76AA580E27B52F91F5AF(pRuntimeInstance, pModuleInstance, pEntityId, Offset, pAdditionalData, pCPUInstruction, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::EntityId()
{
    return this->m_pEntityId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::Offset()
{
    return this->m_Offset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const GUID& RuntimeType, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pEntityId, UINT64 Offset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol** ppCreatedObject)
{
    return Proc166F47D8BD25C8CC59B1502B3F4A5DDB(pModule, RuntimeType, pEntityId, Offset, pAdditionalData, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Connection()
{
    return this->m_pConnection;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SourceId()
{
    return this->m_SourceId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::MessageCode()
{
    return this->m_MessageCode;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Parameter1()
{
    return this->m_pParameter1;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Parameter2()
{
    return this->m_pParameter2;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, UINT32 MessageCode, Microsoft::VisualStudio::Debugger::DkmVariant* pParameter1, Microsoft::VisualStudio::Debugger::DkmVariant* pParameter2, Microsoft::VisualStudio::Debugger::DkmCustomMessage** ppCreatedObject)
{
    return Proc6D698C640DFDABA88B6B6A8B78565B1C(pConnection, pProcess, SourceId, MessageCode, pParameter1, pParameter2, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::OnCustomStop(Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& VsService)
{
    return Proc5C808A6463557CF774E01775628F0DCA(this, pThread, VsService);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendHigher(Microsoft::VisualStudio::Debugger::DkmCustomMessage** ppReplyMessage)
{
    return Proc1BAFA69EABAF1980E4618AC80AEECB47(this, ppReplyMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendLower(Microsoft::VisualStudio::Debugger::DkmCustomMessage** ppReplyMessage)
{
    return ProcA035DEDBF7F91EB78B75DE7CDEB4644C(this, ppReplyMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendLower(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmSendLowerAsyncResult>* pCompletionRoutine)
{
    return Proc73CBBC77F9E0A5C530459780952936FE(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendToVsService(const GUID& VsService, bool IsBlocking)
{
    return Proc387497D446792B6386776489669D2D7B(this, VsService, IsBlocking);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e MemoryLayout, UINT64 BaseAddress, UINT32 LoadOrder, UINT32 Size, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance** ppCreatedObject)
{
    return ProcCCE122D321D1AFDE76D7CACE58F839C7(pName, pFullName, TimeDateStamp, pRuntimeInstance, pVersion, pSymbolFileId, Flags, MemoryLayout, BaseAddress, LoadOrder, Size, pLoadContext, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue::Create(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pReturnFrom, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue** ppCreatedObject)
{
    return Proc3C62BEDE7059A6F82EF5950D9B08F212(pReturnFrom, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject)
{
    return Proc0F93893A27AD0F7C9A3E108C73ABCEF6(pProcess, Id, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject)
{
    return Proc1A4BA89C2192C5ED79E0F488CA118164(pProcess, Id, Capabilities, pParentRuntime, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId::Type()
{
    return this->m_Type;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId::Data()
{
    return this->m_pData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId::Create(const GUID& SymbolProviderId, UINT32 Type, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pData, Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId** ppCreatedObject)
{
    return Proc439EB6AA207DB70F8ED3430FFCAB70A6(SymbolProviderId, Type, pData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::MenuName()
{
    return this->m_pMenuName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Description()
{
    return this->m_pDescription;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Metric()
{
    return this->m_pMetric;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmString* pMenuName, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pMetric, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo** ppCreatedObject)
{
    return ProcA9F782A3E84B2CDB9646FDCE26477F26(Id, pMenuName, pDescription, pMetric, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::Value()
{
    return this->m_Value;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, UINT64 Value, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress** ppCreatedObject)
{
    return Proc76C4E68C18BC734895D4A803EED86642(pRuntimeInstance, Value, pInstructionAddress, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::OptionsString()
{
    return this->m_pOptionsString;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::EngineFilter()
{
    return this->m_pEngineFilter;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::Create(Microsoft::VisualStudio::Debugger::DkmString* pOptionsString, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* pEngineFilter, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings** ppCreatedObject)
{
    return ProcD1BDFF0E74198F9E97B1200C099D36B2(pOptionsString, pEngineFilter, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::GetGPUAdditionalEnvironmentVariables(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario::e Scenario, Microsoft::VisualStudio::Debugger::DkmString** ppAdditionalEnvironmentBlock)
{
    return Proc3B2F13165414C4F66EE876593C947FF7(this, Scenario, ppAdditionalEnvironmentBlock);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Connection()
{
    return this->m_pConnection;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::RemoteExecutable()
{
    return this->m_pRemoteExecutable;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Arguments()
{
    return this->m_pArguments;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::CurrentDirectory()
{
    return this->m_pCurrentDirectory;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommandFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Close()
{
    return Proc55CE06AE749FE4FDB97CE54A455619A3(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmString* pRemoteExecutable, Microsoft::VisualStudio::Debugger::DkmString* pArguments, Microsoft::VisualStudio::Debugger::DkmString* pCurrentDirectory, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommandFlags::e Flags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand** ppCreatedObject)
{
    return Proc8FCA18285F43AB559217B26B94231774(pConnection, SourceId, pRemoteExecutable, pArguments, pCurrentDirectory, Flags, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::OnProcessExit(UINT32 ExitCode)
{
    return Proc533B990E9F9B15A54DDC4E3E1D2E1078(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::OnStdOut(Microsoft::VisualStudio::Debugger::DkmString* pText)
{
    return ProcCE2CA685D8412F7CDB1945E19E677AEA(this, pText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::OnStdErr(Microsoft::VisualStudio::Debugger::DkmString* pText)
{
    return ProcA8DA7BD7B83089DE1427BED550F265FD(this, pText);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Start()
{
    return Proc72A6761FCC1029893756B99ADC6B9E6C(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Abort()
{
    return Proc86DE7C8070519AEDC00A37E1FA5E127C(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::InstructionPointer()
{
    return this->m_InstructionPointer;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::InstructionLength()
{
    return this->m_InstructionLength;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Address()
{
    return this->m_pAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::AddressOffset()
{
    return this->m_pAddressOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::CodeBytes()
{
    return this->m_pCodeBytes;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::RawOpcode()
{
    return this->m_pRawOpcode;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::RawOperands()
{
    return this->m_pRawOperands;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::FormattedOpcode()
{
    return this->m_pFormattedOpcode;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::FormattedOperands()
{
    return this->m_pFormattedOperands;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Symbol()
{
    return this->m_pSymbol;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::DocumentPosition()
{
    return this->m_pDocumentPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::ByteOffset()
{
    return this->m_ByteOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<CV_HREG_e>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::RegisterOperands()
{
    return this->m_pRegisterOperands;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::ValidInstruction()
{
    return this->m_ValidInstruction;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 InstructionPointer, UINT32 InstructionLength, Microsoft::VisualStudio::Debugger::DkmString* pAddress, Microsoft::VisualStudio::Debugger::DkmString* pAddressOffset, Microsoft::VisualStudio::Debugger::DkmString* pCodeBytes, Microsoft::VisualStudio::Debugger::DkmString* pRawOpcode, Microsoft::VisualStudio::Debugger::DkmString* pRawOperands, Microsoft::VisualStudio::Debugger::DkmString* pFormattedOpcode, Microsoft::VisualStudio::Debugger::DkmString* pFormattedOperands, Microsoft::VisualStudio::Debugger::DkmString* pSymbol, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pDocumentPosition, UINT32 ByteOffset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<CV_HREG_e>* pRegisterOperands, bool ValidInstruction, Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction** ppCreatedObject)
{
    return Proc3416010C84D4A08CE249F39B46310F4B(pProcess, InstructionPointer, InstructionLength, pAddress, pAddressOffset, pCodeBytes, pRawOpcode, pRawOperands, pFormattedOpcode, pFormattedOperands, pSymbol, pDocumentPosition, ByteOffset, pRegisterOperands, ValidInstruction, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmDynamicSymbolFileId::Create(const GUID& SymbolProviderId, Microsoft::VisualStudio::Debugger::Symbols::DkmDynamicSymbolFileId** ppCreatedObject)
{
    return Proc2CDF0821065EEEAF4BF0768BBC714CF9(SymbolProviderId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject** ppCreatedObject)
{
    return Proc0AD4448F733B3969810D3200D16F7571(pProcess, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::InitCache()
{
    return Proc212CD04490F098DD69043824CE41E472(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetTargetClass(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 AssemblyCookie, UINT32* pCookie, UINT32* pValueAttributeCount, UINT32* pViewerAttributeCount, UINT32* pVisualizerAttributeCount)
{
    return Proc5CB574B305F260A0A4DC51E163157D25(this, pName, AssemblyCookie, pCookie, pValueAttributeCount, pViewerAttributeCount, pVisualizerAttributeCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetTargetAssembly(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32* pCookie)
{
    return Proc19D6B8616421D55B78D376D6CD3A5C5D(this, pName, pCookie);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetAssembly(UINT32 AssemblyCookie, UINT32 Flags, UINT32* pFlagsOut, Microsoft::VisualStudio::Debugger::DkmString** ppName, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pPdbBytes)
{
    return Proc71288BA136E46AD8363AFD5AA013391E(this, AssemblyCookie, Flags, pFlagsOut, ppName, pAssemblyBytes, pPdbBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetHostAssembly(UINT32 Flags, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pPdbBytes)
{
    return ProcD089BFE2A48AC9E0A8F4B1DDDC4A9F71(this, Flags, pAssemblyBytes, pPdbBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetValueAttributeProps(UINT32 ClassCookie, UINT32 Ordinal, Microsoft::VisualStudio::Debugger::DkmString** ppTargetedAssembly, UINT32* pAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppName, Microsoft::VisualStudio::Debugger::DkmString** ppValue, Microsoft::VisualStudio::Debugger::DkmString** ppType)
{
    return ProcB619FA0B30165B806D34B9DE6755888B(this, ClassCookie, Ordinal, ppTargetedAssembly, pAssemblyLocation, ppName, ppValue, ppType);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetViewerAttributeProps(UINT32 ClassCookie, UINT32 Ordinal, Microsoft::VisualStudio::Debugger::DkmString** ppTargetedAssembly, UINT32* pAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppClassName, UINT32* pClassAssemblyLocation)
{
    return ProcFD5E0390E2DDF834E43AC2E8528EFDE3(this, ClassCookie, Ordinal, ppTargetedAssembly, pAssemblyLocation, ppClassName, pClassAssemblyLocation);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetVisualizerAttributeProps(UINT32 ClassCookie, UINT32 Ordinal, Microsoft::VisualStudio::Debugger::DkmString** ppTargetedAssembly, UINT32* pAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppDisplayClassName, UINT32* pDisplayClassAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppProxyClassName, UINT32* pProxyClassAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppDescription, UINT32* pType)
{
    return Proc94B68F827E58FE88F3FA8771B9D09337(this, ClassCookie, Ordinal, ppTargetedAssembly, pAssemblyLocation, ppDisplayClassName, pDisplayClassAssemblyLocation, ppProxyClassName, pProxyClassAssemblyLocation, ppDescription, pType);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::EngineId()
{
    return this->m_EngineId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrDebuggingServicesId::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::ClrDebuggingServicesId()
{
    return this->m_ClrDebuggingServicesId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::Languages()
{
    return this->m_pLanguages;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Symbols::DkmImageDebugDirectoryFormat>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::ImageDebugDirectoryFormats()
{
    return this->m_pImageDebugDirectoryFormats;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::EnableFuncEvalQuickAbort()
{
    return this->m_EnableFuncEvalQuickAbort;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::FuncEvalQuickAbortExcludeList()
{
    return this->m_pFuncEvalQuickAbortExcludeList;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::EnableAsyncDebugging()
{
    return this->m_EnableAsyncDebugging;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::RemoteClrPdbNamePatterns()
{
    return this->m_pRemoteClrPdbNamePatterns;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::BaseDebugMonitorId()
{
    return this->m_BaseDebugMonitorId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::MaxCallStackFrames()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->MaxCallStackFrames;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsEditAndContinue()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsEditAndContinue;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::ValidateFilesForMinidumps()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ValidateFilesForMinidumps;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmRegistryTweak*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::RegistryTweaks()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pRegistryTweaks;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsJustMyCodeEnabled()
{
    return this->m_IsJustMyCodeEnabled;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetSymbolPaths(_Deref_out_ Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings** ppValue)
{
    return Get250481482FAEDAA4BBEBC807B24DD715(this, ppValue);
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsSuppressOptimizationsEnabled()
{
    return this->m_IsSuppressOptimizationsEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsStepOverPropertiesAndOperatorsEnabled()
{
    return this->m_IsStepOverPropertiesAndOperatorsEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsNativeExportsEnabled()
{
    return this->m_IsNativeExportsEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsGpuRaceHazardsAllowSameSettingEnabled()
{
    return this->m_IsGpuRaceHazardsAllowSameSettingEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::RequireFullTrustForSourceServer()
{
    return this->m_RequireFullTrustForSourceServer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::FindSettings(const GUID& EngineId, Microsoft::VisualStudio::Debugger::DkmEngineSettings** ppSettings)
{
    return ProcEAB82333D65B545623818EFFC257B255(EngineId, ppSettings);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetSettings(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmEngineSettings*>* pSettings)
{
    return ProcB58779AE70E61CE2C137F2DC7C7E39A2(pSettings);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::FindProcess(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc66C5B8466345C8B890DE700EC642A0DF(this, UniqueId, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return ProcCFA56E1A30696A54C78DD3B62C48CB58(this, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetLanguage(const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage** ppLanguage)
{
    return Proc55C239704FB9EE8A91BCDFF2A41E9307(this, CompilerId, ppLanguage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetCodeViewCompilers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId>* pCodeViewCompilers)
{
    return Proc712AEE7B1CBFE90A27AABC87EDA764C0(this, pCodeViewCompilers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetUserDocumentPath(Microsoft::VisualStudio::Debugger::DkmString** ppUserDocumentPath)
{
    return Proc785B704BB677152C77F39C102DD245C6(this, ppUserDocumentPath);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::SymbolPaths()
{
    return this->m_pSymbolPaths;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::SymbolCachePath()
{
    return this->m_pSymbolCachePath;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::IncludeList()
{
    return this->m_pIncludeList;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::ExcludeList()
{
    return this->m_pExcludeList;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::ManualLoading()
{
    return this->m_ManualLoading;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::LoadAdjacentSymbols()
{
    return this->m_LoadAdjacentSymbols;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pSymbolPaths, Microsoft::VisualStudio::Debugger::DkmString* pSymbolCachePath, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pIncludeList, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pExcludeList, bool ManualLoading, bool LoadAdjacentSymbols, Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings** ppCreatedObject)
{
    return Proc22A1D0256F691113C635408F3AB12787(pSymbolPaths, pSymbolCachePath, pIncludeList, pExcludeList, ManualLoading, LoadAdjacentSymbols, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::RuntimeBreakpoint()
{
    return this->m_pRuntimeBreakpoint;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Source()
{
    return this->m_pSource;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Language()
{
    return this->m_pLanguage;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::RuntimeInstance()
{
    return this->m_pRuntimeBreakpoint->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Close()
{
    return Proc7DFB0CC45F58E9F2422E3D6ADD30D56C(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pSource, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition** ppCreatedObject)
{
    return ProcDA01083FD1F7BC6E21CF70FEBE852E08(pRuntimeBreakpoint, pSource, pLanguage, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Parse(Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return ProcC551A87289B36A81E4E7DC67503FA13B(this, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Evaluate(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, bool* pStop, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc22969485654512BB4766B642E35146B1(this, pStackFrame, pStop, ppErrorText);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::InspectionContext()
{
    return this->m_pInspectionContext;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Language()
{
    return this->m_pInspectionContext->Language();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::InspectionSession()
{
    return this->m_pInspectionContext->InspectionSession();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::RuntimeInstance()
{
    return this->m_pInspectionContext->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Close()
{
    return Proc18F3F98E2BDA11EE2E0551E6EB174A15(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::GetChildren(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 InitialRequestSize, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine)
{
    return Proc304D6F6048468BB211A98ECADD5190CC(this, pWorkList, InitialRequestSize, pInspectionContext, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::SetValueAsString(Microsoft::VisualStudio::Debugger::DkmString* pValue, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc0D96A87BB543F851A5DE00719E779D3C(this, pValue, Timeout, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::GetUnderlyingString(Microsoft::VisualStudio::Debugger::DkmString** ppStringValue)
{
    return Proc4943C591B2842416B41CCEDF949F0CAA(this, ppStringValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::CreateObjectId()
{
    return Proc4F92F70F3E82F62D90F9A64274110E0E(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::DestroyObjectId()
{
    return ProcE7EB085795DD0AF19384C3FEDDC02346(this);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Count()
{
    return this->m_Count;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::InspectionContext()
{
    return this->m_pInspectionContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Language()
{
    return this->m_pInspectionContext->Language();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::InspectionSession()
{
    return this->m_pInspectionContext->InspectionSession();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::RuntimeInstance()
{
    return this->m_pInspectionContext->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Close()
{
    return Proc893685F10EC87472D047E00FE7DBEF94(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Create(UINT32 Count, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext** ppCreatedObject)
{
    return ProcF0C60D4E64737DC5E907AC0500338F29(Count, pStackFrame, pInspectionContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::GetItems(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 StartIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine)
{
    return ProcD2CB7DED0F650EA239322E6F3A6CB5A2(this, pWorkList, StartIndex, Count, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& ExceptionCategory, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger** ppCreatedObject)
{
    return ProcA277FC9EA1AD7D48A50697B88E56D01A(ProcessingStage, pThread, ExceptionCategory, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger::Code()
{
    return this->m_Code;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& ExceptionCategory, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger** ppCreatedObject)
{
    return ProcDC69BC0A967710B649D98D8171E6AB4E(ProcessingStage, pThread, ExceptionCategory, Code, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionGlobalTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionGlobalTrigger** ppCreatedObject)
{
    return ProcD3051BA529DC1A0C80DE71D6B8A5D237(ProcessingStage, pThread, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Code()
{
    return this->m_Code;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::ProcessingStage()
{
    return this->m_ProcessingStage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::ImplementationException()
{
    return this->m_pImplementationException;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Process()
{
    return this->m_pThread->Process();
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::OnDebugMonitorException()
{
    return Proc46F4EBD73CFB584D76BA34433F61DB86(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::OnContinued()
{
    return Proc2BDC566C9437414EFB44DCA2FB0655BF(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::CanModifyProcessing(bool* pResult)
{
    return ProcC4606A8DA0BC602AF74AB3F9240E24F8(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::SquashProcessing()
{
    return Proc7CBBB15E9B8502248D458346A2C09640(this);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetDescription(Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return Proc6D04FF97A36E6FBE5A873E9E4D373191(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetAdditionalInformation(Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return ProcA507F5EA1FFFB25DB6C264A1A3E9D9A0(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetWinRTErrorInfo(Microsoft::VisualStudio::Debugger::DkmString** ppRestrictedDescription, Microsoft::VisualStudio::Debugger::DkmString** ppRestrictedErrorReference, Microsoft::VisualStudio::Debugger::DkmString** ppRestrictedCapabilitySid)
{
    return Proc32C54A299942A4DF0FC187766A44B6D8(this, ppRestrictedDescription, ppRestrictedErrorReference, ppRestrictedCapabilitySid);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::OnOutOfBandException()
{
    return Proc8DE481C3F9EEB3173D2DF9D68D38D3BE(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetExceptionStackTrace(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>** ppStackTrace)
{
    return Proc4102811B876B002C9EBF58B1231D3419(this, ppStackTrace);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& ExceptionCategory, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger** ppCreatedObject)
{
    return Proc2997D2B4489466E485DF7E7BA9519AA0(ProcessingStage, pThread, ExceptionCategory, pName, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::ProcessingStage()
{
    return this->m_ProcessingStage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::Thread()
{
    return this->m_pThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Exception()
{
    return this->m_pException;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Description()
{
    return this->m_pDescription;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::RestrictedErrorDescription()
{
    return this->m_pRestrictedErrorDescription;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::CapabilitySid()
{
    return this->m_pCapabilitySid;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::RestrictedReference()
{
    return this->m_pRestrictedReference;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::AdditionalInformation()
{
    return this->m_pAdditionalInformation;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::SourceId()
{
    return this->m_SourceId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::StackTrace()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pStackTrace;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Process()
{
    return this->m_pException->Process();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Thread()
{
    return this->m_pException->Thread();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::RuntimeInstance()
{
    return this->m_pException->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pException, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedErrorDescription, Microsoft::VisualStudio::Debugger::DkmString* pCapabilitySid, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pAdditionalInformation, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit** ppCreatedObject)
{
    return Proc82C475324C56B876A52EA3F7C064EFC7(pException, pDescription, pRestrictedErrorDescription, pCapabilitySid, pRestrictedReference, pAdditionalInformation, SourceId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pException, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedErrorDescription, Microsoft::VisualStudio::Debugger::DkmString* pCapabilitySid, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pAdditionalInformation, const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* pStackTrace, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit** ppCreatedObject)
{
    return Proc7C607E439F8FC343B781AA531EE6CBEB(pException, pDescription, pRestrictedErrorDescription, pCapabilitySid, pRestrictedReference, pAdditionalInformation, SourceId, pStackTrace, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Send()
{
    return ProcB462A99D32FCE88A7D5A90C41736C64D(this);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult::ErrorMessage()
{
    return this->m_pErrorMessage;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult::HasSideEffects()
{
    return this->m_HasSideEffects;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreadIds, HRESULT EvaluationResults, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage, bool HasSideEffects, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult** ppCreatedObject)
{
    return ProcF87D21978E9C526845E798A88842F450(pThreadIds, EvaluationResults, pName, pFullName, pRuntimeInstance, pErrorMessage, HasSideEffects, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::ErrorMessage()
{
    return this->m_pErrorMessage;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Flags()
{
    return this->m_Flags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Type()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e Flags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult** ppCreatedObject)
{
    return Proc25600235530C4F6D98FFF804F230681D(pInspectionContext, pStackFrame, pName, pFullName, pErrorMessage, Flags, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmString* pType, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult** ppCreatedObject)
{
    return ProcCB940B4E5BD2C7FE35C1403BA8667C6F(pInspectionContext, pStackFrame, pName, pFullName, pErrorMessage, Flags, pType, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome::Address()
{
    return this->m_Address;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome::Create(UINT64 Address, Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome** ppCreatedObject)
{
    return ProcD1DED409EDEADF892DF44AC593A875CA(Address, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::FileName()
{
    return this->m_pFileName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::FilePath()
{
    return this->m_pFilePath;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::Attributes()
{
    return this->m_Attributes;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::CreationTime()
{
    return this->m_CreationTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::LastAccessTime()
{
    return this->m_LastAccessTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::LastWriteTime()
{
    return this->m_LastWriteTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::FileSize()
{
    return this->m_FileSize;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileName, Microsoft::VisualStudio::Debugger::DkmString* pFilePath, UINT32 Attributes, UINT64 CreationTime, UINT64 LastAccessTime, UINT64 LastWriteTime, UINT64 FileSize, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo** ppCreatedObject)
{
    return Proc128B9579786732D548FB332A0B330884(pFileName, pFilePath, Attributes, CreationTime, LastAccessTime, LastWriteTime, FileSize, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::RemoteFilePath()
{
    return this->m_pRemoteFilePath;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::Close()
{
    return ProcE20B1EDA2CA598DA00992416EE3EBC95(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream** ppCreatedObject)
{
    return Proc512DAF21364C293BE3611EE0A2AB259B(pConnection, pRemoteFilePath, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::WriteFirst(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Content, UINT64 TotalFileSize, UINT64 LastWriteTime, bool OverwriteExisting)
{
    return ProcBF5C3FB352B37CE289A04F7F698B6005(this, Content, TotalFileSize, LastWriteTime, OverwriteExisting);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::WriteNext(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Content)
{
    return Proc394EABA320D7CFF611EB0D16BA910E50(this, Content);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::ReadFirst(void* pContentBuffer, UINT32 BufferSize, UINT32* pBytesRead, UINT64* pLastWriteTime, UINT64* pTotalFileSize)
{
    return Proc8213AA4FF03A692BCCC88DDB65068B50(this, pContentBuffer, BufferSize, pBytesRead, pLastWriteTime, pTotalFileSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::ReadNext(void* pContentBuffer, UINT32 BufferSize, UINT32* pBytesRead)
{
    return Proc9B59AAB03E31F3B304B956E0EAA505B4(this, pContentBuffer, BufferSize, pBytesRead);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::UnwoundRegisters()
{
    return this->m_pUnwoundRegisters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::GetInstructionPointer(UINT64* pValue)
{
    return Proc0B7E2AD76C535C1C35C3948F1F2C45DF(this, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::GetStackPointer(UINT64* pValue)
{
    return ProcC0AB0BE9B5D47BDCB64470DFC9FA2B70(this, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::GetRegisterValue(UINT32 Id, void* pBuffer, UINT32 Size, UINT32* pBytesRead)
{
    return Proc14365162F719EE309833526528F9F58D(this, Id, pBuffer, Size, pBytesRead);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::DispatchId()
{
    return this->m_DispatchId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GPUDevice()
{
    return this->m_GPUDevice;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GPUShader()
{
    return this->m_GPUShader;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GPUShaderDispatch()
{
    return this->m_GPUShaderDispatch;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GroupDimensions()
{
    return this->m_pGroupDimensions;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::NumberOfGroups()
{
    return this->m_NumberOfGroups;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::ThreadDimensions()
{
    return this->m_pThreadDimensions;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::NumberOfThreads()
{
    return this->m_NumberOfThreads;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Process()
{
    return this->m_pProcess;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Connection()
{
    return this->m_pProcess->Connection();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Create(UINT32 DispatchId, UINT64 GPUDevice, UINT64 GPUShader, UINT64 GPUShaderDispatch, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* pGroupDimensions, UINT64 NumberOfGroups, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* pThreadDimensions, UINT32 NumberOfThreads, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel** ppCreatedObject)
{
    return Proc70432FE96C3AD9E0FF944F8DEDE6D609(DispatchId, GPUDevice, GPUShader, GPUShaderDispatch, pGroupDimensions, NumberOfGroups, pThreadDimensions, NumberOfThreads, pProcess, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Unload(UINT32 ExitCode)
{
    return ProcD8C5AEC94B361E4D97A914AAFF227264(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::FindComputeThread(UINT64 GlobalThreadIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppComputeThread)
{
    return Proc7555F39063D612CCEC13E6563676F002(this, GlobalThreadIndex, ppComputeThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetComputeVectorWidth(UINT32* pWidth)
{
    return Proc6DE89FDFD6A2F6751D3C5B48FF2E1B99(this, pWidth);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetActiveThreadGroups(Microsoft::VisualStudio::Debugger::DkmArray<UINT64>* pActiveThreadGroups, UINT32* pNumberOfGroups)
{
    return Proc08309D087A5DE326E3C34B180D4043BE(this, pActiveThreadGroups, pNumberOfGroups);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetCurrentThreadDimensions(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pThreadDimensions, UINT32* pNumberOfDimensions)
{
    return Proc26BA35089930A40C5436AE4DC5794A7A(this, pThreadDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetCurrentGroupDimensions(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pGroupDimensions, UINT32* pNumberOfDimensions)
{
    return Proc3E4C247AE33A7932565EF80AD32F3135(this, pGroupDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetComputeKernelName(Microsoft::VisualStudio::Debugger::DkmString** ppComputeKernelName)
{
    return Proc00D7D596CD9722CDE7B7901FFBB9DBF2(this, ppComputeKernelName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetComputeKernelProperties(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty>* pComputeProperties, UINT32* pNumberOfProperties)
{
    return Proc2E465FDD46A4B4DC92D709FF51472ADC(this, pComputeProperties, pNumberOfProperties);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Select(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pFrom, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>* pThreadInfoArray)
{
    return Proc9C1FD869706730AA7EFF44A78D267C92(this, pFrom, Where, pThreadInfoArray);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GroupBy(Microsoft::VisualStudio::Debugger::GPU::DkmQueryComputeThreadInfoFlags::e GroupByFlags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pFrom, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>* pThreadInfoArray)
{
    return ProcD4C3C1C4B0F5F1BAA4647C8F7EF693FD(this, GroupByFlags, pFrom, Where, pThreadInfoArray);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetStoppedThreads(Microsoft::VisualStudio::Debugger::DkmArray<UINT64>* pThreadIdArray)
{
    return Proc9EB53CEDD4070927EF381FE18879D14F(this, pThreadIdArray);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetThreadFromId(UINT64 ThreadId, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppThread)
{
    return ProcAA5382361712FF7C2DB61AF2F559F507(this, ThreadId, ppThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::UpdateFlaggedState(const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, bool Flagged)
{
    return Proc91AD1E7974AB8724E982A8D9BDA27FAF(this, Where, Flagged);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::UpdateFrozenState(const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, bool Frozen)
{
    return ProcA153D09816AF6B9868DED1F2AA6D1A13(this, Where, Frozen);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetFlatComputeKernelDimensions(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pFlatThreadDimensions, Microsoft::VisualStudio::Debugger::DkmArray<INT32>* pFlatIndexBase, UINT32* pNumberOfDimensions, Microsoft::VisualStudio::Debugger::GPU::DkmComputeKernelModel::e* pModel)
{
    return ProcC21FFEF8BC14B5A4DD66728B44AE9EC2(this, pFlatThreadDimensions, pFlatIndexBase, pNumberOfDimensions, pModel);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GlobalThreadIndex()
{
    return this->m_GlobalThreadIndex;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::ComputeKernel()
{
    return this->m_pComputeKernel;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::NativeThread()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pNativeThread;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 NativeStartAddress, bool IsMainThread, UINT64 GlobalThreadIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel* pComputeKernel, const Microsoft::VisualStudio::Debugger::DkmThread::System* pSystem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppCreatedObject)
{
    return ProcE1CD74A61F4598BDC8CE45676C134C2C(pProcess, NativeStartAddress, IsMainThread, GlobalThreadIndex, pComputeKernel, pSystem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 NativeStartAddress, bool IsMainThread, UINT64 GlobalThreadIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel* pComputeKernel, Microsoft::VisualStudio::Debugger::DkmThread* pNativeThread, const Microsoft::VisualStudio::Debugger::DkmThread::System* pSystem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppCreatedObject)
{
    return Proc5E4EC8BBF3CBA2610A47A3950747990A(pProcess, NativeStartAddress, IsMainThread, GlobalThreadIndex, pComputeKernel, pNativeThread, pSystem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetThisThreadDimension(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pThreadDimensions, UINT32* pNumberOfDimensions)
{
    return ProcDE293BC2897E94BBAB8BAC9654D13D93(this, pThreadDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetThisGroupDimension(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pGroupDimensions, UINT32* pNumberOfDimensions)
{
    return ProcFE2ED3D7FCB8CBBF9CB8C6E5DAF90BED(this, pGroupDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetThreadId(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pThreadDimensions, UINT32* pNumberOfDimensions)
{
    return Proc835E736595E58DBBC0780B8878972850(this, pThreadDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetGroupId(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pGroupDimensions, UINT32* pNumberOfDimensions)
{
    return Proc064A81821D7B41B5152C78C6D4D1B1F8(this, pGroupDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::ReadMemory(UINT64 Address, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e Flags, void* pBuffer, UINT32 Size, UINT32* pBytesRead)
{
    return Proc2FAC62524E17B80FA70A0CC17E6ACC59(this, Address, InstructionPointer, Flags, pBuffer, Size, pBytesRead);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::WriteMemory(UINT64 Address, UINT64 InstructionPointer, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return ProcD076451B3D57BBE20AF66FD87DB7A3CA(this, Address, InstructionPointer, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::UpdateBufferTag(UINT32 InputTag, UINT32* pForwardedTag)
{
    return Proc9DBDC9183214716614E7527CD4D03D0B(this, InputTag, pForwardedTag);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::ValidateAddress(UINT64 Address, bool* pIsValidGpuMemoryAddress)
{
    return Proc48C49A28A6651642540A84275D9B1CA0(this, Address, pIsValidGpuMemoryAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetRegisterDescriptions(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription>* pRegisterDescriptions)
{
    return ProcFB143392ABCA694056F9F89070E283E4(this, pRegisterDescriptions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::SetRegisterValue(const Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription& RegisterDescription, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pRegisterValue)
{
    return ProcB4B5B53005AB2ACB4A337CC2906C6988(this, RegisterDescription, pRegisterValue);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress::ComputeThread()
{
    return this->m_pComputeThread;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress::InstructionPointer()
{
    return this->m_InstructionPointer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, UINT64 Value, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread* pComputeThread, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress** ppCreatedObject)
{
    return Proc865C2DC79B308E28B79594200F171F1B(pRuntimeInstance, Value, pInstructionAddress, pComputeThread, InstructionPointer, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation::ConflictingInstructionAddress()
{
    return this->m_ConflictingInstructionAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation::ConflictingThreadGlobalIndex()
{
    return this->m_ConflictingThreadGlobalIndex;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, UINT64 ConflictingInstructionAddress, UINT64 ConflictingThreadGlobalIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation** ppCreatedObject)
{
    return Proc55A345846D53FC406B1E062190CCBFF1(pRuntimeInstance, pThread, pInstructionAddress, pName, Code, ProcessingStage, ConflictingInstructionAddress, ConflictingThreadGlobalIndex, ppCreatedObject);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription::Release(Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription* pItem)
{
    return Proc5685DA4F5C12B2EFEE7911100FE853C7(pItem);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd** ppCreatedObject)
{
    return Proc59332EB271778BB3304504B24A36496A(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAmpAdjustBufferTag::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAmpAdjustBufferTag** ppCreatedObject)
{
    return Proc7AC349E33ACBF2C7B296609A50B19D40(ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry::CatchBlocks()
{
    return this->m_pCatchBlocks;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock*>* pCatchBlocks, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry** ppCreatedObject)
{
    return ProcF71648263D0EBB6AB423F469F8345896(pCatchBlocks, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd** ppCreatedObject)
{
    return Proc274F93BAEC7EDA11FB3D8D31398F3E66(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::Create(UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead** ppCreatedObject)
{
    return ProcE164CFE08792BADA3AFC457FC373E7CD(BitPosition, NumBits, Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::Create(UINT32 ByteOffset, UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes** ppCreatedObject)
{
    return Proc3CC641081A4F8E38DBA8B9D7F910E648(ByteOffset, BitPosition, NumBits, Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite::Create(UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite** ppCreatedObject)
{
    return ProcC88C854EE79528CEF5806D3E9A5AAD3E(BitPosition, NumBits, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::Create(UINT32 ByteOffset, UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes** ppCreatedObject)
{
    return ProcC065B509F9ABC0BAC4BBD770D73E7FEB(ByteOffset, BitPosition, NumBits, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot** ppCreatedObject)
{
    return ProcFD8A3508ABF025DFCBF615679CA43098(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr** ppCreatedObject)
{
    return Proc67294CD5516F29DD623A0335B01E2B2D(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft** ppCreatedObject)
{
    return ProcF28A7C520914A2C602F64AC12940AEDD(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight** ppCreatedObject)
{
    return ProcB1F5C35BB7205E5859519C63CAB11717(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor** ppCreatedObject)
{
    return ProcF7DC8A9B604DB7991F313B300879DB14(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock::ErrorCode()
{
    return this->m_ErrorCode;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e ErrorCode, UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock** ppCreatedObject)
{
    return Proc513A853ACBA57C6224E96AFED178B6FC(ErrorCode, Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual** ppCreatedObject)
{
    return Proc7F719CBB10CD5D871FFE04E029F3DB2E(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan** ppCreatedObject)
{
    return ProcF61679F72873B9BAE44FF902F92DDDCC(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual** ppCreatedObject)
{
    return Proc42D2B23BCA47F96E95181509DEC12952(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan** ppCreatedObject)
{
    return Proc651C8C57EB784CC5D51DA3D9F911EC27(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual** ppCreatedObject)
{
    return Proc5F637D126578416C0D844318F488E927(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual** ppCreatedObject)
{
    return Proc4C34599EEC6D0C6D02539A6CE0D3F759(Type, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverridePart()
{
    return this->m_pThreadOverride;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::StackFrame()
{
    return this->m_pStackFrame;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride* pThreadOverride, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext** ppCreatedObject)
{
    return ProcA18DDACFF36E48D6F0D56719700A0A68(pStackFrame, pThreadOverride, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert::OriginalType()
{
    return this->m_OriginalType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert::TargetType()
{
    return this->m_TargetType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e OriginalType, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e TargetType, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert** ppCreatedObject)
{
    return Proc9F997DC1F7AF29677A4047813E08FDCB(OriginalType, TargetType, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide** ppCreatedObject)
{
    return ProcF41F3F1AB2ABAEF7FFBC76C3B591E7F9(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDuplicateTop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDuplicateTop** ppCreatedObject)
{
    return ProcC1CC800269002F7E3A1DA22DF715FE41(ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEndTry::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEndTry** ppCreatedObject)
{
    return Proc5C9051E01C0BD1E2540034FD47353BE5(ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::ResultBytes()
{
    return this->m_pResultBytes;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pResultBytes, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult** ppCreatedObject)
{
    return ProcA2F8C324E55FE9F51080FF9117FD8A9C(SourceId, pResultBytes, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::ArgumentCount()
{
    return this->m_ArgumentCount;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::ReturnValueSize()
{
    return this->m_ReturnValueSize;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCallingConvention::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::CallingConvention()
{
    return this->m_CallingConvention;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::Flags()
{
    return this->m_Flags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::ArgumentFlags()
{
    return this->m_pArgumentFlags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::UniformComplexReturnElementSize()
{
    return this->m_UniformComplexReturnElementSize;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::Create(UINT32 ArgumentCount, UINT32 ReturnValueSize, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCallingConvention::e CallingConvention, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationArgumentFlags::e>* pArgumentFlags, UINT32 UniformComplexReturnElementSize, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction** ppCreatedObject)
{
    return Proc6E64A892D574E60D055678E92E919AB5(ArgumentCount, ReturnValueSize, CallingConvention, Flags, pArgumentFlags, UniformComplexReturnElementSize, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::SourceId()
{
    return this->m_SourceId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::LanguageId()
{
    return this->m_LanguageId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::ArgumentCount()
{
    return this->m_ArgumentCount;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Subroutines()
{
    return this->m_pSubroutines;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Create(const GUID& SourceId, const GUID& LanguageId, UINT32 Id, UINT32 ArgumentCount, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* pSubroutines, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic** ppCreatedObject)
{
    return ProcBBA18CD27180C60E9E997C0A6FE75438(SourceId, LanguageId, Id, ArgumentCount, pSubroutines, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Execute(Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>& Arguments, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* pSubroutines, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e* pFailureReason)
{
    return Proc97F5838B80CF47DFBB5C7A66C074A06E(this, pILContext, Arguments, pSubroutines, pResults, pFailureReason);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes::Offset()
{
    return this->m_Offset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes::Length()
{
    return this->m_Length;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes::Create(UINT32 Offset, UINT32 Length, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes** ppCreatedObject)
{
    return ProcB3E3D0B3952EE50F42598DF26DF31016(Offset, Length, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::RegisterIndex()
{
    return this->m_RegisterIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::BytesToRead()
{
    return this->m_BytesToRead;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::Create(CV_HREG_e RegisterId, UINT32 RegisterIndex, UINT32 BytesToRead, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead** ppCreatedObject)
{
    return ProcEF0A249A2437F16F1944B917B7FD8CB2(RegisterId, RegisterIndex, BytesToRead, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId::GroupIdComponents()
{
    return this->m_GroupIdComponents;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId::Create(Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents::e GroupIdComponents, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId** ppCreatedObject)
{
    return Proc85D3C05E777E3DDC1C1378AC47BC997D(GroupIdComponents, ppCreatedObject);
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::UseDispatchId()
{
    return this->m_UseDispatchId;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::UseFlatModel()
{
    return this->m_UseFlatModel;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::ThreadIdComponents()
{
    return this->m_ThreadIdComponents;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::Create(bool UseDispatchId, bool UseFlatModel, Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents::e ThreadIdComponents, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId** ppCreatedObject)
{
    return ProcFD5E9535C1990A0F26896BACBB2E116E(UseDispatchId, UseFlatModel, ThreadIdComponents, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::RegisterIndex()
{
    return this->m_RegisterIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::BytesToRead()
{
    return this->m_BytesToRead;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::VectorElements()
{
    return this->m_VectorElements;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::Create(CV_HREG_e RegisterId, UINT32 RegisterIndex, UINT32 ByteOffset, UINT32 BytesToRead, UINT32 VectorElements, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead** ppCreatedObject)
{
    return Proc9D1082BBE4C79FA90A9A6DB49A461250(RegisterId, RegisterIndex, ByteOffset, BytesToRead, VectorElements, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::RegisterIndex()
{
    return this->m_RegisterIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::BytesToRead()
{
    return this->m_BytesToRead;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::FirstElement()
{
    return this->m_FirstElement;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::VectorElements()
{
    return this->m_VectorElements;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::Create(CV_HREG_e RegisterId, UINT32 RegisterIndex, UINT32 ByteOffset, UINT32 BytesToRead, UINT32 FirstElement, UINT32 VectorElements, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead** ppCreatedObject)
{
    return Proc0E7C3B425A75C063D8423649080FECF2(RegisterId, RegisterIndex, ByteOffset, BytesToRead, FirstElement, VectorElements, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse** ppCreatedObject)
{
    return Proc54CE95E6EDCFE52433F058A2FCD32205(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue** ppCreatedObject)
{
    return ProcE724C2C7F8598586BC2AE84E232C2A4B(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump::Create(UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump** ppCreatedObject)
{
    return ProcFFB2CBC90C25CF40C1EC0ADEF943DD21(Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse::Create(UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse** ppCreatedObject)
{
    return Proc2A6EFECEEC08A414F708C9237A23820A(Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue::Create(UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue** ppCreatedObject)
{
    return ProcFA7E1E2E0DFF33CDC7B49FE9A2BF2A22(Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad::Create(UINT32 Index, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad** ppCreatedObject)
{
    return ProcBB0D564A3653A0A30F1FC72C203C9C15(Index, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead::Create(UINT32 Size, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e Flags, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead** ppCreatedObject)
{
    return Proc52F772C3D63AAE4A52633DD19BFDC964(Size, Flags, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::CharacterSize()
{
    return this->m_CharacterSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::MaxCharacters()
{
    return this->m_MaxCharacters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::Create(Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e Flags, UINT16 CharacterSize, UINT32 MaxCharacters, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead** ppCreatedObject)
{
    return ProcDA48987D0C3B6A7E18E3AC29CAAD314D(Flags, CharacterSize, MaxCharacters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryWrite::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryWrite** ppCreatedObject)
{
    return Proc61C52246DE45479B72BA6997F2B2A8F1(ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply** ppCreatedObject)
{
    return Proc401CC9B272AC84D4FD02EB44812606BA(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILNop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILNop** ppCreatedObject)
{
    return Proc45F2C6048794F68C28A16C1614F4F4EA(ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::LocalIndex()
{
    return this->m_LocalIndex;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::ValueBytes()
{
    return this->m_pValueBytes;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::Create(UINT32 LocalIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValueBytes, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue** ppCreatedObject)
{
    return ProcFD4EE301C59FC0351D8CF4431CBC623B(LocalIndex, pValueBytes, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection::Parameters()
{
    return this->m_pParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection** ppCreatedObject)
{
    return Proc9DF1C12E7E667FAA07405E2EB93A3FA5(pParameters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPop** ppCreatedObject)
{
    return Proc1DC79D92A0938AE9690076CE9323DAC7(ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant** ppCreatedObject)
{
    return ProcE4F5DD31DD2BC1EDC34C6E1135328142(pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead::Create(CV_HREG_e RegisterId, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead** ppCreatedObject)
{
    return Proc58B9915C02C6BE805485E625EBF9C530(RegisterId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite::Create(CV_HREG_e RegisterId, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite** ppCreatedObject)
{
    return ProcDCC91AD8A2E048D1EA602989BF72949C(RegisterId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder** ppCreatedObject)
{
    return ProcF5C9FC936A5A04CE6DF00B7345A7E8CA(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILReturnTop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILReturnTop** ppCreatedObject)
{
    return ProcF3C1D5377032837C2404235250E0B451(ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave::Create(UINT32 Index, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave** ppCreatedObject)
{
    return ProcD8B6F020C004300F488AA5F72045BC59(Index, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSetBytesRegion::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSetBytesRegion** ppCreatedObject)
{
    return Proc256DC5FA8167A7B12392751E76AD665A(ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType::e Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract** ppCreatedObject)
{
    return ProcB74FE600C741C9E0EA9A5EB02EC32244(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow::FailureCode()
{
    return this->m_FailureCode;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e FailureCode, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow** ppCreatedObject)
{
    return ProcDC178BD53797D38351843A49AAE130A1(FailureCode, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILTlsGetValue::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILTlsGetValue** ppCreatedObject)
{
    return ProcDDCD8B82D3B57686F096172A6C076243(ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::InspectionSession()
{
    return this->m_pInspectionSession;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Timeout()
{
    return this->m_Timeout;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluationFlags()
{
    return this->m_EvaluationFlags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::FuncEvalFlags()
{
    return this->m_FuncEvalFlags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Radix()
{
    return this->m_Radix;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Language()
{
    return this->m_pLanguage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::ReturnValue()
{
    return this->m_pReturnValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::AdditionalVisualizationData()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAdditionalVisualizationData;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::AdditionalVisualizationDataPriority()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->AdditionalVisualizationDataPriority;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e EvaluationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e FuncEvalFlags, UINT32 Radix, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pReturnValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext** ppCreatedObject)
{
    return Proc3E44E2254CE4725B5E4A486A9B526329(pInspectionSession, pRuntimeInstance, pThread, Timeout, EvaluationFlags, FuncEvalFlags, Radix, pLanguage, pReturnValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e EvaluationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e FuncEvalFlags, UINT32 Radix, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pReturnValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData* pAdditionalVisualizationData, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority::e AdditionalVisualizationDataPriority, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext** ppCreatedObject)
{
    return Proc1B8F796B6C622B33C8D151185C0D2B9C(pInspectionSession, pRuntimeInstance, pThread, Timeout, EvaluationFlags, FuncEvalFlags, Radix, pLanguage, pReturnValue, pAdditionalVisualizationData, AdditionalVisualizationDataPriority, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateExpressionOnThreads(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreads, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>* pCompletionRoutine)
{
    return Proc086780F7AB96BE98E973B6DADFEEC905(this, pWorkList, pThreads, pStackFrame, pExpression, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateExpression(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateExpressionAsyncResult>* pCompletionRoutine)
{
    return ProcF7531579429F4DBD3A2C1DEED15F6A9B(this, pWorkList, pExpression, pStackFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameLocals(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameLocalsAsyncResult>* pCompletionRoutine)
{
    return Proc22DAB17B5E419C4DFC5198EFBCADBC18(this, pWorkList, pStackFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameArguments(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameArgumentsAsyncResult>* pCompletionRoutine)
{
    return ProcCEB972D13FE445A9D304AD753C757552(this, pWorkList, pFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameName(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags::e ArgumentFlags, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameNameAsyncResult>* pCompletionRoutine)
{
    return Proc44DBDEA6AB474E8EB67B5F2348EDCC20(this, pWorkList, pFrame, ArgumentFlags, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameReturnType(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameReturnTypeAsyncResult>* pCompletionRoutine)
{
    return Proc281BD02CCE55B2A58FC2C8301699BF33(this, pWorkList, pFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateReturnValue(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pRawReturnValue, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateReturnValueAsyncResult>* pCompletionRoutine)
{
    return Proc8100E1C553B1AE153B3AEF9DAE275F33(this, pWorkList, pStackFrame, pRawReturnValue, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::Close()
{
    return Proc2DCEF64A20FA074BCCA5B25B25800DEC(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession** ppCreatedObject)
{
    return Proc094F295F322424992BB5E795A7035884(pProcess, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::AppPackageId()
{
    return this->m_pAppPackageId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::DisplayName()
{
    return this->m_pDisplayName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::Version()
{
    return this->m_pVersion;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::LogoPath()
{
    return this->m_pLogoPath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::Applications()
{
    return this->m_pApplications;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::DkmString* pDisplayName, Microsoft::VisualStudio::Debugger::DkmString* pVersion, Microsoft::VisualStudio::Debugger::DkmString* pLogoPath, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo*>* pApplications, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo** ppCreatedObject)
{
    return Proc2EA0223CA2C28FD2A44B1ABE5EAA38E6(pAppPackageId, pDisplayName, pVersion, pLogoPath, pApplications, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::AppUserModelId()
{
    return this->m_pAppUserModelId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::DisplayName()
{
    return this->m_pDisplayName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::Executable()
{
    return this->m_pExecutable;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::SmallLogoPath()
{
    return this->m_pSmallLogoPath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::BackgroundColor()
{
    return this->m_pBackgroundColor;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::Description()
{
    return this->m_pDescription;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::DefaultDebugEngine()
{
    return this->m_DefaultDebugEngine;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pAppUserModelId, Microsoft::VisualStudio::Debugger::DkmString* pDisplayName, Microsoft::VisualStudio::Debugger::DkmString* pExecutable, Microsoft::VisualStudio::Debugger::DkmString* pSmallLogoPath, Microsoft::VisualStudio::Debugger::DkmString* pBackgroundColor, Microsoft::VisualStudio::Debugger::DkmString* pDescription, const GUID& DefaultDebugEngine, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo** ppCreatedObject)
{
    return Proc5C4A41F2572CF238937F847AC2A3B828(pAppUserModelId, pDisplayName, pExecutable, pSmallLogoPath, pBackgroundColor, pDescription, DefaultDebugEngine, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstructionPart()
{
    return this->m_pCPUInstruction;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::ModuleInstance()
{
    return this->m_pModuleInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::GetSymbol(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol** ppSymbol)
{
    return Proc2063EA8A5827C04D2BF6A7BA85E27556(this, ppSymbol);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CompareTo(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pOther, INT32* pResult)
{
    return Proc94A165B2D7D457C800C0044AEE4DF1CB(this, pOther, pResult);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::IsInSameFunction(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pOther, bool* pResult)
{
    return ProcCAA57817DCAB36FA6857F059CC28E22C(this, pOther, pResult);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::GetCurrentCPUAddress(Microsoft::VisualStudio::Debugger::DkmArray<UINT64>* pInstructionPointers)
{
    return Proc52D25C4E1682ABDE2CA361EA4457EC20(this, pInstructionPointers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::GetCurrentCPUAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetCurrentCPUAddressAsyncResult>* pCompletionRoutine)
{
    return ProcACB1ED9131E740FA3BE29B6308FECCB2(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::IsUserCode(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsUserCodeAsyncResult>* pCompletionRoutine)
{
    return Proc9B7FAC38CDD9E0656EF668FB4B062428(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::Module()
{
    return this->m_pModule;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::RuntimeType()
{
    return this->m_RuntimeType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::Bind(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddress)
{
    return ProcAC852ACB3B15D4C2B177E7AA9ED66C3F(this, pModuleInstance, ppAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetGPUInstructionMetadataCallback(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol* pNextInstruction, Microsoft::VisualStudio::Debugger::GPU::DkmGPUAddressType::e* pMetadata)
{
    return Proc31D347AE67B44CCB5C5B5025DAC7D49F(this, pInstructionAddress, pNextInstruction, pMetadata);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetNoSourceRanges(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>* pRanges)
{
    return Proc862FD79FBD0E048B914012C907E6262E(this, pRanges);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetUserCodeSourcePositionCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return ProcBDD11793EA51E5D4A4A47BB5D6AF1606(this, pInspectionSession, ppSourcePosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetUserCodeSourcePositionCallback(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetUserCodeSourcePositionCallbackAsyncResult>* pCompletionRoutine)
{
    return ProcC8D8FC52CDB2195F51CF25F6E35EF5FB(this, pWorkList, pInspectionSession, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetDisassemblyLabel(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmString** ppLabel)
{
    return Proc11B96E95076AEBD19435335693648C9F(this, pInspectionSession, ppLabel);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetCompilerId(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId* pCompilerId)
{
    return Proc25C283D1FA9B4F1F3979BA9CA8917013(this, pInspectionSession, pCompilerId);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::IsHiddenCode(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsHiddenCodeAsyncResult>* pCompletionRoutine)
{
    return ProcA273139AC02E5BE47E4FAD7C165037C1(this, pWorkList, pInspectionSession, pInstructionAddress, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSteppingRanges(Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRangeBoundary::e RangeBoundary, bool IncludeInline, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>* pRanges)
{
    return ProcE3287B6AD1874438A4638A94F83D8907(this, RangeBoundary, IncludeInline, pRanges);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::HasLineInfo(bool* pResult)
{
    return Proc23E28172B8ED4C1CF1065854ACDA6236(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::HasLineInfo(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmHasLineInfoAsyncResult>* pCompletionRoutine)
{
    return ProcEECEDA2F659A9B7F31A4E9CEBAF928D5(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetCurrentStatementRange(Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange* pResult)
{
    return Proc312C43C3EBD40AA19100FC0BE9A909AB(this, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePosition(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, bool* pStartOfLine, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return Proc74625D16DFFBC0BBB0B76F58AC775415(this, Flags, pInspectionSession, pStartOfLine, ppSourcePosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePosition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionAsyncResult>* pCompletionRoutine)
{
    return ProcF1DC26DBD878FEE1EC011A3321EF806F(this, pWorkList, Flags, pInspectionSession, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePositionCallback(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, bool* pStartOfLine, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return Proc93764ECF9C2251D624F78B0CE24C436C(this, Flags, pInspectionSession, pStartOfLine, ppSourcePosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePositionCallback(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags::e Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionCallbackAsyncResult>* pCompletionRoutine)
{
    return Proc04DEBA8C7D7338ACBE9E489F5CDDEEC3(this, pWorkList, Flags, pInspectionSession, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& Id, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage** ppCreatedObject)
{
    return Proc456FB60B9E4993FCB92B225C95A1B152(pName, Id, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::GetLanguageSettings(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting*>* pSettings)
{
    return Proc59530E264B592B0BFF5FDCD149513A30(this, pSettings);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::GetLanguageSettings(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetLanguageSettingsAsyncResult>* pCompletionRoutine)
{
    return ProcF1D4F60E91C176CB2494DD14B47089A1(this, pWorkList, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Language()
{
    return this->m_pLanguage;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompilationFlags()
{
    return this->m_CompilationFlags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Text()
{
    return this->m_pText;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Close()
{
    return ProcD69DC66A57C38CA4CAB503AEA3C31D11(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags::e CompilationFlags, Microsoft::VisualStudio::Debugger::DkmString* pText, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression** ppCreatedObject)
{
    return Proc8CE02648478ABDF8A3F6F73CE84429FA(pLanguage, CompilationFlags, pText, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Language()
{
    return this->m_pLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Address()
{
    return this->m_pAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::RuntimeInstance()
{
    return this->m_pAddress->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress** ppCreatedObject)
{
    return Proc425C8315F654ADA55907101C9C65A89A(pLanguage, pAddress, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Compile(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult** ppError)
{
    return Proc9EACD04F3FD1CA479AF6A3CE86B9E9FA(this, pExpression, ppError);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::CompileCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc4A691C7F7E4EA945A06F4071763491F1(this, pCondition, ppCompiledCondition, ppErrorText);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::GetMethodName(Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags::e ArgumentFlags, Microsoft::VisualStudio::Debugger::DkmString** ppMethodName)
{
    return Proc02B8A45DC663391C88C64FF8F16423AE(this, ArgumentFlags, ppMethodName);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::GetStepIntoFlags(Microsoft::VisualStudio::Debugger::Stepping::DkmLanguageStepIntoFlags::e* pStepIntoFlags)
{
    return Proc6217600D01C4D2ECBE61829AFD936139(this, pStepIntoFlags);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting** ppCreatedObject)
{
    return Proc68AD630132C16798EB187E26E4B8E18B(pName, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& other) const
{
    return Proc19F3BC72A701F59F6D869826B65D2C66(*this, other);
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Connection()
{
    return this->m_pConnection;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::FindModule(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& Id, Microsoft::VisualStudio::Debugger::Symbols::DkmModule** ppModule)
{
    return Proc5291958220F6BA230E62F74538F8E025(Id, ppModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetModules(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmModule*>* pModules)
{
    return Proc8CBFCEEC88661ADC3F294DFCA4AF14BD(pModules);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Create(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& Id, Microsoft::VisualStudio::Debugger::DkmString* pName, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Symbols::DkmModule** ppCreatedObject)
{
    return ProcD60BA609E5572E71FE7454972F0CC2FE(Id, pName, CompilerId, pConnection, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetScriptDocuments(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>* pScriptDocuments)
{
    return Proc1893989E63FB4502D761835AA167574F(this, pScriptDocuments);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreData(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>* pScopes)
{
    return Proc787E6277F93875EC906A2F61947281D1(this, MethodId, pScopes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreData(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataAsyncResult>* pCompletionRoutine)
{
    return Proc0F050A725D2A1A68D6AEA249072A74CA(this, pWorkList, MethodId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetFirstMethodInFirstDocument(Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId* pMethod)
{
    return ProcBBBD87DA3F9E7D240B27461DD59C7F82(this, pMethod);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreDataPreRemap(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32* pRemapToken, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>* pScopes)
{
    return ProcAB14A3D49AB97EEE5634A0BE1114A8DB(this, MethodId, pRemapToken, pScopes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreDataPreRemap(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataPreRemapAsyncResult>* pCompletionRoutine)
{
    return ProcFA4AE503D69BFA42C4969ADBDC1209A3(this, pWorkList, MethodId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetTokenSymbolStoreAttribute(UINT32 ParentToken, bool IsPreRemap, Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pData)
{
    return ProcD01D70ACAE8430CBB07B5F422017B9D6(this, ParentToken, IsPreRemap, pAttributeName, pData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetTokenSymbolStoreAttribute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 ParentToken, bool IsPreRemap, Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetTokenSymbolStoreAttributeAsyncResult>* pCompletionRoutine)
{
    return ProcA0F5CAEEAAB4BB662F0A035412F7BBC6(this, pWorkList, ParentToken, IsPreRemap, pAttributeName, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::TranslateAcceleratorTagByIP(UINT32 InputTag, UINT32 InstructionPointer, UINT32* pRegisterType, UINT32* pRegisterIndex, UINT32* pFirstElement, UINT32* pVectorElements, UINT32* pByteOffset, UINT32* pVectorElementSize)
{
    return ProcD04C7DFC744864F9E28B48FDE7FC2E93(this, InputTag, InstructionPointer, pRegisterType, pRegisterIndex, pFirstElement, pVectorElements, pByteOffset, pVectorElementSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetCompilerOptions(Microsoft::VisualStudio::Debugger::DkmString** ppCompilerOptions)
{
    return Proc1FA09A66CFC6C30956FDF9F38B06E31F(this, ppCompilerOptions);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::TranslateAcceleratorTagByRva(UINT32 InputTag, UINT32 Rva, UINT32* pRegisterType, UINT32* pRegisterIndex, UINT32* pFirstElement, UINT32* pVectorElements, UINT32* pByteOffset, UINT32* pVectorElementSize)
{
    return Proc09E6E2514FF654881B54EB0150C7AC32(this, InputTag, Rva, pRegisterType, pRegisterIndex, pFirstElement, pVectorElements, pByteOffset, pVectorElementSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::IsValidAcceleratorTag(UINT32 InputTag, UINT32 Rva, bool* pIsValid)
{
    return Proc8C41A92D8B47ABE0375B9D7756FD489D(this, InputTag, Rva, pIsValid);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetPointerToHLSLRegister(CV_HREG_e RegisterType, UINT32 RegisterIndex, UINT32 FirstElement, UINT32 VectorElements, UINT32 ByteOffset, UINT32 VectorElementSize, UINT32 Rva, UINT32 StartLiveRange, UINT32 EndLiveRange, UINT64* pAddress, bool* pIsNewDynamicTag)
{
    return Proc5F33BB9A16D050DC6A11F8D02254B011(this, RegisterType, RegisterIndex, FirstElement, VectorElements, ByteOffset, VectorElementSize, Rva, StartLiveRange, EndLiveRange, pAddress, pIsNewDynamicTag);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::SetPointerToHLSLRegister(UINT64 Address, CV_HREG_e RegisterType, UINT32 RegisterIndex, UINT32 FirstElement, UINT32 VectorElements, UINT32 ByteOffset, UINT32 VectorElementSize, UINT32 StartLiveRange, UINT32 EndLiveRange)
{
    return Proc9DF311E58282BDB725263E4F8096A4C5(this, Address, RegisterType, RegisterIndex, FirstElement, VectorElements, ByteOffset, VectorElementSize, StartLiveRange, EndLiveRange);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetAcceleratorTagTableSize(UINT32* pSize, UINT32* pSizeOfForwardedTags)
{
    return Proc4621B3FD8E354DF3C09CD7AF4EFA6890(this, pSize, pSizeOfForwardedTags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetInstructionOffsetForRva(UINT32 RVA, UINT32* pInstructionOffset)
{
    return Proc5134BC888343F0CBDC3CFF37F53CE11F(this, RVA, pInstructionOffset);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pModules)
{
    return Proc101685421B67B01CA3E0DB5E650B022E(this, pModules);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::UndecorateName(Microsoft::VisualStudio::Debugger::DkmString* pDecoratedName, UINT32 Options, Microsoft::VisualStudio::Debugger::DkmString** ppUndecoratedName)
{
    return ProcE94B97BDA30ADC68B86021B4E04E88B9(this, pDecoratedName, Options, ppUndecoratedName);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetPublicSymbolByNameCallback(Microsoft::VisualStudio::Debugger::DkmString* pPublicName, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol** ppAddress)
{
    return ProcB78DCC1D97D2784074F1B8AD23A79A8D(this, pPublicName, ppAddress);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetSourceServerData(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pStreamData)
{
    return Proc6F7D7F50E471D11AD110BF84C52571CC(this, pModuleInstance, pStreamData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::FindDocuments(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*>* pDocuments)
{
    return ProcCCBBBEED8A02B87E7A41F8504E31545E(this, pSourceFileId, pDocuments);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::FindDocuments(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindDocumentsAsyncResult>* pCompletionRoutine)
{
    return Proc203BC1170806E54DBAAF1B3530F58C16(this, pWorkList, pSourceFileId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetSymbolFilePath(Microsoft::VisualStudio::Debugger::DkmString** ppFilePath)
{
    return Proc63D01FE35215A6F186CDAAF3981ECB78(this, ppFilePath);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetEntryPointSymbols(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>* pPossibleEntryPoints)
{
    return ProcD1DA8568A04474B5C880F261EDF65D23(this, pPossibleEntryPoints);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetFunctionInfo(Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmRVASizePair>* pResults)
{
    return ProcB3AE544A716277EBD21AB3A79E73A97D(this, pFunctionName, pResults);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetFunctionInfo(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetFunctionInfoAsyncResult>* pCompletionRoutine)
{
    return Proc8BFB1F00FB320ADA9A2FD47EB5E00505(this, pWorkList, pFunctionName, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetSymbolInterface(const GUID& InterfaceID, IUnknown** ppSymbolInterface)
{
    return ProcF1B19E03C0D1B1CB1DFED383F9D9A51C(this, InterfaceID, ppSymbolInterface);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& other) const
{
    return Proc1B02BC6A77ED80B4C26F62A6EA215225(*this, other);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfoPart()
{
    return this->m_pMinidumpInfo;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TimeDateStamp()
{
    return this->m_TimeDateStamp;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleVersion* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Version()
{
    return this->m_pVersion;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::SymbolFileId()
{
    return this->m_pSymbolFileId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::MemoryLayout()
{
    return this->m_MemoryLayout;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::BaseAddress()
{
    return this->m_BaseAddress;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::LoadOrder()
{
    return this->m_LoadOrder;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Size()
{
    return this->m_Size;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::LoadContext()
{
    return this->m_pLoadContext;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Process()
{
    return this->m_pRuntimeInstance->Process();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Connection()
{
    return this->m_pRuntimeInstance->Connection();
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsDisabled()
{
    return this->m_IsDisabled;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetModule(_Deref_out_opt_ Microsoft::VisualStudio::Debugger::Symbols::DkmModule** ppValue)
{
    return Get645AD40C25493913B4F735C441506A16(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::SetDisabled(bool IsDisabled)
{
    return ProcEC7B013CEB23AA93633EDBA7FAB549B1(this, IsDisabled);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetGPUDisassembly(UINT64 Address, UINT32 Count, bool IsForward, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pDisassembly, bool* pIsEnd)
{
    return ProcA2068CD9D703B7D4CE4B42E82A5C761E(this, Address, Count, IsForward, pDisassembly, pIsEnd);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetGPUDisassemblySize(UINT64* pSize)
{
    return Proc07E9A8763D0D6AD6ACDBED6ED0AFEC7A(this, pSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetNextGPUInstructionAddress(UINT64 StartAddress, UINT64* pNextAddress)
{
    return Proc5CE38E6CF8E905E0A2FDD562AE2B9F6F(this, StartAddress, pNextAddress);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnSymbolsLoaded(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, bool IsReload)
{
    return Proc00D734DD81ACDC01605A9CFD79A152DD(this, pModule, IsReload);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::SetModule(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, bool IsReload)
{
    return ProcA2A87FA9B2EABE057C973454C4D0E0FE(this, pModule, IsReload);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::FlagAsTransitionModule()
{
    return Proc5A1A29171D03FC392A4795717141E0C3(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::ClearTransitionModuleFlag()
{
    return Proc1880B774E3CEB4FFE43F3E5FFFFFC505(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsTransitionModule(bool* pResult)
{
    return Proc4B179835811F44DCE0F243F176717948(this, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TryLoadBinary()
{
    return Proc0B9652121F6BC866281A1E15F8B76330(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TryLoadSymbols()
{
    return Proc34893D26C250199161E3A453FFEEF918(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetSymbolStatusMessage(bool ExcludeCommonErrors, Microsoft::VisualStudio::Debugger::DkmString** ppStatus)
{
    return ProcE57162D15B9C4A9B50CAF4AF489C894F(this, ExcludeCommonErrors, ppStatus);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetSymbolLoadInformation(Microsoft::VisualStudio::Debugger::DkmString** ppDescription)
{
    return ProcC2B6CE7C926FEA8B7BB1737D6705C84C(this, ppDescription);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::ReadSymbols(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppSymbolBuffer)
{
    return Proc5411B0DDBEF94775850CBFCCE24FDAA0(this, ppSymbolBuffer);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Unload()
{
    return Proc1DF3FBE6FE204B1CB87244F8FE368C24(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnSymbolsUpdated(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule)
{
    return Proc7C740EFAED2FCAE33007EF4EB2BCA3CF(this, pModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnBinaryLoaded(Microsoft::VisualStudio::Debugger::DkmString* pPath)
{
    return Proc3FCE740432071F95E811C82C437CB8D0(this, pPath);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsUserCode(bool* pIsUserCode)
{
    return ProcF386FCA16584C1EAE2CEB33B55A36BA3(this, pIsUserCode);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::FileVersionString()
{
    return this->m_pFileVersionString;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::CompanyName()
{
    return this->m_pCompanyName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::FileVersionMS()
{
    return this->m_FileVersionMS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::FileVersionLS()
{
    return this->m_FileVersionLS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::ProductVersionMS()
{
    return this->m_ProductVersionMS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::ProductVersionLS()
{
    return this->m_ProductVersionLS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::VersionFlags()
{
    return this->m_VersionFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileVersionString, Microsoft::VisualStudio::Debugger::DkmString* pCompanyName, UINT32 FileVersionMS, UINT32 FileVersionLS, UINT32 ProductVersionMS, UINT32 ProductVersionLS, UINT32 VersionFlags, Microsoft::VisualStudio::Debugger::DkmModuleVersion** ppCreatedObject)
{
    return Proc2717980A0CDDDFF0805419095281221C(pFileVersionString, pCompanyName, FileVersionMS, FileVersionLS, ProductVersionMS, ProductVersionLS, VersionFlags, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::ThreadContext()
{
    return this->m_pThreadContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Close()
{
    return ProcDC7ED1E90FA2A6178BEA83BB0A11B501(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext** ppCreatedObject)
{
    return ProcA29A9B6A00CD4E346ACD54992947A817(pRuntimeInstance, pThread, pThreadContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Initialize(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize)
{
    return Proc2D82CAC96183DD7B6D1DF3394318FC27(this, pRegisters, StackRangeSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::UpdatePosition(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize)
{
    return Proc8A1248C3A4D0B316E04BDEB5C39F281A(this, pRegisters, StackRangeSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::WalkNextFrame(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult* pResult)
{
    return Proc35BF8659E4F78CFC4EDCF9F8C35DCF25(this, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult::Release(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult* pItem)
{
    return ProcF077EF6B9A532BB38F440A3E41457FEE(pItem);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::AddressType()
{
    return this->m_AddressType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressStepType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::StepType()
{
    return this->m_StepType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::AddressTypeLength()
{
    return this->m_AddressTypeLength;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::Create(Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressType::e AddressType, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressStepType::e StepType, UINT32 AddressTypeLength, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata** ppCreatedObject)
{
    return Proc3CC4BB810E58E0616B44FC6441DB2E43(AddressType, StepType, AddressTypeLength, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*>(DkmInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*>(DkmInstructionAddress::ModuleInstance());
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::RVA()
{
    return this->m_RVA;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::Create(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance* pModuleInstance, UINT32 RVA, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress** ppCreatedObject)
{
    return Proc1EA107D7E0BFF457B5E6A661C838536A(pRuntimeInstance, pModuleInstance, RVA, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::FindNearestExport(Microsoft::VisualStudio::Debugger::DkmString** ppExportName, INT32* pByteOffset)
{
    return Proc918993F014B90FB01D72E7053BB1AAF2(this, ppExportName, pByteOffset);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::FindNearestExport(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindNearestExportAsyncResult>* pCompletionRoutine)
{
    return Proc60E84CC95C998F0AD7E7E519F0209668(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::GetSteppingCallSites(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>& SteppingRanges, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite*>* pCallSites)
{
    return Proc44EADD160F31BE6B3796FA9A467F646C(this, SteppingRanges, pCallSites);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::RVA()
{
    return this->m_RVA;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, UINT32 RVA, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol** ppCreatedObject)
{
    return Proc62D0A91244300EC2F3874A30E936DF26(pModule, RVA, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::GetNativeInstructionMetadataCallback(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata** ppMetadata)
{
    return ProcA5DB4FF28172AC8EE337B4F616F0D8FC(this, pInstructionAddress, ppMetadata);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*>(DkmModuleInstance::RuntimeInstance());
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::BaseAddress()
{
    return static_cast<UINT64>(DkmModuleInstance::BaseAddress());
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::Size()
{
    return static_cast<UINT32>(DkmModuleInstance::Size());
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrHeaderStatus::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::ClrHeaderStatus()
{
    return this->m_ClrHeaderStatus;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout::e MemoryLayout, UINT32 LoadOrder, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* pRuntimeInstance, UINT64 BaseAddress, UINT32 Size, Microsoft::VisualStudio::Debugger::Clr::DkmClrHeaderStatus::e ClrHeaderStatus, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppCreatedObject)
{
    return ProcB8D112804ACF0EF98486C2DBE47F5860(pName, pFullName, TimeDateStamp, pVersion, pSymbolFileId, Flags, MemoryLayout, LoadOrder, pLoadContext, pRuntimeInstance, BaseAddress, Size, ClrHeaderStatus, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::GetFunctionTableEntry(UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppEntry)
{
    return Proc7C33005073B197E468D344B6CC30046F(this, Address, ppEntry);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::FindExportName(Microsoft::VisualStudio::Debugger::DkmString* pName, bool IgnoreDataExports, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress** ppAddress)
{
    return Proc88303C178160F6B7A48F74A2AE8D50B5(this, pName, IgnoreDataExports, ppAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::FindExportName(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pName, bool IgnoreDataExports, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindExportNameAsyncResult>* pCompletionRoutine)
{
    return Proc80A9F462958D3BF363A4E3F18DB01E46(this, pWorkList, pName, IgnoreDataExports, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue::Registers()
{
    return this->m_pRegisters;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue::Memory()
{
    return this->m_pMemory;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue::Create(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pReturnFrom, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister*>* pRegisters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pMemory, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue** ppCreatedObject)
{
    return ProcC6565F2B8739BF2909221336A3BBE9C6(pReturnFrom, pRegisters, pMemory, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister::Identifier()
{
    return this->m_Identifier;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister::Create(CV_HREG_e Identifier, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister** ppCreatedObject)
{
    return Proc12B8AEBDE8DC06ECC146022EFDF43BA0(Identifier, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance** ppCreatedObject)
{
    return Proc0C813EFC4A612A8F0E0975C93D9CA8B2(pProcess, Id, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance** ppCreatedObject)
{
    return ProcACB567FCFFFF620887A60A7FEDA08D1F(pProcess, Id, Capabilities, pParentRuntime, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::FindNativeModuleInstance(UINT64 BaseAddress, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppNativeModuleInstance)
{
    return Proc32F748045CAE5D710346099F66C76CBF(this, BaseAddress, ppNativeModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::GetNativeModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*>* pNativeModuleInstances)
{
    return ProcFD045CFE2611847953C966E4D4891465(this, pNativeModuleInstances);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::CallSite()
{
    return this->m_pCallSite;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::CallTarget()
{
    return this->m_pCallTarget;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::CallTargetAddress()
{
    return this->m_pCallTargetAddress;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::Create(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* pCallSite, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* pCallTarget, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* pCallTargetAddress, Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite** ppCreatedObject)
{
    return Proc9712D292D3F561C85D575D1D1A169743(pCallSite, pCallTarget, pCallTargetAddress, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::Mvid()
{
    return this->m_Mvid;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::Age()
{
    return this->m_Age;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::PdbName()
{
    return this->m_pPdbName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::Create(const GUID& SymbolProviderId, const GUID& Mvid, UINT32 Age, Microsoft::VisualStudio::Debugger::DkmString* pPdbName, Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId** ppCreatedObject)
{
    return ProcFD1ECC0384614A7BB087DDC735CC263F(SymbolProviderId, Mvid, Age, pPdbName, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint::Create(const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint** ppCreatedObject)
{
    return ProcF0887F8CD77331C223C58112B02B3D06(SourceId, CompilerId, pThread, IsBarrier, pInstructionAddress, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::ModuleName()
{
    return this->m_pModuleName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::AddressName()
{
    return this->m_pAddressName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::DkmString* pAddressName, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint** ppCreatedObject)
{
    return Proc60332A18F85A4FFB428E5704BCDD2A1E(pProcess, SourceId, CompilerId, pThread, IsBarrier, pModuleName, pAddressName, pFunctionName, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::SourceId()
{
    return this->m_SourceId;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::IsBarrier()
{
    return this->m_IsBarrier;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Close()
{
    return Proc4921BEC0D30D1765A57ECFF2126DBB4B(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::GetBoundBreakpoints(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>* pBoundBreakpoints)
{
    return ProcD1322FBC5A4F53CD71D904A9129D140F(this, pBoundBreakpoints);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Enable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnablePendingBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcA128E99A1AEAC21ACBFA950EE3F3B480(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Disable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisablePendingBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc3AA44FB37FBBCFFA6FBBE1CA72E86896(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Enroll(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnrollPendingBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcEFEC79D1BCD21D1131F213381B99DD64(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::SetCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>* pCompletionRoutine)
{
    return Proc477ABB8F3A0820484777E4374E219075(this, pWorkList, pCondition, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc292FF758655DE22ECB36F4C74707AA8A(this, pWorkList, pCondition, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::OnBreakpointBound(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints)
{
    return ProcB460D8699FACB2F98617CEE663F430B5(this, BoundBreakpoints);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::OnBreakpointUnbound(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointUnboundReason::e Reason)
{
    return ProcA9A34CABE5D34924B96CEC8E5546A656(this, BoundBreakpoints, Reason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::OnBreakpointMessage(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel::e Level, Microsoft::VisualStudio::Debugger::DkmString* pMessage)
{
    return Proc99CA4912ED11CCD3CA63F744165160AB(this, Level, pMessage);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint::DataElementLocation()
{
    return this->m_pDataElementLocation;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmString* pDataElementLocation, UINT32 Size, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint** ppCreatedObject)
{
    return Proc8ECC658EC2242BE249FD192CBE25E53F(pProcess, SourceId, CompilerId, pThread, IsBarrier, pDataElementLocation, Size, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint** ppCreatedObject)
{
    return Proc6053B28C3096673FC90D26445A76528D(pProcess, SourceId, CompilerId, pThread, IsBarrier, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint::GetCurrentSourcePosition(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppCurrentPosition)
{
    return Proc9B0261EA0FE6234EFD936CB4480EA78D(this, ppCurrentPosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint::GetCurrentSourceText(Microsoft::VisualStudio::Debugger::DkmString** ppCurrentText)
{
    return ProcF9D4693132F4DAF29D2D657F564DEF25(this, ppCurrentText);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::ModuleName()
{
    return this->m_pModuleName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::LineOffset()
{
    return this->m_LineOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, UINT32 LineOffset, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint** ppCreatedObject)
{
    return ProcE56F511514FFDB6E7EBB991014B63565(pProcess, SourceId, CompilerId, pThread, IsBarrier, pModuleName, pFunctionName, LineOffset, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome::Address()
{
    return this->m_Address;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome::Create(UINT64 Address, Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome** ppCreatedObject)
{
    return ProcC2C38CE8A50D042DEED2E1DBADC5CB25(Address, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmProcess::Live* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::LivePart()
{
    return this->m_pLive;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Path()
{
    return this->m_pPath;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::StartMethod()
{
    return this->m_StartMethod;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::EngineSettings()
{
    return this->m_pEngineSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SystemInformation()
{
    return this->m_pSystemInformation;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::BaseDebugMonitorId()
{
    return this->m_BaseDebugMonitorId;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsAppPackage()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsAppPackage;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsNativeDebuggingEnabled()
{
    return this->m_IsNativeDebuggingEnabled;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindProcess(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc3878B0A51524BC8FD74356AF6390338C(UniqueId, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return Proc33E7E6971423BF9A85008A3E9CFD7DC9(pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, const GUID& UniqueId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e StartMethod, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* pSystemInformation, const GUID& BaseDebugMonitorId, bool IsNativeDebuggingEnabled, const Microsoft::VisualStudio::Debugger::DkmProcess::Live* pLive, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DkmProcess** ppCreatedObject)
{
    return ProcC475EB6F33F01CF8E23EBF14281DC9D5(pConnection, pPath, UniqueId, StartMethod, pEngineSettings, pDebugLaunchSettings, pSystemInformation, BaseDebugMonitorId, IsNativeDebuggingEnabled, pLive, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, const GUID& UniqueId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e StartMethod, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* pSystemInformation, const GUID& BaseDebugMonitorId, bool IsAppPackage, bool IsNativeDebuggingEnabled, const Microsoft::VisualStudio::Debugger::DkmProcess::Live* pLive, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DkmProcess** ppCreatedObject)
{
    return Proc106265AC3459BC4D58F9E120E7890A5B(pConnection, pPath, UniqueId, StartMethod, pEngineSettings, pDebugLaunchSettings, pSystemInformation, BaseDebugMonitorId, IsAppPackage, IsNativeDebuggingEnabled, pLive, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetThreads(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>* pThreads)
{
    return ProcC36364A347A1331856E21EB8986BAE70(this, pThreads);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindSystemThread(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmThread** ppThread)
{
    return Proc271368D023C6928C09CB19546C3F1AD1(this, Id, ppThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnAsyncBreakComplete(Microsoft::VisualStudio::Debugger::DkmAsyncBreakStatus::e Status, Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcED5672D2B090E000D7A7F7AD376C8B29(this, Status, pThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetPendingBreakpoints(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*>* pPendingBreakpoints)
{
    return Proc4A0E15FDF157B102C15D0945524E44EA(this, pPendingBreakpoints);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindRuntimeInstance(const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance** ppRuntimeInstance)
{
    return ProcE26FC60E9788891FD620E40D02F8214A(this, Id, ppRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetRuntimeInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*>* pRuntimeInstances)
{
    return Proc6A4CB9E6ACE0329D50B59CB473BB5DA6(this, pRuntimeInstances);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetComputeKernels(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*>* pComputeKernels)
{
    return Proc83904421FD75D950D0C529A5A96F888B(this, pComputeKernels);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetRuntimeFunctionResolutionRequests(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*>* pRuntimeFunctionResolutionRequests)
{
    return ProcFE2313088C600310FB7FB38145E2E44A(this, pRuntimeFunctionResolutionRequests);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnEntryPoint(Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcDF334C7812DE5779F127659C7CD0F4FC(this, pThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::CreateNativeInstructionAddress(UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddressObject)
{
    return Proc5A54344DA99A8E8110ED35DAA5DA2324(this, InstructionPointer, ppAddressObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindNativeModule(UINT64 Address, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppModuleInstance)
{
    return ProcF4FA5D54D06ED8FB9E7DEB680FC83C0D(this, Address, ppModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindNativeModule(UINT64 Address, bool IncludeDisabledModules, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppModuleInstance)
{
    return Proc8A6D7EC2A52F26AD397C691D3330A926(this, Address, IncludeDisabledModules, ppModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AsyncBreak(bool StopImmediately)
{
    return ProcAF31D72F6E65E289D17CCB5D3D2F418F(this, StopImmediately);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::LocateBinary(Microsoft::VisualStudio::Debugger::DkmString* pApplicationPath, Microsoft::VisualStudio::Debugger::DkmString* pDumpPath, Microsoft::VisualStudio::Debugger::DkmString* pOriginalPath, UINT32 TimeDateStamp, UINT32 ImageSize, Microsoft::VisualStudio::Debugger::DkmString** ppFoundPath)
{
    return Proc1BA75E1240F3CFD277658D59B4759BAB(this, pApplicationPath, pDumpPath, pOriginalPath, TimeDateStamp, ImageSize, ppFoundPath);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Disassemble(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions)
{
    return Proc1BFA716C410EE92B5D9550D310574100(this, pAddress, Count, pDisassembledInstructions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetInstructionAddress(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartAddress, INT32 InstructionOffset, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddress)
{
    return Proc418F9EE0619D1B155F4CBF61E05C3742(this, pStartAddress, InstructionOffset, ppAddress);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::WriteDump(Microsoft::VisualStudio::Debugger::DkmDumpType::e DumpType, Microsoft::VisualStudio::Debugger::DkmString* pPath, Microsoft::VisualStudio::Debugger::DkmThread* pTargetThread)
{
    return Proc78457549C84AD5A4D3E96DDC28B4A91D(this, DumpType, pPath, pTargetThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AddExceptionTrigger(const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger* pTrigger)
{
    return Proc9FB80C6A3DB27E2C52259C3282AE46F7(this, SourceId, pTrigger);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AddExceptionTrigger(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger* pTrigger, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Exceptions::DkmAddExceptionTriggerAsyncResult>* pCompletionRoutine)
{
    return Proc433805FB32119EF9F52D897E3DB167CC(this, pWorkList, SourceId, pTrigger, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ClearExceptionTriggers(const GUID& SourceId)
{
    return ProcD2F3BF5A81EA26B2F9702DE5AA7F854E(this, SourceId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SearchRuntimeFunctionTable(UINT64 Address, UINT64* pBaseAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppFunctionTableEntry)
{
    return Proc94A9989CD07F6E368BE9234F2C761007(this, Address, pBaseAddress, ppFunctionTableEntry);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetGPUBreakpointBehavior(Microsoft::VisualStudio::Debugger::GPU::DkmGPUBreakpointBehaviorFlags::e* pBreakpointBehavior)
{
    return Proc2A48A9D77297CAE270C2A2DBC52F163B(this, pBreakpointBehavior);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SetGPUMemoryAccessWarning(UINT32 WarningCode, bool Enable)
{
    return Proc221A1C16A0CA91E399F361A5B5A38AC9(this, WarningCode, Enable);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ClearAllGPUMemoryAccessWarnings()
{
    return Proc8D47871CB4A49A7D7E9DB77822948CFD(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetInstructionAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetInstructionAddressAsyncResult>* pCompletionRoutine)
{
    return Proc9D6623C601DB3190377A91A37C7419B0(this, pWorkList, InstructionPointer, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnInstructionPatchInserted(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& OriginalMemory)
{
    return ProcBBC3412E622A85C7A9C9A2B97362ACC4(this, Address, OriginalMemory);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnInstructionPatchRemoved(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& OriginalMemory)
{
    return Proc6B1CD2F016C6DF558BBBB8943EC462EA(this, Address, OriginalMemory);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ReadMemory(UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e Flags, void* pBuffer, UINT32 Size, UINT32* pBytesRead)
{
    return Proc43F8B1A71560988CDA93783A20518F4C(this, Address, Flags, pBuffer, Size, pBytesRead);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ReadMemoryString(UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags::e Flags, UINT16 CharacterSize, UINT32 MaxCharacters, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pStringMemory)
{
    return ProcFB08A1C7BD77B71CAE548E8932D320E1(this, Address, Flags, CharacterSize, MaxCharacters, pStringMemory);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::WriteMemory(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return ProcCB54C33EFFC65296BF4C0F6267CAF6B9(this, Address, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::InvisibleWriteMemory(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return Proc6918CAE6B208EA57C2B5EFC585308EA4(this, Address, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetHandleCount(UINT32* pHandleCount)
{
    return Proc264596E3D714E689ED29EB416C0EDB59(this, pHandleCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetRunningTime(UINT64* pRunningTime)
{
    return Proc535260FC7FAE6E6D8632B4D1639CFB53(this, pRunningTime);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SetRunningTime(UINT64 RunningTime)
{
    return Proc4013D302AF1F5E1D81F7B9F13E7BE15C(this, RunningTime);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetNativeRuntimeInstance(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance** ppRuntimeInstance)
{
    return Proc9FA203E127EE0B8B16CF94D1DBF8F7E5(this, ppRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Detach()
{
    return Proc6CE4E58CC03DB77D9C770472F95BCF46(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Terminate(UINT32 ExitCode)
{
    return Proc47D4E3D46CE7EA40D78544A4E2F2CCCB(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::StoppingEventProcessingBegin(bool ForceQueue)
{
    return Proc7AB53941FD46A190C2C1AA3D528041D9(this, ForceQueue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::StoppingEventProcessingContinue(Microsoft::VisualStudio::Debugger::DkmStoppingEventProcessingNextAction::e* pNextAction)
{
    return ProcD53F280F1F4958974C7D9C5765C56D3D(this, pNextAction);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AbortingFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e Flags)
{
    return Proc4DD206531745B166ED6A848124817007(this, Flags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsStopped(bool* pResult)
{
    return ProcEC0AAA177C50B8CBA6F8BDF561155D7D(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetSystemThreads(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>* pSystemThreads)
{
    return ProcFC48FDC6FDEA04D6E5196CF1CBEEE2E4(this, pSystemThreads);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AllocateVirtualMemory(UINT64 Address, UINT32 Size, UINT32 AllocationType, UINT32 PageProtection, UINT64* pAllocatedAddress)
{
    return ProcA863A9CAB9B57E2180E37E0162F20CE1(this, Address, Size, AllocationType, PageProtection, pAllocatedAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FreeVirtualMemory(UINT64 Address, UINT32 Size, UINT32 FreeType)
{
    return Proc4C097F77E57173F0A64E1BC1D0723263(this, Address, Size, FreeType);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::VolatileReadMemory(UINT64 Address, void* pBuffer, UINT32 Size)
{
    return Proc38B421E6EE7506792532303AF2226FCE(this, Address, pBuffer, Size);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::VolatileWriteMemory(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return Proc9DE0E3BEAA03DD17B309B44950EB2366(this, Address, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnLoadComplete()
{
    return Proc1045230454C0D39659EA1D5AD3413E7E(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Unload(UINT32 ExitCode)
{
    return Proc353AC2FCF8655B4292847535571BE6DA(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::TryLocateBinary(Microsoft::VisualStudio::Debugger::DkmString* pApplicationPath, Microsoft::VisualStudio::Debugger::DkmString* pDumpPath, Microsoft::VisualStudio::Debugger::DkmString* pOriginalPath, UINT32 TimeDateStamp, UINT32 ImageSize, Microsoft::VisualStudio::Debugger::DkmString** ppFoundPath)
{
    return Proc912C6A5D8C8520F4EE9D8D805F709792(this, pApplicationPath, pDumpPath, pOriginalPath, TimeDateStamp, ImageSize, ppFoundPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetDumpExePath(Microsoft::VisualStudio::Debugger::DkmString** ppExePath)
{
    return Proc0F286FA438BB0A3E8BE280B348C50768(this, ppExePath);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Path()
{
    return this->m_pPath;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::ProcessId()
{
    return this->m_ProcessId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::UniqueProcessId()
{
    return this->m_UniqueProcessId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::StartMethod()
{
    return this->m_StartMethod;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::HostingProcessLanguage()
{
    return this->m_HostingProcessLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::EngineSettings()
{
    return this->m_pEngineSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, UINT32 ProcessId, const GUID& UniqueProcessId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod::e StartMethod, const GUID& HostingProcessLanguage, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest** ppCreatedObject)
{
    return Proc95205A6BC436A6D493CD550A588C10F8(pConnection, pPath, ProcessId, UniqueProcessId, StartMethod, HostingProcessLanguage, pEngineSettings, pDebugLaunchSettings, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::AttachToProcess(Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc609FC4C1EFA5159E8A99CB48C4A049B6(this, ppProcess);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList::GetAdditionalEnvironmentVariables(UINT32 ImplementationIndex, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario::e Scenario, Microsoft::VisualStudio::Debugger::DkmString** ppAdditionalEnvironmentBlock)
{
    return ProcF505EE31F3B51D5736BBC626A76BFA18(this, ImplementationIndex, pDebugLaunchSettings, Scenario, ppAdditionalEnvironmentBlock);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList::Create(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList** ppCreatedObject)
{
    return Proc7E7DA05F4F334A3C130300B9DE219574(ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::FileName()
{
    return this->m_pFileName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Arguments()
{
    return this->m_pArguments;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::WorkingDirectory()
{
    return this->m_pWorkingDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Environment()
{
    return this->m_pEnvironment;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::StartupInfo()
{
    return this->m_pStartupInfo;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::ModeFlags()
{
    return this->m_ModeFlags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Win32Flags()
{
    return this->m_Win32Flags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Connection()
{
    return this->m_pConnection;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::EngineSettings()
{
    return this->m_pEngineSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Close()
{
    return Proc133D28FFA03AD3445985EA795062324F(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileName, Microsoft::VisualStudio::Debugger::DkmString* pArguments, Microsoft::VisualStudio::Debugger::DkmString* pWorkingDirectory, Microsoft::VisualStudio::Debugger::DkmString* pEnvironment, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo* pStartupInfo, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags::e ModeFlags, UINT32 Win32Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest** ppCreatedObject)
{
    return ProcCE60681703B6B3BE0727ACD155F1F4B0(pFileName, pArguments, pWorkingDirectory, pEnvironment, pStartupInfo, ModeFlags, Win32Flags, pConnection, pEngineSettings, pDebugLaunchSettings, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::LaunchProcess(UINT32 AdditionalWin32Flags, Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo* pLaunchedProcess)
{
    return ProcEE04EDDA44575ACCE2D895843CC5E455(this, AdditionalWin32Flags, pLaunchedProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::ResumeProcess()
{
    return Proc92D5E0C5D4EAF1F319BEA651257EFED6(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::LaunchDebuggedProcess(Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo* pLaunchedProcess)
{
    return ProcB93000BE4745096FE67A3B4F7FC0E930(this, pLaunchedProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::ResumeDebuggedProcess(const GUID& UniqueProcessId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc048095810FEB921258184BC243942C8C(this, UniqueProcessId, ppProcess);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Desktop()
{
    return this->m_pDesktop;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Title()
{
    return this->m_pTitle;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::X()
{
    return this->m_X;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Y()
{
    return this->m_Y;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::XSize()
{
    return this->m_XSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::YSize()
{
    return this->m_YSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::XCountChars()
{
    return this->m_XCountChars;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::YCountChars()
{
    return this->m_YCountChars;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::FillAttribute()
{
    return this->m_FillAttribute;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::ShowWindow()
{
    return this->m_ShowWindow;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::StdInputHandle()
{
    return this->m_StdInputHandle;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::StdOutputHandle()
{
    return this->m_StdOutputHandle;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::StdErrorHandle()
{
    return this->m_StdErrorHandle;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pDesktop, Microsoft::VisualStudio::Debugger::DkmString* pTitle, UINT32 X, UINT32 Y, UINT32 XSize, UINT32 YSize, UINT32 XCountChars, UINT32 YCountChars, UINT32 FillAttribute, UINT32 Flags, UINT16 ShowWindow, UINT64 StdInputHandle, UINT64 StdOutputHandle, UINT64 StdErrorHandle, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo** ppCreatedObject)
{
    return ProcA8FADDCF3708A1A38F469A40A28BA3B8(pDesktop, pTitle, X, Y, XSize, YSize, XCountChars, YCountChars, FillAttribute, Flags, ShowWindow, StdInputHandle, StdOutputHandle, StdErrorHandle, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::EvaluationResult()
{
    return this->m_pEvaluationResult;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* pEvaluationResult, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy** ppCreatedObject)
{
    return Proc5E7FD8F8CCFD4B162EAF3C29B5240CD8(Id, pEvaluationResult, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::InitSourceDataProvider(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return ProcAC74F0017B56DBED5A20E546C72C4091(this, ppDataOut);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::GetManagedViewerCreationData(Microsoft::VisualStudio::Debugger::DkmString** ppAssemblyName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyPdb, Microsoft::VisualStudio::Debugger::DkmString** ppClassName, UINT32* pAssemblyResolution, bool* pReplacementOk)
{
    return ProcD00A582A8E46FA8DA5A6390AC691465D(this, ppAssemblyName, ppAssemblyBytes, ppAssemblyPdb, ppClassName, pAssemblyResolution, pReplacementOk);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::InPlaceUpdateObject(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& DataIn, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return ProcC17D73FF4688C3A6F221FDC45D39BEFA(this, DataIn, ppDataOut);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::ResolveAssemblyReference(Microsoft::VisualStudio::Debugger::DkmString* pAssemblyName, UINT32 Flags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyPdb, Microsoft::VisualStudio::Debugger::DkmString** ppAssemblyLocation, UINT32* pAssemblyResolution)
{
    return Proc24A65EB99D5591E0DD35D8B55E0614F8(this, pAssemblyName, Flags, ppAssemblyBytes, ppAssemblyPdb, ppAssemblyLocation, pAssemblyResolution);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::GetInitialData(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return Proc53BD85DE362C9852CF729B63A0D58D8B(this, ppDataOut);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::CreateReplacementObject(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& DataIn, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return Proc7E66F613557B51733EA6A6D6A87087D7(this, DataIn, ppDataOut);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo::FriendlyName()
{
    return this->m_pFriendlyName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo::EngineIds()
{
    return this->m_pEngineIds;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pFriendlyName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* pEngineIds, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo** ppCreatedObject)
{
    return Proc302B29EB2B5017008BE1DC136F1ED5EE(pFriendlyName, pEngineIds, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue::ReturnFrom()
{
    return this->m_pReturnFrom;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Module()
{
    return this->m_pModule;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::DocumentName()
{
    return this->m_pDocumentName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::ScriptDocument()
{
    return this->m_pScriptDocument;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::MatchStrength()
{
    return this->m_MatchStrength;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Warning()
{
    return this->m_Warning;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::TextRequested()
{
    return this->m_TextRequested;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Close()
{
    return Proc2DB31E954D2ED062F8C66B849EE60429(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pDocumentName, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pScriptDocument, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength::e MatchStrength, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning::e Warning, bool TextRequested, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument** ppCreatedObject)
{
    return Proc4E2ECDABAF53878BC2CB86BB0CA5DE92(pModule, pDocumentName, pScriptDocument, MatchStrength, Warning, TextRequested, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::FindSymbols(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::DkmString* pText, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>* pInstructionSymbols, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*>* pSymbolLocation)
{
    return Proc1A9C348A582748AB15065E17A667A486(this, TextSpan, pText, pInstructionSymbols, pSymbolLocation);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::FindSymbols(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::DkmString* pText, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindSymbolsAsyncResult>* pCompletionRoutine)
{
    return ProcB9407B9EAA35C920D32759FE968A25CA(this, pWorkList, TextSpan, pText, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument::ScriptBlocks()
{
    return this->m_pScriptBlocks;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pDocumentName, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pScriptDocument, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength::e MatchStrength, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning::e Warning, bool TextRequested, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>* pScriptBlocks, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument** ppCreatedObject)
{
    return Proc00BCCC33F43438DB686C5A05BE34F2E9(pModule, pDocumentName, pScriptDocument, MatchStrength, Warning, TextRequested, pScriptBlocks, DataItem, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::ArrayLength()
{
    return this->m_ArrayLength;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const GUID& VisualizerId, const GUID& SourceId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* pValueHome, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags::e Flags, UINT32 ArrayLength, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression** ppCreatedObject)
{
    return ProcE236B855866DB4A74880D6FEA3185901(pInspectionContext, VisualizerId, SourceId, pStackFrame, pValueHome, pModule, pName, pFullName, Flags, ArrayLength, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::StartTime()
{
    return this->m_StartTime;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::SessionId()
{
    return this->m_SessionId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Title()
{
    return this->m_pTitle;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::UserName()
{
    return this->m_pUserName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::ClrVersions()
{
    return this->m_pClrVersions;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::CommandLine()
{
    return this->m_pCommandLine;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::CurrentDirectory()
{
    return this->m_pCurrentDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::EnvironmentBlock()
{
    return this->m_pEnvironmentBlock;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::IntegrityLevel()
{
    return this->m_IntegrityLevel;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::PublishedPrograms()
{
    return this->m_pPublishedPrograms;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::ProcessorArchitecture()
{
    return this->m_ProcessorArchitecture;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::AppPackageId()
{
    return this->m_pAppPackageId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Create(UINT32 Id, UINT64 StartTime, UINT32 SessionId, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pTitle, Microsoft::VisualStudio::Debugger::DkmString* pUserName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pClrVersions, Microsoft::VisualStudio::Debugger::DkmString* pCommandLine, Microsoft::VisualStudio::Debugger::DkmString* pCurrentDirectory, Microsoft::VisualStudio::Debugger::DkmString* pEnvironmentBlock, UINT32 IntegrityLevel, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo*>* pPublishedPrograms, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessFlags::e Flags, UINT16 ProcessorArchitecture, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo** ppCreatedObject)
{
    return Proc37D73B0F874CC8F77777D40219EDB14A(Id, StartTime, SessionId, pName, pTitle, pUserName, pClrVersions, pCommandLine, pCurrentDirectory, pEnvironmentBlock, IntegrityLevel, pPublishedPrograms, Flags, ProcessorArchitecture, pAppPackageId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SourceId()
{
    return this->m_SourceId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Thread()
{
    return this->m_pThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Close()
{
    return Proc7729A748D025D8D1D27D5F70D2E2971C(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetCompiledConditionPending()
{
    return ProcFC9C6DD35B19AD87E29CF388843DEF42(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetCompiledConditionPending(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionPendingAsyncResult>* pCompletionRoutine)
{
    return Proc0245E3B12859026D7920DFF4858DF38F(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetEvaluationCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return ProcE46325D07FF9ECFA31F70280E1A0DD0F(this, pCondition, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetEvaluationCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetEvaluationConditionAsyncResult>* pCompletionRoutine)
{
    return ProcA19DF47DA04A1D5C32B02E7F4032BED7(this, pWorkList, pCondition, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearConditions()
{
    return ProcF4A3B764CCDEFECC871133DFB3DABD74(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearConditions(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointConditionsAsyncResult>* pCompletionRoutine)
{
    return Proc99E8152F458A4714289FF221F4100D2F(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, UINT32 HitCountValue)
{
    return Proc1E9AD8DA5F656684C0C7A9CBFACB19A3(this, pCondition, HitCountValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, UINT32 HitCountValue, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc2F391C137BC1096F8C013BDECD30B957(this, pWorkList, pCondition, HitCountValue, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearHitCountCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, UINT32* pCurrentHitCount)
{
    return ProcF9E386AD9771E9F2C3058D5834F64CB5(this, pCondition, pCurrentHitCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearHitCountCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc8F395CEE476179C6FEBC6905D21E7A85(this, pWorkList, pCondition, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::GetHitCountConditionStatus(UINT32* pCurrentHitCount)
{
    return Proc2933A0DFA7612550A1AF4A41C1E9C15F(this, pCurrentHitCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::GetHitCountConditionStatus(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc4C9A3BE3A5112A28D0AF6CA87F562C70(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::GetCompiledCondition(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e* pConditionOperator, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition)
{
    return Proc41499D88B1F6924ECF29547583D8DD95(this, pInstructionAddress, pConditionOperator, ppCompiledCondition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::OnBreakpointConditionFailed(Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage)
{
    return ProcE8EF7EF6768418441FE22C86348944FC(this, pErrorMessage);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::RequestBreakpointEventOnModifiedThread(Microsoft::VisualStudio::Debugger::DkmThread* pModifiedBreakThread)
{
    return Proc39CF936CBBD422C18149B4C96CF48257(this, pModifiedBreakThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::RequestBreakpointEventOnModifiedThread(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pModifiedBreakThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmRequestBreakpointEventOnModifiedThreadAsyncResult>* pCompletionRoutine)
{
    return ProcA6288D90C3F6D3DECB145E59C1E2E0BE(this, pWorkList, pModifiedBreakThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Enable()
{
    return Proc93E2EB641A58D187BC71A1FD19D779A4(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Enable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableRuntimeBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc9893B43ADE803E4FF563307C23A5DE77(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Test()
{
    return ProcFFE7BBBBC1EC94B9CB3791B48190C3C2(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Test(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTestRuntimeBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcAB4964C8D77D3256EFE0D6A44501C685(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Disable()
{
    return Proc37D0CD0D0909DE69E045690F177B6ED0(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Disable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableRuntimeBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc7F86958C6499B678D002E26D8724C3E4(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::OnHit(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool HasException)
{
    return Proc11942CA3E32D2CC5E71549580B4EEE2F(this, pThread, HasException);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::EvaluateConditionAndSelectThread(Microsoft::VisualStudio::Debugger::DkmThread* pFirstStoppedThread, Microsoft::VisualStudio::Debugger::DkmThread** ppConditionMetThread)
{
    return ProcA744AE7AD70089B93C050396189C0E6D(this, pFirstStoppedThread, ppConditionMetThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::EvaluateConditionAndSelectThread(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pFirstStoppedThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluateConditionAndSelectThreadAsyncResult>* pCompletionRoutine)
{
    return Proc654E5E6C9B16E21E572DC1F61E81FC11(this, pWorkList, pFirstStoppedThread, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::LineOffset()
{
    return this->m_LineOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::ModuleName()
{
    return this->m_pModuleName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::SearchFlags()
{
    return this->m_SearchFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::Close()
{
    return Proc1CB7AA5C0E18E7C2533CABD78EF033B3(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, UINT32 LineOffset, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags::e SearchFlags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest** ppCreatedObject)
{
    return Proc02F5B636B11CFD1F31E0C794EE4631B8(pProcess, CompilerId, pFunctionName, LineOffset, pModuleName, SearchFlags, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::EnableResolution(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList)
{
    return ProcDF15402D0A339E45CC2A57DB2F63EBE3(this, pWorkList);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnFunctionResolved(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress)
{
    return ProcB7DF07C7E259E057345053EA721F2BCE(this, pAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnFunctionResolved(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnFunctionResolvedAsyncResult>* pCompletionRoutine)
{
    return Proc4C6C4F1118EF07A4E19E8D544DBDEEA0(this, pWorkList, pAddress, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnResolverMessage(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel::e Level, Microsoft::VisualStudio::Debugger::DkmString* pMessage)
{
    return Proc10A22778D523D607BD6C09729AD0F35E(this, Level, pMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnResolverMessage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel::e Level, Microsoft::VisualStudio::Debugger::DkmString* pMessage, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnResolverMessageAsyncResult>* pCompletionRoutine)
{
    return ProcC1543CFD5ACC8E9540123E1C97C081EC(this, pWorkList, Level, pMessage, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Address()
{
    return this->m_Address;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmDataAccessStopMask::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 Address, Microsoft::VisualStudio::Debugger::Breakpoints::DkmDataAccessStopMask::e Access, UINT32 Size, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint** ppCreatedObject)
{
    return Proc473E9833342ED425C288649015CC324B(pRuntimeInstance, SourceId, pThread, Address, Access, Size, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Capabilities()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->Capabilities;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::ParentRuntime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pParentRuntime;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Connection()
{
    return this->m_pProcess->Connection();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetScriptDocumentTreeNodes(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*>* pScriptDocumentTreeNodes)
{
    return Proc0E8B280F47F46C4B2A2734040F7FA707(this, pScriptDocumentTreeNodes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pModuleInstances)
{
    return Proc245EB5834F220A1C282AA6E2B457151C(this, pModuleInstances);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetTaskProviders(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*>* pTaskProviders)
{
    return Proc9E83BEF15E45216D9E571931B801FC8F(this, pTaskProviders);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::ResolveCPUInstructionAddress(UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddressObject, bool* pFirstAddress)
{
    return ProcF47641A9B4F4EF84594FF51457BD43AD(this, InstructionPointer, ppAddressObject, pFirstAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::ResolveCPUInstructionAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmResolveCPUInstructionAddressAsyncResult>* pCompletionRoutine)
{
    return ProcDDA5249C91A40BC1C63ABF57EE417F35(this, pWorkList, InstructionPointer, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::FindModulesByName(Microsoft::VisualStudio::Debugger::DkmString* pSearchKey, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pMatches)
{
    return Proc10463036625AB2B5AAA7F05509328531(this, pSearchKey, pMatches);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::SetRegisterValue(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackWalkFrame, CV_HREG_e RegisterIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue)
{
    return Proc49AB6C5E8A36B60EA1D587680080E9ED(this, pStackWalkFrame, RegisterIndex, pValue);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::BeforeEnableNewStepper(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper)
{
    return Proc003CEB61065326C60432436C71B15AF3(this, pStepper);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::OwnsCurrentExecutionLocation(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, bool* pOwnsFrame)
{
    return ProcFF2EBEF240F6308F4BC2649DFFAED7C9(this, pStepper, Reason, pOwnsFrame);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Step(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason)
{
    return Proc803C37AF1E9AECCD4C7CAE2B2785162A(this, pStepper, Reason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::StopStep(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper)
{
    return ProcC0CB9DB875E57138C93DFCE332C3D32C(this, pStepper);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::AfterSteppingArbitration(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pNewControllingRuntimeInstance)
{
    return ProcAA61459CFDC30CEC49DA6E3BBD21802C(this, pStepper, Reason, pNewControllingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::OnNewControllingRuntimeInstance(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pControllingRuntimeInstance)
{
    return Proc6C79DBE9F40FE80E961282947D988039(this, pStepper, Reason, pControllingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::StepControlRequested(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance, bool* pGranted)
{
    return ProcF0247C5D3632A8B6B5A018211C1D2410(this, pStepper, Reason, pCallingRuntimeInstance, pGranted);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::TakeStepControl(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, bool LeaveGuardsInPlace, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance)
{
    return Proc17820A171C58275B4CB2469D9614049B(this, pStepper, LeaveGuardsInPlace, Reason, pCallingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::NotifyStepComplete(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper)
{
    return Proc2344FF3BDFEDB69A0DC72C3155B8F61B(this, pStepper);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetThreadDisplayProperties(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>* pCompletionRoutine)
{
    return ProcB0B79064BF97FA5726711951AECE4E77(this, pWorkList, pThread, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetThreadName(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmString** ppName)
{
    return Proc2EA1B4DEDF4599B865E8E1A2E5718E86(this, pThread, ppName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetThreadName(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadNameAsyncResult>* pCompletionRoutine)
{
    return ProcA73EB0668CACF4528C6378839C71F455(this, pWorkList, pThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Unload()
{
    return ProcCA285C60E7286A27F6D525028789BEB1(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetManagedHeapSamplers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*>* pManagedHeapSamplers)
{
    return ProcB94CF78451EDBCA915BAFD75C300EF35(this, pManagedHeapSamplers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetManagedHeapWalkers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*>* pManagedHeapWalkers)
{
    return ProcA4A36CF75EB42A472782FD7825A58C9D(this, pManagedHeapWalkers);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetCodePathsInRange(ICorDebugFrame* pCorFrame, UINT32 StartILOffset, UINT32 EndILOffset, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* pCodePaths)
{
    return Proc1DF54DB322921281DE98E82C2A0D2D12(this, pCorFrame, StartILOffset, EndILOffset, pCodePaths);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Disassemble(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions)
{
    return ProcA67728A0C5C3D3B4EACB1F1C598A20D7(this, pAddress, Count, pDisassembledInstructions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetInstructionAddress(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartAddress, INT32 InstructionOffset, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddress)
{
    return Proc147D5B957653AEED0BF962688F3879AE(this, pStartAddress, InstructionOffset, ppAddress);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId::CompareTo(const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& other) const
{
    return ProcE97BC9882851F8E9E5A3179B48A6A534(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::IsBarrier()
{
    return this->m_IsBarrier;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, bool IsBarrier, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint** ppCreatedObject)
{
    return ProcCB83857C81F60315EF70D865BF0E4B1A(SourceId, pThread, pInstructionAddress, IsBarrier, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::SetCompiledCondition(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator)
{
    return ProcE485A2033078735C920AC84BD6F97736(this, pCompiledCondition, ConditionOperator);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::SetCompiledCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionAsyncResult>* pCompletionRoutine)
{
    return Proc7AF36FD7B7E0B4CE88AC133EBE2CA062(this, pWorkList, pCompiledCondition, ConditionOperator, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryPushConditionToTargetDevice(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator)
{
    return ProcB7BFDF6A5DD40400B07E77E9E74DD0ED(this, pCompiledCondition, ConditionOperator);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryPushConditionToTargetDevice(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator::e ConditionOperator, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryPushConditionToTargetDeviceAsyncResult>* pCompletionRoutine)
{
    return Proc3ABAEA10372ACE2485C57CA038BBC209(this, pWorkList, pCompiledCondition, ConditionOperator, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryClearConditionOnTargetDevice()
{
    return Proc720EFC94A30F2FDA0A06EC4DDEA4C417(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryClearConditionOnTargetDevice(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryClearConditionOnTargetDeviceAsyncResult>* pCompletionRoutine)
{
    return Proc79B572DB628856A7B5E44CCD638AF7DC(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue& other) const
{
    return Proc3DE111A28EFA51314B6DEABFD2A12DB2(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo::CodeText()
{
    return this->m_pCodeText;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo::TextSpan()
{
    return this->m_TextSpan;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pCodeText, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo** ppCreatedObject)
{
    return Proc50B5D8DA1C11FB7B3B25AF5A65A55FB0(pCodeText, TextSpan, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::UniqueId()
{
    return static_cast<const GUID&>(DkmScriptDocumentTreeNode::UniqueId());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Module()
{
    return this->m_pModule;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Url()
{
    return this->m_pUrl;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::FilePath()
{
    return this->m_pFilePath;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentContentType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::ContentType()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ContentType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptEmbeddedDocumentKind::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::EmbeddedDocumentKind()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->EmbeddedDocumentKind;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::GetSourceProjectItem(_Deref_out_opt_ Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem** ppValue)
{
    return GetC5849E9833F5F36297EB088EC664A234(this, ppValue);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::JmcState()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->JmcState;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* pParent, Microsoft::VisualStudio::Debugger::DkmString* pTitle, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pUrl, Microsoft::VisualStudio::Debugger::DkmString* pFilePath, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags::e Flags, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem* pSourceProjectItem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument** ppCreatedObject)
{
    return ProcEA0F13D8EBAAD5C57D07D7CA0ADFBE54(pRuntimeInstance, pParent, pTitle, pModule, pUrl, pFilePath, Flags, pSourceProjectItem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* pParent, Microsoft::VisualStudio::Debugger::DkmString* pTitle, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pUrl, Microsoft::VisualStudio::Debugger::DkmString* pFilePath, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags::e Flags, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentContentType::e ContentType, Microsoft::VisualStudio::Debugger::Script::DkmScriptEmbeddedDocumentKind::e EmbeddedDocumentKind, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem* pSourceProjectItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState::e JmcState, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument** ppCreatedObject)
{
    return ProcA673B7F58C93640EC322B5C0A2E63F79(pRuntimeInstance, pParent, pTitle, pModule, pUrl, pFilePath, Flags, ContentType, EmbeddedDocumentKind, pSourceProjectItem, JmcState, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::GetContent(bool EnableContentEvents, Microsoft::VisualStudio::Debugger::DkmString** ppContent, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pSectionDividers)
{
    return Proc605D280FE9838181FA3A4A2B68F0F82B(this, EnableContentEvents, ppContent, pSectionDividers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetRaiseContentEvents(bool Enable)
{
    return ProcB907C0A7AFABDB032781F0EB78062FA2(this, Enable);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::TryResolve(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument** ppResolvedDocument)
{
    return Proc3070F6337FAFE9328B926573E08C6350(this, pSourceFileId, ppResolvedDocument);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetRaiseSymbolEvents(bool Enable)
{
    return ProcDEE08F4607BF904380CD375869159CAA(this, Enable);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetRaiseSymbolEvents(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, bool Enable, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmSetRaiseSymbolEventsAsyncResult>* pCompletionRoutine)
{
    return Proc2E0CDF0E0AEBB33AA8AE4C476F46A6E1(this, pWorkList, Enable, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::GetProjectItemScriptBlocks(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>** ppScriptBlocks)
{
    return Proc6C9638A955AE91EA6325FFD14E45E14C(this, ppScriptBlocks);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::OnContentInsert(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& Span, Microsoft::VisualStudio::Debugger::DkmString* pNewText)
{
    return ProcE2EA22D316F3FD9C3A1E03841E45F509(this, Span, pNewText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::OnContentRemove(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& Span, UINT32 CharsToRemove)
{
    return Proc28927B0EE826B95D2F3582541114A6FB(this, Span, CharsToRemove);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetJmcState(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState::e NewValue)
{
    return Proc6110C67BD847D8134C925AC608E254E1(this, NewValue);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Parent()
{
    return this->m_pParent;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Title()
{
    return this->m_pTitle;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* pParent, Microsoft::VisualStudio::Debugger::DkmString* pTitle, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode** ppCreatedObject)
{
    return Proc1AE37B2274C1C965566B6B7955EABD47(pRuntimeInstance, pParent, pTitle, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Unload()
{
    return Proc14A934ACD96B407ADFD71AE6C2B5C520(this);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*>(DkmInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::Document()
{
    return this->m_pDocument;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::Revision()
{
    return this->m_Revision;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::StartIndex()
{
    return this->m_StartIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::StatementLength()
{
    return this->m_StatementLength;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::Create(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pDocument, UINT32 Revision, UINT32 StartIndex, UINT32 StatementLength, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress** ppCreatedObject)
{
    return ProcF1A9A362454701895C74085D767B0A84(pModuleInstance, pRuntimeInstance, pDocument, Revision, StartIndex, StatementLength, pAdditionalData, pCPUInstruction, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::Document()
{
    return this->m_pDocument;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::Revision()
{
    return this->m_Revision;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::StartIndex()
{
    return this->m_StartIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::StatementLength()
{
    return this->m_StatementLength;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const GUID& RuntimeType, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pDocument, UINT32 Revision, UINT32 StartIndex, UINT32 StatementLength, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol** ppCreatedObject)
{
    return ProcB0BD63F2B9661E923F8200970F45D067(pModule, RuntimeType, pDocument, Revision, StartIndex, StatementLength, pAdditionalData, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::GetNextSteppingAction(Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol* pStartingInstruction, bool IsSteppingByLine, Microsoft::VisualStudio::Debugger::Script::DkmScriptSymbolNextSteppingAction::e* pResult)
{
    return Proc35C553500D44E1B4057B6A4FA0819122(this, pStartingInstruction, IsSteppingByLine, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::LoadOrderIndex()
{
    return this->m_LoadOrderIndex;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, UINT32 LoadOrderIndex, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance** ppCreatedObject)
{
    return Proc470676CA7F49CBA39017F29721BF5721(pProcess, Id, LoadOrderIndex, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, UINT32 LoadOrderIndex, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance** ppCreatedObject)
{
    return ProcB33C67B27C7D54EBA23E2C2FB33D4DBC(pProcess, Id, Capabilities, pParentRuntime, LoadOrderIndex, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::GetRemoteDebugApplication(IRemoteDebugApplication** ppApplication)
{
    return Proc7BC07BA209278B7749391B532A06C4B1(this, ppApplication);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::AbortExecutionOnResume()
{
    return Proc69A328E0ADD079DF0ACFF13D910911C8(this);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::OnScriptCriticalError(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pSource, UINT32 MessageId, Microsoft::VisualStudio::Debugger::DkmString* pMessage, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pSourcePosition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmOnScriptCriticalErrorAsyncResult>* pCompletionRoutine)
{
    return Proc128384C8203A27AA4CD3890344DFF576(this, pWorkList, pSource, MessageId, pMessage, pInstructionAddress, pSourcePosition, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::OnScriptSymbolsUpdated(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>& Documents)
{
    return ProcAEDE145089DD531D49D8D3AFC3277A6C(this, Documents);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem::Path()
{
    return this->m_pPath;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem::IsGenerated()
{
    return this->m_IsGenerated;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem::Create(Microsoft::VisualStudio::Debugger::DkmString* pPath, bool IsGenerated, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem** ppCreatedObject)
{
    return Proc2F17F66CDE0E78674E5011F343327F56(pPath, IsGenerated, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest** ppCreatedObject)
{
    return Proc8C8881FB7D3648D13E24DE5A80DD1F83(SourceId, pThread, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::OnGPUSingleStepComplete(Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcADBB6CC055D2BD215B9891EC59C55284(this, pThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::EnableTempBreak(const Microsoft::VisualStudio::Debugger::DkmArray<UINT64>& TempBreakInstructions)
{
    return Proc5C34DFAF0E3CA60C3523472E5C911930(this, TempBreakInstructions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::ClearTempBreak()
{
    return Proc39295C4B4207546A5413781780E09C01(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::EnableSingleStep()
{
    return ProcAE64E2E60E05EDDB9DBF80F18CB6B1D1(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::ClearSingleStep()
{
    return ProcE5290FEE5BE393C4CBEFDBC334154102(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::OnSingleStepComplete()
{
    return Proc96B2A0869281F2E9E1E8FB63DDDC012B(this);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5Hash* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5HashPart()
{
    return this->m_pMD5Hash;
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1Hash* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1HashPart()
{
    return this->m_pSHA1Hash;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::DocumentName()
{
    return this->m_pDocumentName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::ScriptDocument()
{
    return this->m_pScriptDocument;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::Create(Microsoft::VisualStudio::Debugger::DkmString* pDocumentName, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pScriptDocument, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5Hash* pMD5Hash, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1Hash* pSHA1Hash, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId** ppCreatedObject)
{
    return Proc8CB20AF3128815B290295CECB4F778C2(pDocumentName, pScriptDocument, pMD5Hash, pSHA1Hash, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::SourceFileId()
{
    return this->m_pSourceFileId;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::TextSpan()
{
    return this->m_TextSpan;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::DocumentName()
{
    return this->m_pSourceFileId->DocumentName();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppCreatedObject)
{
    return ProcC7F5C260E52A1B26A2C10C0D8BF7787C(pSourceFileId, TextSpan, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::InspectionSession()
{
    return this->m_pInspectionSession;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::FilterOptions()
{
    return this->m_FilterOptions;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::FormatOptions()
{
    return this->m_FormatOptions;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::ThreadContext()
{
    return this->m_pThreadContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::AsyncContext()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAsyncContext;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Operation()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->Operation;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Close()
{
    return ProcFFE6AA7C220F41C1F306FAAC721E5E76(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e FilterOptions, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& FormatOptions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext** ppCreatedObject)
{
    return ProcDEEC88626A3FA552218C1327D95542B1(pInspectionSession, pThread, FilterOptions, FormatOptions, pThreadContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e FilterOptions, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& FormatOptions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation::e Operation, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext** ppCreatedObject)
{
    return Proc25F3629003D01C15D2C699A63D201EAD(pInspectionSession, pThread, FilterOptions, FormatOptions, pThreadContext, pAsyncContext, Operation, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::GetNextFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 RequestSize, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetNextFramesAsyncResult>* pCompletionRoutine)
{
    return ProcC523C229635B2E14B58D880FD561BD8B(this, pWorkList, RequestSize, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::Options()
{
    return this->m_Options;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::FrameName()
{
    return this->m_pFrameName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::ReturnType()
{
    return this->m_pReturnType;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::SourcePosition()
{
    return this->m_pSourcePosition;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& Options, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmString* pFrameName, Microsoft::VisualStudio::Debugger::DkmString* pReturnType, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pSourcePosition, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame** ppCreatedObject)
{
    return Proc28D1273D015808E5A637BACE1F82718C(pFrame, Options, CompilerId, pFrameName, pReturnType, pSourcePosition, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::GetEffectiveAddresses(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Disassembly::DkmEffectiveAddress>** ppEffectiveAddresses)
{
    return Proc4C1B28C21F3C11BDC1687B7F3D78B840(this, pAddress, ppEffectiveAddresses);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::StackMemoryRange()
{
    return this->m_StackMemoryRange;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::RegisterHash()
{
    return this->m_RegisterHash;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::MemoryHash()
{
    return this->m_MemoryHash;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange& StackMemoryRange, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& RegisterHash, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& MemoryHash, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash** ppCreatedObject)
{
    return Proc7F3F889DF5BFA8C78C8D53CD3D56516D(pThread, StackMemoryRange, RegisterHash, MemoryHash, ppCreatedObject);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange::CompareTo(const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange& other) const
{
    return Proc9828B496783EE3A4837AA6A8CB8EA07F(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::ThreadContext()
{
    return this->m_pThreadContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Process()
{
    return this->m_pThread->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Close()
{
    return Proc0F86415E78B3D06F5C59926FF40D2E0A(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext** ppCreatedObject)
{
    return ProcA34DFAA73EBF7F9AFDC8E6C494472623(pThread, pThreadContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::FindSymbolStackWalkContext(const GUID& SymbolProviderId, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext** ppSymbolStackWalkContext)
{
    return ProcC5D26383F8A6987AA14E7F72D5BAB969(this, SymbolProviderId, ppSymbolStackWalkContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::HeuristicWalkFrames(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 RequestSize, UINT64 EndStackPointer, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pFrames, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppNextRegisters, bool* pEndOfStack)
{
    return Proc565FEFF060E22589D7A3DA86DBF0C5A9(this, pRegisters, RequestSize, EndStackPointer, pFrames, ppNextRegisters, pEndOfStack);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::HeuristicWalkFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 RequestSize, UINT64 EndStackPointer, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmHeuristicWalkFramesAsyncResult>* pCompletionRoutine)
{
    return ProcD8298F6AEBCFE639A5277E7C6B4C291E(this, pWorkList, pRegisters, RequestSize, EndStackPointer, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFramesAndCheckCache(UINT32 RequestSizeHintIfCacheIsValid, UINT32 RequestSizeHintIfCacheIsInvalid, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash* pCachedHash, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pFrames, bool* pEndOfStack, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash** ppActualStackHash, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext** ppActualStackWalkContext, bool* pIsCacheValid)
{
    return Proc919F289A3BBDF586B90161CC0F85674B(this, RequestSizeHintIfCacheIsValid, RequestSizeHintIfCacheIsInvalid, pCachedHash, pFrames, pEndOfStack, ppActualStackHash, ppActualStackWalkContext, pIsCacheValid);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFramesAndCheckCache(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 RequestSizeHintIfCacheIsValid, UINT32 RequestSizeHintIfCacheIsInvalid, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash* pCachedHash, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult>* pCompletionRoutine)
{
    return Proc582931453CE802630963C16E4C3CE31C(this, pWorkList, RequestSizeHintIfCacheIsValid, RequestSizeHintIfCacheIsInvalid, pCachedHash, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFrames(UINT32 RequestSizeHint, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pFrames, bool* pEndOfStack)
{
    return ProcD6F5490DFB1533AA47E6BFB583FACB52(this, RequestSizeHint, pFrames, pEndOfStack);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 RequestSizeHint, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAsyncResult>* pCompletionRoutine)
{
    return ProcD7B60D34DF9743384ECC91AAED076C34(this, pWorkList, RequestSizeHint, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::FrameBase()
{
    return this->m_FrameBase;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::FrameSize()
{
    return this->m_FrameSize;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Flags()
{
    return this->m_Flags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Description()
{
    return this->m_pDescription;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Registers()
{
    return this->m_pRegisters;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Annotations()
{
    return this->m_pAnnotations;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::AnnotatedModule()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAnnotatedModule;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::AsyncContext()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAsyncContext;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Data()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pData;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::RuntimeInstance()
{
    if (this->m_pInstructionAddress != NULL)
    {
        return this->m_pInstructionAddress->RuntimeInstance();
    }
    return (Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*)0;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::ModuleInstance()
{
    if (this->m_pInstructionAddress != NULL)
    {
        return this->m_pInstructionAddress->ModuleInstance();
    }
    return (Microsoft::VisualStudio::Debugger::DkmModuleInstance*)0;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Process()
{
    return this->m_pThread->Process();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Connection()
{
    return this->m_pThread->Connection();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT64 FrameBase, UINT32 FrameSize, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppCreatedObject)
{
    return ProcA0BA43B79BBE61B6ED073DE327837C99(pThread, pInstructionAddress, FrameBase, FrameSize, Flags, pDescription, pRegisters, pAnnotations, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT64 FrameBase, UINT32 FrameSize, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations, Microsoft::VisualStudio::Debugger::DkmModuleInstance* pAnnotatedModule, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* pData, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppCreatedObject)
{
    return Proc279D105745DA281D3F61B6DCF5411056(pThread, pInstructionAddress, FrameBase, FrameSize, Flags, pDescription, pRegisters, pAnnotations, pAnnotatedModule, pAsyncContext, pData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::OnSetNextStatementCompleted(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStatement)
{
    return Proc4E67D055D6D2E433A2852293B6E54BA1(this, pNewStatement);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::InterceptCurrentException(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInterceptActionFlags::e InterceptAction, UINT64* pCookie)
{
    return Proc1630B1D062AC4FA4C48876B44B526781(this, InterceptAction, pCookie);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetUnwindAddress(Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppNewAddress)
{
    return ProcB774E248DFD633FF0DB4E742857915BF(this, ppNewAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::SetNextStatement(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStatement)
{
    return ProcA21A0DDB349EAED3F11615E3530AE002(this, pNewStatement);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::CanSetNextStatement(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStatement, UINT32* pResult)
{
    return ProcB4069C4360C0041F560E048681EFCB5E(this, pNewStatement, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Format(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& Options, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame** ppFormattedFrame)
{
    return ProcD6009FD4D2BFA6D9143568A4A20A299E(this, pInspectionSession, Options, ppFormattedFrame);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetInstructionSymbol(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol** ppSymbol)
{
    return Proc0EE400E922AE4C51108614E9BA744DBA(this, ppSymbol);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetInspectionInterface(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pSession, const GUID& InterfaceID, IUnknown** ppFrameInterface)
{
    return Proc08B4418EC0C18825B12F3E72299F915C(this, pSession, InterfaceID, ppFrameInterface);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::ComputeUserStatus(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, bool* pUser, bool* pExceptionImplementation)
{
    return Proc44D0BCBEFEC7D375AC47BA3B8004849F(this, pInspectionSession, pUser, pExceptionImplementation);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation::Value()
{
    return this->m_Value;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation::Create(const GUID& Id, UINT64 Value, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation** ppCreatedObject)
{
    return Proc6094CA2A993E3F9848322098956FD3F5(Id, Value, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmRemoteAuthenticationMode::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection::AuthenticationMode()
{
    return this->m_AuthenticationMode;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection::ProxyServer()
{
    return this->m_pProxyServer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection::Abort()
{
    return ProcDD11033D3489012566EDD562BBE02571(this);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StartingAddress()
{
    return this->m_pStartingAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::FrameBase()
{
    return this->m_FrameBase;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StepKind()
{
    return this->m_StepKind;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StepUnit()
{
    return this->m_StepUnit;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::SourceId()
{
    return this->m_SourceId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CodePath()
{
    return this->m_pCodePath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CrossThreadParent()
{
    return this->m_pCrossThreadParent;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::ShouldCaptureReturnValue()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ShouldCaptureReturnValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CurrentCodePaths()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pCurrentCodePaths;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CurrentMethodName()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pCurrentMethodName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Close()
{
    return Proc46A6B17E652C2B421E2B2F3B3E34CD21(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartingAddress, UINT64 FrameBase, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind::e StepKind, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e StepUnit, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath* pCodePath, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pCrossThreadParent, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper** ppCreatedObject)
{
    return Proc614B3EA5586AF72A6005519B6F6C9C50(pThread, pStartingAddress, FrameBase, StepKind, StepUnit, SourceId, pCodePath, pCrossThreadParent, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartingAddress, UINT64 FrameBase, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind::e StepKind, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e StepUnit, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath* pCodePath, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pCrossThreadParent, bool ShouldCaptureReturnValue, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* pCurrentCodePaths, Microsoft::VisualStudio::Debugger::DkmString* pCurrentMethodName, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper** ppCreatedObject)
{
    return ProcC1A3683E892B091686163189B43D1000(pThread, pStartingAddress, FrameBase, StepKind, StepUnit, SourceId, pCodePath, pCrossThreadParent, ShouldCaptureReturnValue, pCurrentCodePaths, pCurrentMethodName, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::BeforeEnable()
{
    return Proc969AFD652C52B34DFBA58A08419D9038(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Enable(bool RemoveOtherSteppers)
{
    return Proc7B97F0FF86BD2E2D682B864DFF17E77F(this, RemoveOtherSteppers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CancelStepper(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance)
{
    return Proc63E53E7C4821AF09FA0624C5CADC370F(this, pCallingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::GetControllingRuntimeInstance(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance** ppRuntimeInstance)
{
    return ProcE7A61A9F049FF2D74FDA1483C449EB9F(this, ppRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StepControlRequested(Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance, bool* pGranted)
{
    return Proc8A5F09971F6A17F44FEF05D97B445AFD(this, Reason, pCallingRuntimeInstance, pGranted);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::TakeStepControl(bool LeaveGuardsInPlace, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance)
{
    return Proc154EECF6D0808A631400840CD20CE9A7(this, LeaveGuardsInPlace, Reason, pCallingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnStepArbitration(Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCurrentControllingRuntimeInstance)
{
    return Proc2C4711ACA8448D643F9553C50E310375(this, Reason, pCurrentControllingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnCrossThreadStepArbitration(Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason::e Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCurrentControllingRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pNewThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStartingInstructionAddress, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper** ppNewStepper)
{
    return Proc75944E1AEDA5BD6E213831B42B08C09F(this, Reason, pCurrentControllingRuntimeInstance, pNewThread, pNewStartingInstructionAddress, ppNewStepper);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnReturnValues(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*>* pReturnValues, bool LastValueInCurrentContext)
{
    return ProcC1E64E1BAA30DE49027A7DBE4849ED6D(this, pReturnValues, LastValueInCurrentContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnStepComplete(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool HasException)
{
    return Proc23A5971C1BF1E602DEE5AB4BEFB31342(this, pThread, HasException);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::SetExceptionInFlight(bool Enable)
{
    return Proc687EB6BCECC901CC320D6678FDA635CC(this, Enable);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::IsExceptionInFlight(bool* pEnabled)
{
    return ProcE3FC472EC679C1DE3AB9FFAD538956CA(this, pEnabled);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::CodePathOffset()
{
    return this->m_CodePathOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::EndOffset()
{
    return this->m_EndOffset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 CodePathOffset, UINT32 EndOffset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath** ppCreatedObject)
{
    return Proc9E2248E24ABD99A8B1E10B4450E75955(pName, CodePathOffset, EndOffset, pAdditionalData, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::InstructionSymbol()
{
    return this->m_pInstructionSymbol;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::Language()
{
    return this->m_pLanguage;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol* pInstructionSymbol, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource** ppCreatedObject)
{
    return ProcB8F55C2292C5362692D5A78BF5A1E049(pInstructionSymbol, pInstructionAddress, pLanguage, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::GetCodePaths(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit::e StepUnit, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* pCodePaths)
{
    return Proc0339C3F8A834349475BA153214394E66(this, pStackFrame, StepUnit, pCodePaths);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Flags()
{
    return this->m_Flags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Values()
{
    return this->m_pValues;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Category()
{
    return this->m_Category;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::StorageType()
{
    return this->m_StorageType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::TypeModifierFlags()
{
    return this->m_TypeModifierFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::CustomUIVisualizers()
{
    return this->m_pCustomUIVisualizers;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreadIds, HRESULT EvaluationResults, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pValues, Microsoft::VisualStudio::Debugger::DkmString* pType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory::e Category, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType::e Access, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType::e StorageType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags::e TypeModifierFlags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult** ppCreatedObject)
{
    return Proc0BB87DD0FEF959F7D6EBC724EA4C6B07(pThreadIds, EvaluationResults, pName, pFullName, pRuntimeInstance, Flags, pValues, pType, Category, Access, StorageType, TypeModifierFlags, pCustomUIVisualizers, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Flags()
{
    return this->m_Flags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Value()
{
    return this->m_pValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::EditableValue()
{
    return this->m_pEditableValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Category()
{
    return this->m_Category;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::StorageType()
{
    return this->m_StorageType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::TypeModifierFlags()
{
    return this->m_TypeModifierFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Address()
{
    return this->m_pAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::CustomUIVisualizers()
{
    return this->m_pCustomUIVisualizers;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::ExternalModules()
{
    return this->m_pExternalModules;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags::e Flags, Microsoft::VisualStudio::Debugger::DkmString* pValue, Microsoft::VisualStudio::Debugger::DkmString* pEditableValue, Microsoft::VisualStudio::Debugger::DkmString* pType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory::e Category, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType::e Access, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType::e StorageType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags::e TypeModifierFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pExternalModules, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult** ppCreatedObject)
{
    return Proc42A2B316A229EB6E25BB276960D29FB9(pInspectionContext, pStackFrame, pName, pFullName, Flags, pValue, pEditableValue, pType, Category, Access, StorageType, TypeModifierFlags, pAddress, pCustomUIVisualizers, pExternalModules, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId::SymbolProviderId()
{
    return this->m_SymbolProviderId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Process()
{
    return this->m_pProcess;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Language()
{
    return this->m_pLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::LineOffset()
{
    return this->m_LineOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::ModuleName()
{
    return this->m_pModuleName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::SearchFlags()
{
    return this->m_SearchFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, UINT32 LineOffset, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags::e SearchFlags, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest** ppCreatedObject)
{
    return Proc3932AEFE94C36823D1A160EFA97E3F11(pProcess, pModule, pLanguage, pFunctionName, LineOffset, pModuleName, SearchFlags, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Resolve(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>* pAddresses)
{
    return Proc5AFC8CFC0FF188C22A757EFC938F0AB2(this, pAddresses);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::StackWalkContext()
{
    return this->m_pStackWalkContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::SymbolProviderId()
{
    return this->m_SymbolProviderId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Thread()
{
    return this->m_pStackWalkContext->Thread();
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::ThreadContext()
{
    return this->m_pStackWalkContext->ThreadContext();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Close()
{
    return ProcBDF0D5748E83AE15E24B5B1687A335C2(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext* pStackWalkContext, const GUID& SymbolProviderId, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext** ppCreatedObject)
{
    return ProcA2953E3BF3583689D4AA360B2A068724(pStackWalkContext, SymbolProviderId, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Initialize(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize)
{
    return Proc11DEBCF91819AB5C7D511F5CC8132865(this, pRegisters, StackRangeSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::UpdatePosition(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress)
{
    return Proc8EA48BC824C9B98D3446CD1284310781(this, pRegisters, StackRangeSize, pInstructionAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::WalkNextFrame(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppNextRegisters, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppFrameObject)
{
    return ProcE53FE4708620D30C1080556AF0FFBE3F(this, ppNextRegisters, ppFrameObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::ProcessorArchitecture()
{
    return this->m_ProcessorArchitecture;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::PageSize()
{
    return this->m_PageSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::OperatingSystemVersion()
{
    return this->m_OperatingSystemVersion;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::SuiteMask()
{
    return this->m_SuiteMask;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::ProcessorFeatures()
{
    return this->m_ProcessorFeatures;
}

inline DECLSPEC_NOTHROW MINIDUMP_TYPE STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::MinidumpFlags()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->MinidumpFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::SystemDirectory()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pSystemDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::SystemWow64Directory()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pSystemWow64Directory;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Create(UINT16 ProcessorArchitecture, UINT32 PageSize, UINT32 OperatingSystemVersion, UINT16 SuiteMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags::e Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures::e ProcessorFeatures, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppCreatedObject)
{
    return Proc35DBD0B3A9C4D65B34C9C9DC38DEEA7A(ProcessorArchitecture, PageSize, OperatingSystemVersion, SuiteMask, Flags, ProcessorFeatures, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Create(UINT16 ProcessorArchitecture, UINT32 PageSize, UINT32 OperatingSystemVersion, UINT16 SuiteMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags::e Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures::e ProcessorFeatures, MINIDUMP_TYPE MinidumpFlags, Microsoft::VisualStudio::Debugger::DkmString* pSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pSystemWow64Directory, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppCreatedObject)
{
    return ProcBB4C4C507C3D48982BF5C6EA6D711C9C(ProcessorArchitecture, PageSize, OperatingSystemVersion, SuiteMask, Flags, ProcessorFeatures, MinidumpFlags, pSystemDirectory, pSystemWow64Directory, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::TaskProvider()
{
    return this->m_pTaskProvider;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::TaskId()
{
    return this->m_TaskId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::ParentTaskId()
{
    return this->m_ParentTaskId;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::StackSegment()
{
    return this->m_StackSegment;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskReturnStatus::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::ReturnStatus()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ReturnStatus;
}

inline DECLSPEC_NOTHROW double STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::StartTime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->StartTime;
}

inline DECLSPEC_NOTHROW double STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::CompletedTime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->CompletedTime;
}

inline DECLSPEC_NOTHROW double STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Duration()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->Duration;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Close()
{
    return ProcE195EB82A3658BBE184BF772FE70EE44(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Create(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider* pTaskProvider, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 TaskId, UINT64 ParentTaskId, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment& StackSegment, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask** ppCreatedObject)
{
    return Proc3BC141B0950632BBEDF0F3A329B42598(pTaskProvider, pThread, TaskId, ParentTaskId, StackSegment, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Create(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider* pTaskProvider, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 TaskId, UINT64 ParentTaskId, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment& StackSegment, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskReturnStatus::e ReturnStatus, double StartTime, double CompletedTime, double Duration, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask** ppCreatedObject)
{
    return ProcF67FD0F8724B847483F082B115F61994(pTaskProvider, pThread, TaskId, ParentTaskId, StackSegment, ReturnStatus, StartTime, CompletedTime, Duration, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::GetChildTasks(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>* pItems)
{
    return Proc6F163AC98BAF7B488B85A75616791C9F(this, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::GetTaskProperties(UINT32 Radix, UINT32 Fields, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties* pProperties)
{
    return Proc678BC032D274C3D145554F7DA4BCF98C(this, Radix, Fields, pProperties);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::GetSynchronizationObjects(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject*>* pItems)
{
    return ProcEAFDA659BBC3E7B5DECD28D58939CC40(this, pItems);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties::Release(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties* pItem)
{
    return ProcA07FAFB63F4649DD290A721E8EFE4162(pItem);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::TaskProviderId()
{
    return this->m_TaskProviderId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProviderCapabilityFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::AdditionalCapabilities()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->AdditionalCapabilities;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Close()
{
    return Proc21FB0093543B45F8828E79D9EEF3AA3A(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Create(const GUID& TaskProviderId, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider** ppCreatedObject)
{
    return ProcCCE97B15762479275D3FB2967C597CCB(TaskProviderId, pName, pRuntimeInstance, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Create(const GUID& TaskProviderId, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProviderCapabilityFlags::e AdditionalCapabilities, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider** ppCreatedObject)
{
    return ProcF5AF3CCABE57E88CB0B16B900C3902FB(TaskProviderId, pName, pRuntimeInstance, AdditionalCapabilities, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::FindTask(UINT64 TaskId, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask** ppTask)
{
    return Proc62E124921D164B7AECA13D786603EC06(this, TaskId, ppTask);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::GetTasks(bool IsRoot, UINT32 RequestCount, UINT32* pScheduledTaskCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>* pItems, UINT32* pTaskEnumFlags)
{
    return ProcCDD4E8C991BEBFAC2D35C0F765297B11(this, IsRoot, RequestCount, pScheduledTaskCount, pItems, pTaskEnumFlags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::GetPropertyNames(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>* pNames)
{
    return Proc1C52C73B1F05AD5D701CFE684EFF003B(this, pNames);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Task()
{
    return this->m_pTask;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::OwningThread()
{
    return this->m_pOwningThread;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::DecimalName()
{
    return this->m_pDecimalName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::HexidecimalName()
{
    return this->m_pHexidecimalName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::WaitTime()
{
    return this->m_WaitTime;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Timeout()
{
    return this->m_Timeout;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Close()
{
    return ProcF54418460BC26AF2C3429E967BAEDB56(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Create(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* pTask, Microsoft::VisualStudio::Debugger::DkmThread* pOwningThread, Microsoft::VisualStudio::Debugger::DkmString* pDecimalName, Microsoft::VisualStudio::Debugger::DkmString* pHexidecimalName, Microsoft::VisualStudio::Debugger::DkmString* pType, UINT32 WaitTime, UINT32 Timeout, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject** ppCreatedObject)
{
    return ProcA598DC6767B6B5E321EA1C7E6742268C(pTask, pOwningThread, pDecimalName, pHexidecimalName, pType, WaitTime, Timeout, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& other) const
{
    return Proc94CE83C176C18E080657DE893B3FB7D1(*this, other);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmThread::System* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SystemPart()
{
    return this->m_pSystem;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::NativeStartAddress()
{
    return this->m_NativeStartAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::TebAddress()
{
    return this->m_TebAddress;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::IsMainThread()
{
    return this->m_IsMainThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Connection()
{
    return this->m_pProcess->Connection();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SystemInformation()
{
    return this->m_pProcess->SystemInformation();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 NativeStartAddress, UINT64 TebAddress, bool IsMainThread, const Microsoft::VisualStudio::Debugger::DkmThread::System* pSystem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DkmThread** ppCreatedObject)
{
    return Proc660872E9B1A72FBC89EE136ED9490954(pProcess, NativeStartAddress, TebAddress, IsMainThread, pSystem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetSteppers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*>* pSteppers)
{
    return Proc32245DDCC51A1CA87768FB26C135C6CF(this, pSteppers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnEmbeddedBreakpointHit(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, bool ShowAsException)
{
    return Proc9EC9594DE9AD4721F7CA1A6661474411(this, pInstructionAddress, ShowAsException);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::BeginFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e Flags)
{
    return Proc21018EEF594F640991F4C8723510500B(this, Flags);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::RaiseExecutionControlException(UINT32 ExceptionCode)
{
    return ProcCC77495B04753F1B0085CAF63BCF1679(this, ExceptionCode);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetExtendedRegisters(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>* pExtendedRegisters)
{
    return ProcC85E3C661A3F69393C3308D5AA724031(this, pExtendedRegisters);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SetExtendedRegisterValue(CV_HREG_e RegisterIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue)
{
    return ProcDA2C88FCD29A13D41642E51A73A0C5F3(this, RegisterIndex, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::CreateFrameRegisters(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& UnwoundRegisters, UINT32 VFrame, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppCreatedObject)
{
    return ProcCFC90B74E86F409E42174D75C612ECC1(this, UnwoundRegisters, VFrame, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetManagedThreadProperties(INT32* pManagedThreadId)
{
    return Proc1F8112701DC8FD65384408A8F7AC2688(this, pManagedThreadId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetManagedThreadProperties(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetManagedThreadPropertiesAsyncResult>* pCompletionRoutine)
{
    return Proc32E9F18F7EC761620221F110A2CE057F(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetTopStackWalkFrame(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppFrame)
{
    return Proc8877C3D70304E8D4D8932D1B95A128BC(this, pRuntimeInstance, ppFrame);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentFrameInfo(UINT64* pReturnAddress, UINT64* pFrameBase, UINT64* pVFrame)
{
    return Proc13E806B9B3C4319EF36A2D0160C5F358(this, pReturnAddress, pFrameBase, pVFrame);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetTopStackFrame(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppTopFrame)
{
    return ProcF5A59EE47B626A7A0FF46B584F2CF13F(this, ppTopFrame);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentRegisters(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& PseudoRegisters, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppCreatedObject)
{
    return Proc764B89CAFFE718355031F1555E23D68B(this, PseudoRegisters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::CreateRegistersObject(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& ThreadContext, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& PseudoRegisters, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& ExtendedRegisters, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppCreatedObject)
{
    return ProcE07A59DADEB847529B1EDACF190F9622(this, ThreadContext, PseudoRegisters, ExtendedRegisters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnContinueExecution(bool* pContinueTargetProcess)
{
    return Proc0960E067C6E6CE7EBFEEDBBDFE1D27A8(this, pContinueTargetProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnBeginFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e Flags, bool* pContinueTargetProcess)
{
    return Proc82FF1FA4E1EEAE6244230B42302688EF(this, Flags, pContinueTargetProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::EndFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags::e Flags)
{
    return ProcF525CDEB2CCDEEF6A83975AAF4A2818E(this, Flags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::IsStoppingEventQueued(bool IgnoreAsyncBreakEvents, bool* pResult)
{
    return ProcEBB9C20B7D84DC94119D75E52F0311D0(this, IgnoreAsyncBreakEvents, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentFuncEvalMode(Microsoft::VisualStudio::Debugger::DkmFuncEvalMode::e* pCurrentMode)
{
    return ProcE7E936BAFB8A03BADC8D5E852E215D5F(this, pCurrentMode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SetContext(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Context)
{
    return Proc47057DDC632AD45CEC7B2F19D7C55FC5(this, Context);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetContext(UINT32 ContextFlags, void* pContext, UINT32 ContextSize)
{
    return Proc6C71BAFC0CA8B6BB34725A9DB87FBDAC(this, ContextFlags, pContext, ContextSize);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentLocation(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetCurrentLocationAsyncResult>* pCompletionRoutine)
{
    return Proc4560E9791A28974C03DBB766B0923E3F(this, pWorkList, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetStackAddressRange(Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange* pMemoryRange)
{
    return ProcBF51E4F2615C39213EB93E638D855420(this, pMemoryRange);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Suspend(bool InternalSuspension, UINT32* pExternalSuspensionCount)
{
    return Proc8B5D381DB7DEAB34963D4ED0B1F13B59(this, InternalSuspension, pExternalSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Resume(bool InternalSuspension, UINT32* pExternalSuspensionCount)
{
    return Proc0CD674D84CB44BC00252F10D501563F9(this, InternalSuspension, pExternalSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetSuspensionCount(bool ShowInternal, UINT32* pSuspensionCount)
{
    return ProcD1CE80C145D86692B21A5385E307B03C(this, ShowInternal, pSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetDebuggerSuspensionCount(UINT32* pSuspensionCount)
{
    return Proc43848E55BF00ABC986124109B62D5595(this, pSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetTlsValue(UINT32 TlsIndex, UINT64* pValue)
{
    return Proc73F92C73F402A0645B5F0E13E132A009(this, TlsIndex, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SetTlsValue(UINT32 TlsIndex, UINT64 Value)
{
    return Proc2953901DB8E2A56A7761ADC76A4C51C9(this, TlsIndex, Value);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileProperties(INT32* pPriority, UINT64* pAffinityMask)
{
    return ProcCB686005B0C45325B528A4AB178C8DDA(this, pPriority, pAffinityMask);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileProperties(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatilePropertiesAsyncResult>* pCompletionRoutine)
{
    return Proc85E5BDCC65DBFBFD46BD72850AB5598D(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileFlags(Microsoft::VisualStudio::Debugger::ThreadProperties::DkmVolatileThreadFlags::e* pFlags)
{
    return Proc72D8789037B29D9BE4656FCAB8B158C1(this, pFlags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileFlags(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatileFlagsAsyncResult>* pCompletionRoutine)
{
    return ProcE025EC0D8596C9875C1203A22839D44C(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnInterceptExceptionCompleted(UINT64 Cookie)
{
    return Proc28873A94D65410FCC0056B9C83596DD0(this, Cookie);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Unload(UINT32 ExitCode)
{
    return ProcCEC10D8029BB7FE6392177BA9943EDE1(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetThreadCurrentWinRtErrorInfo(UINT64* pWinRTErrorInfo)
{
    return ProcA889D7143B7FAC827A4BAE8265E8FB6A(this, pWinRTErrorInfo);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection::Results()
{
    return this->m_pResults;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection::FailureReason()
{
    return this->m_FailureReason;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason::e FailureReason, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection** ppCreatedObject)
{
    return ProcE6D433576CE0AC1C21EE4E98D3422D5A(pResults, FailureReason, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::Qualifier()
{
    return this->m_pQualifier;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::Kind()
{
    return this->m_Kind;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnectionFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmApiVersion::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ProtocolVersion()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS11FeaturePack1) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ProtocolVersion;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FindConnection(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection** ppConnection)
{
    return ProcAB7E84604904D5C915B4A266F97F80F5(UniqueId, ppConnection);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetConnections(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*>* pConnections)
{
    return Proc2C8F3653A7BDEAB26FDAC5E12529D820(pConnections);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FindProcess(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return ProcF8399B27892C4BBF5D648783DCDCBA5A(this, UniqueId, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return ProcC071CA11E0A11A2E283015A2F9433338(this, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FindLiveProcess(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return ProcD6035EBBD17B0D0141A839FB20A8A90F(this, Id, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetLiveProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return ProcDB0050730FB328F4C9D7C1BB448007A9(this, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetRequests(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*>* pRequests)
{
    return ProcC43FD22B022A5A6DDF7F66F3A86E698F(this, pRequests);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ActivateAppPackage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform::e AppPlatform, Microsoft::VisualStudio::Debugger::DkmString* pActivationName, bool LaunchForDebugging, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine)
{
    return ProcA792859DA394A6CB2C2E468A8805621E(this, pWorkList, AppPlatform, pActivationName, LaunchForDebugging, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::SuspendAppPackage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmSuspendAppPackageAsyncResult>* pCompletionRoutine)
{
    return ProcDE7401ACE2C30C377F9CBF611BDF4337(this, pWorkList, pAppPackageId, SessionId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ResumeAppPackage(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId)
{
    return ProcD2B975D78F12643226D0BB33B75EAD13(this, pAppPackageId, SessionId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ShutDownAppPackage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmShutDownAppPackageAsyncResult>* pCompletionRoutine)
{
    return ProcB34EA264F4F8FECA9A9F132A25DCD7D8(this, pWorkList, pAppPackageId, SessionId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetIsolatedStorageRootForApplication(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::DkmString** ppDirectoryFullPath)
{
    return ProcD10A03178A61DDA50CE791FE7A50CE1A(this, pAppPackageId, ppDirectoryFullPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetAppPackageExecutionState(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackageExecutionState::e* pAppPackageExecutionState)
{
    return ProcFE6C80165E565AC3EC08B717C8E51C9E(this, pAppPackageId, SessionId, pAppPackageExecutionState);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::EnumerateBackgroundTasks(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmEnumerateBackgroundTasksAsyncResult>* pCompletionRoutine)
{
    return ProcF45761B62AD6B1092A2DF893E962C810(this, pWorkList, pAppPackageId, SessionId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ActivateBackgroundTask(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, const GUID& TaskId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmActivateBackgroundTaskAsyncResult>* pCompletionRoutine)
{
    return Proc30FEC696C9945D2B0417493F60C0A048(this, pWorkList, pAppPackageId, SessionId, TaskId, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::EnumPackages(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo*>* pPackages)
{
    return Proc98A6A894DD93626ADCA0978BCE953839(this, pPackages);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DeployFile(Microsoft::VisualStudio::Debugger::DkmString* pLocalFilePath, Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, bool OverwriteExisting)
{
    return ProcDDD014885B12C65BD78508D907B44AD7(this, pLocalFilePath, pRemoteFilePath, OverwriteExisting);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DownloadFile(Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, Microsoft::VisualStudio::Debugger::DkmString* pLocalFilePath, bool OverwriteExisting)
{
    return Proc3652ACA5E5318812E35FB3CA4438BE02(this, pRemoteFilePath, pLocalFilePath, OverwriteExisting);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DownloadFile(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, Microsoft::VisualStudio::Debugger::DkmString* pLocalFilePath, bool OverwriteExisting, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmDownloadFileAsyncResult>* pCompletionRoutine)
{
    return ProcD5CB3FCA82CC14A00D5F13D7E222756B(this, pWorkList, pRemoteFilePath, pLocalFilePath, OverwriteExisting, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DeleteFile(Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath)
{
    return ProcB8D5E627A1202BFABE708EACCB652FBB(this, pRemoteFilePath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetDNSName(Microsoft::VisualStudio::Debugger::DkmString** ppName)
{
    return Proc215DD9BC078CB88CF23C40B8C2910BE3(this, ppName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::CreateDirectory(Microsoft::VisualStudio::Debugger::DkmString* pRemoteDirectoryPath)
{
    return Proc97FB9A3F5C72B5CCF8B0B70D68A04767(this, pRemoteDirectoryPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::RemoveDirectory(Microsoft::VisualStudio::Debugger::DkmString* pRemoteDirectoryPath, bool Recursive)
{
    return Proc42B2E39E095C8CC924104C96D815A87F(this, pRemoteDirectoryPath, Recursive);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetFileListing(Microsoft::VisualStudio::Debugger::DkmString* pRootDirectoryPath, Microsoft::VisualStudio::Debugger::DkmString* pSearchWildcard, bool Recursive, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo*>* pResults)
{
    return ProcBA58E5F29495587EE83647ED4B7CA047(this, pRootDirectoryPath, pSearchWildcard, Recursive, pResults);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::EnumRunningProcesses(bool IncludeFromAllUsers, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo*>* pProcesses)
{
    return Proc78D9244B76EA8F1DE4E149D466A3067E(this, IncludeFromAllUsers, RequestedPropertyMask, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetRunningProcessInfo(UINT32 Id, UINT64 StartTime, bool IsDebuggee, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask::e RequestedPropertyMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo** ppProcessInfo)
{
    return Proc39246E41B82608CB696343435CB621CC(this, Id, StartTime, IsDebuggee, RequestedPropertyMask, ppProcessInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::TerminateRunningProcess(UINT32 Id, UINT64 StartTime, UINT32 ExitCode)
{
    return Proc865805A776E7741A6D402D348F5B10C8(this, Id, StartTime, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetSystemInformation(bool NativeSystemInfo, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppSystemInfo)
{
    return Proc2C5C54E587F4180B257B172F561B9D86(this, NativeSystemInfo, ppSystemInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetClrVersionOfExecutable(Microsoft::VisualStudio::Debugger::DkmString* pExePath, Microsoft::VisualStudio::Debugger::DkmString** ppClrVersionString)
{
    return Proc64B5767554228566D9C77062DA22744E(this, pExePath, ppClrVersionString);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::QueryIsWOW64Executable(Microsoft::VisualStudio::Debugger::DkmString* pExePath, bool* pResult)
{
    return Proc0869184C622FC2631C3092D1F9F56171(this, pExePath, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetDefaultClrVersion(Microsoft::VisualStudio::Debugger::DkmString** ppClrVersionString)
{
    return Proc8B8D1408689D364C99D8A5AEA2A33BF9(this, ppClrVersionString);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FlushClosedObjectQueue()
{
    return Proc455ECE81CE1CDD87D2DA5494FE7B4B03(this);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUnknownInstructionAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::DkmUnknownInstructionAddress** ppCreatedObject)
{
    return Proc8EDE4866600ED1B4F51326202AD7B614(pRuntimeInstance, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister::Identifier()
{
    return this->m_Identifier;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister::Create(CV_HREG_e Identifier, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister** ppCreatedObject)
{
    return Proc466368E9818C5AAA5A91F1B4871168C3(Identifier, pValue, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Connection()
{
    return this->m_pConnection;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::OutputKind()
{
    return this->m_OutputKind;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::MessageText()
{
    return this->m_pMessageText;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::MessageBoxFlags()
{
    return this->m_MessageBoxFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::ErrorCode()
{
    return this->m_ErrorCode;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind::e OutputKind, Microsoft::VisualStudio::Debugger::DkmString* pMessageText, UINT32 MessageBoxFlags, HRESULT ErrorCode, Microsoft::VisualStudio::Debugger::DkmUserMessage** ppCreatedObject)
{
    return ProcFDD9B7914B7C22033996520394B90F8A(pConnection, pProcess, OutputKind, pMessageText, MessageBoxFlags, ErrorCode, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Post()
{
    return ProcBA1057B67974B1DAE7A677E1B7156D48(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::DisplayPrompt(UINT32* pResult)
{
    return ProcA3E4FFDD239F6E8EB98DECB7AD2660ED(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::DisplayPrompt(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmDisplayUserMessagePromptAsyncResult>* pCompletionRoutine)
{
    return Proc724F9A5CAEC412BD5A71787991347219(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::InspectionContext()
{
    return this->m_pInspectionContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::VisualizerId()
{
    return this->m_VisualizerId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::ValueHome()
{
    return this->m_pValueHome;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::InspectionSession()
{
    return this->m_pInspectionContext->InspectionSession();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::RuntimeInstance()
{
    return this->m_pInspectionContext->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::Close()
{
    return Proc37A7A04E658357DDF89FD94C01950EDE(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::EvaluateVisualizedExpression(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult** ppResultObject)
{
    return Proc775646EA9C2CEA81FE5E83FA6B154C80(this, ppResultObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::UseDefaultEvaluationBehavior(bool* pUseDefaultEvaluationBehavior, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult** ppDefaultEvaluationResult)
{
    return Proc2EAA5EF1A1F3D78893EF5BF262A09FF1(this, pUseDefaultEvaluationBehavior, ppDefaultEvaluationResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetChildren(UINT32 InitialRequestSize, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>* pInitialChildren, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext** ppEnumContext)
{
    return Proc16C97186D55550648ABE74675D33BF50(this, InitialRequestSize, pInspectionContext, pInitialChildren, ppEnumContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetItems(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext* pEnumContext, UINT32 StartIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>* pItems)
{
    return Proc0A069DACDF37E06B697F148BFAE76960(this, pEnumContext, StartIndex, Count, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::SetValueAsString(Microsoft::VisualStudio::Debugger::DkmString* pValue, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return ProcEC64BFA42F296CC9011D7887E9AA821E(this, pValue, Timeout, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetUnderlyingString(Microsoft::VisualStudio::Debugger::DkmString** ppStringValue)
{
    return Proc2DAB6617600220DC44DEB7DBC7D87FA6(this, ppStringValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetSymbolInterface(const GUID& TypeSymbolInterfaceId, IUnknown** ppTypeSymbolInterface)
{
    return ProcA236F77AF12387A7771096B443CA3FC7(this, TypeSymbolInterfaceId, ppTypeSymbolInterface);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::EvaluateExpressionCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult** ppResultObject)
{
    return Proc7138B8A8F36654C2D04C9FD6EB1981F5(this, pInspectionContext, pExpression, pStackFrame, ppResultObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::CreateDefaultChildFullName(INT32 Index, Microsoft::VisualStudio::Debugger::DkmString** ppFullName)
{
    return ProcE7CC624DFD52EBFD7D8D4328B80F7B8B(this, Index, ppFullName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetChildrenCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pDefaultEvaluationResult, UINT32 InitialRequestSize, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>* pInitialChildren, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext** ppEnumContext)
{
    return ProcCC231CEFF16CBD971CC342AC73007747(this, pDefaultEvaluationResult, InitialRequestSize, pInspectionContext, pInitialChildren, ppEnumContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetItemsCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext* pEnumContext, UINT32 StartIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>* pItems)
{
    return ProcE50B12FF94F4FB40DEF8945C53BB3691(this, pEnumContext, StartIndex, Count, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::SetValueAsStringCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pDefaultEvaluationResult, Microsoft::VisualStudio::Debugger::DkmString* pValue, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc7EEBF387B7C2B848675D0F50E63E9996(this, pDefaultEvaluationResult, pValue, Timeout, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetUnderlyingStringCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pDefaultEvaluationResult, Microsoft::VisualStudio::Debugger::DkmString** ppStringValue)
{
    return ProcAED1622BD40E6A09C5DE0FE3F1603171(this, pDefaultEvaluationResult, ppStringValue);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::ExceptionFlags()
{
    return this->m_ExceptionFlags;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::ParentExceptionRecordAddress()
{
    return this->m_ParentExceptionRecordAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::Address()
{
    return this->m_Address;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::ExceptionParameters()
{
    return this->m_pExceptionParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage::e ProcessingStage, UINT32 ExceptionFlags, UINT64 ParentExceptionRecordAddress, UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pExceptionParameters, Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation** ppCreatedObject)
{
    return Proc83735219E8CC0CD40DBBF6F68C286948(pRuntimeInstance, pThread, pInstructionAddress, Code, ProcessingStage, ExceptionFlags, ParentExceptionRecordAddress, Address, pExceptionParameters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX64FrameRegisters::Rip()
{
    return this->m_Rip;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX64FrameRegisters::Rsp()
{
    return this->m_Rsp;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX86FrameRegisters::Eip()
{
    return this->m_Eip;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX86FrameRegisters::Esp()
{
    return this->m_Esp;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX86FrameRegisters::VFrame()
{
    return this->m_VFrame;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::TaskProviderId()
{
    return this->m_TaskProviderId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::TaskIdentityStackFrame()
{
    return this->m_pTaskIdentityStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::InternalStackFrame()
{
    return this->m_pInternalStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::FrameObject()
{
    return this->m_pFrameObject;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::Task()
{
    return this->m_pTask;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::ReturnStackFunctions()
{
    return this->m_pReturnStackFunctions;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const GUID& TaskProviderId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pTaskIdentityStackFrame, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pInternalStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* pFrameObject, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* pTask, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*>* pReturnStackFunctions, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext** ppCreatedObject)
{
    return Proc0820CA92D0247DC5DF701F1C1ECEA7DF(pInspectionSession, TaskProviderId, pTaskIdentityStackFrame, pInternalStackFrame, pFrameObject, pTask, pReturnStackFunctions, pRuntimeInstance, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::GetTaskCreationStack(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskCreationStackAsyncResult>* pCompletionRoutine)
{
    return Proc86FDCE2F5D7CA7AEEFDCA32E39728044(this, pWorkList, pThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::GetTaskContinuationFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskContinuationFramesAsyncResult>* pCompletionRoutine)
{
    return Proc4CE2773DE0FDDAF90435E6FDFCFAAAED(this, pWorkList, pThread, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::GetAsyncCallStack(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetAsyncCallStackAsyncResult>* pCompletionRoutine)
{
    return Proc1C7E85CB433B74A1BE139D8B40E53768(this, pWorkList, pThread, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::FrameStart()
{
    return this->m_FrameStart;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::FrameEnd()
{
    return this->m_FrameEnd;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::CatchHandlerILOffset()
{
    return this->m_CatchHandlerILOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Process()
{
    return this->m_pThread->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 FrameStart, UINT64 FrameEnd, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT32 CatchHandlerILOffset, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation** ppCreatedObject)
{
    return Proc7A6C7A0227D6BD610F97D032767448A8(pThread, FrameStart, FrameEnd, pInstructionAddress, CatchHandlerILOffset, pName, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::OnClrDebugMonitorExceptionCaught()
{
    return ProcAB099C958E2B4BDC4A6A8969DF728294(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*>(DkmModuleInstance::RuntimeInstance());
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::FindEmbeddedModule(UINT32 Index, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance** ppEmbeddedModule)
{
    return Proc75FF43FC6B24BBA9BCB13405C170E6F2(this, Index, ppEmbeddedModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetEmbeddedModules(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*>* pEmbeddedModules)
{
    return Proc07F31C87616869864CBF6033F37DAAB9(this, pEmbeddedModules);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetAssemblyImageBytes(UINT32 RVA, UINT32 BytesRequested, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pImageBytes)
{
    return ProcD535CEE9B7C2831AB2793C7873F721C8(this, RVA, BytesRequested, pImageBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetClassInfo(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pClassSignature, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol*>* pInstanceFields, UINT32* pSize)
{
    return ProcB9BAA2DA346F0AF91423145A3413CA27(this, pClassSignature, pInstanceFields, pSize);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Offset()
{
    return this->m_Offset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Size, UINT32 Offset, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol** ppCreatedObject)
{
    return Proc0CF9D0EC7EF8995BD39E312B58463B27(pName, Size, Offset, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*>(DkmClrInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*>(DkmClrInstructionAddress::ModuleInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::ContainerModule()
{
    return this->m_pContainerModule;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::GenericParameters()
{
    return this->m_pGenericParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::Create(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 NativeOffset, UINT32 ILOffset, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance* pContainerModule, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pGenericParameters, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress** ppCreatedObject)
{
    return Proc9B089C79F9336B6ABA00EF766311F77F(MethodId, NativeOffset, ILOffset, pRuntimeInstance, pModuleInstance, pContainerModule, pGenericParameters, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::EmbeddedModuleIndex()
{
    return this->m_EmbeddedModuleIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::NativeOffset()
{
    return this->m_NativeOffset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::GenericParameters()
{
    return this->m_pGenericParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 ILOffset, UINT32 EmbeddedModuleIndex, UINT32 NativeOffset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pGenericParameters, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol** ppCreatedObject)
{
    return Proc249AAF78F1239055957393B3DC7BE289(pModule, MethodId, ILOffset, EmbeddedModuleIndex, NativeOffset, pGenericParameters, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*>(DkmClrModuleInstance::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::ContainerModule()
{
    return this->m_pContainerModule;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities::e Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, Microsoft::VisualStudio::Debugger::DkmString* pRuntimeVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance** ppCreatedObject)
{
    return ProcC6E2961BDBDC1A9CA97272FF4B74A350(pProcess, Id, Capabilities, pParentRuntime, pRuntimeVersion, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::ModuleInstance()
{
    return this->m_pModuleInstance;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::Token()
{
    return this->m_Token;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::GenericArguments()
{
    return this->m_pGenericArguments;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::AppDomain()
{
    return this->m_pModuleInstance->AppDomain();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::RuntimeInstance()
{
    return this->m_pModuleInstance->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 Token, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericArguments, Microsoft::VisualStudio::Debugger::Clr::DkmClrType** ppCreatedObject)
{
    return ProcEDF0FCE8A74B5D0C131F7752E8991D3D(pModuleInstance, Token, pGenericArguments, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::ResolveMethodName(Microsoft::VisualStudio::Debugger::DkmString* pMethodName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pParameterTypes, Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId* pResult)
{
    return Proc8538455986C021ACA81FB03C2A62E0A6(this, pMethodName, pParameterTypes, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Language()
{
    return this->m_pLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Close()
{
    return Proc323D69516EBA1BCDC37105AA207724E0(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData** ppCreatedObject)
{
    return ProcFA215BDCF150EB6AB9820C4A27727AC2(pLanguage, pInspectionSession, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Initialize(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>& VisualizationFiles)
{
    return ProcA39016543127594E0FEB0444CDC3DF07(this, VisualizationFiles);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue** ppCreatedObject)
{
    return Proc9EB16C97D0F941B559CA036DF7F4341E(pRuntimeInstance, pValue, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_opt_ inline DECLSPEC_NOTHROW ICorDebugHandleValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, ICorDebugHandleValue* pValue, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue** ppCreatedObject)
{
    return Proc16C7D428BB76D469DE0C081CC2EB0A62(pRuntimeInstance, pValue, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::Expression()
{
    return this->m_pExpression;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::IntermediateLanguage()
{
    return this->m_pIntermediateLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::TargetRuntime()
{
    return this->m_pTargetRuntime;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pExpression, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pIntermediateLanguage, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pTargetRuntime, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult** ppCreatedObject)
{
    return Proc1061F6811AA7AD0D33CC213D93488771(pInspectionContext, pStackFrame, pName, pFullName, pExpression, pIntermediateLanguage, pTargetRuntime, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo::Release(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo* pItem)
{
    return Proc0C053A2A86820E43F81FB08DAC8CE244(pItem);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::Close()
{
    return Proc94B18169AB0EDFAE1D81988AA6E03752(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler** ppCreatedObject)
{
    return ProcD924583F9543AD80E04AE68B28A15BDE(pRuntimeInstance, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::InitializeHeapObjectWalk(UINT32 TargetObjectCount, bool LiveObjectStatsOnly)
{
    return ProcCC7C33549F96E9BFCC53D8D4796C4789(this, TargetObjectCount, LiveObjectStatsOnly);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::NextObjects(UINT32 RequestCount, UINT32* pFetchedCount)
{
    return Proc3A6D0DF639ECB96F5A8FCD3BFF85AE11(this, RequestCount, pFetchedCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::NextReferences(UINT32 RequestCount, UINT32* pFetchedCount)
{
    return ProcE8071A89F43A788EBFEBB41CBC4489AA(this, RequestCount, pFetchedCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::NextRoots(UINT32 RequestCount, UINT32* pFetchedCount)
{
    return ProcBBB2B6145A59219AFF600BAA441C73A8(this, RequestCount, pFetchedCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::GetSampledHeapData(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pItems)
{
    return ProcE7DE701BDD91AE12A722F8CC317D19BC(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::GetSampledHeapTypeStats(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo>* pItems)
{
    return ProcFFE0C8AF37E73BF497ECBCABECEEA17A(this, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::GetRoots(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>* pItems)
{
    return ProcD96B04D45E8105CE11F115D9F742F71C(this, pItems);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo::Release(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo* pItem)
{
    return ProcBEDC326A3D66F01DD50255E127A47AEA(pItem);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::Close()
{
    return Proc79FC2AA34BD6D341512F69F8135965C1(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker** ppCreatedObject)
{
    return Proc01ED18A9A87787ECBAFD76CA6F41C042(pRuntimeInstance, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::InitializeHeapObjectWalk()
{
    return ProcB3C9F5EA2C9BFB8EB3DB4F9E5D8BB6DE(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::InitializeHeapReferenceWalk()
{
    return ProcE18D30D305F175DD1817B8F658179FD9(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::InitializeHeapRootsWalk()
{
    return Proc797764A0BAC725C4193977B374A1E5A4(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::NextObjects(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapObjectInfo>* pItems)
{
    return Proc39D50FE942130684A08B74A259BEAAD4(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::NextReferences(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedObjectReferenceInfo>* pItems)
{
    return Proc089C4F654C8E15E4AE89DDF3A1A857B2(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::NextRoots(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>* pItems)
{
    return ProcBDA1C4B8B62A848BDDA4ED914C3950B5(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::GetTypeNames(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId>& TypeIds, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>* pTypeNames)
{
    return ProcDDC4469B03A149435C884CD60D958A3E(this, TypeIds, pTypeNames);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::GetSegments(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSegmentInfo>* pSegments)
{
    return Proc0789C5EB42EE609273BB5E426139B584(this, pSegments);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Method()
{
    return this->m_Method;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::ModuleInstance()
{
    return this->m_pModuleInstance;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::AwaitIndex()
{
    return this->m_AwaitIndex;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::AsyncStackWalkContext()
{
    return this->m_pAsyncStackWalkContext;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Data()
{
    return this->m_pData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags::e Flags, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& Method, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 AwaitIndex, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* pData, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame** ppCreatedObject)
{
    return ProcF307798AFAEC3339F0F539394CF897AD(pThread, Flags, Method, pModuleInstance, AwaitIndex, pAsyncStackWalkContext, pData, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Thread()
{
    return this->m_pThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Runtime()
{
    return this->m_pRuntime;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Address()
{
    return this->m_pAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntime, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext** ppCreatedObject)
{
    return Proc3190D0E445D2FE7421CF79FA67C8F250(pThread, pRuntime, pAddress, pName, pFullName, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::GetReturnValueInfo(Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo** ppValueInfo)
{
    return Proc978E4E1F1C2A124CCD52C37CE7B3FE2F(this, ppValueInfo);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::CorElementType()
{
    return this->m_CorElementType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::Address()
{
    return this->m_Address;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::ValueBuffer()
{
    return this->m_pValueBuffer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::Create(ICorDebugType* pCorType, UINT32 CorElementType, UINT32 Size, UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValueBuffer, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy** ppCreatedObject)
{
    return ProcD87D1398C6DB7E1C5819A7AEF3065005(pCorType, CorElementType, Size, Address, pValueBuffer, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo::Tag::e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW ICorDebugType* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo::CorType()
{
    return this->m_pCorType;
}

_Ret_opt_ inline DECLSPEC_NOTHROW ICorDebugValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference::CorValue()
{
    return this->m_pCorValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference::Create(ICorDebugType* pCorType, ICorDebugValue* pCorValue, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference** ppCreatedObject)
{
    return ProcD5CA6002328EC4403BAE43C674FC3C77(pCorType, pCorValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmManagedTaskInfo::Release(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmManagedTaskInfo* pItem)
{
    return Proc1E701FEAF4CA56487DDB8AD758EC4739(pItem);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue::Context()
{
    return this->m_pContext;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue::Create(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pReturnFrom, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext* pContext, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue** ppCreatedObject)
{
    return Proc8D47D19688BAF506460B4626D5B8D8EF(pReturnFrom, pContext, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRegistryTweak::ValueName()
{
    return this->m_pValueName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRegistryTweak::Data()
{
    return this->m_Data;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRegistryTweak::Create(Microsoft::VisualStudio::Debugger::DkmString* pValueName, UINT32 Data, Microsoft::VisualStudio::Debugger::DkmRegistryTweak** ppCreatedObject)
{
    return Proc4BD013B67BCF30535C934FEC828B0D2F(pValueName, Data, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext::Frames()
{
    return this->m_pFrames;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions::e FilterOptions, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& FormatOptions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation::e Operation, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* pFrames, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext** ppCreatedObject)
{
    return Proc096C4143603B1A366F404656A77DF808(pInspectionSession, pThread, FilterOptions, FormatOptions, pThreadContext, pAsyncContext, Operation, pFrames, DataItem, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData** ppCreatedObject)
{
    return Proc75D8E6CFCFD2990F41F14B42601A66B9(pInspectionSession, DataItem, ppCreatedObject);
}

#pragma warning(pop)

#pragma pack(pop)
#pragma warning(pop)

#endif // #ifndef _INC_VSDEBUGENG_

